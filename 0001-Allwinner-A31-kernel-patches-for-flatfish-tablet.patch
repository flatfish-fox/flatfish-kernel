From 7ca30403d8945b31744c8b39fb5778862b632caa Mon Sep 17 00:00:00 2001
From: Flatfish <flatfish.fox@gmail.com>
Date: Wed, 12 Feb 2014 17:18:12 +0800
Subject: [PATCH] Allwinner A31 kernel patches for flatfish tablet

---
 arch/arm/configs/sun6ismp_fiber_defconfig          |   60 +-
 arch/arm/mach-sun6i/ar100/include/ar100_cfgs.h     |    2 +-
 arch/arm/mach-sun6i/core.c                         |   10 +-
 arch/arm/mach-sun6i/rf/Makefile                    |    3 +-
 arch/arm/mach-sun6i/rf/bt_pm.c                     |    3 +-
 arch/arm/mach-sun6i/rf/gps_class.c                 |  178 +
 arch/arm/mach-sun6i/rf/wifi_pm.c                   |    8 +-
 arch/arm/mach-sun6i/rf/wifi_pm_ap6xxx.c            |   59 +-
 drivers/bluetooth/btlmp.c                          |    4 +-
 drivers/gpu/ion/ion_carveout_heap.c                |   81 +-
 drivers/input/Makefile                             |    2 +-
 drivers/input/init_ctp.c                           |   10 +
 drivers/input/ls/Kconfig                           |   12 +
 drivers/input/ls/LTR-303ALS.h                      |   41 +
 drivers/input/ls/Makefile                          |    3 +-
 drivers/input/ls/ltr303.c                          | 1025 +++
 drivers/input/touchscreen/ft5x_ts.c                |  344 +-
 drivers/input/touchscreen/ft5x_ts.h                |   12 +
 drivers/input/touchscreen/ft_app.i                 | 3436 ++++----
 drivers/media/video/sunxi-vfe/config.c             |   14 +-
 drivers/media/video/sunxi-vfe/device/Makefile      |   28 +-
 drivers/media/video/sunxi-vfe/device/hi253.c       | 1875 ++---
 drivers/media/video/sunxi-vfe/device/s5k4ec_mipi.c | 7469 +++++++++--------
 drivers/media/video/sunxi-vfe/vfe.c                |   58 +-
 drivers/misc/Kconfig                               |    1 +
 drivers/misc/Makefile                              |    1 +
 drivers/misc/inv_mpu/Kconfig                       |   77 +
 drivers/misc/inv_mpu/Makefile                      |   45 +
 drivers/misc/inv_mpu/README                        |  104 +
 drivers/misc/inv_mpu/accel/Kconfig                 |  133 +
 drivers/misc/inv_mpu/accel/Makefile                |   38 +
 drivers/misc/inv_mpu/accel/adxl34x.c               |  728 ++
 drivers/misc/inv_mpu/accel/bma150.c                |  777 ++
 drivers/misc/inv_mpu/accel/bma222.c                |  654 ++
 drivers/misc/inv_mpu/accel/bma250.c                |  787 ++
 drivers/misc/inv_mpu/accel/cma3000.c               |  222 +
 drivers/misc/inv_mpu/accel/kxsd9.c                 |  264 +
 drivers/misc/inv_mpu/accel/kxtf9.c                 |  841 ++
 drivers/misc/inv_mpu/accel/lis331.c                |  745 ++
 drivers/misc/inv_mpu/accel/lis3dh.c                |  728 ++
 drivers/misc/inv_mpu/accel/lsm303dlx_a.c           |  881 ++
 drivers/misc/inv_mpu/accel/mma8450.c               |  804 ++
 drivers/misc/inv_mpu/accel/mma845x.c               |  713 ++
 drivers/misc/inv_mpu/accel/mpu6050.c               |  699 ++
 drivers/misc/inv_mpu/accel/mpu6050.h               |   28 +
 drivers/misc/inv_mpu/compass/Kconfig               |  121 +
 drivers/misc/inv_mpu/compass/Makefile              |   38 +
 drivers/misc/inv_mpu/compass/ak8972.c              |  499 ++
 drivers/misc/inv_mpu/compass/ak8975.c              |  500 ++
 drivers/misc/inv_mpu/compass/ami306.c              | 1020 +++
 drivers/misc/inv_mpu/compass/ami30x.c              |  308 +
 drivers/misc/inv_mpu/compass/ami_hw.h              |   87 +
 drivers/misc/inv_mpu/compass/ami_sensor_def.h      |  144 +
 drivers/misc/inv_mpu/compass/hmc5883.c             |  391 +
 drivers/misc/inv_mpu/compass/hscdtd002b.c          |  294 +
 drivers/misc/inv_mpu/compass/hscdtd004a.c          |  318 +
 drivers/misc/inv_mpu/compass/lsm303dlx_m.c         |  395 +
 drivers/misc/inv_mpu/compass/mmc314x.c             |  313 +
 drivers/misc/inv_mpu/compass/yas529-kernel.c       |  611 ++
 drivers/misc/inv_mpu/compass/yas530.c              |  580 ++
 drivers/misc/inv_mpu/log.h                         |  287 +
 drivers/misc/inv_mpu/mldl_cfg.c                    | 1966 +++++
 drivers/misc/inv_mpu/mldl_cfg.h                    |  380 +
 drivers/misc/inv_mpu/mldl_print_cfg.c              |  138 +
 drivers/misc/inv_mpu/mldl_print_cfg.h              |   38 +
 drivers/misc/inv_mpu/mlsl-kernel.c                 |  420 +
 drivers/misc/inv_mpu/mlsl.h                        |  186 +
 drivers/misc/inv_mpu/mltypes.h                     |  234 +
 drivers/misc/inv_mpu/mpu-dev.c                     | 1512 ++++
 drivers/misc/inv_mpu/mpu-dev.h                     |   36 +
 drivers/misc/inv_mpu/mpu6050b1.h                   |  435 +
 drivers/misc/inv_mpu/mpuirq.c                      |  257 +
 drivers/misc/inv_mpu/mpuirq.h                      |   36 +
 drivers/misc/inv_mpu/pressure/Kconfig              |   20 +
 drivers/misc/inv_mpu/pressure/Makefile             |    8 +
 drivers/misc/inv_mpu/pressure/bma085.c             |  367 +
 drivers/misc/inv_mpu/slaveirq.c                    |  266 +
 drivers/misc/inv_mpu/slaveirq.h                    |   36 +
 drivers/misc/inv_mpu/timerirq.c                    |  296 +
 drivers/misc/inv_mpu/timerirq.h                    |   30 +
 drivers/net/wireless/bcmdhd/bcmsdh_linux.c         |    3 +-
 drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c         |    9 +-
 drivers/net/wireless/bcmdhd/dhd.h                  |    3 +-
 drivers/net/wireless/bcmdhd/dhd_common.c           |   21 +-
 drivers/net/wireless/bcmdhd/dhd_custom_gpio.c      |    8 +-
 drivers/net/wireless/bcmdhd/include/wlioctl.h      |    8 +-
 drivers/net/wireless/bcmdhd/wl_android.c           |    3 +-
 drivers/power/axp_power/axp-sply.h                 |   12 +-
 drivers/power/axp_power/axp22-sply.c               |  178 +-
 drivers/rtc/alarm.c                                |    8 +-
 drivers/staging/android/switch/switch_headset.c    |   17 +-
 drivers/tty/serial/sw_uart.c                       |   18 +
 drivers/usb/gadget/f_mass_storage.c                |   30 +-
 drivers/usb/gadget/f_rndis.c                       |   12 +-
 drivers/usb/host/sw_hci_sun6i.c                    |    2 +-
 drivers/usb/sun6i_usb/hcd/hcd0/sw_hcd0.c           |   49 +-
 drivers/usb/sun6i_usb/manager/usb_hw_scan.c        |    4 +-
 drivers/usb/sun6i_usb/udc/sw_udc.c                 |   68 +-
 drivers/video/Makefile                             |    2 +-
 drivers/video/sun6i/disp/de_bsp/de/disp_lcd.c      |   10 +-
 drivers/video/sun6i/disp/dev_disp.c                |    6 +-
 drivers/video/sun6i/disp/dev_disp_attrnode.c       |    8 +-
 drivers/video/sun6i/lcd/Makefile                   |    3 +-
 drivers/video/sun6i/lcd/dev_lcd.c                  |    2 +-
 drivers/video/sun6i/lcd/lcd0_panel_cfg-hv800x480.c |   30 +-
 fs/notify/fanotify/Kconfig                         |    4 +-
 include/linux/ctp.h                                |    1 +
 include/linux/mpu.h                                |  366 +
 include/net/bluetooth/amp.h                        |  293 +
 include/net/bluetooth/bluetooth.h                  |  117 +-
 include/net/bluetooth/hci.h                        |  429 +-
 include/net/bluetooth/hci_core.h                   |  656 +-
 include/net/bluetooth/l2cap.h                      |  915 +-
 include/net/bluetooth/mgmt.h                       |  353 +-
 include/net/bluetooth/rfcomm.h                     |   10 +-
 include/net/bluetooth/sco.h                        |    4 +-
 include/net/bluetooth/smp.h                        |   33 +-
 .../eurasiacon/build/linux2/config/core.mk         |    2 +-
 net/bluetooth/Kconfig                              |    3 +-
 net/bluetooth/Makefile                             |    3 +-
 net/bluetooth/af_bluetooth.c                       |   37 +-
 net/bluetooth/amp.c                                | 2041 +++++
 net/bluetooth/bnep/core.c                          |   28 +-
 net/bluetooth/bnep/netdev.c                        |    1 +
 net/bluetooth/cmtp/capi.c                          |    6 +-
 net/bluetooth/cmtp/cmtp.h                          |    1 -
 net/bluetooth/cmtp/core.c                          |   41 +-
 net/bluetooth/hci_conn.c                           |  904 +-
 net/bluetooth/hci_core.c                           | 1318 ++-
 net/bluetooth/hci_event.c                          | 1568 ++--
 net/bluetooth/hci_sock.c                           |  112 +-
 net/bluetooth/hci_sysfs.c                          |  157 +-
 net/bluetooth/hidp/core.c                          |  363 +-
 net/bluetooth/hidp/hidp.h                          |   16 -
 net/bluetooth/l2cap_core.c                         | 8755 +++++++++++++-------
 net/bluetooth/l2cap_sock.c                         |  987 ++-
 net/bluetooth/lib.c                                |   23 +-
 net/bluetooth/mgmt.c                               | 3277 +++++---
 net/bluetooth/rfcomm/core.c                        |  231 +-
 net/bluetooth/rfcomm/sock.c                        |   63 +-
 net/bluetooth/rfcomm/tty.c                         |   68 +-
 net/bluetooth/sco.c                                |  137 +-
 net/bluetooth/smp.c                                |  827 +-
 scripts/build_sun6i_fiber.sh                       |   16 +-
 sound/soc/sun6i/sun6i-codec.c                      |   24 +-
 145 files changed, 46694 insertions(+), 14584 deletions(-)
 create mode 100644 arch/arm/mach-sun6i/rf/gps_class.c
 create mode 100644 drivers/input/ls/LTR-303ALS.h
 create mode 100644 drivers/input/ls/ltr303.c
 create mode 100644 drivers/misc/inv_mpu/Kconfig
 create mode 100644 drivers/misc/inv_mpu/Makefile
 create mode 100644 drivers/misc/inv_mpu/README
 create mode 100644 drivers/misc/inv_mpu/accel/Kconfig
 create mode 100644 drivers/misc/inv_mpu/accel/Makefile
 create mode 100644 drivers/misc/inv_mpu/accel/adxl34x.c
 create mode 100644 drivers/misc/inv_mpu/accel/bma150.c
 create mode 100644 drivers/misc/inv_mpu/accel/bma222.c
 create mode 100644 drivers/misc/inv_mpu/accel/bma250.c
 create mode 100644 drivers/misc/inv_mpu/accel/cma3000.c
 create mode 100644 drivers/misc/inv_mpu/accel/kxsd9.c
 create mode 100644 drivers/misc/inv_mpu/accel/kxtf9.c
 create mode 100644 drivers/misc/inv_mpu/accel/lis331.c
 create mode 100644 drivers/misc/inv_mpu/accel/lis3dh.c
 create mode 100644 drivers/misc/inv_mpu/accel/lsm303dlx_a.c
 create mode 100644 drivers/misc/inv_mpu/accel/mma8450.c
 create mode 100644 drivers/misc/inv_mpu/accel/mma845x.c
 create mode 100644 drivers/misc/inv_mpu/accel/mpu6050.c
 create mode 100644 drivers/misc/inv_mpu/accel/mpu6050.h
 create mode 100644 drivers/misc/inv_mpu/compass/Kconfig
 create mode 100644 drivers/misc/inv_mpu/compass/Makefile
 create mode 100644 drivers/misc/inv_mpu/compass/ak8972.c
 create mode 100644 drivers/misc/inv_mpu/compass/ak8975.c
 create mode 100644 drivers/misc/inv_mpu/compass/ami306.c
 create mode 100644 drivers/misc/inv_mpu/compass/ami30x.c
 create mode 100644 drivers/misc/inv_mpu/compass/ami_hw.h
 create mode 100644 drivers/misc/inv_mpu/compass/ami_sensor_def.h
 create mode 100644 drivers/misc/inv_mpu/compass/hmc5883.c
 create mode 100644 drivers/misc/inv_mpu/compass/hscdtd002b.c
 create mode 100644 drivers/misc/inv_mpu/compass/hscdtd004a.c
 create mode 100644 drivers/misc/inv_mpu/compass/lsm303dlx_m.c
 create mode 100644 drivers/misc/inv_mpu/compass/mmc314x.c
 create mode 100644 drivers/misc/inv_mpu/compass/yas529-kernel.c
 create mode 100644 drivers/misc/inv_mpu/compass/yas530.c
 create mode 100644 drivers/misc/inv_mpu/log.h
 create mode 100644 drivers/misc/inv_mpu/mldl_cfg.c
 create mode 100644 drivers/misc/inv_mpu/mldl_cfg.h
 create mode 100644 drivers/misc/inv_mpu/mldl_print_cfg.c
 create mode 100644 drivers/misc/inv_mpu/mldl_print_cfg.h
 create mode 100644 drivers/misc/inv_mpu/mlsl-kernel.c
 create mode 100644 drivers/misc/inv_mpu/mlsl.h
 create mode 100644 drivers/misc/inv_mpu/mltypes.h
 create mode 100644 drivers/misc/inv_mpu/mpu-dev.c
 create mode 100644 drivers/misc/inv_mpu/mpu-dev.h
 create mode 100644 drivers/misc/inv_mpu/mpu6050b1.h
 create mode 100644 drivers/misc/inv_mpu/mpuirq.c
 create mode 100644 drivers/misc/inv_mpu/mpuirq.h
 create mode 100644 drivers/misc/inv_mpu/pressure/Kconfig
 create mode 100644 drivers/misc/inv_mpu/pressure/Makefile
 create mode 100644 drivers/misc/inv_mpu/pressure/bma085.c
 create mode 100644 drivers/misc/inv_mpu/slaveirq.c
 create mode 100644 drivers/misc/inv_mpu/slaveirq.h
 create mode 100644 drivers/misc/inv_mpu/timerirq.c
 create mode 100644 drivers/misc/inv_mpu/timerirq.h
 create mode 100644 include/linux/mpu.h
 create mode 100644 include/net/bluetooth/amp.h
 mode change 100755 => 100644 include/net/bluetooth/hci.h
 mode change 100755 => 100644 include/net/bluetooth/l2cap.h
 create mode 100644 net/bluetooth/amp.c
 mode change 100755 => 100644 net/bluetooth/hci_conn.c
 mode change 100755 => 100644 net/bluetooth/hci_core.c
 mode change 100755 => 100644 net/bluetooth/hci_event.c
 mode change 100755 => 100644 net/bluetooth/l2cap_core.c
 mode change 100755 => 100644 net/bluetooth/l2cap_sock.c
 mode change 100755 => 100644 net/bluetooth/sco.c

diff --git a/arch/arm/configs/sun6ismp_fiber_defconfig b/arch/arm/configs/sun6ismp_fiber_defconfig
index 6b3f7cd..34502bc 100755
--- a/arch/arm/configs/sun6ismp_fiber_defconfig
+++ b/arch/arm/configs/sun6ismp_fiber_defconfig
@@ -810,7 +810,8 @@ CONFIG_BT_HCIUART=y
 CONFIG_BT_HCIUART_H4=y
 CONFIG_BT_HCIUART_BCSP=y
 # CONFIG_BT_BLUESLEEP is not set
-# CONFIG_BT_LPM is not set
+CONFIG_BT_LPM=y
+CONFIG_BT_LOW_LEVEL_TRIGGER=y
 # CONFIG_BT_HCIUART_ATH3K is not set
 CONFIG_BT_HCIUART_RTKH5=y
 # CONFIG_BT_HCIUART_LL is not set
@@ -938,7 +939,28 @@ CONFIG_UID_STAT=y
 #
 # CONFIG_ALTERA_STAPL is not set
 # CONFIG_SW_3G_MODULE is not set
-
+CONFIG_MPU_SENSORS_TIMERIRQ=y
+CONFIG_INV_SENSORS=m
+# CONFIG_MPU_SENSORS_MPU3050 is not set
+# CONFIG_MPU_SENSORS_MPU6050A2 is not set
+CONFIG_MPU_SENSORS_MPU6050B1=y
+CONFIG_MPU_SENSORS_MPU6050_GYRO=y
+CONFIG_INV_SENSORS_ACCELEROMETERS=y
+# CONFIG_MPU_SENSORS_ADXL34X is not set
+# CONFIG_MPU_SENSORS_BMA222 is not set
+# CONFIG_MPU_SENSORS_BMA150 is not set
+# CONFIG_MPU_SENSORS_BMA250 is not set
+# CONFIG_MPU_SENSORS_KXSD9 is not set
+# CONFIG_MPU_SENSORS_KXTF9 is not set
+# CONFIG_MPU_SENSORS_LIS331DLH is not set
+# CONFIG_MPU_SENSORS_LIS3DH is not set
+# CONFIG_MPU_SENSORS_LSM303DLX_A is not set
+# CONFIG_MPU_SENSORS_MMA8450 is not set
+# CONFIG_MPU_SENSORS_MMA845X is not set
+CONFIG_MPU_SENSORS_MPU6050_ACCEL=y
+# CONFIG_INV_SENSORS_COMPASS is not set
+# CONFIG_INV_SENSORS_PRESSURE is not set
+CONFIG_MPU_USERSPACE_DEBUG=y
 #
 # SCSI device support
 #
@@ -1097,18 +1119,23 @@ CONFIG_WLAN=y
 # CONFIG_WIFI_CONTROL_FUNC is not set
 # CONFIG_ATH_COMMON is not set
 # CONFIG_BCM4330 is not set
-# CONFIG_BCMDHD is not set
+CONFIG_BCMDHD=m
+CONFIG_BCMDHD_FW_PATH="/system/vendor/modules/fw_bcmxxxx.bin"
+CONFIG_BCMDHD_NVRAM_PATH="/system/vendor/modules/nvram_apxxxx.txt"
+CONFIG_BCMDHD_OOB=y
+# CONFIG_BCMDHD_SDIO_IRQ is not set
+# CONFIG_BCMDHD_OOB_LOW_LEVEL_TRIGGER is not set
 # CONFIG_BRCMFMAC is not set
 # CONFIG_HOSTAP is not set
 # CONFIG_IWM is not set
 # CONFIG_LIBERTAS is not set
 # CONFIG_MWIFIEX is not set
-CONFIG_RTL8192CU_SW=m
-CONFIG_RTL8188EU=m
-CONFIG_RTL8189ES=m
-CONFIG_RTL8723AS=m
-CONFIG_RTL8723AU=m
-CONFIG_RTL8188EU_SW=m
+# CONFIG_RTL8192CU_SW is not set
+# CONFIG_RTL8188EU is not set
+# CONFIG_RTL8189ES is not set
+# CONFIG_RTL8723AS is not set
+# CONFIG_RTL8723AU is not set
+# CONFIG_RTL8188EU_SW is not set
 
 #
 # Enable WiMAX (Networking options) to see the WiMAX drivers
@@ -1207,10 +1234,10 @@ CONFIG_TOUCHSCREEN_AW5306=m
 # CONFIG_TOUCHSCREEN_ST1232 is not set
 # CONFIG_TOUCHSCREEN_TPS6507X is not set
 CONFIG_TOUCHSCREEN_FT5X_TS=m
-CONFIG_TOUCHSCREEN_GSLX680=m
-CONFIG_TOUCHSCREEN_GT82X=m
-CONFIG_TOUCHSCREEN_SUN6I_TS=m
-CONFIG_TOUCHSCREEN_ILITEK_AIMVF=m
+# CONFIG_TOUCHSCREEN_GSLX680 is not set
+# CONFIG_TOUCHSCREEN_GT82X is not set
+# CONFIG_TOUCHSCREEN_SUN6I_TS is not set
+# CONFIG_TOUCHSCREEN_ILITEK_AIMVF is not set
 CONFIG_INPUT_MISC=y
 # CONFIG_INPUT_AD714X is not set
 # CONFIG_INPUT_BMA150 is not set
@@ -1237,7 +1264,8 @@ CONFIG_INPUT_E_COMPASS=y
 CONFIG_E_COMPASS_L3M303D=m
 CONFIG_E_COMPASS_FXOS8700=m
 CONFIG_INPUT_LIGHT_SENSOR=y
-CONFIG_INPUT_LTR501ALS=m
+# CONFIG_INPUT_LTR501ALS is not set
+CONFIG_INPUT_LTR303=m
 
 #
 # Hardware I/O ports
@@ -1832,7 +1860,7 @@ CONFIG_HID_SUPPORT=y
 CONFIG_HID=y
 CONFIG_HID_BATTERY_STRENGTH=y
 # CONFIG_HIDRAW is not set
-# CONFIG_UHID is not set
+CONFIG_UHID=y
 
 #
 # USB Input Devices
@@ -2318,7 +2346,7 @@ CONFIG_FILE_LOCKING=y
 CONFIG_FSNOTIFY=y
 CONFIG_DNOTIFY=y
 CONFIG_INOTIFY_USER=y
-# CONFIG_FANOTIFY is not set
+CONFIG_FANOTIFY=y
 # CONFIG_QUOTA is not set
 # CONFIG_QUOTACTL is not set
 # CONFIG_AUTOFS4_FS is not set
diff --git a/arch/arm/mach-sun6i/ar100/include/ar100_cfgs.h b/arch/arm/mach-sun6i/ar100/include/ar100_cfgs.h
index 2ab25dc..5d8275a 100755
--- a/arch/arm/mach-sun6i/ar100/include/ar100_cfgs.h
+++ b/arch/arm/mach-sun6i/ar100/include/ar100_cfgs.h
@@ -26,7 +26,7 @@
 #define	AR100_VERSIONS				(100)
 
 /* debugger system */
-#define AR100_DEBUG_ON	
+//#define AR100_DEBUG_ON	
 #define	AR100_DEBUG_LEVEL			(3)	/* debug level */
 
 /* the max number of cached message frame */
diff --git a/arch/arm/mach-sun6i/core.c b/arch/arm/mach-sun6i/core.c
index 23e80e4..c1e2917 100755
--- a/arch/arm/mach-sun6i/core.c
+++ b/arch/arm/mach-sun6i/core.c
@@ -59,7 +59,11 @@ static struct map_desc sun6i_io_desc[] __initdata = {
 };
 
 #if defined(CONFIG_ION) || defined(CONFIG_ION_MODULE)
-static struct tag_mem32 ion_mem __initdata = {
+/*static struct tag_mem32 ion_mem __initdata = {
+	.start	= ION_CARVEOUT_MEM_BASE,
+	.size	= ION_CARVEOUT_MEM_SIZE,
+};*/
+struct tag_mem32 ion_mem = {
 	.start	= ION_CARVEOUT_MEM_BASE,
 	.size	= ION_CARVEOUT_MEM_SIZE,
 };
@@ -150,10 +154,12 @@ static int __init early_ion_reserve(char *p)
 {
 	char *endp;
 
-	ion_mem.start= ION_CARVEOUT_MEM_BASE;
+	//ion_mem.start= ION_CARVEOUT_MEM_BASE;
 	ion_mem.size  = memparse(p, &endp);
 	if (*endp == '@')
 		ion_mem.start = memparse(endp + 1, NULL);
+	else
+		ion_mem.start = PLAT_PHYS_OFFSET + PLAT_MEM_SIZE - ion_mem.size;
 
 	pr_debug("[%s]: ION memory reserve: [0x%016x - 0x%016x]\n",
 			__func__, ion_mem.start, ion_mem.size);
diff --git a/arch/arm/mach-sun6i/rf/Makefile b/arch/arm/mach-sun6i/rf/Makefile
index 6bdbd70..19422d5 100755
--- a/arch/arm/mach-sun6i/rf/Makefile
+++ b/arch/arm/mach-sun6i/rf/Makefile
@@ -11,4 +11,5 @@ wifi_gpio-y := wifi_pm.o wifi_pm_ap6xxx.o \
 
 obj-$(CONFIG_RFKILL)  += bt_gpio.o
 
-bt_gpio-y := bt_pm.o
\ No newline at end of file
+bt_gpio-y := bt_pm.o
+obj-y += gps_class.o
diff --git a/arch/arm/mach-sun6i/rf/bt_pm.c b/arch/arm/mach-sun6i/rf/bt_pm.c
index de1acd7..e643af2 100755
--- a/arch/arm/mach-sun6i/rf/bt_pm.c
+++ b/arch/arm/mach-sun6i/rf/bt_pm.c
@@ -23,11 +23,10 @@ static int rfkill_set_power(void *data, bool blocked)
 {
     unsigned int mod_sel = wifi_pm_get_mod_type();
     
-    RF_MSG("rfkill set power %d\n", blocked);
-    
     switch (mod_sel)
     {
         case 2: /* ap6210 */
+        case 10: /* gb9663 */
             if (!blocked) {
                 wifi_pm_gpio_ctrl("ap6xxx_bt_regon", 1);
             } else {
diff --git a/arch/arm/mach-sun6i/rf/gps_class.c b/arch/arm/mach-sun6i/rf/gps_class.c
new file mode 100644
index 0000000..cb71cc4
--- /dev/null
+++ b/arch/arm/mach-sun6i/rf/gps_class.c
@@ -0,0 +1,178 @@
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sysfs.h>
+#include <linux/delay.h>
+#include <mach/gpio.h>
+#include <linux/gpio.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <mach/system.h>
+
+#define GPS_RESET	GPIOA(0)
+#define GPS_STANDBY	GPIOA(1)
+
+#define GPS_MSG(...)     do {printk("[gps]: "__VA_ARGS__);} while(0)
+
+static int standby_state;
+static int reset_state;
+
+static ssize_t standby_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	standby_state = __gpio_get_value(GPS_STANDBY);
+	GPS_MSG("gps_standby = %d\n",standby_state);
+	return sprintf(buf, "%d\n", standby_state);
+}
+
+static ssize_t standby_store(struct class *class,
+				  struct class_attribute *attr,
+				  const char *buf, size_t count)
+{
+	int err;
+	int store_state;
+
+	store_state = simple_strtoul(buf, 0, 10);
+
+	switch (store_state){
+	case 1:
+		err = gpio_direction_output(GPS_STANDBY,1);
+		if (err) {
+			GPS_MSG("failed to set gps_standby to high.\n");
+			return -1;
+		}
+		else
+		{
+			GPS_MSG("succeed to set gps_standby to high.\n");
+		}
+		break;
+	case 0:
+		err = gpio_direction_output(GPS_STANDBY,0);
+		if (err) {
+			GPS_MSG("failed to set gps_standby to low.\n");
+			return -1;
+		}
+		else
+		{
+			GPS_MSG("succeed to set gps_standby to low.\n");
+		}
+		break;
+	default:
+ 	break;
+	}
+	return count;
+}
+
+static ssize_t reset_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	reset_state = __gpio_get_value(GPS_RESET); 
+	GPS_MSG("gps_reset = %d\n",reset_state);
+	return sprintf(buf, "%d\n", reset_state);
+}
+
+static ssize_t reset_store(struct class *class,
+				  struct class_attribute *attr,
+				  const char *buf, size_t count)
+{
+	int err;
+	int store_state;
+
+	store_state = simple_strtoul(buf, 0, 10);
+
+	switch (store_state){
+	case 1:
+		err = gpio_direction_output(GPS_RESET,1);
+		if (err) {
+			GPS_MSG("failed to set gps_reset to high.\n");
+			return -1;
+		}
+		else
+		{
+			GPS_MSG("succeed to set gps_reset to high.\n");
+		}
+		break;
+	case 0:
+		err = gpio_direction_output(GPS_RESET,0);
+		if (err) {
+			GPS_MSG("failed to set gps_reset to low.\n");
+			return -1;
+		}
+		else
+		{
+			GPS_MSG("succeed to set gps_reset to low.\n");
+		}
+		break;
+	default:
+ 	break;
+	}
+	return count;
+}
+
+#if 0
+static void bcm4751_config_32k_clk(void)
+{
+   unsigned int reg_addr, reg_val;
+   unsigned int tiwl18xx_32k_gpio;
+
+   tiwl18xx_32k_gpio = GPIOM(7);
+   gpio_request(tiwl18xx_32k_gpio, NULL);
+   sw_gpio_setpull(tiwl18xx_32k_gpio, 1);
+   sw_gpio_setdrvlevel(tiwl18xx_32k_gpio, 3);
+   sw_gpio_setcfg(tiwl18xx_32k_gpio, 0x03);
+
+//enable clk
+   reg_addr = 0xf1f01400 + 0xf0;
+   reg_val = readl(reg_addr);
+   writel( reg_val | (1<<31), reg_addr); 
+}
+#endif
+
+static struct class_attribute gps_dev_attrs[] = {
+	__ATTR(standby, 0666, standby_show, standby_store),
+	__ATTR(reset, 0666, reset_show, reset_store),
+	__ATTR_NULL
+};
+
+
+static struct class gps_class = {
+	.name		= "gps",
+	.class_attrs	= gps_dev_attrs,
+};
+
+
+static int __init gps_init(void)
+{
+	int error;
+	error = class_register(&gps_class);
+//	bcm4751_config_32k_clk();
+	if (error)
+	{
+		GPS_MSG("failed to regist gps_class.\n");
+		goto out;	
+	}
+	error = gpio_request(GPS_STANDBY,NULL);
+	if (error)
+		GPS_MSG("failed to request gps_standby.\n");
+	error = gpio_direction_output(GPS_STANDBY,0);
+	if (error)
+		GPS_MSG("failed to set gps_standby to low.\n");
+	error = gpio_request(GPS_RESET,NULL);
+	if (error)
+		GPS_MSG("failed to request gps_reset.\n");
+	error = gpio_direction_output(GPS_RESET,1);
+	if (error)
+		GPS_MSG("failed to set gps_reset to high.\n");
+	out:
+	return error;
+}
+
+subsys_initcall(gps_init);
+
+static void __exit gps_exit(void)
+{
+	class_unregister(&gps_class);
+	gpio_free(GPS_STANDBY);
+	gpio_free(GPS_RESET);
+}
+module_exit(gps_exit);
diff --git a/arch/arm/mach-sun6i/rf/wifi_pm.c b/arch/arm/mach-sun6i/rf/wifi_pm.c
index 90d7f7e..42b7046 100755
--- a/arch/arm/mach-sun6i/rf/wifi_pm.c
+++ b/arch/arm/mach-sun6i/rf/wifi_pm.c
@@ -21,7 +21,8 @@ static char* wifi_mod[] = {" ",
 	"rtl8188eu",  /* 6 - RTL8188EU*/
 	"mtk6620",	  /* 7 - MTK6620() */
 	"rtl8723au",  /* 8 - RTL8723AU*/
-	"ap6330",     /* 9 - AP6330*/
+	"gb9662",     /* 9 - BCM40181*/
+	"gb9663",     /* 10 - BCM40183*/
 };
 
 int wifi_pm_get_mod_type(void)
@@ -190,7 +191,10 @@ static int __devinit wifi_pm_probe(struct platform_device *pdev)
 		case 8: /* RTL8723AU */
 			rtl8723au_gpio_init();
 			break;
-		case 9: /* AP6330 */
+		case 9: /* BCM40181 */
+			ap6xxx_gpio_init();
+			break;
+		case 10: /* BCM40183 */
 			ap6xxx_gpio_init();
 			break;
 		default:
diff --git a/arch/arm/mach-sun6i/rf/wifi_pm_ap6xxx.c b/arch/arm/mach-sun6i/rf/wifi_pm_ap6xxx.c
index 5258da3..d13e822 100755
--- a/arch/arm/mach-sun6i/rf/wifi_pm_ap6xxx.c
+++ b/arch/arm/mach-sun6i/rf/wifi_pm_ap6xxx.c
@@ -7,10 +7,17 @@
 #include <mach/sys_config.h>
 #include <mach/gpio.h>
 #include <linux/regulator/consumer.h>
+#include <mach/system.h>
 #include "wifi_pm.h"
 
 #define ap6xxx_msg(...)    do {printk("[ap6xxx]: "__VA_ARGS__);} while(0)
 
+//static void tiwl18xx_config_pm_volt(void);
+static int tiwl18xx_config_pm_volt(void);//modify to fix the compile warning: ‘return’ with a value, in function returning void
+static void ap6xxx_config_32k_clk(void);
+
+//static int ap6xxx_powerup = 0;
+//static int ap6xxx_suspend = 0;
 static int ap6xxx_wl_regon = 0;
 static int ap6xxx_bt_regon = 0;
 static char * axp_name = NULL;
@@ -42,7 +49,7 @@ static int ap6xxx_module_power(int onoff)
 
 	if (onoff) {
 		ap6xxx_msg("regulator on.\n");
-		ret = regulator_set_voltage(wifi_ldo, 3300000, 3300000);
+		ret = regulator_set_voltage(wifi_ldo, 1800000, 1800000);
 		if (ret < 0) {
 			ap6xxx_msg("regulator_set_voltage fail, return %d.\n", ret);
 			regulator_put(wifi_ldo);
@@ -156,4 +163,54 @@ void ap6xxx_gpio_init(void)
 	ops->power = ap6xxx_power;
 
 	ap6xxx_module_power(1);
+	
+	tiwl18xx_config_pm_volt();
+	ap6xxx_config_32k_clk();
+}
+
+
+static char pm_axp_name[] = "axp22_ldoio1";
+//static void tiwl18xx_config_pm_volt(void)
+static int tiwl18xx_config_pm_volt(void)//modify to fix the compile warning: ‘return’ with a value, in function returning void
+{
+   struct regulator* pm_ldo = NULL;
+   int ret = 0;
+
+   pm_ldo = regulator_get(NULL, pm_axp_name);
+   if (!pm_ldo) {
+       printk("get power regulator failed.\n");
+       return -ret;
+   } 
+
+   ret = regulator_set_voltage(pm_ldo, 1800000, 1800000);
+   if (ret < 0) {
+      printk("regulator_set_voltage fail, return %d.\n", ret);
+      return ret;
+   }
+
+   ret = regulator_enable(pm_ldo);
+   if (ret < 0) {
+   printk("regulator_enable fail, return %d.\n", ret);
+      return ret;
+   }
+
+   printk("ret=%d\n", ret);
+   return ret;
+} 
+
+static void ap6xxx_config_32k_clk(void)
+{
+   unsigned int reg_addr, reg_val;
+   unsigned int tiwl18xx_32k_gpio;
+
+   tiwl18xx_32k_gpio = GPIOM(7);
+   gpio_request(tiwl18xx_32k_gpio, NULL);
+   sw_gpio_setpull(tiwl18xx_32k_gpio, 1);
+   sw_gpio_setdrvlevel(tiwl18xx_32k_gpio, 3);
+   sw_gpio_setcfg(tiwl18xx_32k_gpio, 0x03);
+
+//enable clk
+   reg_addr = 0xf1f01400 + 0xf0;
+   reg_val = readl(reg_addr);
+   writel( reg_val | (1<<31), reg_addr); 
 }
diff --git a/drivers/bluetooth/btlmp.c b/drivers/bluetooth/btlmp.c
index 30710bb..95c2f5b 100755
--- a/drivers/bluetooth/btlmp.c
+++ b/drivers/bluetooth/btlmp.c
@@ -55,7 +55,7 @@
 #include <net/bluetooth/hci_core.h>
 #include "hci_uart.h"
 
-//#define BT_DEBUG 1
+#define BT_DEBUG 1
 #ifdef  BT_DEBUG
 #define BT_LPM_DBG(fmt, arg...)  printk(KERN_ERR "[BT_LPM] %s: " fmt "\n" , __func__ , ## arg)
 #else
@@ -98,7 +98,7 @@ DECLARE_DELAYED_WORK(sleep_workqueue, bluesleep_sleep_work);
 #define bluesleep_tx_idle()     schedule_delayed_work(&sleep_workqueue, 0)
 
 /* 10 second timeout */
-#define TX_TIMER_INTERVAL	10
+#define TX_TIMER_INTERVAL	3
 
 /* state variable names and bit positions */
 #define BT_PROTO	0x01
diff --git a/drivers/gpu/ion/ion_carveout_heap.c b/drivers/gpu/ion/ion_carveout_heap.c
index 95761a5..9ac6557 100755
--- a/drivers/gpu/ion/ion_carveout_heap.c
+++ b/drivers/gpu/ion/ion_carveout_heap.c
@@ -27,6 +27,15 @@
 
 #include <asm/mach/map.h>
 
+//#define DEBUG_HEAP
+
+#ifdef DEBUG_HEAP
+u32 total_alloc = 0;
+u32 alloc_cnt = 0, free_cnt = 0;
+u32 max_single_len = 0, max_total_alloc = 0;
+static DEFINE_RWLOCK(heap_lock);
+#endif
+
 struct ion_carveout_heap {
 	struct ion_heap heap;
 	struct gen_pool *pool;
@@ -41,21 +50,73 @@ ion_phys_addr_t ion_carveout_allocate(struct ion_heap *heap,
 		container_of(heap, struct ion_carveout_heap, heap);
 	unsigned long offset = gen_pool_alloc(carveout_heap->pool, size);
 
-	if (!offset)
+#ifdef DEBUG_HEAP
+	u32 tmp_a_c, tmp_f_c, tmp_t_a, max_s_l, max_t_a;
+	unsigned long flags;
+#endif
+
+	if (!offset) {
+#ifdef DEBUG_HEAP
+		read_lock_irqsave(&heap_lock, flags);
+		tmp_a_c = alloc_cnt;
+		tmp_f_c = free_cnt;
+		tmp_t_a = total_alloc;
+		read_unlock_irqrestore(&heap_lock, flags);
+		printk("%s(%d) err: size 0x%08x, align 0x%08x. alloc_cnt %d, free_cnt %d, total_alloc 0x%08x\n",
+			__func__, __LINE__, (int)size, (int)align, tmp_a_c, tmp_f_c, tmp_t_a);
+#endif
 		return ION_CARVEOUT_ALLOCATE_FAIL;
-
+	}
+#ifdef DEBUG_HEAP
+	else {
+		write_lock_irqsave(&heap_lock, flags);
+		alloc_cnt++;
+		total_alloc += size;
+		if(max_single_len < size)
+			max_single_len = size;
+		if(max_total_alloc < total_alloc)
+			max_total_alloc = total_alloc;
+		tmp_a_c = alloc_cnt;
+		tmp_f_c = free_cnt;
+		tmp_t_a = total_alloc;
+		max_s_l = max_single_len;
+		max_t_a = max_total_alloc;
+		write_unlock_irqrestore(&heap_lock, flags);
+		printk("%s(%d) success: size 0x%08x, align 0x%08x, ret 0x%08x, alloc_cnt %d, free_cnt %d,"
+			"max_single_len 0x%08x, total_alloc 0x%08x, max_total_alloc 0x%08x\n", __func__, __LINE__,
+			(int)size, (int)align, (int)offset, tmp_a_c, tmp_f_c, max_s_l, tmp_t_a, max_t_a);
+	}
+#endif
 	return offset;
 }
 
-void ion_carveout_free(struct ion_heap *heap, ion_phys_addr_t addr,
-		       unsigned long size)
+void ion_carveout_free(struct ion_heap *heap, ion_phys_addr_t addr, unsigned long size)
 {
 	struct ion_carveout_heap *carveout_heap =
 		container_of(heap, struct ion_carveout_heap, heap);
 
+#ifdef DEBUG_HEAP
+	u32 tmp_a_c, tmp_f_c, tmp_t_a, max_s_l, max_t_a;
+	unsigned long flags;
+#endif
+
 	if (addr == ION_CARVEOUT_ALLOCATE_FAIL)
 		return;
 	gen_pool_free(carveout_heap->pool, addr, size);
+#ifdef DEBUG_HEAP
+	write_lock_irqsave(&heap_lock, flags);
+	free_cnt++;
+	total_alloc -= size;
+	tmp_a_c = alloc_cnt;
+	tmp_f_c = free_cnt;
+	tmp_t_a = total_alloc;
+	max_s_l = max_single_len;
+	max_t_a = max_total_alloc;
+	write_unlock_irqrestore(&heap_lock, flags);
+	printk("%s(%d): addr 0x%08x, size 0x%08x, alloc_cnt %d, free_cnt %d, max_single_len 0x%08x,"
+		"total_alloc 0x%08x, max_total_alloc 0x%08x\n", __func__, __LINE__,
+		(int)addr, (int)size, tmp_a_c, tmp_f_c, max_s_l, tmp_t_a, max_t_a);
+#endif
 }
 
 static int ion_carveout_heap_phys(struct ion_heap *heap,
@@ -107,6 +168,9 @@ void ion_carveout_heap_unmap_dma(struct ion_heap *heap,
 				 struct ion_buffer *buffer)
 {
 	sg_free_table(buffer->sg_table);
+	/* liugang add */
+	kfree(buffer->sg_table);
+	buffer->sg_table = NULL;
 }
 
 void *ion_carveout_heap_map_kernel(struct ion_heap *heap,
@@ -151,6 +215,8 @@ static struct ion_heap_ops carveout_heap_ops = {
 	.unmap_kernel = ion_carveout_heap_unmap_kernel,
 };
 
+#include <asm/setup.h>
+extern struct tag_mem32 ion_mem;
 struct ion_heap *ion_carveout_heap_create(struct ion_platform_heap *heap_data)
 {
 	struct ion_carveout_heap *carveout_heap;
@@ -164,9 +230,10 @@ struct ion_heap *ion_carveout_heap_create(struct ion_platform_heap *heap_data)
 		kfree(carveout_heap);
 		return ERR_PTR(-ENOMEM);
 	}
-	carveout_heap->base = heap_data->base;
-	gen_pool_add(carveout_heap->pool, carveout_heap->base, heap_data->size,
-		     -1);
+	//carveout_heap->base = heap_data->base;
+	//gen_pool_add(carveout_heap->pool, carveout_heap->base, heap_data->size, -1);
+	carveout_heap->base = ion_mem.start;
+	gen_pool_add(carveout_heap->pool, carveout_heap->base, ion_mem.size, -1);
 	carveout_heap->heap.ops = &carveout_heap_ops;
 	carveout_heap->heap.type = ION_HEAP_TYPE_CARVEOUT;
 
diff --git a/drivers/input/Makefile b/drivers/input/Makefile
index 9af5493..f8e75d4 100755
--- a/drivers/input/Makefile
+++ b/drivers/input/Makefile
@@ -24,7 +24,7 @@ obj-$(CONFIG_INPUT_TOUCHSCREEN)	+= touchscreen/
 obj-$(CONFIG_INPUT_MISC)	+= misc/
 obj-$(CONFIG_INPUT_GYR)		+= gyr/
 obj-$(CONFIG_INPUT_E_COMPASS)	+= e_compass/
-obj-$(CONFIG_INPUT_E_COMPASS)	+= ls/
+obj-$(CONFIG_INPUT_LIGHT_SENSOR)	+= ls/
 
 obj-$(CONFIG_INPUT_APMPOWER)	+= apm-power.o
 obj-$(CONFIG_INPUT_KEYRESET)	+= keyreset.o
diff --git a/drivers/input/init_ctp.c b/drivers/input/init_ctp.c
index 390afd0..0945526 100755
--- a/drivers/input/init_ctp.c
+++ b/drivers/input/init_ctp.c
@@ -284,6 +284,16 @@ static int ctp_fetch_sysconfig_para(void)
 		goto script_get_item_err;
 	}
 	config_info.screen_max_x = val.val;
+
+// add enable_fwupdate by ethan 13/06/24 ----begin
+
+	if(SCIRPT_ITEM_VALUE_TYPE_INT != script_get_item("ctp_para", "ctp_enable_fwupdate", &val)){
+		pr_err("%s: ctp_screen_max_x script_get_item err. \n",__func__ );
+		goto script_get_item_err;
+	}
+	config_info.enable_fwupdate = val.val;
+
+// add enable_fwupdate by ethan 13/06/24 ---end
 	
         if(SCIRPT_ITEM_VALUE_TYPE_INT != script_get_item("ctp_para", "ctp_screen_max_y", &val)){
         		pr_err("%s: ctp_screen_max_y script_get_item err. \n",__func__ );
diff --git a/drivers/input/ls/Kconfig b/drivers/input/ls/Kconfig
index dec32bd..ce6b211 100755
--- a/drivers/input/ls/Kconfig
+++ b/drivers/input/ls/Kconfig
@@ -21,4 +21,16 @@ config INPUT_LTR501ALS
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called ltr501als.
+
+config INPUT_LTR303
+	tristate "LTR303 LIGHT SENSOR driver"
+	depends on I2C
+	default m
+	help
+	  Say Y here if you want to use LTR303
+	  through I2C interface.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ltr303.
+
 endif
diff --git a/drivers/input/ls/LTR-303ALS.h b/drivers/input/ls/LTR-303ALS.h
new file mode 100644
index 0000000..0b5da87
--- /dev/null
+++ b/drivers/input/ls/LTR-303ALS.h
@@ -0,0 +1,41 @@
+/*****************************add by mark*************************/
+//#include <linux/leds.h>
+//#include <linux/device.h>
+//#include <linux/suspend.h>
+//#include <mach/sys_config.h>
+#define DEVICE_NAME		"al300x"
+#define LTR303_SLAVE_ADDR	0x29
+#define LTR303_PART_ID		0x86
+#define LTR303_MANUFACTURER_ID	0x87
+#define PARTID 0xA0
+#define MANUID 0x05
+/*
+enum {
+	DEBUG_INIT = 1U << 0,
+	DEBUG_REPORT_ALS_DATA = 1U << 1,
+	DEBUG_REPORT_PS_DATA = 1U << 2,
+	DEBUG_SUSPEND = 1U << 3,
+	DEBUG_CONTROL_INFO = 1U << 4,
+	DEBUG_INT = 1U << 5,
+};
+
+#define dprintk(level_mask, fmt, arg...)	if (unlikely(debug_mask & level_mask)) \
+	printk("*ltr_303:*" fmt , ## arg)
+
+static u32 debug_mask = 0;
+*/
+struct sensor_config{
+	int twi_id;
+	int int1;
+	int int_mode;
+};
+static struct sensor_config sensor_config ;
+
+
+/*: Addresses to scan */
+
+static const unsigned short normal_i2c[2] = {LTR303_SLAVE_ADDR,I2C_CLIENT_END};
+static int i2c_num = 0;
+static const unsigned short i2c_address[] = {LTR303_SLAVE_ADDR, LTR303_SLAVE_ADDR};
+/************************************add end**********************/
+
diff --git a/drivers/input/ls/Makefile b/drivers/input/ls/Makefile
index ea57589..e151904 100755
--- a/drivers/input/ls/Makefile
+++ b/drivers/input/ls/Makefile
@@ -4,5 +4,6 @@
 
 # Each configuration option enables a list of files.
 
-obj-$(CONFIG_INPUT_LTR501ALS)		+= ltr_501als.o
+#obj-$(CONFIG_INPUT_LTR501ALS)		+= ltr_501als.o
 
+obj-$(CONFIG_INPUT_LTR303)		+= ltr303.o
diff --git a/drivers/input/ls/ltr303.c b/drivers/input/ls/ltr303.c
new file mode 100644
index 0000000..be5683f
--- /dev/null
+++ b/drivers/input/ls/ltr303.c
@@ -0,0 +1,1025 @@
+/******************** (C) COPYRIGHT 2011 STMicroelectronics ********************
+*
+* File Name         : al303x.c //(edit)
+* Authors            : Star-wu - Application Team
+* Version            : V 0.2
+* Date                : 06/24/2011
+* Description       : al303x Digital Ambient Light Sensor API //(edit)
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+* THIS SOFTWARE IS SPECIFICALLY DESIGNED FOR EXCLUSIVE USE WITH ST PARTS.
+*
+*******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/i2c-dev.h>
+#include <linux/uaccess.h>
+#include <linux/slab.h>
+#include <linux/miscdevice.h>
+#include <linux/earlysuspend.h>
+#define al300x_MAJOR   249
+#define al300x_MINOR   4
+#define G_MAX			8000
+#define FUZZ			0
+#define FLAT			0
+/* al303x light sensor registers */
+
+//(edit)#define CTRL_REG            0x00    /* power mode control reg */
+#define CTRL_REG            0x80    /* power mode control reg */ //(edit)
+//(edit)#define TIME_CTRL_REG       0x01    /* Timing Control reg */
+//(edit)#define ALS_CTRL_REG        0x02    /*ALS Control reg */
+//(edit)#define INT_STATUS_REG      0x03    /* Interrupt Status reg */
+//(edit)#define DATA_REG            0x05    /* Data reg */
+#define DATA_REG            0x88    /* Data reg */ //(edit)
+//(edit)#define ALS_WINDOW_REG      0x08    /*ALS Window*/
+#define NAME			"al300x"  //?? NAME of device shoudl be setup in BSP file. //(edit)
+#define DEBUG 0
+#define D printk("line=%d,func=%s\n",__LINE__,__func__);
+
+
+#define al300x_IOCTL_BASE 'l'
+/* The following define the IOCTL command values via the ioctl macros */
+#define AL300X_SET_POWER_MODE		_IOW(al300x_IOCTL_BASE, 1, int)
+#define AL300X_SET_ALS_LEVEL		_IOW(al300x_IOCTL_BASE, 2, int)
+#define AL300X_READ_DATA_VALUE	    _IOW(al300x_IOCTL_BASE, 3, int)
+
+
+/*add by mark*/
+#include <mach/sys_config.h>
+#include "LTR-303ALS.h"
+//add end
+
+
+struct al300x_data {
+	struct i2c_client *client;
+//	struct lsm303dlh_acc_platform_data *pdata;
+
+	struct mutex lock;
+
+	struct delayed_work input_work;
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	atomic_t enabled;
+	int on_before_suspend;
+	struct early_suspend early_suspend;
+	u8 shift_adj;
+	u8 resume_state[5];
+};
+
+static struct al300x_data *acc;
+static void al300x_early_suspend(struct early_suspend *h);
+static void al300x_late_resume(struct early_suspend *h);
+ /*
+static int lux_table[64]={1,1,1,2,2,2,3,4,4,5,6,7,9,11,13,16,19,22,27,32,39,46,56,67,80,96,
+                          116,139,167,200,240,289,346,416,499,599,720,864,1037,1245,1495,
+                          1795,2154,2586,3105,3728,4475,5372,6449,7743,9295,11159,13396,
+                          16082,19307,23178,27826,33405,40103,48144,57797,69386,83298,
+                          100000};
+*/                        
+static int lux_table[64]={50,150,200,300,500,700,900,1000,1100,1200,1300,1400,1500,1600,13,16,19,22,27,32,39,46,56,67,80,96,
+                          116,139,167,200,240,289,346,416,499,599,720,864,1037,1245,1495,
+                          1795,2154,2586,3105,3728,4475,5372,6449,7743,9295,11159,13396,
+                          16082,19307,23178,27826,33405,40103,48144,57797,69386,83298,
+                          100000};                          
+                          
+
+
+struct al300x_data *light_data;
+
+static char al300x_i2c_write(unsigned char reg_addr,
+				    unsigned char *data,
+				    unsigned char len);
+/*
+static char al300x_i2c_read(unsigned char reg_addr,
+				   unsigned char *data,
+				   unsigned char len);
+*/
+/*  i2c write routine for al300x digital accscope */
+static char al300x_i2c_write(unsigned char reg_addr,
+                unsigned char *data,  unsigned char len)
+{
+    int dummy;
+	int i;
+	if (light_data->client == NULL)  /*  No global client pointer? */
+		return -1;
+	for (i = 0; i < len; i++)
+		{
+		dummy = i2c_smbus_write_byte_data(light_data->client,
+			                      reg_addr++, data[i]);
+		if (dummy)
+			{
+			#if DEBUG
+			printk(KERN_ERR "i2c write error\n");
+			#endif
+			return dummy;
+			}
+		}
+	return 0;
+}
+/*
+//  i2c read routine for al300x digital ambient Light Sensor 
+static char al300x_i2c_read(unsigned char reg_addr,	
+                    unsigned char *data, unsigned char len)
+{
+    int dummy = 0;
+	int i = 0;
+
+	if (light_data->client == NULL)  //  No global client pointer? 
+		return -1;
+	while (i < len)
+		{
+		dummy = i2c_smbus_read_word_data(light_data->client, reg_addr++);
+		if (dummy >= 0)
+			{
+			data[i] = dummy & 0x00ff;
+			i++;
+			}
+		else {
+			#if DEBUG
+			printk(KERN_ERR" i2c read error\n ");
+			#endif
+			return dummy;
+			}
+		dummy = len;
+		}
+	return dummy;
+}
+*/
+
+int al300x_set_power_mode(char mode)
+{
+	int res = 0;
+	res = i2c_smbus_read_word_data(light_data->client, CTRL_REG);
+//(edit)	if ((res & 0x00FF) == 0x0003) {
+	if ((res & 0x0001) == 0x0000) { //(edit)
+	   res = al300x_i2c_write(CTRL_REG, &mode, 1);
+	}
+	return res;
+}
+
+int al300x_set_als_level(char level)
+{
+	int res = 0;
+	unsigned char gain_level; //(edit)
+	res = i2c_smbus_read_word_data(light_data->client, CTRL_REG);
+//(edit)	if ((res & 0x00FF) == 0x0003) {
+	if ((res & 0x00FF) == 0x0000) { //(edit)
+//(edit)	   res = al300x_i2c_write(ALS_CTRL_REG, &level, 1);
+		gain_level = res & 0xE3; //(edit)
+		gain_level += (level << 2); //(edit)
+		res = al300x_i2c_write(CTRL_REG, &gain_level, 1); //(edit)
+	}
+	return res;
+}
+
+/* Device Initialization  */
+static int device_init(void)
+{	
+    int res;
+	unsigned char buf[10];
+//(edit)	buf[0] = 0x00;
+//(edit)	buf[1] = 0x11;
+//(edit)	buf[2] = 0xa0;
+	buf[0] = 0x01; //(edit)
+//mark	buf[0] = 0x0D;
+	
+//(edit)	res = al300x_i2c_write(CTRL_REG, &buf[0], 3);
+		res = al300x_i2c_write(CTRL_REG, &buf[0], 1); //(edit)
+//(edit)	buf[8] = 0x00;
+//(edit)	res = al300x_i2c_write(ALS_WINDOW_REG, &buf[8], 1);
+	return res;
+}
+
+/* lignt sensor data readout */
+//int al300x_read_data_values(unsigned int *data)
+int al300x_read_data_values(unsigned char *data)
+{		
+	int val;
+	unsigned char rd_data[12]; //(edit)
+	unsigned char als_gain_fac = 0, als_int_fac = 0; //(edit)
+	unsigned short ch0_reading, ch1_reading, als_ratio, calc_lux;
+
+	/* ------ (edit)
+	* #bytes		Reg_addr				array_element
+	* 1. 			0x80 (ALS_CONTR)		[0]
+	* 2. 			0x81 (NA)				[1]
+	* 3. 			0x82 (NA)				[2]
+	* 4. 			0x83 (NA)				[3]
+	* 5. 			0x84 (NA)				[4]
+	* 6. 			0x85 (ALS_MEAS_RATE)	[5]
+	* 7. 			0x86 (PART_ID)			[6]
+	* 8. 			0x87 (MANUFAC_ID)		[7]
+	* 9. 			0x88 (ALS_DATA_CH1_0)	[8]
+	* A. 			0x89 (ALS_DATA_CH1_1)	[9]
+	* B. 			0x8A (ALS_DATA_CH0_0)	[A]
+	* C. 		0x8B (ALS_DATA_CH0_1)	[B]
+	(edit) ------ */
+
+//(edit)	val = i2c_smbus_read_byte_data(light_data->client, DATA_REG);
+//	val = i2c_smbus_read_i2c_block_data(light_data->client, DATA_REG, 0x0C, rd_data); //(edit)
+	val = i2c_smbus_read_i2c_block_data(light_data->client, CTRL_REG, 0x0C, rd_data);
+
+//(edit)	val &= 0x3f;
+//(edit)>
+	if ((rd_data[0] & 0x1C) == 0x00) { 			//gain 1x
+		als_gain_fac = 1;
+	} else if ((rd_data[0] & 0x1C) == 0x04) {		//gain 2x
+		als_gain_fac = 2;
+	} else if ((rd_data[0] & 0x1C) == 0x08) {		//gain 4x
+		als_gain_fac = 4;
+	} else if ((rd_data[0] & 0x1C) == 0x0C) {		//gain 8x
+		als_gain_fac = 8;
+	} else if ((rd_data[0] & 0x18) == 0x0C) {		//gain 48x
+		als_gain_fac = 48;
+	} else if ((rd_data[0] & 0x1C) == 0x1C) {		//gain 96x
+		als_gain_fac = 96;
+	}
+
+	if ((rd_data[5] & 0x38) == 0x00) {			//100ms
+		als_int_fac = 10;
+	} else if ((rd_data[5] & 0x38) == 0x08) {		//50ms
+		als_int_fac = 5;
+	} else if ((rd_data[5] & 0x38) == 0x10) {		//200ms
+		als_int_fac = 20;
+	} else if ((rd_data[5] & 0x38) == 0x18) {		//400ms
+		als_int_fac = 40;
+	} else if ((rd_data[5] & 0x38) == 0x20) {		//150ms
+		als_int_fac = 15;
+	} else if ((rd_data[5] & 0x38) == 0x28) {		//250ms
+		als_int_fac = 25;
+	} else if ((rd_data[5] & 0x38) == 0x30) {		//300ms
+		als_int_fac = 30;
+	} else if ((rd_data[5] & 0x38) == 0x38) {		//350ms
+		als_int_fac = 35;
+	}
+
+	ch0_reading = rd_data[0x0B];
+	ch0_reading <<= 8;
+	ch0_reading += rd_data[0x0A];
+
+	ch1_reading = rd_data[0x09];
+	ch1_reading <<= 8;
+	ch1_reading += rd_data[0x08];
+
+	if ((ch0_reading + ch1_reading) == 0) {
+		als_ratio = 1000;
+	} else {
+		als_ratio = (ch1_reading * 1000) / (ch0_reading + ch1_reading);
+	}
+
+	if (als_ratio < 450) {
+		calc_lux = ((17743 * ch0_reading) + (11059 * ch1_reading)) / (als_gain_fac * (als_int_fac * 1000));
+	} else if ((als_ratio >= 450) && (als_ratio < 640)) {
+		calc_lux = ((42785 * ch0_reading) - (19548 * ch1_reading)) / (als_gain_fac * (als_int_fac * 1000));
+	} else if ((als_ratio >= 640) && (als_ratio < 850)) {
+		calc_lux = ((5926 * ch0_reading) + (1185 * ch1_reading)) / (als_gain_fac * (als_int_fac * 1000));
+	} else {
+		calc_lux = 0;
+	}
+
+	if ((calc_lux >= 0) && (calc_lux <= 1)) {
+		val = 0;
+	} else if (calc_lux == 2) {
+		val = 3;
+	} else if (calc_lux == 3) {
+		val = 6;
+	} else if (calc_lux == 4) {
+		val = 7;
+	} else if (calc_lux == 5) {
+		val = 9;
+	} else if (calc_lux == 6) {
+		val = 10;
+	} else if ((calc_lux >= 7) && (calc_lux < 9)) {
+		val = 11;
+	} else if ((calc_lux >= 9) && (calc_lux < 11)) {
+		val = 12;
+	} else if ((calc_lux >= 11) && (calc_lux < 13)) {
+		val = 13;
+	} else if ((calc_lux >= 13) && (calc_lux < 19)) {
+		val = 15;
+	} else if ((calc_lux >= 19) && (calc_lux < 22)) {
+		val = 16;
+	} else if ((calc_lux >= 22) && (calc_lux < 27)) {
+		val = 17;
+	} else if ((calc_lux >= 27) && (calc_lux < 32)) {
+		val = 18;
+	} else if ((calc_lux >= 32) && (calc_lux < 39)) {
+		val = 19;
+	} else if ((calc_lux >= 39) && (calc_lux < 46)) {
+		val = 20;
+	} else if ((calc_lux >= 46) && (calc_lux < 56)) {
+		val = 21;
+	} else if ((calc_lux >= 56) && (calc_lux < 67)) {
+		val = 22;
+	} else if ((calc_lux >= 67) && (calc_lux < 80)) {
+		val = 23;
+	} else if ((calc_lux >= 80) && (calc_lux < 96)) {
+		val = 24;
+	} else if ((calc_lux >= 96) && (calc_lux < 116)) {
+		val = 25;
+	} else if ((calc_lux >= 116) && (calc_lux < 139)) {
+		val = 26;
+	} else if ((calc_lux >= 139) && (calc_lux < 167)) {
+		val = 27;
+	} else if ((calc_lux >= 167) && (calc_lux < 200)) {
+		val = 28;
+	} else if ((calc_lux >= 200) && (calc_lux < 240)) {
+		val = 29;
+	} else if ((calc_lux >= 240) && (calc_lux < 289)) {
+		val = 30;
+	} else if ((calc_lux >= 289) && (calc_lux < 346)) {
+		val = 31;
+	} else if ((calc_lux >= 346) && (calc_lux < 416)) {
+		val = 32;
+	} else if ((calc_lux >= 416) && (calc_lux < 499)) {
+		val = 33;
+	} else if ((calc_lux >= 499) && (calc_lux < 599)) {
+		val = 34;
+	} else if ((calc_lux >= 599) && (calc_lux < 720)) {
+		val = 35;
+	} else if ((calc_lux >= 720) && (calc_lux < 864)) {
+		val = 36;
+	} else if ((calc_lux >= 864) && (calc_lux < 1037)) {
+		val = 37;
+	} else if ((calc_lux >= 1037) && (calc_lux < 1245)) {
+		val = 38;
+	} else if ((calc_lux >= 1245) && (calc_lux < 1495)) {
+		val = 39;
+	} else if ((calc_lux >= 1495) && (calc_lux < 1795)) {
+		val = 40;
+	} else if ((calc_lux >= 1795) && (calc_lux < 2145)) {
+		val = 41;
+	} else if ((calc_lux >= 2145) && (calc_lux < 2586)) {
+		val = 42;
+	} else if ((calc_lux >= 2586) && (calc_lux < 3105)) {
+		val = 43;
+	} else if ((calc_lux >= 3105) && (calc_lux < 3728)) {
+		val = 44;
+	} else if ((calc_lux >= 3728) && (calc_lux < 4475)) {
+		val = 45;
+	} else if ((calc_lux >= 4475) && (calc_lux < 5372)) {
+		val = 46;
+	} else if ((calc_lux >= 5372) && (calc_lux < 6449)) {
+		val = 47;
+	} else if ((calc_lux >= 6449) && (calc_lux < 7743)) {
+		val = 48;
+	} else if ((calc_lux >= 7743) && (calc_lux < 9295)) {
+		val = 49;
+	} else if ((calc_lux >= 9295) && (calc_lux < 11159)) {
+		val = 50;
+	} else if ((calc_lux >= 11159) && (calc_lux < 13396)) {
+		val = 51;
+	} else if ((calc_lux >= 13396) && (calc_lux < 16082)) {
+		val = 52;
+	} else if ((calc_lux >= 16082) && (calc_lux < 19307)) {
+		val = 53;
+	} else if ((calc_lux >= 19307) && (calc_lux < 23178)) {
+		val = 54;
+	} else if ((calc_lux >= 23178) && (calc_lux < 27826)) {
+		val = 55;
+	} else if ((calc_lux >= 27826) && (calc_lux < 33405)) {
+		val = 56;
+	} else if ((calc_lux >= 33405) && (calc_lux < 40103)) {
+		val = 57;
+	} else if ((calc_lux >= 40103) && (calc_lux < 48144)) {
+		val = 58;
+	} else if ((calc_lux >= 48144) && (calc_lux < 57797)) {
+		val = 59;
+//	} else if ((calc_lux >= 57797) && (calc_lux <= 65000)) {
+	} else if ((calc_lux >= 57797) && (calc_lux <= 65535)) {
+		val = 60;
+	}
+//(edit)<
+	*data = (lux_table[val]);
+	return val;
+
+}
+
+static void al300x_report_values(struct al300x_data *acc,
+//					unsigned int *data)
+					int data)
+{
+	
+//	input_report_abs(acc->input_dev, ABS_MISC, *data);
+	input_report_abs(acc->input_dev, ABS_MISC, data);
+
+	input_sync(acc->input_dev);
+
+}
+
+
+static int al300x_enable(struct al300x_data *acc)
+{
+	int err;
+	
+
+	if (!atomic_cmpxchg(&acc->enabled, 0, 1)) {
+
+		err = device_init();
+		if (err < 0) {
+			atomic_set(&acc->enabled, 0);
+			return err;
+		}
+		schedule_delayed_work(&acc->input_work,
+				      msecs_to_jiffies(200));
+	}
+
+	return 0;
+}
+
+static int al300x_disable(struct al300x_data *acc)
+{
+	if (atomic_cmpxchg(&acc->enabled, 1, 0)) {
+		cancel_delayed_work_sync(&acc->input_work);
+		
+	}
+
+	return 0;
+}
+
+/*  read command for al300x device file  */
+static ssize_t al300x_read(struct file *file, char __user *buf,
+                              size_t count, loff_t *offset)
+{
+   #if DEBUG	
+   unsigned char data[1];
+// unsigned int data[1];		//2013-06-11
+   #endif
+   if (light_data->client == NULL)
+   	return -1;
+   #if DEBUG
+   al300x_read_data_values(&data[0]);
+   #endif
+   return 0;
+}
+
+/*  write command for al300x device file */
+static ssize_t al300x_write(struct file *file, const char __user *buf,
+           size_t count, loff_t *offset)
+{	
+   if (light_data->client == NULL)
+   	return -1;
+   #if DEBUG
+   printk(KERN_INFO "al300x should be accessed with ioctl command\n");
+   #endif
+   return 0;
+}
+
+/*  open command for al300x device file  */
+static int al300x_open(struct inode *inode, struct file *file)
+{	
+	int err;
+	err = nonseekable_open(inode, file);
+	if (err < 0)
+		return err;
+
+	file->private_data = light_data;
+
+	return 0;
+
+  // device_init();
+   #if DEBUG
+   printk(KERN_INFO "al300x has been opened\n");
+   #endif
+   return 0;
+}
+
+/*  release command for al300x device file */
+static int al300x_close(struct inode *inode, struct file *file)
+{	
+   #if DEBUG
+   printk(KERN_INFO "al300x has been closed\n");
+   #endif
+   return 0;
+}
+
+/*  ioctl command for al300x device file */
+//static int al300x_ioctl(struct file *file,
+static long al300x_ioctl(struct file *file,
+                   unsigned int cmd, unsigned long arg)
+{
+//  	printk(KERN_INFO "into read 303\n");	////////////////////
+	int err = 0;
+	unsigned char data[6];
+//	unsigned int data[6];		//2013-06-13
+	/* check al300x_client */
+	if (acc->client == NULL) {
+		#if DEBUG
+		printk(KERN_ERR "I2C driver not install\n");
+		#endif
+		return -EFAULT;
+	}
+	/* cmd mapping */
+switch (cmd) {
+
+	case AL300X_SET_POWER_MODE:
+		if (copy_from_user(data, (unsigned char *)arg, 1) != 0) {
+			#if DEBUG
+			printk(KERN_ERR "copy_to_user error\n");
+			#endif
+			return -EFAULT;
+		}
+		err = al300x_set_power_mode(*data);
+		return err;
+	case AL300X_SET_ALS_LEVEL: 
+		if (copy_from_user(data, (unsigned char *)arg, 1) != 0) {
+			#if DEBUG
+			printk(KERN_ERR "copy_from_user error\n");
+			#endif
+			return -EFAULT;
+		}
+		err = al300x_set_als_level(*data);
+		return err;
+	case AL300X_READ_DATA_VALUE:
+		err = al300x_read_data_values(&data[0]);
+//		printk(KERN_INFO "into case err=%d\n");	////////////////////
+//		err = al300x_read_data_values(&data);
+		if (copy_to_user((unsigned char *)arg, data, 1) != 0) {
+			    #if DEBUG
+				printk(KERN_ERR "copy_to error\n");
+				#endif
+				return -EFAULT;
+		}
+		return err;
+	default:
+		return 0;
+ }
+}
+
+
+
+static ssize_t ls_poll_delay_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return 0;	
+}
+
+
+static ssize_t ls_poll_delay_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int64_t new_delay;
+	int err;
+
+	err = strict_strtoll(buf, 10, &new_delay);
+	if (err < 0)
+		return err;
+
+	
+
+	return size;
+}
+
+static ssize_t light_enable_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	
+	return sprintf(buf, "%d\n",
+		       (&light_data->enabled ) ? 1 : 0);
+}
+
+static ssize_t light_enable_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+
+	bool new_value;
+
+	if (sysfs_streq(buf, "1"))
+		new_value = true;
+	else if (sysfs_streq(buf, "0"))
+		new_value = false;
+	else {
+		printk("%s: invalid value %d\n", __func__, *buf);
+		return -EINVAL;
+	}
+/*
+	if(new_value)
+		al300x_enable(light_data);		
+	else
+		al300x_disable(light_data);
+*/		
+	return size;
+}
+
+
+static DEVICE_ATTR(ls_poll_delay, S_IRUGO | S_IWUSR | S_IWGRP,
+		   ls_poll_delay_show, ls_poll_delay_store);
+
+static struct device_attribute dev_attr_light_enable =
+	__ATTR(enable, S_IRUGO | S_IWUSR | S_IWGRP,
+	       light_enable_show, light_enable_store);
+
+static struct attribute *light_sysfs_attrs[] = {
+	&dev_attr_light_enable.attr,
+	&dev_attr_ls_poll_delay.attr,
+	NULL
+};
+
+static struct attribute_group light_attribute_group = {
+	.attrs = light_sysfs_attrs,
+};
+
+static const struct file_operations al300x_fops = {
+	.owner = THIS_MODULE,	
+	.read = al300x_read,	
+	.write = al300x_write,
+	.open = al300x_open,
+	.release = al300x_close,
+	.unlocked_ioctl = al300x_ioctl,
+};
+static struct miscdevice al300x_misc_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = NAME,
+	.fops = &al300x_fops,
+};
+
+static void al300x_input_work_func(struct work_struct *work)
+{
+	struct al300x_data *acc;
+	unsigned char data;
+//	unsigned int data;
+	int err;
+//   	int poll_interval = 200;
+	int poll_interval = 600;
+
+	acc = container_of((struct delayed_work *)work,
+			    struct al300x_data, input_work);
+
+	mutex_lock(&acc->lock);
+	device_init();
+	err = al300x_read_data_values(&data);
+	if (err < 0)
+		dev_err(&acc->client->dev, "get al300x data failed\n");
+	else
+//		al300x_report_values(acc, &data);
+		al300x_report_values(acc, err);
+
+	schedule_delayed_work(&acc->input_work,msecs_to_jiffies(poll_interval));
+	mutex_unlock(&acc->lock);
+}
+
+int al300x_input_open(struct input_dev *input)
+{
+	struct al300x_data *acc = input_get_drvdata(input);
+
+	return al300x_enable(acc);
+}
+
+void al300x_input_close(struct input_dev *dev)
+{
+	struct al300x_data *acc = input_get_drvdata(dev);
+
+	al300x_disable(acc);	
+}
+
+static int al300x_input_init(struct al300x_data *acc)
+{
+	int err;
+	INIT_DELAYED_WORK(&acc->input_work, al300x_input_work_func);
+	acc->input_dev = input_allocate_device();
+	if (!acc->input_dev) {
+		err = -ENOMEM;
+		dev_err(&acc->client->dev, "input device allocate failed\n");
+		goto err0;
+	}
+
+	acc->input_dev->open = al300x_input_open;
+	acc->input_dev->close =al300x_input_close;
+
+	input_set_drvdata(acc->input_dev, acc);
+	
+	set_bit(EV_ABS, acc->input_dev->evbit);
+
+	input_set_capability(acc->input_dev, EV_ABS, ABS_MISC);
+	input_set_abs_params(acc->input_dev, ABS_MISC, 0, 9, 0, 0);
+
+	acc->input_dev->name = "lightsensor-level";
+
+	err = input_register_device(acc->input_dev); //??regist a input event device
+	if (err) {
+		dev_err(&acc->client->dev,
+			"unable to register input polled device %s\n",
+			acc->input_dev->name);
+		goto err1;
+	}
+	err = sysfs_create_group(&acc->input_dev->dev.kobj,
+				 &light_attribute_group);
+	if (err) {
+		printk("%s: could not create sysfs group\n", __func__);
+		goto err1;
+	}
+	return 0;
+
+err1:
+	input_free_device(acc->input_dev);
+err0:
+	return err;
+}
+
+static int al300x_probe(struct i2c_client *client,
+			   const struct i2c_device_id *id)					
+
+{
+//	printk("++++sam debug al300x_probe-----------------\n");
+	struct al300x_data *acc;
+	int err = -1;
+	int tempvalue;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "client not i2c capable\n");
+		err = -ENODEV;
+		goto exit;
+	}	
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK))
+		goto exit;
+
+
+	acc = kzalloc(sizeof(*acc), GFP_KERNEL);
+	if (acc == NULL) {
+		dev_err(&client->dev,
+			"failed to allocate memory for module data\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	i2c_set_clientdata(client, acc);
+	mutex_init(&acc->lock);
+	mutex_lock(&acc->lock);
+	acc->client = client;
+
+	if (i2c_smbus_read_byte(client) < 0) {	
+		#if DEBUG	
+		printk(KERN_ERR "i2c_smbus_read_byte error!!\n");
+		#endif	
+		goto exit_kfree;
+	} else {	
+		#if DEBUG	
+		printk(KERN_INFO "al300x Device detected!\n");	
+		#endif	
+	}
+
+	/* read power mode */
+	tempvalue = i2c_smbus_read_word_data(client, CTRL_REG);
+	if ((tempvalue & 0x00FF) == 0x0003) {
+		#if DEBUG	
+		printk(KERN_INFO "The Light sensor is in idle mode!\n");	
+		#endif	
+		} else {
+		//acc->client = NULL;	
+		//goto exit_kfree;
+		#if DEBUG
+		printk(KERN_INFO "The Light sensor is in active mode!\n");
+		#endif
+	}
+
+	err = al300x_input_init(acc);
+	if (err < 0)
+		goto out;
+//	printk("----------al300x_input_init-----------------\n");
+    light_data = acc;
+
+	err = misc_register(&al300x_misc_device);  //?? register a charactor device 
+	if (err < 0) {
+		dev_err(&client->dev, "al300x_device register failed\n");
+		goto err4;
+	}
+//	printk("----------misc_register-----------------\n");
+	acc->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	acc->early_suspend.suspend = al300x_early_suspend;
+	acc->early_suspend.resume = al300x_late_resume;
+	register_early_suspend(&acc->early_suspend);
+
+	/* As default, do not report information */
+	atomic_set(&acc->enabled, 0);
+
+	mutex_unlock(&acc->lock);
+
+	dev_info(&client->dev, "al300x probe success\n");
+
+	return 0;
+	
+	#if DEBUG
+	printk(KERN_INFO "al300x device created successfully\n");
+	#endif
+	return 0;
+err4:
+	input_unregister_device(acc->input_dev);
+	input_free_device(acc->input_dev);
+out:
+	#if DEBUG	
+	printk(KERN_ERR "%s: Driver Initialization failed\n", __FILE__);
+	#endif
+exit_kfree:
+    kfree(acc);
+exit:	
+	return 0;
+}
+
+static int __devexit al300x_remove(struct i2c_client *client)
+{
+	struct al300x_data *acc = i2c_get_clientdata(client);
+	#if DEBUG	
+	printk(KERN_INFO "al300x driver removing\n");
+	#endif	
+
+	misc_deregister(&al300x_misc_device);
+	sysfs_remove_group(&acc->input_dev->dev.kobj,
+			   &light_attribute_group);
+	input_unregister_device(acc->input_dev);
+	input_free_device(acc->input_dev);
+
+	kfree(acc);	
+	return 0;
+}
+
+static void al300x_late_resume(struct early_suspend *h)
+{
+    	int res;
+	unsigned char buf[1];
+	buf[0] = 0x00;	
+	
+	res = al300x_i2c_write(CTRL_REG, &buf[0], 1);
+
+	#if DEBUG	
+	printk(KERN_INFO "al300x_resume\n");
+	#endif		
+	al300x_enable(light_data);
+//	return 0;
+}
+
+static void al300x_early_suspend(struct early_suspend *h)
+{	
+    	int res;
+	unsigned char buf[1];
+   	al300x_disable(light_data); 
+	buf[0] = 0x0b;	
+	res = al300x_i2c_write(CTRL_REG, &buf[0], 1);
+	#if DEBUG
+	printk(KERN_INFO "al300x_suspend\n");
+	#endif
+//   	return res;
+}
+
+static const struct i2c_device_id al300x_id[] = {
+	{"al300x", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, al300x_id);
+
+static struct i2c_driver al300x_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = al300x_probe,
+	.id_table = al300x_id,
+	.address_list   = normal_i2c,
+	.remove = __devexit_p(al300x_remove),
+	.driver = {
+		   .name = "al300x",
+		   },
+};
+
+/**
+ * ls_detect - Device detection callback for automatic device creation
+ * return value:  
+ *                    = 0; success;
+ *                    < 0; err
+ */
+static int ls_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	int ret;
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+            return -ENODEV;
+//         printk(KERN_INFO "ltr303 i2c_check_functionality is ok\n");   
+	if (sensor_config.twi_id == adapter->nr) {
+		for (i2c_num = 0; i2c_num < (sizeof(i2c_address)/sizeof(i2c_address[0]));i2c_num++) {	    
+			client->addr = i2c_address[i2c_num];
+			//dprintk(DEBUG_INIT, "%s:addr= 0x%x,i2c_num:%d\n",__func__,client->addr,i2c_num);
+			ret = i2c_smbus_read_byte_data(client,LTR303_MANUFACTURER_ID);
+			//dprintk(DEBUG_INIT, "Read MID value is :%d",ret);
+			if ((ret &0x00FF) == MANUID) {
+				ret = i2c_smbus_read_byte_data(client,LTR303_PART_ID);
+				//dprintk(DEBUG_INIT, "Read PID value is :%d",ret);
+				if ((ret &0x00FF) == PARTID) {
+					//printk("LS Device detected!\n" );
+					strlcpy(info->type, DEVICE_NAME, I2C_NAME_SIZE);
+					return 0;
+				}
+			}                                                           
+		}
+        
+		pr_info("%s:LS Device not found, \
+		maybe the other gsensor equipment! \n",__func__);
+		return -ENODEV;
+	} else {
+		return -ENODEV;
+	}
+}
+
+/**
+ * ls_fetch_sysconfig_para - get config info from sysconfig.fex file.
+ * return value:  
+ *                    = 0; success;
+ *                    < 0; err
+ */
+static int ls_fetch_sysconfig_para(void)
+{
+	int ret = -1;
+	int device_used = -1;
+	int twi_id = 0;
+	int sensor_int = 0;
+	script_item_u	val;
+	script_item_value_type_e  type;	
+		
+//	printk(KERN_INFO "========%s===================\n", __func__);
+	
+	type = script_get_item("ls_para", "ls_used", &val);
+ 
+	if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+		pr_err("%s: type err  device_used = %d. \n", __func__, val.val);
+		goto script_get_err;
+	}
+	device_used = val.val;
+	if (1 == device_used) {
+		type = script_get_item("ls_para", "ls_twi_id", &val);	
+		if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+			pr_err("%s: type err twi_id = %d. \n", __func__, val.val);
+			goto script_get_err;
+		}
+		twi_id = val.val;
+
+		type = script_get_item("ls_para", "ls_int", &val);
+//                printk(KERN_INFO "type=%d\n",type);	
+		if (SCIRPT_ITEM_VALUE_TYPE_PIO != type) {
+//			printk("%s: type err twi int1 = %d. \n", __func__, val.gpio.gpio);
+			goto script_get_err;
+		}
+		sensor_int = val.gpio.gpio;
+
+		
+		ret = 0;
+		
+	} else {
+		pr_err("%s: ls_unused. \n",  __func__);
+		ret = -1;
+	}
+	sensor_config.twi_id = twi_id;
+	sensor_config.int1 = sensor_int;
+
+	return ret;
+
+script_get_err:
+	pr_notice("=========script_get_err============\n");
+	return ret;
+
+}
+
+static int __init al300x_init(void)
+{
+//	printk(KERN_INFO "al300x light sensor init\n");
+
+// add by mark----
+	if(ls_fetch_sysconfig_para())
+	 {
+//		printk("%s: err.\n", __func__);
+		return -1;
+	}
+	al300x_driver.detect = ls_detect;
+//end
+
+	return i2c_add_driver(&al300x_driver);
+}
+
+static void __exit al300x_exit(void)
+{
+	i2c_del_driver(&al300x_driver);
+	return;
+}
+
+module_init(al300x_init);
+module_exit(al300x_exit);
+
+MODULE_DESCRIPTION("al300x light sensor driver");
+MODULE_AUTHOR("");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/touchscreen/ft5x_ts.c b/drivers/input/touchscreen/ft5x_ts.c
index bf4def2..a7e1bb5 100755
--- a/drivers/input/touchscreen/ft5x_ts.c
+++ b/drivers/input/touchscreen/ft5x_ts.c
@@ -47,7 +47,7 @@
 #include <mach/gpio.h> 
 #include <linux/ctp.h>
 
-
+#define SYSFS_DEBUG
 
 #define FOR_TSLIB_TEST
 //#define TOUCH_KEY_SUPPORT
@@ -79,6 +79,7 @@ struct i2c_dev{
 
 extern struct ctp_config_info config_info;
 
+static struct mutex g_device_mutex; //add by ethan 13/05/22
 
 static struct class *i2c_dev_class;
 static LIST_HEAD (i2c_dev_list);
@@ -100,6 +101,7 @@ static int key_val = 0;
 #define SCREEN_MAX_Y			(screen_max_y)
 #define PRESS_MAX			(255)
 
+static int enable_fwupdate = 0; //add by ethan 03/05/21
 static int screen_max_x = 0;
 static int screen_max_y = 0;
 static int revert_x_flag = 0;
@@ -188,22 +190,11 @@ static struct i2c_dev *get_free_i2c_dev(struct i2c_adapter *adap)
 static int ft5x_i2c_rxdata(char *rxdata, int length);
 
 struct ts_event {
-	u16	x1;
-	u16	y1;
-	u16	x2;
-	u16	y2;
-	u16	x3;
-	u16	y3;
-	u16	x4;
-	u16	y4;
-	u16	x5;
-	u16	y5;
+	u16	au16_x[CFG_MAX_TOUCH_POINTS];
+	u16	au16_y[CFG_MAX_TOUCH_POINTS];	
 	u16	pressure;
-	s16 touch_ID1;
-	s16 touch_ID2;
-	s16 touch_ID3;
-	s16 touch_ID4;
-	s16 touch_ID5;
+	s16 touch_ID[CFG_MAX_TOUCH_POINTS];
+	u8	touch_event[CFG_MAX_TOUCH_POINTS];
     u8  touch_point;
 };
 
@@ -452,6 +443,7 @@ unsigned char fts_ctpm_get_i_file_ver(void)
 {
         unsigned int ui_sz;
         ui_sz = sizeof(CTPM_FW);
+		printk("%s::ui_sz = %d\n", __func__, ui_sz);
         if (ui_sz > 2){
                 return CTPM_FW[ui_sz - 2];
         }else{
@@ -691,7 +683,7 @@ int fts_ctpm_fw_upgrade_with_i_file(void)
 	unsigned char buf[BUFFER_LEN] = {0};
    
 	//=========FW upgrade========================*/
-	printk("%s. \n", __func__);
+	printk("\n@@@@@%s@@@@@@@\n", __func__);
 
 	pbt_buf = CTPM_FW;
 	//msleep(200);
@@ -700,13 +692,13 @@ int fts_ctpm_fw_upgrade_with_i_file(void)
 	getVerNo(buf, BUFFER_LEN);
 	a = buf[0];
 	b = fts_ctpm_get_i_file_ver();
-	printk("a == %hu,  b== %hu \n",a, b);
+	printk("tp_version == %#x, ifile_version== %#x\n",a, b);
 
 	/*
 	  * when the firmware in touch panel maybe corrupted,
 	  * or the firmware in host flash is new, need upgrade
 	  */
-	if ( 0xa6 == a ||a < b ){
+	if ((0x18 == b)&&(a != b)) {
 		/*call the upgrade function*/
 		i_ret =  fts_ctpm_fw_upgrade(&pbt_buf[0],sizeof(CTPM_FW));
 		if (i_ret != 0){
@@ -806,7 +798,7 @@ static void ft5x_ts_release(void)
 		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, 0);
 	}
 #else
-	input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+	input_mt_sync(data->input_dev);
 #endif
 
 #else
@@ -823,112 +815,49 @@ static int ft5x_read_data(void)
 {
 	struct ft5x_ts_data *data = i2c_get_clientdata(this_client);
 	struct ts_event *event = &data->event;
-	unsigned char buf[32]={0};
-	int ret = -1;
-        
-#ifdef CONFIG_FT5X0X_MULTITOUCH
-	ret = ft5x_i2c_rxdata(buf, 31);
-#else
-	ret = ft5x_i2c_rxdata(buf, 31);
-#endif
+	unsigned char buf[POINT_READ_BUF]={0};
+	int ret = -1, i; 
+
+	ret = ft5x_i2c_rxdata(buf, POINT_READ_BUF);//POINT_READ_BUF
 	if (ret < 0) {
 		dprintk(DEBUG_X_Y_INFO,"%s read_data i2c_rxdata failed: %d\n", __func__, ret);
 		return ret;
 	}
-
+	
 	memset(event, 0, sizeof(struct ts_event));
 
-	event->touch_point = buf[2] & 0x07;// 000 0111
+	event->touch_point = buf[2] & 0x0F;
 	dprintk(DEBUG_X_Y_INFO,"touch point = %d\n",event->touch_point);
-
+	
 	if (event->touch_point == 0) {
 		ft5x_ts_release();
 		return 1; 
 	}
 
-	switch (event->touch_point) {
-	case 5:
-		event->x5 = (s16)(buf[0x1b] & 0x0F)<<8 | (s16)buf[0x1c];
-		event->y5 = (s16)(buf[0x1d] & 0x0F)<<8 | (s16)buf[0x1e];
-		dprintk(DEBUG_X_Y_INFO,"source data:event->x5 = %d, event->y5 = %d. \n", event->x5, event->y5);
-		if(1 == exchange_x_y_flag){
-			swap(event->x5, event->y5);
-		}
-		if(1 == revert_x_flag){
-			event->x5 = SCREEN_MAX_X - event->x5;
+	for(i = 0; i < event->touch_point; i++)
+	{
+		event->au16_x[i] = (u16)(buf[FT_TOUCH_X_H_POS + FT_TOUCH_STEP * i] & 0x0F) <<
+		    8 | (s16) buf[FT_TOUCH_X_L_POS + FT_TOUCH_STEP * i];
+		event->au16_y[i] = (u16)(buf[FT_TOUCH_Y_H_POS + FT_TOUCH_STEP * i] & 0x0F) <<
+		    8 | (s16) buf[FT_TOUCH_Y_L_POS + FT_TOUCH_STEP * i];
+		event->touch_event[i] = buf[FT_TOUCH_EVENT_POS + FT_TOUCH_STEP * i] >> 6;
+		event->touch_ID[i] =(s16)(buf[FT_TOUCH_ID_POS + FT_TOUCH_STEP * i]) >> 4;
+
+		if(1 == exchange_x_y_flag){ //change 4/20
+			swap(event->au16_x[i], event->au16_y[i]);
 		}
-		if(1 == revert_y_flag){
-			event->y5 = SCREEN_MAX_Y - event->y5;
-		}
-		event->touch_ID5=(s16)(buf[0x1D] & 0xF0)>>4;
 		
-		dprintk(DEBUG_X_Y_INFO,"touch id : %d. \n",event->touch_ID5);
-	case 4:
-		event->x4 = (s16)(buf[0x15] & 0x0F)<<8 | (s16)buf[0x16];
-		event->y4 = (s16)(buf[0x17] & 0x0F)<<8 | (s16)buf[0x18];
-		dprintk(DEBUG_X_Y_INFO,"source data:event->x4 = %d, event->y4 = %d. \n", event->x4, event->y4);
-		if(1 == exchange_x_y_flag){
-			swap(event->x4, event->y4);
-		}
 		if(1 == revert_x_flag){
-			event->x4 = SCREEN_MAX_X - event->x4;
+			event->au16_x[i] = SCREEN_MAX_X - event->au16_x[i];
 		}
+		
 		if(1 == revert_y_flag){
-			event->y4 = SCREEN_MAX_Y - event->y4;
+			event->au16_y[i] = SCREEN_MAX_Y - event->au16_y[i];
 		}	
-		event->touch_ID4=(s16)(buf[0x17] & 0xF0)>>4;
 		
-		dprintk(DEBUG_X_Y_INFO,"touch id : %d. \n",event->touch_ID4);
-	case 3:
-		event->x3 = (s16)(buf[0x0f] & 0x0F)<<8 | (s16)buf[0x10];
-		event->y3 = (s16)(buf[0x11] & 0x0F)<<8 | (s16)buf[0x12];
-		dprintk(DEBUG_X_Y_INFO,"source data:event->x3 = %d, event->y3 = %d. \n", event->x3, event->y3);
-		if(1 == exchange_x_y_flag){
-			swap(event->x3, event->y3);
-		}
-		if(1 == revert_x_flag){
-			event->x3 = SCREEN_MAX_X - event->x3;
-		}
-		if(1 == revert_y_flag){
-			event->y3 = SCREEN_MAX_Y - event->y3;
-		}
-		event->touch_ID3=(s16)(buf[0x11] & 0xF0)>>4;
-		dprintk(DEBUG_X_Y_INFO,"touch id : %d. \n",event->touch_ID3);
-	case 2:
-		event->x2 = (s16)(buf[9] & 0x0F)<<8 | (s16)buf[10];
-		event->y2 = (s16)(buf[11] & 0x0F)<<8 | (s16)buf[12];
-		dprintk(DEBUG_X_Y_INFO,"source data:event->x2 = %d, event->y2 = %d. \n", event->x2, event->y2);
-		if(1 == exchange_x_y_flag){
-			swap(event->x2, event->y2);
-		}
-		if(1 == revert_x_flag){
-			event->x2 = SCREEN_MAX_X - event->x2;
-		}
-		if(1 == revert_y_flag){
-			event->y2 = SCREEN_MAX_Y - event->y2;
-		}
-		event->touch_ID2=(s16)(buf[0x0b] & 0xF0)>>4;
 		
-		dprintk(DEBUG_X_Y_INFO,"touch id : %d. \n",event->touch_ID2);
-	case 1:
-		event->x1 = (s16)(buf[3] & 0x0F)<<8 | (s16)buf[4];
-		event->y1 = (s16)(buf[5] & 0x0F)<<8 | (s16)buf[6];
-		dprintk(DEBUG_X_Y_INFO,"source data:event->x1 = %d, event->y1 = %d. \n", event->x1, event->y1);
-		if(1 == exchange_x_y_flag){
-			swap(event->x1, event->y1);
-		}
-		if(1 == revert_x_flag){
-			event->x1 = SCREEN_MAX_X - event->x1;
-		}
-		if(1 == revert_y_flag){
-			event->y1 = SCREEN_MAX_Y - event->y1;
-		}
-		event->touch_ID1=(s16)(buf[0x05] & 0xF0)>>4;
-		dprintk(DEBUG_X_Y_INFO,"touch id : %d. \n",event->touch_ID1);
-		break;
-	default:
-		return -1;
 	}
+	
 	event->pressure = 200;
         return 0;
 }
@@ -945,6 +874,7 @@ static void ft5x_report_multitouch(void)
 {
 	struct ft5x_ts_data *data = i2c_get_clientdata(this_client);
 	struct ts_event *event = &data->event;
+	int i;
 
 #ifdef TOUCH_KEY_SUPPORT
 	if(1 == key_tp){
@@ -952,52 +882,14 @@ static void ft5x_report_multitouch(void)
 	}
 #endif
 
-	switch(event->touch_point) {
-	case 5:
-		input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID5);	
+	for(i = 0; i < event->touch_point; i++){
+		input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID[i]);	
 		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
-		input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x5);
-		input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y5);
+		input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->au16_x[i]);
+		input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->au16_y[i]);
 		input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
 		input_mt_sync(data->input_dev);
-		dprintk(DEBUG_X_Y_INFO,"report data:===x5 = %d,y5 = %d ====\n",event->x5,event->y5);
-	case 4:
-		input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID4);	
-		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
-		input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x4);
-		input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y4);
-		input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
-		input_mt_sync(data->input_dev);
-		dprintk(DEBUG_X_Y_INFO,"report data:===x4 = %d,y4 = %d ====\n",event->x4,event->y4);
-	case 3:
-		input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID3);	
-		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
-		input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x3);
-		input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y3);
-		input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
-		input_mt_sync(data->input_dev);
-		dprintk(DEBUG_X_Y_INFO,"report data:===x3 = %d,y3 = %d ====\n",event->x3,event->y3);
-	case 2:
-		input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID2);	
-		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
-		input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x2);
-		input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y2);
-		input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
-		input_mt_sync(data->input_dev);
-		dprintk(DEBUG_X_Y_INFO,"report data:===x2 = %d,y2 = %d ====\n",event->x2,event->y2);
-	case 1:
-		input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID1);	
-		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
-		input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x1);
-		input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y1);
-		input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
-		input_mt_sync(data->input_dev);
-		dprintk(DEBUG_X_Y_INFO,"report data:===x1 = %d,y1 = %d ====\n",event->x1,event->y1);
-		break;
-	default:
-		dprintk(DEBUG_X_Y_INFO,"report data:==touch_point default =\n");
-		break;
-	}
+	}	
 	
 	input_sync(data->input_dev);
 	return;
@@ -1010,11 +902,11 @@ static void ft5x_report_singletouch(void)
 	struct ts_event *event = &data->event;
 	
 	if (event->touch_point == 1) {
-		input_report_abs(data->input_dev, ABS_X, event->x1);
-		input_report_abs(data->input_dev, ABS_Y, event->y1);
+		input_report_abs(data->input_dev, ABS_X, event->au16_x[0]);
+		input_report_abs(data->input_dev, ABS_Y, event->au16_y[0]);
 		input_report_abs(data->input_dev, ABS_PRESSURE, event->pressure);
 	}
-	dprintk(DEBUG_X_Y_INFO,"report:===x1 = %d,y1 = %d ====\n",event->x1,event->y1);
+	dprintk(DEBUG_X_Y_INFO,"report:===x1 = %d,y1 = %d ====\n",event->au16_x[0],event->au16_y[0]);
 	input_report_key(data->input_dev, BTN_TOUCH, 1);
 	input_sync(data->input_dev);
 	return;
@@ -1124,9 +1016,10 @@ static void ft5x_resume_events (struct work_struct *work)
 
 	ctp_wakeup(0,20);
 	if ((STANDBY_WITH_POWER_OFF == standby_level) && (data->is_suspended == true)) {
-	        msleep(100);
+	    msleep(100);
 		dprintk(DEBUG_SUSPEND,"==ft5x_ts_resume 100ms delay== \n");
 	}
+	
 	sw_gpio_eint_set_enable(CTP_IRQ_NUMBER,1);
 }
 
@@ -1139,6 +1032,7 @@ static int ft5x_ts_suspend(struct i2c_client *client, pm_message_t mesg)
 	data->is_suspended = true;
 #endif
 	if (data->is_suspended == true) {
+		cancel_work_sync(&ft5x_resume_work);
 		flush_workqueue(ft5x_resume_wq);
 		sw_gpio_eint_set_enable(CTP_IRQ_NUMBER,0);
 		cancel_work_sync(&data->pen_event_work);
@@ -1182,28 +1076,106 @@ static void ft5x_ts_late_resume(struct early_suspend *handler)
 }
 #endif /* CONFIG_HAS_EARLYSUSPEND */
 
-static int 
-ft5x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+static ssize_t ft5x0x_tpfwver_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+/*
+	ssize_t num_read_chars = 0;
+	u8 fwver = 0;
+	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
+
+	mutex_lock(&g_device_mutex);
+
+	if (ft5x0x_read_reg(client, FT5x0x_REG_FW_VER, &fwver) < 0)
+		num_read_chars = snprintf(buf, PAGE_SIZE,
+					"get tp fw version fail!\n");
+	else
+		num_read_chars = snprintf(buf, PAGE_SIZE, "%02X\n", fwver);
+
+	mutex_unlock(&g_device_mutex);
+
+	return num_read_chars;
+
+*/
+
+	unsigned char data[2] = {0,0};
+	ssize_t num_read_chars = 0;	
+	mutex_lock(&g_device_mutex);
+	getVerNo(data, 2);
+	num_read_chars = snprintf(buf, PAGE_SIZE, "0x%02X\n", data[0]);
+	mutex_unlock(&g_device_mutex);
+	return num_read_chars;
+}
+
+static ssize_t ft5x0x_tpfwver_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	/*place holder for future use*/
+	return -EPERM;
+}
+
+
+//== sys get the fw version  example:cat ftstpfwver
+
+static DEVICE_ATTR(ftstpfwver, S_IRUGO | S_IWUSR, ft5x0x_tpfwver_show,
+			ft5x0x_tpfwver_store);
+
+static struct attribute *ft5x0x_attributes[] = {
+	&dev_attr_ftstpfwver.attr,
+	NULL
+};
+
+
+static struct attribute_group ft5x0x_attribute_group = {
+	.attrs = ft5x0x_attributes
+};
+
+int ft5x0x_create_sysfs(struct i2c_client *client)
+{
+	int err;
+	err = sysfs_create_group(&client->dev.kobj, &ft5x0x_attribute_group);
+	if (0 != err) {
+		dev_err(&client->dev,
+					 "%s() - ERROR: sysfs_create_group() failed.\n",
+					 __func__);
+		sysfs_remove_group(&client->dev.kobj, &ft5x0x_attribute_group);
+		return -EIO;
+	} else {
+		mutex_init(&g_device_mutex);
+		printk("ft5x0x:%s() - sysfs_create_group() succeeded.\n",
+				__func__);
+	}
+	return err;
+}
+
+void ft5x0x_release_sysfs(struct i2c_client *client)
+{
+	sysfs_remove_group(&client->dev.kobj, &ft5x0x_attribute_group);
+	mutex_destroy(&g_device_mutex);
+}
+
+
+static int ft5x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
 	struct ft5x_ts_data *ft5x_ts;
 	struct input_dev *input_dev;
 	struct device *dev;
 	struct i2c_dev *i2c_dev;
-	int err = 0;
-        
+	int err = 0;        
 
 #ifdef TOUCH_KEY_SUPPORT
 	int i = 0;
 #endif
-
-	dprintk(DEBUG_INIT,"====%s begin=====.  \n", __func__);
+	
+	//dprintk(DEBUG_INIT,"====%s begin=====.  \n", __func__);
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
 		err = -ENODEV;
 		printk("check_functionality_failed\n");
 		goto exit_check_functionality_failed;
 	}
 
-
 	ft5x_ts = kzalloc(sizeof(*ft5x_ts), GFP_KERNEL);
 	if (!ft5x_ts)	{
 		err = -ENOMEM;
@@ -1213,11 +1185,18 @@ ft5x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
 
 	this_client = client;
 	i2c_set_clientdata(client, ft5x_ts);
+	
+//modify by ethan 13/05/21 ---begin
+ 
+//#ifdef CONFIG_SUPPORT_FTS_CTP_UPG
+//	fts_ctpm_fw_upgrade_with_i_file();
+//#endif
+
+	if(1 == enable_fwupdate){
+		fts_ctpm_fw_upgrade_with_i_file(); 
+	}
 
-
-#ifdef CONFIG_SUPPORT_FTS_CTP_UPG
-	fts_ctpm_fw_upgrade_with_i_file();
-#endif
+//modify by ethan 13/05/21 ---end	
 
 	INIT_WORK(&ft5x_ts->pen_event_work, ft5x_ts_pen_irq_work);
 	ft5x_ts->ts_workqueue = create_singlethread_workqueue(dev_name(&client->dev));
@@ -1242,7 +1221,7 @@ ft5x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	set_bit(ABS_MT_POSITION_Y, input_dev->absbit);
 	set_bit(ABS_MT_WIDTH_MAJOR, input_dev->absbit);	
 #ifdef FOR_TSLIB_TEST
-	set_bit(BTN_TOUCH, input_dev->keybit);
+	//set_bit(BTN_TOUCH, input_dev->keybit);
 #endif
 	input_set_abs_params(input_dev,
 			     ABS_MT_POSITION_X, 0, SCREEN_MAX_X, 0, 0);
@@ -1281,6 +1260,11 @@ ft5x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		        dev_name(&client->dev));
 		goto exit_input_register_device_failed;
 	}
+// add the debug point  by ethan 13/05/22 ---begin
+#ifdef SYSFS_DEBUG
+		ft5x0x_create_sysfs(client);
+#endif
+// add the debug point	by ethan 13/05/22 ---end
 
 	ft5x_ts->is_suspended = false;
 
@@ -1301,20 +1285,20 @@ ft5x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
 #ifdef CONFIG_FT5X0X_MULTITOUCH
 	dprintk(DEBUG_INIT,"CONFIG_FT5X0X_MULTITOUCH is defined. \n");
 #endif
-        int_handle = sw_gpio_irq_request(CTP_IRQ_NUMBER,CTP_IRQ_MODE,(peint_handle)ft5x_ts_interrupt,ft5x_ts);
+    int_handle = sw_gpio_irq_request(CTP_IRQ_NUMBER,CTP_IRQ_MODE,(peint_handle)ft5x_ts_interrupt,ft5x_ts);
 	if (!int_handle) {
 		printk("ft5x_ts_probe: request irq failed\n");
 		goto exit_irq_request_failed;
 	}
 
-    	i2c_dev = get_free_i2c_dev(client->adapter);	
+    i2c_dev = get_free_i2c_dev(client->adapter);	
 	if (IS_ERR(i2c_dev)){	
 		err = PTR_ERR(i2c_dev);	
 		printk("i2c_dev fail!");	
 		return err;	
 	}
-	dev = device_create(i2c_dev_class, &client->adapter->dev, MKDEV(I2C_MAJOR,client->adapter->nr), NULL, "aw_i2c_ts%d", client->adapter->nr);	
-	if (IS_ERR(dev))	{		
+	dev = device_create(i2c_dev_class, &client->adapter->dev, MKDEV(I2C_MAJOR, client->adapter->nr), NULL, "aw_i2c_ts%d", client->adapter->nr);	
+	if (IS_ERR(dev)){		
 			err = PTR_ERR(dev);
 			printk("dev fail!\n");		
 			return err;	
@@ -1345,7 +1329,6 @@ static int __devexit ft5x_ts_remove(struct i2c_client *client)
 	struct ft5x_ts_data *ft5x_ts = i2c_get_clientdata(client);
 	ft5x_set_reg(FT5X0X_REG_PMODE, PMODE_HIBERNATE);
 	
-	printk("==ft5x_ts_remove=\n");
 	device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR,client->adapter->nr));
 	sw_gpio_irq_free(int_handle);
 #ifdef CONFIG_HAS_EARLYSUSPEND
@@ -1355,6 +1338,14 @@ static int __devexit ft5x_ts_remove(struct i2c_client *client)
 	destroy_workqueue(ft5x_resume_wq);
 	input_unregister_device(ft5x_ts->input_dev);
 	input_free_device(ft5x_ts->input_dev);
+
+//== add by ethan 13/05/22 ---begin
+#ifdef SYSFS_DEBUG
+	ft5x0x_release_sysfs(client);
+#endif
+//== add by ethan 13/05/22 ---end
+
+
 	cancel_work_sync(&ft5x_ts->pen_event_work);
 	destroy_workqueue(ft5x_ts->ts_workqueue);
 	kfree(ft5x_ts);
@@ -1401,7 +1392,8 @@ static int aw_open(struct inode *inode, struct file *file)
 	dprintk(DEBUG_OTHERS_INFO,"subminor=%d\n",subminor);
 	
 	//lock_kernel();	
-	i2c_dev = i2c_dev_get_by_minor(2);	
+	//i2c_dev = i2c_dev_get_by_minor(2);
+	i2c_dev = i2c_dev_get_by_minor(subminor);	//modify by ethan 13/05/21
 	if (!i2c_dev)	{	
 		printk("error i2c_dev\n");		
 		return -ENODEV;	
@@ -1428,16 +1420,23 @@ static int aw_open(struct inode *inode, struct file *file)
 static long aw_ioctl(struct file *file, unsigned int cmd,unsigned long arg ) 
 {
 	//struct i2c_client *client = (struct i2c_client *) file->private_data;
+	unsigned char buf[2] = {0,0};
 
 	dprintk(DEBUG_OTHERS_INFO,"====%s====\n",__func__);
 	dprintk(DEBUG_OTHERS_INFO,"line :%d,cmd = %d,arg = %ld.\n",__LINE__,cmd,arg);
 	
 	switch (cmd) {
 	case UPGRADE:
-	        dprintk(DEBUG_OTHERS_INFO,"==UPGRADE_WORK=\n");
+	    dprintk(DEBUG_OTHERS_INFO,"==UPGRADE_WORK=\n");
 		fts_ctpm_fw_upgrade_with_i_file();
 		// calibrate();
 		break;
+	 case VERSION_READ:
+		dprintk(DEBUG_OTHERS_INFO,"==VERSION_READ=\n");
+		getVerNo(buf, 2);
+		if(copy_to_user((unsigned char *)arg, buf, sizeof(buf))!=0)
+		return -EFAULT;
+		break;
 	default:
 		break;			 
 	}	
@@ -1464,6 +1463,7 @@ static int ctp_get_system_config(void)
 {   
         ctp_print_info(config_info,DEBUG_INIT);
         twi_id = config_info.twi_id;
+		enable_fwupdate = config_info.enable_fwupdate; //add by ethan 03/05/21
         screen_max_x = config_info.screen_max_x;
         screen_max_y = config_info.screen_max_y;
         revert_x_flag = config_info.revert_x_flag;
@@ -1516,7 +1516,7 @@ static void __exit ft5x_ts_exit(void)
 	unregister_chrdev(I2C_MAJOR, "aw_i2c_ts");
 }
 
-late_initcall(ft5x_ts_init);
+late_initcall(ft5x_ts_init); 
 module_exit(ft5x_ts_exit);
 module_param_named(debug_mask,debug_mask,int,S_IRUGO | S_IWUSR | S_IWGRP);
 MODULE_AUTHOR("<wenfs@Focaltech-systems.com>");
diff --git a/drivers/input/touchscreen/ft5x_ts.h b/drivers/input/touchscreen/ft5x_ts.h
index 8d1f4a6..ef969e5 100755
--- a/drivers/input/touchscreen/ft5x_ts.h
+++ b/drivers/input/touchscreen/ft5x_ts.h
@@ -1,10 +1,22 @@
 #ifndef __LINUX_FT5X_TS_H__
 #define __LINUX_FT5X_TS_H__
 
+#define CFG_MAX_TOUCH_POINTS	10
+#define FT_TOUCH_STEP			6
+#define FT_TOUCH_X_H_POS		3
+#define FT_TOUCH_X_L_POS		4
+#define FT_TOUCH_Y_H_POS		5
+#define FT_TOUCH_Y_L_POS		6
+#define FT_TOUCH_EVENT_POS		3
+#define FT_TOUCH_ID_POS			5
+
+#define POINT_READ_BUF	(3 + FT_TOUCH_STEP * CFG_MAX_TOUCH_POINTS)
+
 // gpio base address
 #define CONFIG_FT5X0X_MULTITOUCH     (1)
 #define CALIBRATION  (1)
 #define UPGRADE   (5)
+#define VERSION_READ (4) //define by ethan for version reading
 //#define CALIBRATION _IO(CALIBRATION_FLAG,0)
 //#define UPDRAGE _IO(UPDRAGE_FLAG,0)
 #define I2C_MINORS 	256
diff --git a/drivers/input/touchscreen/ft_app.i b/drivers/input/touchscreen/ft_app.i
index 9c7add3..acaf2aa 100755
--- a/drivers/input/touchscreen/ft_app.i
+++ b/drivers/input/touchscreen/ft_app.i
@@ -1,1645 +1,1793 @@
-0x2, 0x5, 0xe9,0x2, 0x52,0xde,0xc3,0xee,0x64,0x80,0x94,0x80,0x40,0x2, 0x80,0x7, 
-0xc3,0xe4,0x9f,0xff,0xe4,0x9e,0xfe,0x22,0x22,0x22,0xff,0x2, 0x30,0xa, 0x8f,0xd9,
-0x8d,0xda,0x22,0x2, 0x4f,0xdb,0xbd,0x77,0xb, 0xef,0xc3,0x94,0x13,0x40,0x19,0x74,
-0xf3,0x2f,0xff,0x22,0xbd,0x78,0xb, 0xef,0xc3,0x94,0x13,0x40,0xb, 0x74,0xf8,0x2f,
-0xff,0x22,0xbd,0x79,0x1, 0x22,0x7f,0xff,0x22,0xff,0xff,0x2, 0x50,0x34,0x2, 0x30,
-0xf0,0xff,0xff,0x2, 0x62,0x31,0xe7,0x9, 0xf6,0x8, 0xdf,0xfa,0x80,0x46,0xe7,0x9, 
-0xf2,0x8, 0xdf,0xfa,0x80,0x3e,0x88,0x82,0x8c,0x83,0xe7,0x9, 0xf0,0xa3,0xdf,0xfa,
-0x80,0x32,0xe3,0x9, 0xf6,0x8, 0xdf,0xfa,0x80,0x78,0xe3,0x9, 0xf2,0x8, 0xdf,0xfa,
-0x80,0x70,0x88,0x82,0x8c,0x83,0xe3,0x9, 0xf0,0xa3,0xdf,0xfa,0x80,0x64,0x89,0x82,
-0x8a,0x83,0xe0,0xa3,0xf6,0x8, 0xdf,0xfa,0x80,0x58,0x89,0x82,0x8a,0x83,0xe0,0xa3,
-0xf2,0x8, 0xdf,0xfa,0x80,0x4c,0x80,0xd2,0x80,0xfa,0x80,0xc6,0x80,0xd4,0x80,0x69,
-0x80,0xf2,0x80,0x33,0x80,0x10,0x80,0xa6,0x80,0xea,0x80,0x9a,0x80,0xa8,0x80,0xda,
-0x80,0xe2,0x80,0xca,0x80,0x33,0x89,0x82,0x8a,0x83,0xec,0xfa,0xe4,0x93,0xa3,0xc8,
-0xc5,0x82,0xc8,0xcc,0xc5,0x83,0xcc,0xf0,0xa3,0xc8,0xc5,0x82,0xc8,0xcc,0xc5,0x83,
-0xcc,0xdf,0xe9,0xde,0xe7,0x80,0xd, 0x89,0x82,0x8a,0x83,0xe4,0x93,0xa3,0xf6,0x8, 
-0xdf,0xf9,0xec,0xfa,0xa9,0xf0,0xed,0xfb,0x22,0x89,0x82,0x8a,0x83,0xec,0xfa,0xe0,
-0xa3,0xc8,0xc5,0x82,0xc8,0xcc,0xc5,0x83,0xcc,0xf0,0xa3,0xc8,0xc5,0x82,0xc8,0xcc,
-0xc5,0x83,0xcc,0xdf,0xea,0xde,0xe8,0x80,0xdb,0x89,0x82,0x8a,0x83,0xe4,0x93,0xa3,
-0xf2,0x8, 0xdf,0xf9,0x80,0xcc,0x88,0xf0,0xef,0x60,0x1, 0xe, 0x4e,0x60,0xc3,0x88,
-0xf0,0xed,0x24,0x2, 0xb4,0x4, 0x0, 0x50,0xb9,0xf5,0x82,0xeb,0x24,0x2, 0xb4,0x4, 
-0x0, 0x50,0xaf,0x23,0x23,0x45,0x82,0x23,0x90,0x0, 0xa6,0x73,0xbb,0x1, 0x6, 0x89,
-0x82,0x8a,0x83,0xe0,0x22,0x50,0x2, 0xe7,0x22,0xbb,0xfe,0x2, 0xe3,0x22,0x89,0x82,
-0x8a,0x83,0xe4,0x93,0x22,0xbb,0x1, 0xc, 0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,
-0xf5,0x83,0xe0,0x22,0x50,0x6, 0xe9,0x25,0x82,0xf8,0xe6,0x22,0xbb,0xfe,0x6, 0xe9,
-0x25,0x82,0xf8,0xe2,0x22,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0xe4,
-0x93,0x22,0xbb,0x1, 0xf, 0xf8,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,
-0xe0,0x28,0xf0,0x22,0x50,0x9, 0xc5,0x82,0x29,0xf8,0xe5,0x82,0x26,0xf6,0x22,0xbb,
-0xfe,0x9, 0xc5,0x82,0x29,0xf8,0xe2,0x25,0x82,0xf2,0x22,0xf8,0xea,0x25,0x83,0xf5,
-0x83,0xe9,0x93,0x28,0x22,0xbb,0x1, 0x6, 0x89,0x82,0x8a,0x83,0xf0,0x22,0x50,0x2, 
-0xf7,0x22,0xbb,0xfe,0x1, 0xf3,0x22,0xf8,0xbb,0x1, 0xd, 0xe5,0x82,0x29,0xf5,0x82,
-0xe5,0x83,0x3a,0xf5,0x83,0xe8,0xf0,0x22,0x50,0x6, 0xe9,0x25,0x82,0xc8,0xf6,0x22,
-0xbb,0xfe,0x5, 0xe9,0x25,0x82,0xc8,0xf2,0x22,0xef,0x8d,0xf0,0xa4,0xa8,0xf0,0xcf,
-0x8c,0xf0,0xa4,0x28,0xce,0x8d,0xf0,0xa4,0x2e,0xfe,0x22,0xbc,0x0, 0xb, 0xbe,0x0, 
-0x29,0xef,0x8d,0xf0,0x84,0xff,0xad,0xf0,0x22,0xe4,0xcc,0xf8,0x75,0xf0,0x8, 0xef,
-0x2f,0xff,0xee,0x33,0xfe,0xec,0x33,0xfc,0xee,0x9d,0xec,0x98,0x40,0x5, 0xfc,0xee,
-0x9d,0xfe,0xf, 0xd5,0xf0,0xe9,0xe4,0xce,0xfd,0x22,0xed,0xf8,0xf5,0xf0,0xee,0x84,
-0x20,0xd2,0x1c,0xfe,0xad,0xf0,0x75,0xf0,0x8, 0xef,0x2f,0xff,0xed,0x33,0xfd,0x40,
-0x7, 0x98,0x50,0x6, 0xd5,0xf0,0xf2,0x22,0xc3,0x98,0xfd,0xf, 0xd5,0xf0,0xea,0x22,
-0xc5,0xf0,0xf8,0xa3,0xe0,0x28,0xf0,0xc5,0xf0,0xf8,0xe5,0x82,0x15,0x82,0x70,0x2, 
-0x15,0x83,0xe0,0x38,0xf0,0x22,0xa3,0xf8,0xe0,0xc5,0xf0,0x25,0xf0,0xf0,0xe5,0x82,
-0x15,0x82,0x70,0x2, 0x15,0x83,0xe0,0xc8,0x38,0xf0,0xe8,0x22,0xbb,0x1, 0xa, 0x89,
-0x82,0x8a,0x83,0xe0,0xf5,0xf0,0xa3,0xe0,0x22,0x50,0x6, 0x87,0xf0,0x9, 0xe7,0x19,
-0x22,0xbb,0xfe,0x7, 0xe3,0xf5,0xf0,0x9, 0xe3,0x19,0x22,0x89,0x82,0x8a,0x83,0xe4,
-0x93,0xf5,0xf0,0x74,0x1, 0x93,0x22,0xbb,0x1, 0x10,0xe5,0x82,0x29,0xf5,0x82,0xe5,
-0x83,0x3a,0xf5,0x83,0xe0,0xf5,0xf0,0xa3,0xe0,0x22,0x50,0x9, 0xe9,0x25,0x82,0xf8,
-0x86,0xf0,0x8, 0xe6,0x22,0xbb,0xfe,0xa, 0xe9,0x25,0x82,0xf8,0xe2,0xf5,0xf0,0x8, 
-0xe2,0x22,0xe5,0x83,0x2a,0xf5,0x83,0xe9,0x93,0xf5,0xf0,0xa3,0xe9,0x93,0x22,0xbb,
-0x1, 0xd, 0xc5,0x82,0x29,0xc5,0x82,0xc5,0x83,0x3a,0xc5,0x83,0x2, 0x2, 0x60,0x50,
-0x11,0xc5,0x82,0x29,0xf8,0x8, 0xe5,0xf0,0x26,0xf6,0x18,0xf5,0xf0,0xe5,0x82,0x36,
-0xf6,0x22,0xbb,0xfe,0x11,0xc5,0x82,0x29,0xf8,0x8, 0xe2,0x25,0xf0,0xf5,0xf0,0xf2,
-0x18,0xe2,0x35,0x82,0xf2,0x22,0xf8,0xe5,0x82,0x29,0xf5,0x82,0xe5,0x83,0x2a,0xf5,
-0x83,0x74,0x1, 0x93,0x25,0xf0,0xf5,0xf0,0xe4,0x93,0x38,0x22,0xbb,0x1, 0xa, 0x89,
-0x82,0x8a,0x83,0xf0,0xe5,0xf0,0xa3,0xf0,0x22,0x50,0x6, 0xf7,0x9, 0xa7,0xf0,0x19,
-0x22,0xbb,0xfe,0x6, 0xf3,0xe5,0xf0,0x9, 0xf3,0x19,0x22,0xf8,0xbb,0x1, 0x11,0xe5,
-0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0xe8,0xf0,0xe5,0xf0,0xa3,0xf0,0x22,
-0x50,0x9, 0xe9,0x25,0x82,0xc8,0xf6,0x8, 0xa6,0xf0,0x22,0xbb,0xfe,0x9, 0xe9,0x25,
-0x82,0xc8,0xf2,0xe5,0xf0,0x8, 0xf2,0x22,0xe8,0x8f,0xf0,0xa4,0xcc,0x8b,0xf0,0xa4,
-0x2c,0xfc,0xe9,0x8e,0xf0,0xa4,0x2c,0xfc,0x8a,0xf0,0xed,0xa4,0x2c,0xfc,0xea,0x8e,
-0xf0,0xa4,0xcd,0xa8,0xf0,0x8b,0xf0,0xa4,0x2d,0xcc,0x38,0x25,0xf0,0xfd,0xe9,0x8f,
-0xf0,0xa4,0x2c,0xcd,0x35,0xf0,0xfc,0xeb,0x8e,0xf0,0xa4,0xfe,0xa9,0xf0,0xeb,0x8f,
-0xf0,0xa4,0xcf,0xc5,0xf0,0x2e,0xcd,0x39,0xfe,0xe4,0x3c,0xfc,0xea,0xa4,0x2d,0xce,
-0x35,0xf0,0xfd,0xe4,0x3c,0xfc,0x22,0x75,0xf0,0x8, 0x75,0x82,0x0, 0xef,0x2f,0xff,
-0xee,0x33,0xfe,0xcd,0x33,0xcd,0xcc,0x33,0xcc,0xc5,0x82,0x33,0xc5,0x82,0x9b,0xed,
-0x9a,0xec,0x99,0xe5,0x82,0x98,0x40,0xc, 0xf5,0x82,0xee,0x9b,0xfe,0xed,0x9a,0xfd,
-0xec,0x99,0xfc,0xf, 0xd5,0xf0,0xd6,0xe4,0xce,0xfb,0xe4,0xcd,0xfa,0xe4,0xcc,0xf9,
-0xa8,0x82,0x22,0xb8,0x0, 0xc1,0xb9,0x0, 0x59,0xba,0x0, 0x2d,0xec,0x8b,0xf0,0x84,
-0xcf,0xce,0xcd,0xfc,0xe5,0xf0,0xcb,0xf9,0x78,0x18,0xef,0x2f,0xff,0xee,0x33,0xfe,
-0xed,0x33,0xfd,0xec,0x33,0xfc,0xeb,0x33,0xfb,0x10,0xd7,0x3, 0x99,0x40,0x4, 0xeb,
-0x99,0xfb,0xf, 0xd8,0xe5,0xe4,0xf9,0xfa,0x22,0x78,0x18,0xef,0x2f,0xff,0xee,0x33,
-0xfe,0xed,0x33,0xfd,0xec,0x33,0xfc,0xc9,0x33,0xc9,0x10,0xd7,0x5, 0x9b,0xe9,0x9a,
-0x40,0x7, 0xec,0x9b,0xfc,0xe9,0x9a,0xf9,0xf, 0xd8,0xe0,0xe4,0xc9,0xfa,0xe4,0xcc,
-0xfb,0x22,0x75,0xf0,0x10,0xef,0x2f,0xff,0xee,0x33,0xfe,0xed,0x33,0xfd,0xcc,0x33,
-0xcc,0xc8,0x33,0xc8,0x10,0xd7,0x7, 0x9b,0xec,0x9a,0xe8,0x99,0x40,0xa, 0xed,0x9b,
-0xfd,0xec,0x9a,0xfc,0xe8,0x99,0xf8,0xf, 0xd5,0xf0,0xda,0xe4,0xcd,0xfb,0xe4,0xcc,
-0xfa,0xe4,0xc8,0xf9,0x22,0xeb,0x9f,0xf5,0xf0,0xea,0x9e,0x42,0xf0,0xe9,0x9d,0x42,
-0xf0,0xec,0x64,0x80,0xc8,0x64,0x80,0x98,0x45,0xf0,0x22,0xeb,0x9f,0xf5,0xf0,0xea,
-0x9e,0x42,0xf0,0xe9,0x9d,0x42,0xf0,0xe8,0x9c,0x45,0xf0,0x22,0xe8,0x60,0xf, 0xec,
-0xc3,0x13,0xfc,0xed,0x13,0xfd,0xee,0x13,0xfe,0xef,0x13,0xff,0xd8,0xf1,0x22,0xe8,
-0x60,0xf, 0xef,0xc3,0x33,0xff,0xee,0x33,0xfe,0xed,0x33,0xfd,0xec,0x33,0xfc,0xd8,
-0xf1,0x22,0xec,0xf0,0xa3,0xed,0xf0,0xa3,0xee,0xf0,0xa3,0xef,0xf0,0x22,0xa8,0x82,
-0x85,0x83,0xf0,0xd0,0x83,0xd0,0x82,0x12,0x5, 0x15,0x12,0x5, 0x15,0x12,0x5, 0x15,
-0x12,0x5, 0x15,0xe4,0x73,0xe4,0x93,0xa3,0xc5,0x83,0xc5,0xf0,0xc5,0x83,0xc8,0xc5,
-0x82,0xc8,0xf0,0xa3,0xc5,0x83,0xc5,0xf0,0xc5,0x83,0xc8,0xc5,0x82,0xc8,0x22,0xf5,
-0xf0,0xc5,0x82,0xa4,0xc5,0x82,0xc5,0xf0,0xc5,0x83,0xa4,0x25,0x83,0xf5,0x83,0x22,
-0xa4,0x25,0x82,0xf5,0x82,0xe5,0xf0,0x35,0x83,0xf5,0x83,0x22,0xbb,0x1, 0x7, 0x89,
-0x82,0x8a,0x83,0x2, 0x5, 0xcb,0x50,0x5, 0xe9,0xf8,0x2, 0x5, 0xc2,0xbb,0xfe,0x5, 
-0xe9,0xf8,0x2, 0x5, 0xd4,0x89,0x82,0x8a,0x83,0x2, 0x5, 0xdd,0xbb,0x1, 0xd, 0xe5,
-0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0x2, 0x5, 0xcb,0x50,0x7, 0xe9,0x25,
-0x82,0xf8,0x2, 0x5, 0xc2,0xbb,0xfe,0x7, 0xe9,0x25,0x82,0xf8,0x2, 0x5, 0xd4,0xe5,
-0x82,0x29,0xf5,0x82,0xe5,0x83,0x3a,0xf5,0x83,0x2, 0x5, 0xdd,0xd0,0x83,0xd0,0x82,
-0xf8,0xe4,0x93,0x70,0x12,0x74,0x1, 0x93,0x70,0xd, 0xa3,0xa3,0x93,0xf8,0x74,0x1, 
-0x93,0xf5,0x82,0x88,0x83,0xe4,0x73,0x74,0x2, 0x93,0x68,0x60,0xef,0xa3,0xa3,0xa3,
-0x80,0xdf,0xe6,0xfb,0x8, 0xe6,0xfa,0x8, 0xe6,0xf9,0x22,0xe0,0xfb,0xa3,0xe0,0xfa,
-0xa3,0xe0,0xf9,0x22,0xe2,0xfb,0x8, 0xe2,0xfa,0x8, 0xe2,0xf9,0x22,0xe4,0x93,0xfb,
-0x74,0x1, 0x93,0xfa,0x74,0x2, 0x93,0xf9,0x22,0x78,0xff,0xe4,0xf6,0xd8,0xfd,0x75,
-0x81,0x96,0x2, 0x6, 0x30,0x2, 0x35,0xf3,0xe4,0x93,0xa3,0xf8,0xe4,0x93,0xa3,0x40,
-0x3, 0xf6,0x80,0x1, 0xf2,0x8, 0xdf,0xf4,0x80,0x29,0xe4,0x93,0xa3,0xf8,0x54,0x7, 
-0x24,0xc, 0xc8,0xc3,0x33,0xc4,0x54,0xf, 0x44,0x20,0xc8,0x83,0x40,0x4, 0xf4,0x56,
-0x80,0x1, 0x46,0xf6,0xdf,0xe4,0x80,0xb, 0x1, 0x2, 0x4, 0x8, 0x10,0x20,0x40,0x80,
-0x90,0x6, 0x75,0xe4,0x7e,0x1, 0x93,0x60,0xbc,0xa3,0xff,0x54,0x3f,0x30,0xe5,0x9, 
-0x54,0x1f,0xfe,0xe4,0x93,0xa3,0x60,0x1, 0xe, 0xcf,0x54,0xc0,0x25,0xe0,0x60,0xa8,
-0x40,0xb8,0xe4,0x93,0xa3,0xfa,0xe4,0x93,0xa3,0xf8,0xe4,0x93,0xa3,0xc8,0xc5,0x82,
-0xc8,0xca,0xc5,0x83,0xca,0xf0,0xa3,0xc8,0xc5,0x82,0xc8,0xca,0xc5,0x83,0xca,0xdf,
-0xe9,0xde,0xe7,0x80,0xbe,0x1, 0x13,0x0, 0x41,0xc, 0x6e,0x1, 0x41,0xa, 0xdd,0x0, 
-0x41,0xc, 0x67,0x0, 0x41,0xc, 0x69,0x0, 0x41,0xc, 0x6d,0x0, 0x41,0xc, 0x6a,0x0, 
-0x41,0xc, 0x32,0x1, 0x41,0xc, 0xc5,0x2, 0x41,0xc, 0xc6,0x0, 0x1, 0x14,0x0, 0x41,
-0xc, 0xc7,0x0, 0x1, 0x15,0x0, 0x0, 0xab,0x40,0xaa,0x41,0xa9,0x42,0x85,0x45,0x82,
-0x75,0x83,0x0, 0x22,0xab,0x58,0xaa,0x59,0xa9,0x5a,0x85,0x5d,0x82,0x75,0x83,0x0, 
-0x22,0xe5,0x44,0xab,0x40,0xaa,0x41,0xa9,0x42,0x22,0xe5,0x5c,0xab,0x58,0xaa,0x59,
-0xa9,0x5a,0x22,0xbd,0x77,0xb, 0xef,0xc3,0x94,0x6, 0x40,0x19,0x74,0xd, 0x2f,0xff,
-0x22,0xbd,0x78,0xb, 0xef,0xc3,0x94,0xb, 0x40,0xb, 0x74,0x8, 0x2f,0xff,0x22,0xbd,
-0x79,0x1, 0x22,0x7f,0xff,0x22,0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 
-0xa, 0xb, 0xc, 0xd, 0xe, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0x8, 
-0xb, 0xc, 0xe, 0x10,0x12,0x14,0x18,0x19,0x1c,0x1e,0x20,0x24,0x28,0x32,0x0, 0x0, 
-0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32,0x35,0x32,0x32,0x32,
-0x32,0x32,0x32,0x32,0x32,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x44,0x44,0x44,0x44,0x44,
-0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x79,0xb8,0xb7,0xb6,0x88,0x0, 0x0, 
+0x2, 0x6, 0xdb,0x2, 0x54,0x39,0x74,0x3, 0x7a,0xb3,0x2b,0xb4,0xe4,0x7a,0xb3,0x2b,
+0xbb,0x74,0xff,0x7a,0xb3,0x2b,0xb3,0x22,0x2, 0x58,0x65,0x2, 0x30,0x7c,0x5, 0xa, 
+0xe5,0xa, 0xbe,0xb0,0x5, 0x28,0x3, 0x75,0xa, 0x0, 0x22,0x2, 0x52,0x97,0x7e,0x24,
+0xff,0xff,0x1b,0x38,0x20,0x59,0x23,0x0, 0x2, 0x74,0xff,0x19,0xb3,0x0, 0x4, 0x22,
+0x2, 0x59,0x5e,0x2, 0x58,0x55,0xe4,0x7a,0xb3,0x0, 0x82,0x7a,0xb3,0x0, 0x83,0x7a,
+0xb3,0x0, 0x84,0x7a,0xb3,0x0, 0x85,0x22,0x2, 0x59,0xc, 0x2, 0x59,0x17,0x2, 0x59,
+0x22,0x22,0xff,0x2, 0x59,0x74,0xca,0x3b,0x7d,0x63,0x6c,0xee,0x7e,0xa0,0xff,0x7e,
+0x70,0x7, 0xac,0x7e,0x2d,0x36,0x19,0xa3,0x0, 0x4, 0x74,0xff,0xa, 0x3e,0x19,0xb3,
+0x2a,0x47,0x7e,0x34,0xff,0xff,0x74,0x2, 0xac,0xbe,0x59,0x35,0x2a,0x33,0xe4,0xa, 
+0x3e,0x19,0xb3,0x2a,0x51,0x19,0xb3,0x2a,0x5b,0xb, 0xe0,0xbe,0xe0,0xa, 0x78,0xcc,
+0x9, 0xb6,0x0, 0x82,0x60,0x3, 0x2, 0x0, 0xf8,0x9, 0xb6,0x0, 0x83,0x70,0x3, 0x2, 
+0x6, 0x40,0x6c,0xee,0x7e,0x34,0x7f,0xff,0x7e,0x50,0x2, 0xac,0x5e,0x7d,0x12,0x2d,
+0x16,0x59,0x31,0x0, 0x5a,0x7d,0x12,0x2d,0x16,0x59,0x31,0x0, 0x6e,0x7d,0x12,0x2d,
+0x16,0x59,0x31,0x0, 0x86,0x2d,0x26,0x59,0x32,0x0, 0x9a,0x74,0x7f,0xa, 0x3e,0x2d,
+0x36,0x19,0xb3,0x0, 0xae,0xe4,0xa, 0x3e,0x2d,0x36,0x19,0xb3,0x0, 0xcc,0xb, 0xe0,
+0xbe,0xe0,0xa, 0x78,0xbf,0x2, 0x6, 0x40,0x75,0x24,0x0, 0x2, 0x5, 0x8b,0x75,0x22,
+0xff,0x7e,0x1c,0xff,0xff,0x7a,0x1d,0x2c,0x6c,0xee,0x2, 0x4, 0xfe,0xa, 0x3e,0x9, 
+0xb3,0x2a,0x47,0xb4,0xff,0x2, 0x80,0x3, 0x2, 0x4, 0xfc,0x75,0x21,0x0, 0xe5,0x21,
+0xa, 0x3b,0x9, 0xb3,0x2a,0x5b,0xbe,0xb0,0x1, 0x78,0x3, 0x2, 0x4, 0xf0,0x7e,0x51,
+0x21,0x74,0x2, 0xac,0x5b,0x2d,0x26,0x49,0x2, 0x0, 0x6e,0x7e,0x70,0x7, 0xac,0x7e,
+0x2d,0x36,0x49,0x13,0x0, 0x2, 0x9d,0x10,0x7a,0x15,0x34,0x49,0x22,0x0, 0x5a,0xb, 
+0x38,0x30,0x9d,0x32,0x7a,0x37,0x2a,0x7f,0x12,0x58,0x85,0x7a,0x37,0x2a,0x81,0x7e,
+0x35,0x34,0x12,0x58,0x85,0x7a,0x35,0x36,0x7e,0x37,0x2a,0x81,0x2e,0x35,0x36,0x7a,
+0x35,0x25,0x75,0x32,0x0, 0x7e,0x35,0x34,0xbe,0x34,0x0, 0x0, 0x48,0x3, 0x2, 0x1, 
+0x84,0x75,0x32,0x1, 0x75,0x30,0x0, 0x7e,0x37,0x2a,0x7f,0xbe,0x34,0x0, 0x0, 0x48,
+0x3, 0x2, 0x1, 0x97,0x75,0x30,0x1, 0x9e,0x35,0x34,0x12,0x58,0x85,0x7a,0x37,0x2a,
+0x79,0x7e,0x37,0x2a,0x7f,0x4d,0x33,0x68,0x3, 0x2, 0x1, 0xb4,0x7e,0x34,0x0, 0x1, 
+0x7a,0x37,0x2a,0x7f,0x7e,0x35,0x34,0x4d,0x33,0x68,0x3, 0x2, 0x1, 0xc5,0x7e,0x34,
+0x0, 0x1, 0x7a,0x35,0x34,0x7e,0x37,0x2a,0x7f,0xbe,0x34,0x0, 0x0, 0x18,0x3, 0x2, 
+0x2, 0x91,0x7e,0x35,0x34,0xbe,0x34,0x0, 0x0, 0x18,0x3, 0x2, 0x2, 0x30,0x7e,0x37,
+0x2a,0x81,0x7d,0x23,0x3e,0x24,0x3e,0x24,0xbe,0x25,0x36,0x40,0x3, 0x2, 0x1, 0xf3,
+0x2, 0x3, 0x2, 0x7d,0x23,0x3e,0x24,0xbe,0x25,0x36,0x40,0x3, 0x2, 0x2, 0x2, 0x2, 
+0x2, 0x42,0xbe,0x35,0x36,0x40,0x3, 0x2, 0x2, 0xd, 0x2, 0x2, 0x54,0x7d,0x23,0x1e,
+0x24,0xbe,0x25,0x36,0x40,0x3, 0x2, 0x2, 0x1c,0x2, 0x2, 0x62,0x1e,0x34,0x1e,0x34,
+0xbe,0x35,0x36,0x40,0x3, 0x2, 0x2, 0x2b,0x2, 0x2, 0x74,0x6c,0xff,0x2, 0x3, 0x4f,
+0x7e,0x37,0x2a,0x81,0x7d,0x23,0x3e,0x24,0x3e,0x24,0xbe,0x25,0x36,0x40,0x3, 0x2, 
+0x2, 0x48,0x7e,0xf0,0x4, 0x2, 0x3, 0x4f,0x7d,0x23,0x3e,0x24,0xbe,0x25,0x36,0x40,
+0x3, 0x2, 0x2, 0x5a,0x7e,0xf0,0x3, 0x2, 0x3, 0x4f,0xbe,0x35,0x36,0x40,0x3, 0x2, 
+0x2, 0x68,0x7e,0xf0,0x2, 0x2, 0x3, 0x4f,0x7d,0x23,0x1e,0x24,0xbe,0x25,0x36,0x40,
+0x3, 0x2, 0x2, 0x7a,0x7e,0xf0,0x1, 0x2, 0x3, 0x4f,0x1e,0x34,0x1e,0x34,0xbe,0x35,
+0x36,0x40,0x3, 0x2, 0x2, 0x8b,0x6c,0xff,0x2, 0x3, 0x4f,0x7e,0xf0,0xff,0x2, 0x3, 
+0x4f,0x7e,0x35,0x34,0xbe,0x34,0x0, 0x0, 0x18,0x3, 0x2, 0x2, 0xf0,0x7e,0x37,0x2a,
+0x81,0x7d,0x23,0x3e,0x24,0x3e,0x24,0xbe,0x25,0x36,0x40,0x3, 0x2, 0x2, 0xb2,0x2, 
+0x3, 0x14,0x7d,0x23,0x3e,0x24,0xbe,0x25,0x36,0x40,0x3, 0x2, 0x2, 0xc1,0x2, 0x3, 
+0x22,0xbe,0x35,0x36,0x40,0x3, 0x2, 0x2, 0xcc,0x2, 0x3, 0x34,0x7d,0x23,0x1e,0x24,
+0xbe,0x25,0x36,0x40,0x3, 0x2, 0x2, 0xdb,0x2, 0x3, 0x46,0x1e,0x34,0x1e,0x34,0xbe,
+0x35,0x36,0x40,0x3, 0x2, 0x2, 0xea,0x2, 0x3, 0x4c,0x7e,0xf0,0xb, 0x2, 0x3, 0x4f,
+0x7e,0x37,0x2a,0x81,0x7d,0x23,0x3e,0x24,0x3e,0x24,0xbe,0x25,0x36,0x40,0x3, 0x2, 
+0x3, 0x8, 0x7e,0xf0,0x5, 0x2, 0x3, 0x4f,0x7d,0x23,0x3e,0x24,0xbe,0x25,0x36,0x40,
+0x3, 0x2, 0x3, 0x1a,0x7e,0xf0,0x6, 0x2, 0x3, 0x4f,0xbe,0x35,0x36,0x40,0x3, 0x2, 
+0x3, 0x28,0x7e,0xf0,0x7, 0x2, 0x3, 0x4f,0x7d,0x23,0x1e,0x24,0xbe,0x25,0x36,0x40,
+0x3, 0x2, 0x3, 0x3a,0x7e,0xf0,0x8, 0x2, 0x3, 0x4f,0x1e,0x34,0x1e,0x34,0xbe,0x35,
+0x36,0x40,0x3, 0x2, 0x3, 0x4c,0x7e,0xf0,0x9, 0x2, 0x3, 0x4f,0x7e,0xf0,0xa, 0xe5,
+0x21,0xa, 0x3b,0x2d,0x36,0x9, 0x53,0x0, 0xcc,0xbe,0x50,0x2, 0x40,0x3, 0x2, 0x3, 
+0x6d,0x7e,0x15,0x25,0x6d,0x0, 0x7a,0xf, 0x2a,0x7b,0x2, 0x4, 0x66,0x9, 0x73,0x0, 
+0xae,0x1a,0x27,0x1a,0x3f,0x9d,0x32,0x12,0x58,0x85,0x7c,0xb7,0xf5,0x38,0x1a,0x3f,
+0x9e,0x34,0x0, 0x6, 0x12,0x58,0x85,0x7c,0xb7,0xf5,0x39,0xe5,0x21,0xa, 0x3b,0x2d,
+0x36,0x9, 0x73,0x0, 0xb8,0xbe,0x71,0x32,0x78,0x3, 0x2, 0x3, 0xd3,0xe5,0x39,0xa, 
+0x2b,0x7e,0x34,0x0, 0x6, 0x9d,0x32,0x12,0x58,0x85,0x1a,0x26,0x1a,0x24,0xe5,0x38,
+0xa, 0x1b,0x6d,0x0, 0x2f,0x1, 0x7e,0x45,0x36,0x7d,0x34,0x6d,0x22,0x12,0x44,0xa5,
+0x74,0x2, 0x7f,0x1, 0x1e,0x14,0x1e,0x4, 0x50,0x3, 0x4e,0x20,0x80,0x14,0x78,0xf4,
+0x2, 0x3, 0xf3,0x7e,0x45,0x36,0x7d,0x34,0x6d,0x22,0xe5,0x38,0xa, 0x1b,0x6d,0x0, 
+0x12,0x44,0xa5,0x74,0x2, 0x7f,0x1, 0x1e,0x14,0x1e,0x4, 0x50,0x3, 0x4e,0x20,0x80,
+0x14,0x78,0xf4,0x7d,0x34,0x1e,0x34,0x6d,0x22,0x2f,0x10,0x7a,0x1f,0x2a,0x7b,0xe5,
+0x21,0xa, 0x3b,0x2d,0x36,0x9, 0x73,0x0, 0xc2,0xbe,0x71,0x30,0x78,0x3, 0x2, 0x4, 
+0x35,0x7e,0x71,0x39,0x1e,0x70,0xa, 0x27,0xe5,0x38,0xa, 0x3b,0x2d,0x32,0x7e,0x17,
+0x2a,0x81,0xad,0x31,0x74,0x2, 0x1e,0x34,0x1e,0x24,0x50,0x3, 0x4e,0x60,0x80,0x14,
+0x78,0xf4,0x2, 0x4, 0x56,0x7e,0x47,0x2a,0x81,0x7d,0x34,0x6d,0x22,0xe5,0x38,0xa, 
+0x1b,0x6d,0x0, 0x12,0x44,0xa5,0x74,0x2, 0x1e,0x34,0x1e,0x24,0x50,0x3, 0x4e,0x60,
+0x80,0x14,0x78,0xf4,0x7d,0x14,0x1e,0x14,0x6d,0x0, 0x2f,0x1, 0x7e,0x1f,0x2a,0x7b,
+0x2f,0x10,0x7a,0x1f,0x2a,0x7b,0xe5,0x21,0xa, 0x3b,0x2d,0x36,0x9, 0x73,0x0, 0xcc,
+0xbe,0x70,0x1, 0x38,0x3, 0x2, 0x4, 0xc3,0x7e,0x71,0x21,0x74,0x2, 0xac,0x7b,0x2d,
+0x36,0x49,0x23,0x0, 0x86,0x7e,0x35,0x25,0x9d,0x32,0x12,0x58,0x85,0x7d,0x13,0x1a,
+0x2, 0x1a,0x0, 0x7e,0x1f,0x2a,0x7b,0x2f,0x10,0x7a,0x1f,0x2a,0x7b,0x7e,0x71,0x21,
+0x74,0x2, 0xac,0x7b,0x2d,0x36,0x49,0x23,0x0, 0x9a,0x7e,0x37,0x2a,0x79,0x9d,0x32,
+0x12,0x58,0x85,0x7d,0x13,0x1a,0x2, 0x1a,0x0, 0x7e,0x1f,0x2a,0x7b,0x2f,0x10,0x7a,
+0x1f,0x2a,0x7b,0x7e,0xd, 0x2c,0x7e,0x1f,0x2a,0x7b,0xbf,0x10,0x40,0x3, 0x2, 0x4, 
+0xf0,0x7a,0x1d,0x2c,0x7a,0xe1,0x22,0x85,0x21,0x23,0x7e,0x35,0x25,0x7a,0x35,0x27,
+0x7e,0x37,0x2a,0x79,0x7a,0x35,0x2a,0x7a,0xf1,0x29,0x85,0x32,0x33,0x85,0x30,0x31,
+0x5, 0x21,0xe5,0x21,0xb4,0xa, 0x2, 0x80,0x3, 0x2, 0x1, 0x1e,0xb, 0xe0,0x9, 0x76,
+0x0, 0x82,0xbc,0x7e,0x28,0x3, 0x2, 0x1, 0xd, 0xe5,0x22,0xbe,0xb0,0xff,0x78,0x3, 
+0x2, 0x5, 0x89,0x7e,0xa1,0x23,0xe5,0x22,0xa, 0x3b,0x19,0xa3,0x2a,0x47,0x7e,0x5, 
+0x27,0x7e,0x31,0x22,0x74,0x2, 0xac,0x3b,0x59,0x1, 0x2a,0x33,0x7e,0xa0,0x1, 0xe5,
+0x23,0xa, 0x2b,0x19,0xa2,0x2a,0x5b,0x7e,0x35,0x2a,0x59,0x31,0x2a,0x65,0x7e,0x31,
+0x23,0x74,0x2, 0xac,0x3b,0x7d,0x51,0x2d,0x56,0x59,0x5, 0x0, 0x86,0x2d,0x16,0x59,
+0x31,0x0, 0x9a,0xe5,0x29,0x7d,0x32,0x2d,0x36,0x19,0xb3,0x0, 0xae,0xe5,0x33,0x7d,
+0x32,0x2d,0x36,0x19,0xb3,0x0, 0xb8,0xe5,0x31,0x7d,0x32,0x2d,0x36,0x19,0xb3,0x0, 
+0xc2,0x7d,0x32,0x2d,0x36,0x9, 0xb3,0x0, 0xcc,0xbe,0xb0,0x2, 0x40,0x3, 0x2, 0x5, 
+0x89,0x2e,0x34,0x0, 0xcc,0x4, 0x7a,0x39,0xb0,0x5, 0x24,0x9, 0x76,0x0, 0x82,0xbe,
+0x71,0x24,0x28,0x3, 0x2, 0x0, 0xfe,0x6c,0xee,0x7e,0xa0,0x1, 0x2, 0x5, 0xda,0xa, 
+0x3e,0x9, 0x43,0x2a,0x47,0xa, 0x34,0x19,0xa3,0x2a,0x51,0x7e,0x70,0x7, 0xac,0x7e,
+0x7d,0x13,0x2d,0x16,0x19,0x41,0x0, 0x4, 0x7d,0x13,0x2d,0x16,0xb, 0x18,0x40,0x7e,
+0x50,0x2, 0xac,0x45,0x7d,0x12,0x2d,0x16,0x59,0x41,0x0, 0x5a,0x2d,0x36,0x49,0x33,
+0x0, 0x2, 0x2d,0x26,0x59,0x32,0x0, 0x6e,0xb, 0xe0,0x9, 0xb6,0x0, 0x82,0xbc,0xbe,
+0x38,0xbd,0x6c,0xee,0xa, 0x3e,0x9, 0xb3,0x2a,0x51,0x60,0x3, 0x2, 0x6, 0x39,0x7e,
+0x34,0x7f,0xff,0x7e,0x50,0x2, 0xac,0x5e,0x7d,0x12,0x2d,0x16,0x59,0x31,0x0, 0x5a,
+0x7d,0x12,0x2d,0x16,0x59,0x31,0x0, 0x6e,0x7d,0x12,0x2d,0x16,0x59,0x31,0x0, 0x86,
+0x2d,0x26,0x59,0x32,0x0, 0x9a,0x74,0x7f,0xa, 0x3e,0x2d,0x36,0x19,0xb3,0x0, 0xae,
+0xe4,0xa, 0x3e,0x2d,0x36,0x19,0xb3,0x0, 0xcc,0xa, 0x3e,0x2d,0x36,0x19,0xb3,0x0, 
+0xb8,0xa, 0x3e,0x2d,0x36,0x19,0xb3,0x0, 0xc2,0xb, 0xe0,0xbe,0xe0,0xa, 0x78,0xa4,
+0x9, 0xb6,0x0, 0x82,0xf5,0x21,0x6c,0xee,0xa, 0x3e,0x9, 0xb3,0x2a,0x51,0xb4,0x1, 
+0x2, 0x80,0x3, 0x2, 0x6, 0x8c,0xa, 0x3e,0x2d,0x36,0x9, 0xb3,0x0, 0x50,0xb4,0x1, 
+0x2, 0x80,0x3, 0x2, 0x6, 0x6c,0x74,0x3, 0x19,0xb3,0x0, 0x50,0xa, 0x3e,0x2d,0x36,
+0x9, 0xa3,0x0, 0x50,0xbe,0xa0,0x3, 0x68,0x3, 0x2, 0x6, 0x80,0xe4,0x2, 0x6, 0xbe,
+0x4c,0xaa,0x68,0x3, 0x2, 0x6, 0xc2,0x74,0x2, 0x2, 0x6, 0xbe,0xa, 0x3e,0x2d,0x36,
+0x9, 0xb3,0x0, 0x50,0xbe,0xb0,0x2, 0x78,0x3, 0x2, 0x6, 0xa1,0x60,0x3, 0x2, 0x6, 
+0xbc,0x74,0x1, 0x19,0xb3,0x0, 0x46,0x7e,0x51,0x21,0x7c,0xb5,0x4, 0xf5,0x21,0x74,
+0x7, 0xac,0x5b,0x2d,0x26,0x19,0xe2,0x0, 0x4, 0x2, 0x6, 0xc2,0x74,0x3, 0x19,0xb3,
+0x0, 0x46,0xa, 0x2e,0x2d,0x26,0x9, 0x72,0x0, 0x46,0x19,0x72,0x0, 0x50,0xb, 0xe0,
+0xbe,0xe0,0xa, 0x50,0x3, 0x2, 0x6, 0x48,0xda,0x3b,0x22,0x75,0x84,0x1, 0x7e,0x44,
+0x4, 0x1f,0xe4,0x7a,0x49,0xb0,0x1b,0x44,0x78,0xf9,0x7e,0xf8,0x2c,0x50,0x75,0x67,
+0x0, 0x75,0x68,0x0, 0x75,0x9, 0x0, 0x75,0xa, 0x0, 0x75,0xb, 0x0, 0x75,0xc, 0x0, 
+0x75,0xd, 0x0, 0x75,0xe, 0x0, 0x75,0x13,0x0, 0x75,0x14,0x0, 0x75,0x15,0x0, 0x75,
+0x16,0x0, 0x75,0x17,0x0, 0x75,0x18,0x0, 0xc2,0x0, 0x75,0x1a,0x0, 0x75,0x1b,0x0, 
+0x75,0x63,0x0, 0x75,0x64,0x64,0x75,0x65,0x64,0x75,0x66,0x0, 0xc2,0x1, 0x75,0x1e,
+0x0, 0x75,0x1f,0x0, 0x75,0x69,0x0, 0x75,0x51,0x0, 0x75,0x58,0x0, 0x75,0x59,0x0, 
+0x75,0x5a,0x0, 0x75,0x5c,0x0, 0x75,0x5d,0x0, 0x75,0x5e,0x0, 0x75,0x5f,0x0, 0x7e,
+0x4, 0x0, 0xff,0x7e,0x14,0x59,0x7a,0xb, 0xa, 0x40,0x5d,0x44,0x68,0x1a,0x69,0x20,
+0x0, 0x2, 0xb, 0xe, 0xb, 0x44,0x80,0xa, 0x7e,0xb, 0xb0,0x7a,0x29,0xb0,0xb, 0x24,
+0xb, 0xc, 0x1b,0x44,0x78,0xf2,0x80,0xdf,0x2, 0x47,0xf6,0x0, 0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xca,0x3b,0x7e,0xb3,0x27,0x7f,0xf5,0x25,0x7e,0xb3,0x27,0x80,0xf5,0x26,0x7e,0x34,
+0x2a,0x35,0x7e,0x24,0x0, 0x46,0x74,0xff,0x12,0x58,0x95,0xe5,0x25,0x70,0x38,0xe5,
+0x26,0xbe,0xb0,0x0, 0x38,0x3, 0x2, 0xc, 0x8b,0x6c,0xee,0x7e,0xa0,0xff,0x7e,0x70,
+0x7, 0xac,0x7e,0x19,0xa3,0x27,0x3b,0xb, 0xe0,0xbe,0xe0,0xa, 0x78,0xf0,0x7e,0xb3,
+0x27,0x83,0x44,0x4, 0x7a,0xb3,0x27,0x83,0x54,0xf7,0x7a,0xb3,0x27,0x83,0x54,0xdf,
+0x7a,0xb3,0x27,0x83,0x2, 0xc, 0x7d,0x6c,0xee,0x80,0x30,0x7e,0x50,0x7, 0xac,0x5e,
+0x2e,0x24,0x1f,0xce,0xb, 0x28,0x30,0x3e,0x34,0x3e,0x34,0x3e,0x34,0x3e,0x34,0x1b,
+0x28,0x30,0x7e,0x50,0x7, 0xac,0x5e,0x2e,0x24,0x1f,0xd0,0xb, 0x28,0x30,0x3e,0x34,
+0x3e,0x34,0x3e,0x34,0x3e,0x34,0x1b,0x28,0x30,0xb, 0xe0,0xe5,0x25,0xbc,0xbe,0x38,
+0xca,0xe5,0x26,0x70,0xa, 0x7e,0xb3,0x27,0x83,0x44,0x10,0x7a,0xb3,0x27,0x83,0xe5,
+0x26,0xbe,0xb1,0x25,0x68,0x3, 0x75,0x66,0x0, 0x75,0x29,0x0, 0x7e,0xa1,0x29,0x74,
+0x7, 0xa4,0x9, 0x75,0x26,0xf5,0xbe,0x70,0xa, 0x50,0xc, 0xa, 0x37,0x9, 0xb3,0x25,
+0x1d,0x70,0x4, 0xf5,0x66,0x80,0x9, 0x5, 0x29,0xe5,0x29,0xbe,0xb0,0xa, 0x40,0xdc,
+0x6d,0x66,0x6c,0xee,0x6c,0xff,0x80,0x37,0x74,0x7, 0xac,0xbf,0x9, 0xa5,0x1f,0xd2,
+0x7e,0x50,0x7, 0xac,0x5e,0x9, 0xb2,0x27,0x3b,0xbc,0xba,0x78,0x20,0xbe,0xb0,0xff,
+0x68,0x1b,0x2e,0x24,0x27,0x37,0x7e,0x14,0x0, 0x7, 0xad,0x16,0x7d,0x31,0x2e,0x34,
+0x2a,0x35,0x7e,0x14,0x0, 0x5, 0x12,0x58,0x16,0xb, 0x64,0x80,0x8, 0xb, 0xf0,0xe5,
+0x25,0xbc,0xbf,0x38,0xc3,0xb, 0xe0,0xbe,0xe0,0xa, 0x78,0xb8,0x6c,0xee,0x7e,0xf1,
+0x25,0x80,0x35,0x74,0x7, 0xac,0xbf,0x9, 0xa5,0x1f,0xd2,0x7e,0x50,0x7, 0xac,0x5e,
+0x9, 0xb2,0x27,0x3b,0xbc,0xba,0x78,0x1e,0xbe,0xb0,0xff,0x68,0x19,0x2e,0x24,0x27,
+0x37,0x7e,0x14,0x0, 0x7, 0x7d,0x56,0xad,0x51,0x7d,0x35,0x2e,0x34,0x2a,0x35,0x12,
+0x58,0x16,0xb, 0x64,0x80,0x7, 0xb, 0xf0,0xbe,0xf0,0xa, 0x40,0xc6,0xb, 0xe0,0xbe,
+0xe0,0xa, 0x78,0xba,0x6c,0xff,0x6c,0xee,0x80,0x16,0x74,0x7, 0xac,0xbe,0x9, 0x65,
+0x2a,0x39,0x74,0x7, 0xac,0xbf,0x9, 0x75,0x1f,0xd2,0xbc,0x76,0x68,0x8, 0xb, 0xe0,
+0xa, 0x3e,0xbd,0x36,0x40,0xe4,0xa, 0x3e,0xbd,0x36,0x78,0x1a,0x7e,0x70,0x7, 0xac,
+0x7f,0x2e,0x34,0x1f,0xce,0x7e,0x14,0x0, 0x7, 0xad,0x16,0x2e,0x14,0x2a,0x35,0x74,
+0x7, 0x12,0x45,0x12,0xb, 0x64,0xb, 0xf0,0xbe,0xf0,0xa, 0x78,0xb9,0x7e,0x24,0x2a,
+0x35,0x7e,0x34,0x27,0x37,0x7e,0x14,0x0, 0x46,0x12,0x58,0x16,0xe5,0x26,0x70,0x12,
+0x7e,0x24,0x1f,0xce,0x7e,0x34,0x27,0x37,0x7e,0x14,0x0, 0x46,0x12,0x58,0x16,0x2, 
+0xa, 0xef,0x7e,0xb3,0x27,0x83,0x30,0xe3,0x3, 0x2, 0xa, 0xef,0x6c,0xff,0x2, 0xa, 
+0xe6,0x6c,0xee,0x7e,0x70,0x7, 0xac,0x7f,0x9, 0x43,0x1f,0xd2,0x74,0x7, 0xac,0xbe,
+0x9, 0x55,0x27,0x3b,0xbc,0x54,0x68,0x7, 0xb, 0xe0,0xbe,0xe0,0xa, 0x40,0xe4,0x49,
+0x33,0x1f,0xce,0x74,0x7, 0xac,0xbe,0x49,0x25,0x27,0x37,0x12,0x58,0x75,0x7a,0x37,
+0x2a,0x33,0x74,0x7, 0xac,0xbf,0x49,0x35,0x1f,0xd0,0x74,0x7, 0xac,0xbe,0x49,0x25,
+0x27,0x39,0x12,0x58,0x75,0x7a,0x35,0x27,0x7e,0xf7,0x2a,0x33,0x7d,0xef,0x2e,0xe5,
+0x27,0x7a,0xe5,0x21,0x7a,0xe5,0x23,0x7e,0x17,0x0, 0x88,0xbe,0x15,0x21,0x28,0x44,
+0x7e,0x35,0x23,0x6d,0x22,0x7c,0x56,0x7c,0x67,0x6c,0x77,0x12,0x44,0xbf,0x7d,0x63,
+0xbe,0x64,0x1, 0x0, 0x28,0x4, 0x7e,0x64,0x1, 0x0, 0x7d,0x16,0xad,0x1f,0x7c,0x32,
+0x7c,0x21,0xa, 0x0, 0x7d,0x21,0x7a,0x27,0x2a,0x33,0x7d,0x63,0xbe,0x64,0x1, 0x0, 
+0x28,0x4, 0x7e,0x64,0x1, 0x0, 0x7e,0x35,0x27,0xad,0x36,0x7c,0x76,0x7c,0x65,0xa, 
+0x24,0x7a,0x35,0x27,0x7e,0x50,0x7, 0xac,0x5e,0x49,0x32,0x27,0x37,0x74,0x7, 0xac,
+0xbf,0x49,0x15,0x1f,0xce,0xbd,0x13,0x28,0x11,0x7d,0x2, 0x2e,0x4, 0x27,0x37,0x7d,
+0x13,0x2e,0x17,0x2a,0x33,0x1b,0x8, 0x10,0x80,0xb, 0x2e,0x24,0x27,0x37,0x9e,0x37,
+0x2a,0x33,0x1b,0x28,0x30,0x7e,0x50,0x7, 0xac,0x5e,0x49,0x32,0x27,0x39,0x74,0x7, 
+0xac,0xbf,0x49,0x15,0x1f,0xd0,0xbd,0x13,0x28,0x10,0x7d,0x2, 0x2e,0x4, 0x27,0x39,
+0x7d,0x13,0x2e,0x15,0x27,0x1b,0x8, 0x10,0x80,0xa, 0x2e,0x24,0x27,0x39,0x9e,0x35,
+0x27,0x1b,0x28,0x30,0xb, 0xf0,0xe5,0x25,0xbc,0xbf,0x28,0x3, 0x2, 0x9, 0xe1,0x6c,
+0xff,0x74,0x7, 0xac,0xbf,0x49,0x35,0x27,0x37,0x1e,0x34,0x1e,0x34,0x1e,0x34,0x1e,
+0x34,0x59,0x35,0x1f,0xce,0x74,0x7, 0xac,0xbf,0x49,0x35,0x27,0x39,0x1e,0x34,0x1e,
+0x34,0x1e,0x34,0x1e,0x34,0x59,0x35,0x1f,0xd0,0x74,0x7, 0xac,0xbf,0x9, 0x75,0x27,
+0x3b,0x19,0x75,0x1f,0xd2,0xb, 0xf0,0xbe,0xf0,0xa, 0x78,0xc5,0x7e,0xb3,0x27,0x83,
+0x44,0x1, 0x7a,0xb3,0x27,0x83,0xe5,0x25,0xbe,0xb0,0x0, 0x38,0x3, 0x2, 0xc, 0x62,
+0x6c,0xff,0xe5,0x66,0x70,0x66,0xbe,0xf0,0x9, 0x78,0x2, 0x5, 0x66,0x74,0x7, 0xac,
+0xbf,0x49,0x35,0x1f,0xce,0x12,0x55,0x97,0x74,0x7, 0xac,0xbf,0x59,0x35,0x26,0xf1,
+0x74,0x7, 0xac,0xbf,0x49,0x35,0x1f,0xd0,0x12,0x55,0xbc,0x74,0x7, 0xac,0xbf,0x59,
+0x35,0x26,0xf3,0x74,0x7, 0xac,0xbf,0x9, 0x75,0x1f,0xd2,0x19,0x75,0x26,0xf5,0x75,
+0x29,0x0, 0x7e,0x70,0x7, 0xac,0x7f,0x2e,0x34,0x26,0xf1,0x7e,0x51,0x29,0x74,0x7, 
+0xac,0x5b,0x7e,0x30,0x15,0xac,0x3f,0x2d,0x12,0x2e,0x14,0x29,0x61,0x74,0x7, 0x12,
+0x45,0x12,0x5, 0x29,0xe5,0x29,0xb4,0x3, 0xd9,0x2, 0xc, 0x58,0x74,0x7, 0xac,0xbf,
+0x49,0x35,0x1f,0xce,0x12,0x55,0x97,0x7d,0x13,0xe5,0x66,0xa, 0x3b,0x7e,0x24,0x0, 
+0x3, 0x12,0x44,0x73,0x7e,0x34,0x0, 0x7, 0xad,0x32,0x7e,0x10,0x15,0xac,0x1f,0x2d,
+0x3, 0x59,0x10,0x29,0x61,0x74,0x7, 0xac,0xbf,0x49,0x35,0x1f,0xd0,0x12,0x55,0xbc,
+0x7d,0x43,0xe5,0x66,0xa, 0x3b,0x7e,0x24,0x0, 0x3, 0x12,0x44,0x73,0x7e,0x34,0x0, 
+0x7, 0xad,0x32,0x74,0x15,0xac,0xbf,0x2d,0x35,0x59,0x43,0x29,0x63,0x49,0x35,0x29,
+0x68,0x49,0x25,0x29,0x61,0x2d,0x23,0x49,0x35,0x29,0x6f,0x2d,0x32,0x7e,0x24,0x0, 
+0x3, 0x8d,0x32,0x74,0x7, 0xac,0xbf,0x59,0x35,0x26,0xf1,0x74,0x15,0xac,0xbf,0x49,
+0x35,0x29,0x6a,0x49,0x25,0x29,0x63,0x2d,0x23,0x49,0x35,0x29,0x71,0x2d,0x32,0x7e,
+0x24,0x0, 0x3, 0x8d,0x32,0x74,0x7, 0xac,0xbf,0x59,0x35,0x26,0xf3,0x74,0x7, 0xac,
+0xbf,0x9, 0x75,0x1f,0xd2,0x19,0x75,0x26,0xf5,0xbe,0xf0,0x9, 0x78,0xa, 0xe5,0x66,
+0xb4,0xa, 0x3, 0x75,0x66,0x1, 0x5, 0x66,0xb, 0xf0,0xbe,0xf0,0xa, 0x68,0x3, 0x2, 
+0xb, 0x42,0x75,0x29,0x0, 0x7e,0xa1,0x29,0x74,0x7, 0xa4,0x9, 0x75,0x26,0xf5,0xbe,
+0x70,0xa, 0x50,0xe, 0xa, 0x37,0x9, 0xb3,0x25,0x13,0xb4,0x1, 0x5, 0x75,0x66,0x0, 
+0x80,0x9, 0x5, 0x29,0xe5,0x29,0xbe,0xb0,0xa, 0x40,0xda,0xda,0x3b,0x22,0xca,0x3b,
+0x7c,0xdb,0x7e,0xb3,0x20,0x14,0xf5,0x2c,0x75,0x60,0x0, 0x75,0x61,0x0, 0x75,0x62,
+0x0, 0x6d,0x22,0x7e,0x34,0x7f,0xff,0x6c,0xcc,0xe4,0xa, 0x1c,0x19,0xb1,0x2a,0x33,
+0x6c,0xaa,0x7e,0x90,0x2, 0xac,0x9c,0x19,0xa4,0x28,0xc0,0x19,0xb4,0x28,0xc1,0xe5,
+0x2c,0xbc,0xbc,0x28,0x28,0x9, 0x24,0x1f,0x7f,0x1e,0x20,0x7e,0x30,0x2, 0xac,0x23,
+0x9, 0x4, 0x1f,0x7e,0x1e,0x0, 0x7e,0x10,0x48,0xac,0x1, 0x2d,0x1, 0x49,0x10,0xe, 
+0xe, 0xbd,0x12,0x48,0x2, 0x7d,0x21,0xbd,0x13,0x18,0x2, 0x7d,0x31,0xb, 0xc0,0xbe,
+0xc0,0x28,0x78,0xb5,0x2d,0x32,0xe, 0x34,0xe5,0x2c,0xbe,0xb0,0x2, 0x50,0x3, 0x2, 
+0x10,0xd7,0x6c,0xcc,0x7e,0x30,0x6, 0xac,0x3c,0x7d,0x51,0x2e,0x54,0x56,0xe4,0x7e,
+0x44,0x0, 0xff,0xb, 0x2a,0x20,0xbd,0x23,0x58,0x1d,0x7d,0x51,0x2e,0x54,0x56,0xe6,
+0x7e,0x44,0x0, 0xff,0xb, 0x2a,0x20,0x7a,0x25,0x2f,0x2e,0x14,0x56,0xe8,0x7e,0x4, 
+0x0, 0xff,0xb, 0xa, 0x70,0x80,0x7, 0xb, 0xc0,0xbe,0xc0,0x5, 0x40,0xc6,0x6c,0xcc,
+0x2, 0x10,0xc5,0x7e,0x70,0x2, 0xac,0x7c,0x9, 0xb3,0x1f,0x7e,0x1e,0xb0,0xf5,0x22,
+0x9, 0xb3,0x1f,0x7f,0x1e,0xb0,0xf5,0x23,0x4c,0xcc,0x68,0x8, 0xa, 0x3c,0x9, 0xb3,
+0x2a,0x33,0x70,0xa, 0xa, 0x3c,0xb, 0x34,0xa, 0x2c,0x19,0x72,0x2a,0x33,0xe5,0x2c,
+0x14,0xbc,0xbc,0x78,0x3, 0x2, 0x10,0xce,0xa, 0x5c,0xb, 0x54,0xf5,0x2d,0x2, 0x10,
+0xb9,0x7e,0x71,0x2d,0x74,0x2, 0xac,0x7b,0x9, 0xa3,0x1f,0x7e,0x1e,0xa0,0x7a,0xa1,
+0x24,0x9, 0xb3,0x1f,0x7f,0x1e,0xb0,0xf5,0x25,0xa, 0x2a,0xe5,0x22,0xa, 0x3b,0x9d,
+0x32,0x12,0x58,0x85,0x7c,0xb7,0xf5,0x2a,0xe5,0x25,0xa, 0x2b,0xe5,0x23,0xa, 0x3b,
+0x9d,0x32,0x12,0x58,0x85,0x7c,0xb7,0xf5,0x2b,0x75,0x3a,0x2, 0x75,0x2e,0x0, 0x7e,
+0x51,0x23,0x74,0x2, 0xac,0x5b,0x7e,0x71,0x22,0x74,0x48,0xac,0x7b,0x2d,0x32,0x49,
+0x33,0xe, 0xe, 0x7a,0x35,0x31,0x7e,0x31,0x25,0x74,0x2, 0xac,0x3b,0x7e,0x71,0x24,
+0x74,0x48,0xac,0x7b,0x2d,0x13,0x49,0x11,0xe, 0xe, 0x7a,0x15,0x33,0x7d,0x1, 0x3e,
+0x4, 0x3e,0x4, 0x3e,0x4, 0xe, 0x4, 0xe, 0x4, 0xe, 0x4, 0xe, 0x4, 0x7a,0x5, 0x35,
+0xbe,0x15,0x31,0x8, 0x14,0x7e,0x15,0x31,0x3e,0x14,0x3e,0x14,0x3e,0x14,0xe, 0x14,
+0xe, 0x14,0xe, 0x14,0xe, 0x14,0x7a,0x15,0x35,0xe5,0x2a,0xbe,0xb0,0x1, 0x38,0x38,
+0xe5,0x2b,0xbe,0xb0,0x1, 0x38,0x31,0x7c,0xbd,0x54,0x2, 0xb4,0x2, 0x2a,0x2d,0x32,
+0x49,0x23,0xe, 0xe, 0x7e,0x31,0x25,0x74,0x2, 0xac,0x3b,0x7e,0x71,0x22,0x74,0x48,
+0xac,0x7b,0x2d,0x31,0x49,0x33,0xe, 0xe, 0x2d,0x32,0xbe,0x35,0x35,0x18,0x3, 0x2, 
+0x10,0x51,0x75,0x2e,0x1, 0x2, 0x10,0x51,0xe5,0x2a,0xbe,0xb0,0x1, 0x38,0xa, 0xe5,
+0x2b,0xbe,0xb0,0x1, 0x38,0x3, 0x2, 0x10,0x51,0xe5,0x2a,0xbe,0xb0,0x5, 0x40,0x3, 
+0x2, 0x10,0x51,0xe5,0x2b,0xbe,0xb0,0x5, 0x40,0x3, 0x2, 0x10,0x51,0x7c,0xbd,0x54,
+0x1, 0xb4,0x1, 0x2, 0x80,0x3, 0x2, 0x10,0x51,0x6d,0x33,0x7a,0x35,0x37,0x75,0x39,
+0x0, 0x85,0x22,0x26,0x85,0x24,0x28,0xe5,0x24,0xbe,0xb1,0x22,0x50,0x6, 0x85,0x24,
+0x26,0x85,0x22,0x28,0x85,0x23,0x27,0x85,0x25,0x29,0xe5,0x25,0xbe,0xb1,0x23,0x50,
+0x6, 0x85,0x25,0x27,0x85,0x23,0x29,0x75,0x40,0x0, 0x75,0x41,0x0, 0xe5,0x28,0xbe,
+0xb1,0x26,0x78,0x21,0x75,0x40,0x1, 0xe5,0x26,0x60,0x5, 0xe5,0x26,0xb4,0x25,0x3, 
+0x75,0x41,0x1, 0xe5,0x26,0xbe,0xb0,0x0, 0x28,0x2, 0x15,0x26,0xe5,0x28,0xbe,0xb0,
+0x25,0x50,0x2, 0x5, 0x28,0xe5,0x29,0xbe,0xb1,0x27,0x78,0x21,0x75,0x40,0x1, 0xe5,
+0x27,0x60,0x5, 0xe5,0x27,0xb4,0x17,0x3, 0x75,0x41,0x1, 0xe5,0x27,0xbe,0xb0,0x0, 
+0x28,0x2, 0x15,0x27,0xe5,0x29,0xbe,0xb0,0x17,0x50,0x2, 0x5, 0x29,0x85,0x26,0x3b,
+0x2, 0xf, 0x88,0x85,0x27,0x3c,0x2, 0xf, 0x7f,0x7e,0x51,0x3c,0x74,0x2, 0xac,0x5b,
+0x7e,0x71,0x3b,0x74,0x48,0xac,0x7b,0x2d,0x32,0x49,0x33,0xe, 0xe, 0x7a,0x35,0x3e,
+0xe5,0x8, 0xb4,0x1, 0xb, 0xe5,0x3b,0x7e,0x71,0x3c,0x12,0x47,0x4c,0x7a,0x35,0x3e,
+0xe5,0x26,0xbe,0xb1,0x3b,0x68,0x15,0xe5,0x28,0xbe,0xb1,0x3b,0x68,0xe, 0xe5,0x27,
+0xbe,0xb1,0x3c,0x68,0x7, 0xe5,0x29,0xbe,0xb1,0x3c,0x78,0xd, 0x7e,0x35,0x3e,0x2e,
+0x35,0x37,0x7a,0x35,0x37,0x5, 0x39,0x80,0x14,0xbe,0x75,0x3e,0x58,0xc, 0xe5,0x3a,
+0xbe,0xb0,0x0, 0x28,0x5, 0x75,0x3a,0x1, 0x80,0x3, 0x75,0x3a,0x0, 0x5, 0x3c,0xe5,
+0x29,0xbe,0xb1,0x3c,0x50,0x93,0x5, 0x3b,0xe5,0x28,0xbe,0xb1,0x3b,0x50,0x84,0x7e,
+0x31,0x27,0x74,0x2, 0xac,0x3b,0x7e,0x11,0x28,0x74,0x48,0xac,0x1b,0x2d,0x1, 0x49,
+0x20,0xe, 0xe, 0x7e,0x35,0x37,0x9d,0x32,0x7e,0x11,0x29,0x74,0x2, 0xac,0x1b,0x7e,
+0x51,0x26,0x74,0x48,0xac,0x5b,0x2d,0x2, 0x49,0x0, 0xe, 0xe, 0x9d,0x30,0x2d,0x21,
+0x49,0x22,0xe, 0xe, 0x9d,0x32,0x7e,0x31,0x29,0x74,0x2, 0xac,0x3b,0x7e,0x51,0x28,
+0x74,0x48,0xac,0x5b,0x2d,0x21,0x49,0x22,0xe, 0xe, 0x9d,0x32,0x7a,0x35,0x37,0x7e,
+0x35,0x33,0x2e,0x35,0x31,0x7a,0x35,0x35,0xe5,0x40,0xb4,0x1, 0x11,0xe5,0x41,0x70,
+0xd, 0x7e,0x35,0x37,0x9e,0x35,0x35,0x7a,0x35,0x37,0x15,0x39,0x15,0x39,0xe5,0x39,
+0xbe,0xb0,0x4, 0x28,0x6, 0xe5,0x39,0x24,0xfc,0xf5,0x39,0x7e,0x35,0x37,0xbe,0x34,
+0x0, 0x0, 0x58,0x5, 0x6d,0x33,0x7a,0x35,0x37,0x7e,0x15,0x35,0x1a,0x2, 0x1a,0x0, 
+0x7e,0x35,0x2f,0x1a,0x26,0x1a,0x24,0x12,0x44,0xa5,0xe5,0x39,0xa, 0x1b,0x6d,0x0, 
+0x12,0x44,0xa5,0x7f,0x21,0x7e,0x35,0x37,0x1a,0x26,0x1a,0x24,0x7e,0x14,0x0, 0x28,
+0x12,0x44,0xb6,0xbf,0x12,0x8, 0xa, 0xe5,0x3a,0xbe,0xb0,0x0, 0x28,0x3, 0x75,0x2e,
+0x2, 0xe5,0x2e,0xbe,0xb0,0x0, 0x28,0x5f,0x7e,0x11,0x2e,0x2e,0x10,0x60,0xa5,0xe7,
+0x4, 0xa5,0xf7,0xe5,0x2d,0xa, 0x3b,0x9, 0xb3,0x2a,0x33,0x70,0xc, 0xa, 0x2c,0x9, 
+0x52,0x2a,0x33,0x19,0x53,0x2a,0x33,0x80,0x3e,0x75,0x3d,0x0, 0x80,0x32,0x9, 0x33,
+0x2a,0x33,0xa, 0x2c,0x9, 0xa2,0x2a,0x33,0xbc,0xa3,0x28,0x12,0xe5,0x3d,0xa, 0x2b,
+0x9, 0x22,0x2a,0x33,0xbc,0x2a,0x78,0x16,0x19,0x32,0x2a,0x33,0x80,0x10,0xe5,0x3d,
+0xa, 0x2b,0x9, 0xb2,0x2a,0x33,0xbc,0xb3,0x78,0x4, 0x19,0xa2,0x2a,0x33,0x5, 0x3d,
+0xe5,0x2c,0xbe,0xb1,0x3d,0x38,0xc7,0x5, 0x2d,0xe5,0x2c,0xbe,0xb1,0x2d,0x28,0x3, 
+0x2, 0xd, 0x81,0xb, 0xc0,0xe5,0x2c,0xbc,0xbc,0x28,0x3, 0x2, 0xd, 0x43,0x7e,0x34,
+0x2a,0x33,0x12,0x2f,0xe, 0xf5,0x60,0xda,0x3b,0x22,0xca,0x3b,0x7e,0xb3,0x20,0x14,
+0xf5,0x22,0x75,0x23,0x0, 0x7e,0x34,0x27,0x10,0x7a,0x35,0x32,0x7e,0x34,0xd8,0xf0,
+0x7a,0x35,0x34,0x7e,0x35,0xb, 0xbe,0x34,0x0, 0x0, 0x38,0x3, 0x2, 0x11,0x7, 0x1b,
+0x34,0x7a,0x35,0xb, 0x75,0xd, 0x1, 0x7e,0x35,0x13,0xbe,0x34,0x0, 0x0, 0x38,0x3, 
+0x2, 0x11,0x1b,0x1b,0x34,0x7a,0x35,0x13,0x75,0x15,0x1, 0x6d,0x33,0x7a,0x35,0x2c,
+0x7a,0x35,0x30,0x7a,0x35,0x28,0x6c,0xff,0x6c,0xee,0x1a,0x2e,0x3e,0x24,0x7e,0x70,
+0x48,0xac,0x7f,0x2d,0x32,0x49,0x63,0xe, 0xe, 0xbe,0x64,0x0, 0x1e,0x58,0x3, 0x2, 
+0x11,0x4d,0x7d,0x36,0x2e,0x35,0x30,0x7a,0x35,0x30,0x2, 0x11,0x61,0xbe,0x64,0xff,
+0xe2,0x8, 0x3, 0x2, 0x11,0x61,0x7d,0x36,0x12,0x58,0x85,0x2e,0x35,0x2c,0x7a,0x35,
+0x2c,0xbe,0x64,0xff,0x9c,0x48,0x3, 0x2, 0x11,0x85,0x7e,0x35,0x28,0xb, 0x34,0x7a,
+0x35,0x28,0xbe,0x34,0x0, 0xa, 0x38,0x3, 0x2, 0x11,0x85,0x75,0xd, 0x1, 0x7e,0x34,
+0x0, 0x64,0x7a,0x35,0xb, 0x1a,0x3e,0x3e,0x34,0x7e,0x50,0x48,0xac,0x5f,0x2d,0x23,
+0x49,0x32,0xe, 0xe, 0xbe,0x35,0x32,0x48,0x3, 0x2, 0x11,0x9f,0x7a,0x35,0x32,0xbe,
+0x35,0x34,0x18,0x3, 0x2, 0x11,0xaa,0x7a,0x35,0x34,0xb, 0xe0,0xbe,0xe0,0x18,0x68,
+0x3, 0x2, 0x11,0x2a,0xb, 0xf0,0xbe,0xf0,0x26,0x68,0x3, 0x2, 0x11,0x28,0x7e,0x35,
+0x32,0x12,0x58,0x85,0x7a,0x35,0x32,0x7e,0x35,0x34,0x12,0x58,0x85,0x7a,0x35,0x34,
+0xe5,0x22,0xbe,0xb0,0x0, 0x38,0x3, 0x2, 0x13,0x78,0x6c,0xff,0x2, 0x13,0x19,0x7e,
+0x70,0x2, 0xac,0x7f,0x9, 0xa3,0x1f,0x7e,0x1e,0xa0,0x7a,0xa1,0x24,0x9, 0xb3,0x1f,
+0x7f,0x1e,0xb0,0xf5,0x25,0x1a,0x2b,0x3e,0x24,0x1a,0x3a,0x7e,0x14,0x0, 0x48,0xad,
+0x13,0x2d,0x21,0x49,0x22,0xe, 0xe, 0x7a,0x25,0x26,0x6d,0x22,0x7a,0x25,0x2a,0x7a,
+0x25,0x2e,0x1b,0x34,0x7c,0xe7,0x2, 0x12,0x9e,0xe5,0x25,0x1a,0x5b,0x1b,0x54,0xf5,
+0x21,0x2, 0x12,0x8e,0xbe,0xe0,0x0, 0x58,0x3, 0x2, 0x12,0x8c,0xbe,0xe0,0x26,0x48,
+0x3, 0x2, 0x12,0x8c,0xe5,0x21,0xbe,0xb0,0x0, 0x58,0x3, 0x2, 0x12,0x8c,0xe5,0x21,
+0xbe,0xb0,0x18,0x48,0x3, 0x2, 0x12,0x8c,0xe5,0x24,0xbc,0xbe,0x68,0x3, 0x2, 0x12,
+0x5b,0xe5,0x25,0xbe,0xb1,0x21,0x78,0x3, 0x2, 0x12,0x8c,0xe5,0x21,0x1a,0x1b,0x3e,
+0x14,0x1a,0x2e,0x7e,0x34,0x0, 0x48,0xad,0x32,0x2d,0x31,0x49,0x63,0xe, 0xe, 0xbe,
+0x64,0x0, 0x0, 0x7d,0x36,0x48,0x3, 0x2, 0x12,0x86,0x12,0x58,0x85,0x2e,0x35,0x2a,
+0x7a,0x35,0x2a,0x2, 0x12,0x8c,0x2e,0x35,0x2e,0x7a,0x35,0x2e,0x5, 0x21,0xe5,0x25,
+0x1a,0x2b,0xb, 0x24,0xe5,0x21,0x1a,0x3b,0xbd,0x32,0x8, 0x88,0xb, 0xe0,0xe5,0x24,
+0x1a,0x2b,0xb, 0x24,0x1a,0x3e,0xbd,0x32,0x18,0x3, 0x2, 0x12,0x19,0x7e,0x35,0x2e,
+0xbe,0x35,0x2a,0x58,0x3, 0x2, 0x13,0x17,0x7e,0x25,0x32,0xbe,0x25,0x26,0x28,0x3, 
+0x2, 0x13,0x17,0xe5,0xd, 0xbe,0xb0,0x1, 0x78,0x3, 0x2, 0x12,0xe1,0xe5,0x15,0xbe,
+0xb0,0x1, 0x78,0x3, 0x2, 0x12,0xe1,0xe5,0xe, 0xb4,0x1, 0x2, 0x80,0x3, 0x2, 0x12,
+0xf9,0xbe,0x34,0x1, 0x90,0x18,0x3, 0x2, 0x13,0x17,0x7e,0x35,0x26,0xbe,0x34,0x0, 
+0x96,0x38,0x3, 0x2, 0x13,0x17,0x2, 0x12,0xf9,0x7e,0x90,0x2, 0xac,0x9f,0x9, 0x74,
+0x1f,0x7e,0x7e,0x61,0x23,0x74,0x2, 0xac,0xb6,0x19,0x75,0x2a,0x33,0x9, 0x74,0x1f,
+0x7f,0x19,0x75,0x2a,0x34,0x5, 0x23,0xb, 0xf0,0xe5,0x22,0xbc,0xbf,0x28,0x3, 0x2, 
+0x11,0xdf,0xe5,0x23,0xbe,0xb0,0x0, 0x38,0x3, 0x2, 0x13,0x40,0xe5,0x23,0xa, 0x1b,
+0x3e,0x14,0x7e,0x24,0x2a,0x33,0x7e,0x34,0x1f,0x7e,0x12,0x58,0x16,0x2, 0x13,0x72,
+0x7e,0x35,0x30,0xbe,0x35,0x2c,0x48,0x3, 0x2, 0x13,0x52,0x7e,0x34,0x0, 0x64,0x7a,
+0x35,0x13,0x7e,0x35,0x32,0xbe,0x34,0x0, 0x50,0x18,0x3, 0x2, 0x13,0x6f,0x7e,0x35,
+0x34,0xbe,0x35,0x32,0x48,0x3, 0x2, 0x13,0x6f,0x75,0xe, 0x1, 0x2, 0x13,0x72,0x75,
+0xe, 0x0, 0xe5,0x23,0x7a,0xb3,0x20,0x14,0x75,0xd, 0x0, 0x75,0x15,0x0, 0xda,0x3b,
+0x22,0xca,0x3b,0x7d,0xd1,0x7d,0xc3,0x6c,0x66,0x6d,0xee,0x7d,0x1e,0x7d,0x4e,0x7d,
+0xfe,0x6c,0xaa,0x75,0x21,0x0, 0x6c,0xff,0x49,0xdd,0x0, 0x3, 0x6d,0xbb,0x7a,0xb7,
+0x2b,0xd7,0x7a,0xb7,0x2b,0xd9,0xe4,0x7a,0xb3,0x2b,0xdb,0x7a,0xb7,0x2b,0xe6,0x7a,
+0xb7,0x2b,0xe8,0x7a,0xb7,0x2b,0xec,0x7a,0xb3,0x2b,0xee,0x2e,0xc4,0xd, 0x80,0x7a,
+0xb5,0x1e,0x6c,0x77,0x2, 0x15,0xd8,0x7e,0xd0,0x24,0xac,0xd7,0x7d,0xb6,0x6c,0x66,
+0x2, 0x15,0xcb,0x7d,0xab,0x3e,0xa4,0x2d,0xac,0xb, 0xa8,0x90,0xbe,0x94,0x0, 0x28,
+0x8, 0x72,0x7e,0xb3,0x2b,0xef,0xa, 0xab,0xbd,0x9a,0x8, 0xa, 0x7e,0xa7,0x2b,0xec,
+0xb, 0xa4,0x7a,0xa7,0x2b,0xec,0x7d,0xab,0x3e,0xa4,0x2d,0xac,0xb, 0xa8,0x90,0x7e,
+0xb3,0x2b,0xd6,0xa, 0xab,0xbd,0x9a,0x8, 0x2d,0x7e,0xa7,0x2b,0xe6,0xb, 0xa4,0x7a,
+0xa7,0x2b,0xe6,0x7e,0xa7,0x2b,0xe8,0xb, 0xa4,0x7a,0xa7,0x2b,0xe8,0x7d,0xab,0x3e,
+0xa4,0x2d,0xac,0xb, 0xa8,0xa0,0xbe,0xa7,0x2b,0xdc,0x28,0xa, 0x7e,0xa7,0x2b,0xd7,
+0xb, 0xa4,0x7a,0xa7,0x2b,0xd7,0x7d,0xab,0x3e,0xa4,0x2d,0xac,0xb, 0xa8,0xa0,0xbe,
+0xa7,0x2b,0xea,0x38,0x3, 0x2, 0x14,0xdf,0x7e,0xb3,0x2b,0xee,0x4, 0x7a,0xb3,0x2b,
+0xee,0x2, 0x14,0xdf,0x7d,0xab,0x3e,0xa4,0x2d,0xac,0xb, 0xa8,0xa0,0xbe,0xa4,0xff,
+0xd8,0x48,0x3, 0x2, 0x14,0xdf,0x7d,0xab,0x3e,0xa4,0x2d,0xac,0xb, 0xa8,0x90,0x7e,
+0xb3,0x2b,0xd6,0xa, 0xab,0x6e,0xa4,0xff,0xff,0xb, 0xa4,0xbd,0x9a,0x58,0x60,0x7e,
+0xa7,0x2b,0xe6,0xb, 0xa4,0x7a,0xa7,0x2b,0xe6,0x7e,0xa7,0x2b,0xe8,0xb, 0xa4,0x7a,
+0xa7,0x2b,0xe8,0x7d,0xab,0x3e,0xa4,0x2d,0xac,0xb, 0xa8,0xa0,0xbe,0xa7,0x2b,0xde,
+0x58,0xc, 0x7e,0xa7,0x2b,0xd9,0xb, 0xa4,0x7a,0xa7,0x2b,0xd9,0x80,0x1a,0x7d,0xab,
+0x3e,0xa4,0x2d,0xac,0xb, 0xa8,0x90,0x6d,0xaa,0x9d,0xad,0xbd,0x9a,0x58,0x9, 0x7e,
+0xb3,0x2b,0xdb,0x4, 0x7a,0xb3,0x2b,0xdb,0x7d,0xab,0x3e,0xa4,0x2d,0xac,0xb, 0xa8,
+0xa0,0xbe,0xa4,0xff,0x6a,0x58,0x8, 0x7e,0xa5,0x1e,0xb, 0xa4,0x7a,0xa5,0x1e,0x7e,
+0xb3,0x2b,0xd3,0xb4,0x1, 0x25,0x7e,0xb3,0x2b,0xd0,0xbc,0xb7,0x38,0x1d,0x7e,0xb3,
+0x2b,0xcf,0xbc,0xb7,0x40,0x15,0x7e,0xb3,0x2b,0xd2,0xbc,0xb6,0x38,0xd, 0x7e,0xb3,
+0x2b,0xd1,0xbc,0xb6,0x40,0x5, 0xb, 0xb4,0x2, 0x15,0xc9,0x7d,0xab,0x3e,0xa4,0x2d,
+0xac,0xb, 0xa8,0xa0,0xbd,0xad,0x18,0x3, 0x2, 0x15,0xc7,0xa5,0xbf,0x0, 0x4, 0x6d,
+0x11,0x80,0xd, 0x7d,0x1b,0x9e,0x14,0x0, 0x24,0x3e,0x14,0x2d,0x1c,0xb, 0x18,0x10,
+0x7e,0x29,0xb0,0x14,0xbc,0xb7,0x78,0x4, 0x6d,0x44,0x80,0xa, 0x7d,0xab,0x3e,0xa4,
+0x2d,0xac,0x49,0x4a,0x0, 0x48,0xa5,0xbe,0x0, 0x4, 0x6d,0xee,0x80,0xb, 0x7d,0xeb,
+0x1b,0xe4,0x3e,0xe4,0x2d,0xec,0xb, 0xe8,0xe0,0x9, 0xb2,0x0, 0x1, 0x14,0xbc,0xb6,
+0x78,0x4, 0x6d,0xff,0x80,0xa, 0x7d,0xfb,0x3e,0xf4,0x2d,0xfc,0x49,0xff,0x0, 0x2, 
+0xbd,0x41,0x8, 0x2, 0x7d,0x14,0xbd,0xf1,0x8, 0x2, 0x7d,0x1f,0xbd,0xe1,0x8, 0x2, 
+0x7d,0x1e,0x7d,0xab,0x3e,0xa4,0x2d,0xac,0xb, 0xa8,0xa0,0xbd,0xa1,0x48,0x38,0x7c,
+0xb7,0x3e,0xb0,0xf5,0x21,0x7c,0xf6,0x3e,0xf0,0x4c,0xaa,0x78,0xe, 0xe5,0x21,0x7a,
+0xb3,0x2a,0x33,0x7a,0xf3,0x2a,0x34,0xb, 0xa0,0x80,0x1c,0xbe,0xa0,0x28,0x40,0x5, 
+0x7e,0xa0,0x28,0x80,0x12,0x7e,0xe1,0x21,0x7e,0xd0,0x2, 0xac,0xda,0x19,0xe6,0x2a,
+0x33,0x19,0xf6,0x2a,0x34,0xb, 0xa0,0xb, 0xb4,0xb, 0x60,0x9, 0xb2,0x0, 0x1, 0xbc,
+0xb6,0x28,0x3, 0x2, 0x13,0xd3,0xb, 0x70,0x7e,0x29,0xb0,0xbc,0xb7,0x28,0x3, 0x2, 
+0x13,0xc7,0xbe,0xa0,0x0, 0x28,0x24,0x6c,0x77,0x80,0x1c,0x7e,0x50,0x2, 0xac,0x57,
+0x9, 0x62,0x2a,0x33,0x7d,0x12,0x2d,0x10,0x7a,0x19,0x60,0x9, 0x62,0x2a,0x34,0x2d,
+0x20,0x19,0x62,0x0, 0x1, 0xb, 0x70,0xbc,0xa7,0x38,0xe0,0x19,0xa0,0x0, 0x96,0xda,
+0x3b,0x22,0xca,0x79,0x7d,0xf0,0x7d,0xc1,0x7d,0xe2,0x7d,0xd3,0x6c,0xaa,0x6c,0x33,
+0x6d,0x33,0x7a,0x37,0x2a,0x46,0x7a,0x37,0x2a,0x48,0x9, 0x2f,0x0, 0xc1,0x9, 0xbf,
+0x0, 0xc2,0xf5,0x29,0xa, 0x2, 0x2d,0xf, 0x9, 0x10,0x0, 0x99,0x9, 0xbc,0x0, 0x15,
+0xf5,0x2a,0x7e,0xa4,0x0, 0x1, 0x7d,0x2d,0x2e,0x24,0xd, 0x80,0x7d,0x42,0x7d,0xbd,
+0x2e,0xb4,0x1d,0x40,0x9, 0xbf,0x0, 0x96,0x70,0x3, 0x2, 0x18,0x9e,0x7e,0x70,0x2, 
+0xac,0x72,0x2d,0x3f,0x7e,0x39,0x0, 0x7c,0xb0,0x1e,0xb0,0x7e,0xf0,0x24,0xac,0xfb,
+0x9, 0x73,0x0, 0x1, 0x1e,0x70,0xa, 0x97,0x2d,0x97,0x75,0x28,0x0, 0x3e,0x94,0x2d,
+0x94,0xb, 0x98,0x90,0xb, 0xc8,0xc0,0xbd,0x9c,0x40,0x3, 0x75,0x28,0x1, 0x7d,0xa2,
+0xa, 0x24,0x7c,0xb5,0xf5,0xba,0x7d,0x2a,0x7c,0xb5,0xf5,0xb9,0xa, 0xd7,0xa, 0x21,
+0xbd,0xd2,0x40,0xa, 0xa, 0x37,0xa, 0x21,0x9d,0x32,0x7c,0x37,0x80,0x2, 0x6c,0x33,
+0x7a,0x31,0xbb,0x1e,0x0, 0xa, 0x20,0xa, 0x31,0xbd,0x23,0x40,0xa, 0xa, 0x31,0x7d,
+0x52,0x9d,0x53,0x7c,0xab,0x80,0x2, 0x6c,0xaa,0x7c,0xba,0x54,0x3, 0x1a,0x3b,0x3e,
+0x34,0x3e,0x34,0x3e,0x34,0x3e,0x34,0x3e,0x34,0x3e,0x34,0x7c,0x7, 0x7c,0xb0,0x42,
+0xbb,0x7c,0xba,0xe, 0xb0,0xe, 0xb0,0xf5,0xbc,0xe5,0x2a,0xa, 0x3b,0x3e,0x34,0x3e,
+0x34,0x3e,0x34,0x3e,0x34,0x5e,0x34,0x0, 0xf0,0x7c,0x7, 0x7c,0xb0,0x42,0xbc,0x7e,
+0x70,0x2, 0xac,0x72,0x2d,0x3f,0x9, 0x3, 0x0, 0x1, 0x1e,0x0, 0xa, 0xd0,0xa, 0x31,
+0x2d,0x3d,0x9, 0xe, 0x0, 0x1, 0xa, 0xd0,0xbd,0x3d,0x50,0x2, 0x80,0x4, 0xa, 0x30,
+0x1b,0x34,0x7c,0xb7,0xf5,0x27,0x1a,0xd3,0xe5,0x27,0x1a,0x3b,0x9d,0x3d,0xb, 0x34,
+0x7c,0xb7,0xf5,0xc3,0xa, 0x31,0x2d,0x32,0x7e,0xe9,0x0, 0xa, 0x20,0xbd,0x32,0x50,
+0x2, 0x80,0x6, 0xa, 0xa0,0x1b,0xa4,0x7d,0x3a,0x7c,0xb7,0xf5,0x26,0x1a,0x3a,0xe5,
+0x26,0x1a,0xab,0x9d,0xa3,0xb, 0xa4,0x7d,0x3a,0x7c,0xb7,0xf5,0xc4,0x7e,0xa4,0x2a,
+0x36,0x7d,0x3a,0xa, 0x36,0x7c,0xb7,0xf5,0xc1,0x7d,0x3a,0x7c,0xb7,0xf5,0xbd,0x75,
+0xc2,0x7, 0x80,0x3, 0x43,0xc2,0x1, 0x0, 0x0, 0x0, 0x0, 0xe5,0xc2,0x30,0xe7,0xf4,
+0x75,0xc2,0x0, 0x7e,0x1f,0x2a,0x3e,0x7a,0x1f,0x2a,0x4a,0x7e,0x1f,0x2a,0x42,0x7e,
+0x6f,0x2a,0x3a,0x7e,0x4f,0x2a,0x36,0x7a,0x4f,0x2a,0x4e,0x74,0x2, 0xac,0xb2,0x2d,
+0x5f,0x7e,0x59,0xa0,0x1e,0xa0,0x9c,0xa1,0x2, 0x18,0x3e,0x7e,0xf0,0x2, 0xac,0xf2,
+0x7d,0xa7,0x2d,0xaf,0x9, 0x3a,0x0, 0x1, 0x1e,0x30,0x9c,0x31,0x80,0x65,0xbe,0xa0,
+0x0, 0x48,0x5e,0x7e,0xe9,0x0, 0xbc,0xa, 0x8, 0x57,0xbe,0x30,0x0, 0x48,0x52,0x9, 
+0xe, 0x0, 0x1, 0xbc,0x3, 0x8, 0x4a,0x1a,0x8a,0x7e,0x94,0x0, 0x24,0xad,0x98,0x1a,
+0xa3,0x2d,0xa9,0x7d,0x9a,0x3e,0x94,0x2d,0x94,0xb, 0x98,0x80,0xe5,0x2a,0xa, 0x9b,
+0xbd,0x89,0x8, 0x2d,0xe5,0x28,0xb4,0x1, 0x28,0x7d,0x9a,0x5e,0x94,0x0, 0x7, 0x2e,
+0x94,0x59,0x48,0x7d,0x79,0x7a,0xf1,0x82,0x7a,0xe1,0x83,0xe4,0x93,0x64,0xff,0x7d,
+0x9a,0x1e,0x94,0x1e,0x94,0x1e,0x94,0x2d,0x9b,0x7e,0x99,0x0, 0x5c,0xb, 0x7a,0x99,
+0x0, 0xb, 0x30,0x7e,0xf0,0x2, 0xac,0xf2,0x7d,0x97,0x2d,0x9f,0x9, 0xb9,0x0, 0x1, 
+0x1e,0xb0,0x2c,0xb1,0x1a,0x8b,0x1a,0x93,0xbd,0x98,0x8, 0x82,0xb, 0xa0,0x7e,0xf0,
+0x2, 0xac,0xf2,0x7d,0xa7,0x2d,0xaf,0x7e,0xa9,0xb0,0x1e,0xb0,0x2c,0xb1,0x1a,0x9b,
+0x1a,0xaa,0xbd,0xa9,0x18,0x3, 0x2, 0x17,0xab,0x74,0x6, 0x2f,0x11,0x14,0x78,0xfb,
+0x7e,0xf, 0x2a,0x4a,0x12,0x44,0xc1,0x7d,0xe3,0x2e,0xe4,0x0, 0x20,0x7a,0xe7,0x2a,
+0x46,0x74,0x6, 0x2f,0x66,0x14,0x78,0xfb,0x7e,0xf, 0x2a,0x4e,0x7f,0x16,0x12,0x44,
+0xc1,0x2e,0x34,0x0, 0x20,0x7a,0x37,0x2a,0x48,0x7e,0x51,0x29,0x74,0x7, 0xac,0x5b,
+0x7d,0x12,0x2d,0x1f,0x59,0xe1,0x0, 0x50,0x2d,0x2f,0x59,0x32,0x0, 0x52,0xda,0x79,
+0x22,0xca,0x79,0x75,0x18,0x0, 0x75,0x9, 0x0, 0x12,0x34,0x6a,0x12,0x3c,0x8a,0x12,
+0x4f,0x74,0x7e,0x34,0x24,0xcd,0x12,0x4e,0xa3,0xe4,0x7a,0xb3,0x2c,0x50,0x53,0xdb,
+0xf0,0x12,0x39,0x43,0x74,0x21,0x7a,0xb3,0x1f,0x3d,0x12,0x3e,0x7c,0x7e,0x34,0x25,
+0xa3,0x12,0x2c,0xb, 0x12,0x59,0x57,0x12,0x58,0xea,0x7e,0x34,0x3, 0xe8,0x7a,0x37,
+0x21,0x3a,0x12,0x28,0xc1,0x12,0x57,0xa2,0x7e,0x34,0x0, 0x8e,0x12,0x52,0x16,0x53,
+0xea,0xf8,0x43,0xea,0x5, 0x12,0x3f,0x62,0x12,0x54,0x6f,0x7e,0x34,0x0, 0x64,0x12,
+0x58,0xf6,0x7e,0x34,0x1e,0xad,0x7e,0x24,0x0, 0x8e,0x12,0x4c,0xe4,0x74,0x1, 0x7a,
+0xb3,0x1f,0x3b,0x7e,0x73,0x21,0x39,0x7a,0x73,0x1f,0x3c,0x74,0x1, 0x7a,0xb3,0x2c,
+0x30,0x12,0x0, 0x46,0x7e,0xb3,0x2c,0x30,0xb4,0x1, 0x2, 0x80,0x3, 0x2, 0x1a,0xf3,
+0x53,0xdb,0x7f,0x7e,0x34,0x0, 0x64,0x12,0x58,0xf6,0x7e,0xb3,0x2c,0x14,0xf5,0x10,
+0x12,0x40,0x47,0x75,0x12,0x0, 0x75,0x11,0x0, 0x7e,0xb3,0x2c,0x2e,0x60,0x3, 0x2, 
+0x19,0x5b,0x7e,0xb3,0x20,0x45,0xf5,0x19,0x2, 0x19,0x61,0x7e,0xb3,0x20,0x47,0xf5,
+0x19,0x7e,0xb3,0x2c,0x29,0xbe,0xb0,0xff,0x78,0x3, 0x2, 0x19,0x76,0x12,0x53,0x14,
+0x74,0xff,0x7a,0xb3,0x2c,0x29,0x12,0x59,0x2c,0x60,0xfb,0x12,0x58,0xea,0x7e,0x34,
+0x1e,0xad,0x7e,0x24,0x0, 0x8e,0x12,0x46,0xa1,0x7e,0xb3,0x20,0x4b,0xb4,0x1, 0x2, 
+0x80,0x3, 0x2, 0x19,0x99,0xe4,0x12,0x59,0x40,0x12,0x0, 0x1e,0x7e,0x34,0x0, 0x8e,
+0x7e,0x24,0x1e,0xad,0x7e,0x14,0x0, 0x6a,0x7e,0x4, 0x1f,0x7e,0x12,0x13,0x81,0x12,
+0x4c,0x6c,0xf5,0x8, 0xe5,0x18,0xbe,0xb0,0xa, 0x40,0x3, 0x2, 0x19,0xc3,0x5, 0x18,
+0x2, 0x19,0xd0,0xe5,0x18,0xbe,0xb0,0xa, 0x50,0x3, 0x2, 0x19,0xd0,0x12,0x10,0xda,
+0x7e,0x37,0x2b,0xf2,0x4d,0x33,0x68,0x3, 0x2, 0x1a,0x5, 0x7e,0x37,0x2b,0xec,0x7a,
+0x37,0x27,0x8f,0x7e,0x34,0x0, 0x8e,0x7e,0x24,0x1f,0x7e,0x7e,0x14,0x27,0x88,0x12,
+0x4b,0x67,0x7e,0x34,0x0, 0x8e,0x7e,0x24,0x1e,0xad,0x7e,0x14,0x1f,0x7e,0x7e,0x4, 
+0x27,0x88,0x12,0x1a,0xfe,0x74,0x3, 0x12,0x38,0x22,0x12,0x21,0x45,0x12,0x3a,0x60,
+0x12,0x53,0xcc,0x7e,0x34,0x0, 0x64,0x12,0x58,0xf6,0x7e,0x34,0x0, 0x8e,0x7e,0x24,
+0x21,0x3d,0x7e,0x14,0x27,0x92,0x12,0x31,0xcd,0x7e,0x73,0x27,0x7f,0xbe,0x70,0x0, 
+0x38,0x3, 0x2, 0x1a,0x48,0x6d,0x77,0x7e,0x34,0x0, 0x8e,0x7e,0x24,0x21,0x3d,0x7e,
+0x14,0x1f,0x7e,0x7d,0x7, 0x12,0x25,0x2a,0x7e,0x34,0x0, 0x8e,0x12,0x53,0x90,0x7e,
+0x34,0x0, 0x8e,0x12,0x51,0x92,0x7e,0x34,0x1f,0x7e,0x12,0x57,0x2, 0x7e,0x37,0x2b,
+0xf2,0xbe,0x34,0x0, 0x1, 0x68,0x3, 0x2, 0x1a,0x6f,0x6d,0x33,0x7a,0x35,0x54,0xe5,
+0xa, 0xb4,0x5, 0x2, 0x80,0x3, 0x2, 0x1a,0x88,0x7e,0x34,0x1f,0x7e,0x7e,0x24,0x1e,
+0xad,0x7e,0x14,0x0, 0x8e,0x12,0x2d,0x99,0x7e,0x73,0x27,0x7f,0x7a,0x73,0x0, 0x82,
+0xbe,0x70,0x0, 0x38,0x3, 0x2, 0x1a,0xa2,0x7e,0x73,0x1f,0x7f,0x1e,0x70,0x7a,0x73,
+0x0, 0x83,0xe5,0x51,0x60,0x3, 0x2, 0x1a,0xac,0x12,0x50,0x37,0xe5,0x51,0xb4,0x1, 
+0x2, 0x80,0x3, 0x2, 0x1a,0xb9,0x12,0x4d,0x5c,0x7e,0x34,0x27,0x92,0x12,0x53,0x52,
+0xbe,0x34,0x0, 0x1, 0x68,0x3, 0x2, 0x1a,0xd8,0x7e,0x34,0x1e,0xad,0x7e,0x24,0x0, 
+0x8e,0x7e,0xb3,0x27,0x7f,0x12,0x49,0x31,0x12,0x27,0x2, 0x7e,0xb3,0x27,0x83,0x54,
+0xef,0x7a,0xb3,0x27,0x83,0x7e,0x73,0x27,0x7f,0x7a,0x73,0x27,0x80,0x12,0x36,0xf3,
+0x2, 0x19,0x24,0x12,0x59,0x2c,0x60,0xfb,0x12,0x0, 0x61,0xda,0x79,0x22,0xca,0x3b,
+0x7d,0x81,0x7d,0x42,0x7d,0x13,0x6c,0x44,0x7e,0x49,0xb0,0xf5,0x22,0x9, 0xb4,0x0, 
+0x1, 0xf5,0x23,0x7d,0x41,0x2e,0x44,0xd, 0x80,0x9, 0xe8,0x0, 0x96,0x7a,0xe1,0x24,
+0x6d,0xff,0x7d,0x9f,0x7e,0xd0,0x8, 0xac,0xde,0x7c,0xfd,0xbe,0xe0,0x5, 0x40,0x3, 
+0x2, 0x1b,0x36,0x7e,0xf0,0x28,0x7d,0x3f,0x2, 0x1b,0xa0,0x7e,0xf4,0x0, 0x24,0xad,
+0xf3,0x6c,0xaa,0x2, 0x1b,0x98,0xa, 0xea,0x2d,0xef,0x3e,0xe4,0x2d,0xe4,0xb, 0xe8,
+0xe0,0xbe,0xe4,0x0, 0x0, 0x58,0x3, 0x2, 0x1b,0x96,0x90,0x3d,0xd2,0xe4,0x93,0xa, 
+0xdb,0xbd,0xde,0x40,0x3, 0x2, 0x1b,0x96,0x90,0x3d,0xd3,0xe4,0x93,0xa, 0xdb,0xbd,
+0xde,0x38,0x3, 0x2, 0x1b,0x96,0xb, 0x94,0xa, 0xdf,0xbd,0xd9,0x40,0x3, 0x2, 0x1b,
+0x93,0x7e,0x40,0x1, 0xe5,0x69,0xbe,0xb0,0x3, 0x40,0x3, 0x2, 0x1b,0x9e,0x5, 0x69,
+0x2, 0x1b,0x9e,0x75,0x69,0x0, 0xb, 0xa0,0xe5,0x23,0xbc,0xba,0x38,0xa8,0xb, 0x34,
+0xe5,0x22,0xa, 0xeb,0xbd,0xe3,0x38,0x93,0xe5,0x69,0xb4,0x3, 0x2, 0x80,0x3, 0x2, 
+0x1b,0xbb,0x75,0x69,0x0, 0x74,0x1, 0x19,0xb0,0x0, 0x9, 0xbe,0x40,0x1, 0x78,0x3, 
+0x2, 0x1b,0xcf,0x9, 0xb0,0x0, 0x9, 0xb4,0x1, 0x2, 0x80,0x3, 0x2, 0x1d,0x4b,0x6d,
+0x99,0x6d,0x33,0x2, 0x1c,0x6, 0x7d,0x43,0x3e,0x44,0x2d,0x48,0x7e,0x49,0x40,0x1e,
+0x40,0x9, 0x94,0x0, 0x1, 0x1e,0x90,0x7e,0xd0,0x48,0xac,0xd4,0x7e,0xf0,0x2, 0xac,
+0xf9,0x7d,0xe7,0x2d,0xe6,0x2d,0xe1,0x49,0xfe,0xd, 0x80,0xbd,0xf9,0x38,0x3, 0x2, 
+0x1c,0x4, 0x7d,0x9f,0xb, 0x34,0xe5,0x24,0xa, 0xfb,0xbd,0xf3,0x38,0xc8,0x6c,0x55,
+0x6d,0x33,0x2, 0x1d,0x16,0x7d,0xe3,0x3e,0xe4,0x7d,0xfe,0x2d,0xf8,0x7e,0xf9,0x40,
+0x1e,0x40,0x9, 0x9f,0x0, 0x1, 0x1e,0x90,0x7e,0xd0,0x48,0xac,0xd4,0x7e,0xf0,0x2, 
+0xac,0xf9,0x7d,0xf7,0x2d,0xf6,0x2d,0xf1,0x49,0x9f,0xd, 0x80,0x6d,0xff,0xbe,0x40,
+0x0, 0x38,0x3, 0x2, 0x1c,0xf2,0xe5,0x22,0xa, 0xcb,0x1b,0xc4,0xa, 0xd4,0xbd,0xdc,
+0x48,0x3, 0x2, 0x1c,0xf2,0xbe,0x90,0x0, 0x38,0x3, 0x2, 0x1c,0xf2,0xe5,0x23,0xa, 
+0xcb,0x1b,0xc4,0xa, 0xd9,0xbd,0xdc,0x48,0x3, 0x2, 0x1c,0xf2,0xa, 0x54,0x1b,0x54,
+0x7c,0xab,0x2, 0x1c,0xc2,0xa, 0xd9,0x1b,0xd4,0x7d,0x7d,0x7c,0xbf,0xf5,0x21,0x2, 
+0x1c,0xb4,0xbc,0x4a,0x68,0x3, 0x2, 0x1c,0x91,0xbe,0x91,0x21,0x78,0x3, 0x2, 0x1c,
+0xb2,0x7e,0xd0,0x48,0xac,0xda,0x7e,0xf1,0x21,0x74,0x2, 0xac,0xfb,0x7d,0xc7,0x2d,
+0xc6,0x2d,0xc1,0x49,0xdc,0xd, 0x80,0xbe,0xd4,0x0, 0x0, 0x18,0x3, 0x2, 0x1c,0xb2,
+0x2d,0xfd,0x5, 0x21,0xa, 0xc9,0xb, 0xc4,0xe5,0x21,0xa, 0xdb,0xbd,0xdc,0x8, 0xc2,
+0xb, 0xa0,0xa, 0xc4,0xb, 0xc4,0xa, 0xda,0xbd,0xdc,0x8, 0xa9,0x9, 0xb0,0x0, 0x3, 
+0xa, 0xdb,0xad,0xd9,0xbd,0xdf,0x38,0x3, 0x2, 0x1d,0x14,0x7e,0xd7,0x2c,0x4a,0xbe,
+0xd4,0x0, 0x0, 0x38,0x3, 0x2, 0x1d,0x14,0xbd,0xd9,0x28,0x3, 0x2, 0x1d,0x14,0x2, 
+0x1c,0xf6,0x7d,0xe3,0x3e,0xe4,0x2d,0xe8,0x7e,0xe9,0x80,0x7e,0xf0,0x2, 0xac,0xf5,
+0x19,0x87,0x2a,0x33,0x7d,0xe3,0x3e,0xe4,0x2d,0xe8,0x9, 0xbe,0x0, 0x1, 0x19,0xb7,
+0x2a,0x34,0xb, 0x50,0xb, 0x34,0xe5,0x24,0xa, 0xeb,0xbd,0xe3,0x28,0x3, 0x2, 0x1c,
+0x15,0x6d,0x33,0x2, 0x1d,0x41,0x7d,0x93,0x3e,0x94,0x9, 0x49,0x2a,0x33,0x7d,0x19,
+0x2d,0x18,0x7a,0x19,0x40,0x9, 0x49,0x2a,0x34,0x2d,0x98,0x19,0x49,0x0, 0x1, 0xb, 
+0x34,0xa, 0x95,0xbd,0x93,0x38,0xdf,0x19,0x58,0x0, 0x96,0xda,0x3b,0x22,0xc0,0x0, 
+0xc0,0x3f,0xdf,0xbf,0xdf,0xbf,0xc0,0x1, 0xc0,0x82,0xc1,0x2, 0xc1,0x1, 0xc0,0x3f,
+0xdf,0x3d,0xde,0x3c,0xde,0xbe,0xc0,0x2, 0xc1,0x85,0xc2,0x85,0xc2,0x2, 0xc0,0x3e,
+0xde,0x3a,0xdd,0x3a,0xdd,0xbd,0xc0,0x3, 0xc2,0x87,0xc4,0x7, 0xc3,0x3, 0xc0,0x3d,
+0xdd,0x38,0xdb,0xb7,0xdc,0xbc,0xc0,0x4, 0xc3,0x8a,0xc5,0x8a,0xc4,0x4, 0xc0,0x3c,
+0xdc,0x35,0xda,0x35,0xdb,0xbb,0xc0,0x5, 0xc4,0x8c,0xc6,0x8d,0xc5,0x5, 0xc0,0x3b,
+0xdb,0x32,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8e,0xc5,0x86,0xc0,0x3a,
+0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,0xc7,0x8d,0xc5,0x5, 0xc0,0x3b,
+0xdb,0x34,0xd9,0xb4,0xdb,0xbb,0xc0,0x5, 0xc4,0x8b,0xc6,0xb, 0xc4,0x4, 0xc0,0x3c,
+0xdc,0x36,0xdb,0x36,0xdc,0xbc,0xc0,0x4, 0xc3,0x89,0xc4,0x88,0xc3,0x3, 0xc0,0x3d,
+0xdd,0x39,0xdc,0x39,0xdd,0xbd,0xc0,0x3, 0xc2,0x86,0xc3,0x6, 0xc2,0x2, 0xc0,0x3e,
+0xde,0x3b,0xdd,0xbc,0xde,0xbe,0xc0,0x2, 0xc1,0x83,0xc1,0x83,0xc1,0x1, 0xc0,0x3f,
+0xdf,0x3e,0xdf,0x3e,0xdf,0xbf,0xc0,0x0, 0xc0,0x81,0xc0,0x80,0xc0,0x0, 0xca,0x3b,
+0x7d,0x73,0x6d,0x0, 0x7e,0xb3,0x25,0x4f,0xf5,0x23,0x70,0x29,0xf5,0x21,0x6d,0x33,
+0xe5,0x21,0x1a,0x1b,0x7d,0x21,0x3e,0x24,0x59,0x32,0x28,0xa2,0x74,0xff,0x7e,0x34,
+0x0, 0x7, 0xad,0x31,0x19,0xb3,0x28,0x60,0x74,0x2, 0x19,0xb1,0x28,0xb6,0x5, 0x21,
+0xe5,0x21,0xb4,0xa, 0xd9,0x75,0x21,0x0, 0x2, 0x21,0x21,0xe5,0x21,0x1a,0x2b,0x7e,
+0x34,0x0, 0x7, 0xad,0x32,0x9, 0x53,0x24,0xd1,0xbe,0x50,0xff,0x78,0x3, 0x2, 0x21,
+0x1f,0xa, 0x25,0x9, 0xb2,0x25,0x13,0x60,0x8, 0xb4,0x2, 0x2, 0x80,0x3, 0x2, 0x21,
+0x1f,0x75,0x22,0x0, 0x7e,0x31,0x22,0x74,0x7, 0xac,0x3b,0x9, 0xa1,0x28,0x60,0xe5,
+0x21,0x1a,0x2b,0x7e,0x34,0x0, 0x7, 0xad,0x32,0x9, 0x53,0x24,0xd1,0xbc,0x5a,0x68,
+0x3, 0x2, 0x21,0x13,0x49,0x21,0x28,0x5e,0x49,0x33,0x24,0xcf,0x9d,0x32,0x12,0x58,
+0x85,0x7d,0x63,0x7e,0xa1,0x22,0x74,0x7, 0xa4,0x49,0x25,0x28,0x5c,0xe5,0x21,0x1a,
+0xb, 0x7e,0x14,0x0, 0x7, 0xad,0x10,0x49,0x31,0x24,0xcd,0x9d,0x32,0x12,0x58,0x85,
+0x7d,0x3, 0x2d,0x6, 0x7e,0x91,0x22,0x74,0x7, 0xac,0x9b,0x9, 0xa4,0x28,0x60,0xa, 
+0x1a,0x9, 0x71,0x28,0xb6,0xbe,0x70,0x0, 0x28,0x16,0x7e,0x50,0x2, 0xac,0x5a,0x59,
+0x2, 0x28,0xa2,0x2e,0x14,0x28,0xb6,0x7c,0xb7,0x14,0x7a,0x19,0xb0,0x2, 0x21,0x1f,
+0x74,0x2, 0xa4,0x49,0x15,0x28,0xa2,0xbe,0x14,0x0, 0x64,0x28,0x9, 0xbe,0x4, 0x0, 
+0x64,0x28,0x3, 0x2, 0x21,0xd, 0x7d,0x31,0x2e,0x34,0x0, 0x32,0xbd,0x30,0x50,0x9, 
+0xbe,0x14,0x0, 0x32,0x28,0x3, 0x2, 0x21,0xd, 0x3e,0x14,0x3e,0x14,0x3e,0x14,0x3e,
+0x14,0xbd,0x10,0x28,0x3, 0x2, 0x21,0xd, 0x49,0x17,0x0, 0x5, 0xbd,0x10,0x40,0x3, 
+0x2, 0x21,0x0, 0xe5,0x21,0x1a,0x2b,0x7e,0x34,0x0, 0x7, 0xad,0x32,0x9, 0x53,0x24,
+0xd1,0xa, 0x15,0x9, 0xb1,0x25,0x13,0x70,0x4, 0x74,0x3, 0x80,0x2, 0x74,0x1, 0x19,
+0xb1,0x25,0x13,0x7e,0xa0,0x3, 0xe5,0x21,0x1a,0x2b,0x7e,0x34,0x0, 0x7, 0xad,0x32,
+0x9, 0xb3,0x24,0xd1,0xa, 0x1b,0x19,0xa1,0x25,0x1d,0xe5,0x21,0x1a,0x2b,0x7e,0x34,
+0x0, 0x7, 0xad,0x32,0x2e,0x34,0x24,0xcd,0x7e,0x14,0x2a,0x33,0x74,0x7, 0x12,0x45,
+0x12,0xe5,0x23,0xbe,0xb0,0x0, 0x28,0x38,0x15,0x23,0x7e,0x71,0x23,0x74,0x7, 0xac,
+0x7b,0x2e,0x34,0x24,0xcd,0xe5,0x21,0x1a,0x4b,0x7e,0x54,0x0, 0x7, 0xad,0x54,0x7d,
+0x15,0x2e,0x14,0x24,0xcd,0x74,0x7, 0x12,0x45,0x12,0x7e,0x34,0x2a,0x33,0x7e,0x31,
+0x23,0x74,0x7, 0xac,0x3b,0x2e,0x14,0x24,0xcd,0x74,0x7, 0x12,0x45,0x12,0x15,0x21,
+0x7e,0xa1,0x22,0x74,0x7, 0xa4,0x9, 0xa5,0x28,0x60,0x74,0x2, 0xa4,0x59,0x5, 0x28,
+0xa2,0x80,0xc, 0x5, 0x22,0xe5,0x22,0xbe,0xb0,0xa, 0x50,0x3, 0x2, 0x1f,0xb4,0x5, 
+0x21,0x7e,0x73,0x25,0x4f,0xbe,0x71,0x21,0x28,0x3, 0x2, 0x1f,0x8b,0xe5,0x23,0x7a,
+0xb3,0x25,0x4f,0x7e,0x24,0x24,0xcd,0x7e,0x34,0x28,0x5c,0x7e,0x14,0x0, 0x46,0x12,
+0x58,0x16,0xda,0x3b,0x22,0xca,0x3b,0x6d,0x33,0x7a,0x37,0x2a,0x33,0x75,0x23,0x0, 
+0x75,0x24,0x0, 0x7e,0x34,0xe, 0xe, 0x7a,0x35,0x2b,0x7e,0x73,0x20,0x14,0x7a,0x71,
+0x21,0xa, 0x17,0x3e,0x14,0x7e,0x24,0x1f,0x7e,0x7e,0x34,0x2a,0x35,0x12,0x58,0x16,
+0xe5,0x21,0xbe,0xb0,0xa, 0x38,0x3, 0x2, 0x22,0xf7,0x75,0x22,0x0, 0x6c,0xff,0x2, 
+0x22,0x2a,0x7e,0x34,0x3, 0xff,0x7a,0x35,0x25,0x75,0x24,0x0, 0x6c,0xee,0x80,0x4c,
+0x74,0x2, 0xac,0xbe,0x9, 0x75,0x2a,0x36,0xa, 0x27,0x74,0x2, 0xac,0xbf,0x9, 0x75,
+0x29,0x12,0xa, 0x37,0x9d,0x32,0x12,0x58,0x85,0x7d,0x63,0x74,0x2, 0xac,0xbe,0x9, 
+0x75,0x2a,0x35,0xa, 0x27,0x74,0x2, 0xac,0xbf,0x9, 0x75,0x29,0x11,0xa, 0x37,0x9d,
+0x32,0x12,0x58,0x85,0x2d,0x36,0x7a,0x35,0x27,0x7e,0x35,0x25,0xbe,0x35,0x27,0x28,
+0x9, 0x7e,0x35,0x27,0x7a,0x35,0x25,0x7a,0xe1,0x24,0xb, 0xe0,0xe5,0x21,0xbc,0xbe,
+0x38,0xae,0x7e,0x71,0x24,0x74,0x2, 0xac,0x7b,0x9, 0xa3,0x2a,0x36,0x7c,0xba,0x1e,
+0xb0,0x7e,0x90,0x2, 0xac,0x9b,0x9, 0x33,0x2a,0x35,0x7c,0x43,0x1e,0x40,0x7e,0x50,
+0x48,0xac,0x45,0x2d,0x24,0x49,0x22,0xe, 0xe, 0x7a,0x25,0x29,0xbe,0x24,0x0, 0x50,
+0x48,0x16,0xe5,0x22,0x1a,0x2b,0x3e,0x24,0x19,0x32,0x2a,0x85,0x19,0xa2,0x2a,0x86,
+0x74,0xff,0x19,0xb3,0x2a,0x35,0x5, 0x22,0xb, 0xf0,0xe5,0x63,0xbc,0xbf,0x28,0x3, 
+0x2, 0x21,0x82,0x7e,0xf1,0x22,0x2, 0x22,0xdd,0x6d,0x33,0x7a,0x37,0x2a,0x33,0x7e,
+0xa0,0xff,0x6c,0xee,0x80,0x6c,0x7e,0x90,0x2, 0xac,0x9e,0x9, 0x44,0x2a,0x35,0xbe,
+0x40,0xff,0x68,0x5c,0x1e,0x40,0x7e,0x50,0x24,0xac,0x45,0x9, 0xb4,0x2a,0x36,0x1e,
+0xb0,0xa, 0x3b,0x2d,0x23,0x3e,0x24,0x2e,0x25,0x2b,0xb, 0x28,0x30,0xbe,0x34,0x0, 
+0x0, 0x58,0x5, 0x6d,0x33,0x1b,0x28,0x30,0x7e,0x50,0x2, 0xac,0x5e,0x9, 0x62,0x2a,
+0x35,0x7c,0x76,0x1e,0x70,0x7e,0x30,0x24,0xac,0x37,0x9, 0x72,0x2a,0x36,0x7c,0xb7,
+0x1e,0xb0,0xa, 0xb, 0x2d,0x10,0x3e,0x14,0x2e,0x15,0x2b,0xb, 0x18,0x40,0xbe,0x47,
+0x2a,0x33,0x48,0xc, 0x7a,0x61,0x23,0x7a,0x71,0x24,0x7a,0x47,0x2a,0x33,0x7c,0xae,
+0xb, 0xe0,0xe5,0x21,0xbc,0xbe,0x38,0x8e,0xbe,0xa0,0xff,0x68,0x1e,0x7e,0x71,0x23,
+0x7e,0x90,0x2, 0xac,0x9f,0x19,0x74,0x2a,0x85,0xe5,0x24,0x19,0xb4,0x2a,0x86,0x7e,
+0x70,0xff,0x7e,0x50,0x2, 0xac,0x5a,0x19,0x72,0x2a,0x35,0xb, 0xf0,0xbe,0xf0,0xa, 
+0x50,0x3, 0x2, 0x22,0x39,0x7e,0x24,0x2a,0x85,0x7e,0x34,0x2a,0x35,0x7e,0x14,0x0, 
+0x14,0x12,0x58,0x16,0x75,0x21,0xa, 0x7e,0x34,0x29,0x11,0x7e,0x24,0x0, 0x14,0x74,
+0xff,0x12,0x58,0x95,0xe5,0x21,0xbe,0xb0,0x0, 0x28,0x22,0xe5,0x21,0xa, 0x1b,0x3e,
+0x14,0x7e,0x24,0x2a,0x35,0x7e,0x34,0x1f,0x7e,0x12,0x58,0x16,0xe5,0x21,0xa, 0x1b,
+0x3e,0x14,0x7e,0x24,0x2a,0x35,0x7e,0x34,0x29,0x11,0x12,0x58,0x16,0x85,0x21,0x63,
+0xe5,0x21,0x7a,0xb3,0x20,0x14,0xda,0x3b,0x22,0xca,0x3b,0x7c,0xcb,0x4c,0xcc,0x78,
+0x47,0x7e,0x74,0x2b,0x61,0x7a,0x79,0x70,0x5e,0x70,0x70,0x7c,0xb7,0xc4,0x54,0xf, 
+0x7c,0x7b,0x4c,0x77,0x68,0x4, 0xa5,0xbf,0x1, 0x15,0x7e,0xb3,0x2c,0x30,0xb4,0x3, 
+0x7, 0x74,0x1, 0x7e,0x70,0x1, 0x80,0x54,0x74,0x27,0x7e,0x70,0x1, 0x80,0x13,0x7e,
+0xb3,0x2c,0x30,0xb4,0x3, 0x7, 0x74,0x1, 0x7e,0x70,0x3, 0x80,0x3f,0x74,0x27,0x7e,
+0x70,0x3, 0x12,0x54,0xf5,0x2, 0x25,0x27,0xbe,0xc0,0x1, 0x78,0x13,0x7a,0x73,0x2b,
+0x5e,0x74,0x48,0xac,0x7b,0x2e,0x37,0x2b,0x67,0x7a,0x37,0x2b,0x5c,0x2, 0x25,0x27,
+0xbe,0xc0,0x2, 0x78,0x1d,0xa5,0xbf,0x4, 0x7, 0x74,0x1, 0x7e,0x70,0x4, 0x80,0xc, 
+0xa5,0xbf,0x5, 0x2, 0x80,0x3, 0x2, 0x25,0x27,0xe4,0x6c,0x77,0x12,0x50,0x80,0x2, 
+0x25,0x27,0xbe,0xc0,0x3, 0x78,0x7, 0x7a,0x73,0x20,0x4d,0x2, 0x25,0x27,0xbe,0xc0,
+0x4, 0x78,0x7, 0x7a,0x73,0x20,0x4e,0x2, 0x25,0x27,0xbe,0xc0,0x5, 0x78,0x7, 0x7a,
+0x73,0x20,0x4f,0x2, 0x25,0x27,0xbe,0xc0,0x6, 0x78,0x7, 0x7a,0x73,0x20,0x50,0x2, 
+0x25,0x27,0xbe,0xc0,0x7, 0x78,0x7, 0x7a,0x73,0x20,0x51,0x2, 0x25,0x27,0xbe,0xc0,
+0x8, 0x78,0x6, 0x7e,0x74,0x20,0x52,0x80,0x40,0xbe,0xc0,0x9, 0x78,0x6, 0x7e,0x74,
+0x20,0x52,0x80,0x44,0xbe,0xc0,0xa, 0x78,0x6, 0x7e,0x74,0x20,0x54,0x80,0x2a,0xbe,
+0xc0,0xb, 0x78,0x6, 0x7e,0x74,0x20,0x54,0x80,0x2e,0xbe,0xc0,0xc, 0x78,0x6, 0x7e,
+0x74,0x20,0x56,0x80,0x14,0xbe,0xc0,0xd, 0x78,0x6, 0x7e,0x74,0x20,0x56,0x80,0x18,
+0xbe,0xc0,0xe, 0x78,0xa, 0x7e,0x74,0x20,0x58,0x7a,0x79,0x70,0x2, 0x25,0x27,0xbe,
+0xc0,0xf, 0x78,0xb, 0x7e,0x74,0x20,0x58,0x19,0x77,0x0, 0x1, 0x2, 0x25,0x27,0xbe,
+0xc0,0x4c,0x78,0x7, 0x7a,0x73,0x20,0x5a,0x2, 0x25,0x27,0xbe,0xc0,0x4e,0x78,0x7, 
+0x7a,0x73,0x21,0x39,0x2, 0x25,0x27,0xbe,0xc0,0x4f,0x78,0x6, 0x12,0x57,0x70,0x2, 
+0x25,0x27,0x7e,0xb3,0x2b,0x61,0xc4,0x54,0xf, 0x7c,0x6b,0x5e,0x60,0x7, 0xa5,0xbe,
+0x4, 0x4, 0x6c,0xdd,0x80,0x10,0xa5,0xbe,0x6, 0x5, 0x7e,0xd0,0x1, 0x80,0x7, 0xa5,
+0xbe,0x7, 0x3, 0x7e,0xd0,0x2, 0xbe,0xc0,0x50,0x40,0x1e,0xbe,0xc0,0x63,0x38,0x19,
+0x7c,0xb7,0x7e,0x70,0x87,0x12,0x51,0xc, 0x7c,0xab,0x7e,0x50,0x14,0xac,0x5d,0xa, 
+0x3c,0x2d,0x32,0x19,0xa3,0x20,0xd, 0x80,0x5e,0xbe,0xc0,0x78,0x40,0x13,0xbe,0xc0,
+0x8b,0x38,0xe, 0x74,0x14,0xac,0xbd,0xa, 0x2c,0x2d,0x25,0x19,0x72,0x20,0x15,0x80,
+0x46,0xbe,0xc0,0xa0,0x40,0x13,0xbe,0xc0,0xb3,0x38,0xe, 0x74,0x14,0xac,0xbd,0xa, 
+0x2c,0x2d,0x25,0x19,0x72,0x20,0x1d,0x80,0x2e,0xbe,0xc0,0xbf,0x40,0x13,0xbe,0xc0,
+0xd2,0x38,0xe, 0x74,0x14,0xac,0xbd,0xa, 0x2c,0x2d,0x25,0x19,0x72,0x20,0x22,0x80,
+0x16,0xbe,0xc0,0xd3,0x40,0x11,0xbe,0xc0,0xe6,0x38,0xc, 0x74,0x14,0xac,0xbd,0xa, 
+0x2c,0x2d,0x25,0x19,0x72,0x20,0x3e,0xda,0x3b,0x22,0xca,0x3b,0x7d,0x60,0x6d,0x0, 
+0x7a,0x7, 0x2a,0x33,0x75,0x21,0x0, 0x7a,0x37,0x2a,0x35,0x2e,0x34,0xd, 0x80,0x7a,
+0x37,0x2a,0x37,0x7a,0x27,0x2a,0x39,0x6d,0x0, 0x7a,0x7, 0x2a,0x3b,0x75,0x26,0x0, 
+0x75,0x27,0x0, 0x4d,0x66,0x68,0x3, 0x75,0x27,0x1, 0xe5,0x10,0xb4,0x1, 0xe, 0x7e,
+0xb3,0x0, 0x85,0x70,0x3, 0x2, 0x26,0xff,0xe4,0x7a,0xb3,0x0, 0x85,0x7e,0x19,0xb0,
+0x1e,0xb0,0xf5,0x25,0x9, 0xb1,0x0, 0x1, 0x1e,0xb0,0xf5,0x24,0xe5,0x10,0xb4,0x1, 
+0x2a,0xe5,0x27,0xb4,0x1, 0x25,0x75,0x21,0x0, 0x80,0x17,0x7e,0x71,0x21,0x74,0x2, 
+0xac,0x7b,0x2d,0x36,0xb, 0x38,0x30,0xbe,0x34,0x7f,0xff,0x78,0x3, 0x2, 0x26,0xff,
+0x5, 0x21,0x7e,0x73,0x2b,0xcd,0xbe,0x71,0x21,0x38,0xe0,0xe5,0x10,0xb4,0x1, 0x13,
+0xe5,0x27,0xb4,0x1, 0xe, 0x7e,0x71,0x25,0x74,0x2, 0xac,0x7b,0x2d,0x36,0xb, 0x38,
+0x30,0x80,0x4f,0x7e,0xf1,0x25,0x74,0x24,0xac,0xfb,0xe5,0x24,0xa, 0x2b,0x2d,0x72,
+0x7e,0x63,0x2b,0xce,0x7e,0x71,0x25,0xac,0x76,0x2d,0x32,0x7a,0x35,0x22,0x7e,0x37,
+0x2a,0x39,0x2e,0x35,0x22,0x7e,0x39,0x70,0xa, 0x37,0x7a,0x37,0x2a,0x3b,0x3e,0x34,
+0x3e,0x34,0x3e,0x34,0x7a,0x37,0x2a,0x3b,0x7d,0x37,0x3e,0x34,0x7d,0x23,0x2e,0x27,
+0x2a,0x37,0xb, 0x28,0x20,0x2e,0x37,0x2a,0x35,0xb, 0x38,0x30,0x2d,0x32,0x2e,0x37,
+0x2a,0x3b,0x7a,0x37,0x2a,0x3d,0x7e,0x37,0x2a,0x3d,0x12,0x58,0x85,0x7a,0x37,0x2a,
+0x3d,0x7e,0xa3,0x2b,0xf6,0x7e,0xf0,0x24,0xac,0xfa,0xe5,0x24,0xa, 0x3b,0x2d,0x73,
+0x7a,0xa1,0x21,0x2, 0x26,0xbf,0xe5,0x21,0xbe,0xb1,0x25,0x78,0x3, 0x2, 0x26,0xb9,
+0xe5,0x10,0xb4,0x1, 0x13,0xe5,0x27,0xb4,0x1, 0xe, 0x7e,0x71,0x21,0x74,0x2, 0xac,
+0x7b,0x2d,0x36,0xb, 0x38,0x30,0x80,0x46,0x7e,0x63,0x2b,0xce,0x7e,0x71,0x21,0xac,
+0x76,0xe5,0x24,0xa, 0x2b,0x2d,0x32,0x7a,0x35,0x22,0x7e,0x37,0x2a,0x39,0x2e,0x35,
+0x22,0x7e,0x39,0x70,0xa, 0x37,0x7a,0x37,0x2a,0x3b,0x3e,0x34,0x3e,0x34,0x3e,0x34,
+0x7a,0x37,0x2a,0x3b,0x7d,0x37,0x3e,0x34,0x7d,0x23,0x2e,0x27,0x2a,0x37,0xb, 0x28,
+0x20,0x2e,0x37,0x2a,0x35,0xb, 0x38,0x30,0x2d,0x32,0x2e,0x37,0x2a,0x3b,0x7a,0x37,
+0x2a,0x33,0x7e,0x37,0x2a,0x33,0x12,0x58,0x85,0x7e,0x53,0x2b,0xd5,0xa, 0x25,0x2d,
+0x32,0xbe,0x37,0x2a,0x3d,0x58,0x2, 0x5, 0x26,0x2e,0x74,0x0, 0x24,0x5, 0x21,0x7e,
+0x73,0x2b,0xf7,0xbe,0x71,0x21,0x28,0x3, 0x2, 0x26,0x36,0x7e,0x73,0x2b,0xcd,0x1e,
+0x70,0xa, 0x27,0xe5,0x26,0xa, 0x3b,0xbd,0x32,0x28,0x6, 0x7e,0x34,0x0, 0x1, 0x80,
+0x14,0x7e,0x37,0x2c,0x7, 0x7d,0x23,0xb, 0x24,0x7a,0x27,0x2c,0x7, 0xbe,0x34,0x0, 
+0xa, 0x28,0xc, 0x6d,0x33,0x7a,0x37,0x2c,0x2, 0x6d,0x33,0x7a,0x37,0x2c,0x7, 0xda,
+0x3b,0x22,0xca,0x3b,0x6c,0xaa,0x7e,0x37,0x27,0x84,0x7a,0x37,0x2a,0x33,0x7e,0xb3,
+0x27,0x83,0x20,0xe0,0x9, 0x20,0xe2,0x6, 0x20,0xe1,0x3, 0x2, 0x28,0xba,0x20,0x0, 
+0x6, 0x7e,0x74,0x2a,0xd5,0x80,0x4, 0x7e,0x74,0x2b,0x17,0x6c,0xdd,0x74,0xff,0xa, 
+0x3d,0x2d,0x37,0x7a,0x39,0xb0,0xb, 0xd0,0xbe,0xd0,0x42,0x78,0xf2,0x74,0xaa,0x7a,
+0x79,0xb0,0x74,0xaa,0x19,0xb7,0x0, 0x1, 0x74,0x42,0x19,0xb7,0x0, 0x2, 0x7e,0xb3,
+0x27,0x7d,0x19,0xb7,0x0, 0x4, 0x6c,0x77,0x6c,0xdd,0x2, 0x28,0x5b,0x7e,0x90,0x7, 
+0xac,0x9d,0x9, 0x64,0x26,0xf5,0x7c,0xb6,0x54,0xf0,0xbe,0xb0,0x0, 0x28,0x2e,0xb4,
+0xb0,0x2, 0x80,0x3, 0x2, 0x28,0x59,0x2e,0x44,0x26,0xf5,0x7c,0xb6,0x54,0xf, 0x7a,
+0x49,0xb0,0x7e,0x50,0x7, 0xac,0x5d,0x9, 0x62,0x26,0xf5,0xa, 0x26,0x2e,0x27,0x2a,
+0x33,0x9, 0xb2,0x0, 0x46,0xb4,0x1, 0x2, 0x80,0x3, 0x2, 0x28,0x59,0x7e,0x30,0x7, 
+0xac,0x3d,0x9, 0xc1,0x26,0xf5,0xa, 0x4c,0x2e,0x47,0x2a,0x33,0x9, 0xb4,0x0, 0x46,
+0xbe,0xb0,0x3, 0x78,0x3, 0x2, 0x28,0x59,0x7e,0x10,0x6, 0xac,0x17,0x7c,0x61,0x49,
+0x21,0x26,0xf3,0xa, 0x4, 0x5e,0x4, 0x0, 0xf, 0x7c,0xb1,0xa, 0x6, 0x2d,0x7, 0x19,
+0xb0,0x0, 0x5, 0x7c,0xb5,0xa, 0x26,0x2d,0x27,0x19,0xb2,0x0, 0x6, 0x49,0x21,0x26,
+0xf1,0xa, 0x14,0x5e,0x14,0x0, 0xf, 0x7c,0xb3,0xa, 0x16,0x2d,0x17,0x19,0xb1,0x0, 
+0x7, 0x7c,0xb5,0xa, 0x16,0x2d,0x17,0x19,0xb1,0x0, 0x8, 0x7c,0xbc,0xc4,0x54,0xf0,
+0x7c,0x1b,0xa, 0x16,0x2d,0x17,0x2e,0x14,0x0, 0x7, 0x7e,0x19,0xb0,0x2c,0xb1,0x7a,
+0x19,0xb0,0x7e,0x30,0x7, 0xac,0x3d,0x9, 0xb1,0x26,0xf5,0xbe,0xb0,0xff,0x68,0x27,
+0x9, 0xb4,0x0, 0x46,0xbe,0xb0,0x1, 0x68,0x2, 0xb, 0xa0,0x9, 0x34,0x0, 0x46,0x7c,
+0xb3,0xc4,0x33,0x33,0x54,0xc0,0x7c,0x3b,0xa, 0x46,0x2d,0x47,0x2e,0x44,0x0, 0x5, 
+0x7e,0x49,0xb0,0x2c,0xb3,0x80,0xd, 0xa, 0x46,0x2d,0x47,0x2e,0x44,0x0, 0x5, 0x7e,
+0x49,0xb0,0x24,0xc0,0x7a,0x49,0xb0,0xb, 0x70,0xb, 0xd0,0x7e,0xb3,0x0, 0x87,0xbc,
+0xbd,0x28,0x3, 0x2, 0x27,0x5d,0x19,0xa7,0x0, 0x3, 0xe4,0x19,0xb7,0x0, 0x41,0x6c,
+0xdd,0xa, 0x3d,0x2d,0x37,0x7e,0x39,0x60,0x7d,0x27,0x2e,0x24,0x0, 0x41,0x7e,0x29,
+0x70,0x6c,0x76,0x7a,0x29,0x70,0xb, 0xd0,0xbe,0xd0,0x41,0x78,0xe4,0xb2,0x0, 0x74,
+0x1, 0x12,0x59,0x40,0x7e,0xb3,0x27,0x83,0x30,0xe2,0x7, 0x7e,0x37,0x2a,0x33,0x12,
+0x4e,0xa3,0x7e,0xb3,0x27,0x83,0x54,0xfe,0x7a,0xb3,0x27,0x83,0x54,0xfb,0x7a,0xb3,
+0x27,0x83,0x54,0xfd,0x7a,0xb3,0x27,0x83,0x80,0x4, 0xe4,0x12,0x59,0x40,0xda,0x3b,
+0x22,0xca,0x3b,0x7e,0x73,0x1f,0x3b,0x7a,0x73,0x2a,0xc3,0xe4,0x7a,0xb3,0x1f,0x3b,
+0x6c,0xee,0x6c,0xff,0xa, 0x3f,0x9, 0x73,0x20,0xe1,0xbc,0x7e,0x40,0x2, 0x7c,0xe7,
+0xb, 0xf0,0xbe,0xf0,0x26,0x78,0xed,0xbe,0xe0,0x3f,0x50,0xc, 0xa, 0x2e,0x7e,0x34,
+0x0, 0x3f,0x9d,0x32,0x7c,0xe7,0x80,0x2, 0x6c,0xee,0x7c,0xde,0x2, 0x2a,0x4d,0x7e,
+0x34,0x0, 0x64,0x12,0x58,0xf6,0x12,0x0, 0x5e,0x12,0x59,0x2c,0x60,0xfb,0x7e,0x34,
+0x1e,0xad,0x7e,0x24,0x0, 0x8e,0x12,0x46,0xa1,0x6c,0xff,0x80,0x58,0x6c,0xcc,0x80,
+0x4a,0x4c,0xff,0x78,0x11,0xe4,0xa, 0x3c,0x19,0xb3,0x2a,0x93,0x6d,0x33,0x74,0x2, 
+0xac,0xbc,0x59,0x35,0x2a,0x33,0x7e,0x50,0x2, 0xac,0x5c,0x7e,0x70,0x48,0xac,0x7f,
+0x2d,0x32,0x49,0x13,0xe, 0xe, 0xe, 0x14,0xe, 0x14,0xe, 0x14,0xe, 0x14,0xe, 0x14,
+0x2e,0x24,0x2a,0x33,0xb, 0x28,0x30,0x2d,0x31,0x1b,0x28,0x30,0xa, 0x3c,0x2e,0x34,
+0x2a,0x93,0x7e,0x39,0xb0,0x4, 0x7a,0x39,0xb0,0xb, 0xc0,0x7e,0x73,0x1e,0xae,0xbc,
+0x7c,0x38,0xae,0xb, 0xf0,0x7e,0x73,0x1e,0xad,0xbc,0x7f,0x38,0xa0,0x75,0x21,0x0, 
+0x6c,0xff,0x2, 0x2a,0x21,0xa, 0x3f,0x9, 0xa3,0x2a,0x93,0x4c,0xaa,0x78,0xf, 0x7e,
+0x44,0x21,0x34,0x7e,0x70,0x2, 0xac,0x7f,0x59,0x43,0x2a,0x33,0x80,0x25,0x7e,0x50,
+0x2, 0xac,0x5f,0x49,0x12,0x2a,0x33,0xa, 0xa, 0x8d,0x10,0x59,0x12,0x2a,0x33,0x2e,
+0x24,0x2a,0x33,0xb, 0x28,0x30,0x3e,0x34,0x3e,0x34,0x3e,0x34,0x3e,0x34,0x3e,0x34,
+0x1b,0x28,0x30,0x7e,0x70,0x2, 0xac,0x7f,0x49,0x23,0x2a,0x33,0x7e,0x17,0x20,0x5b,
+0x9e,0x17,0x21,0x3a,0xbd,0x21,0x50,0x1c,0xa, 0x1f,0x9, 0x31,0x1f,0x64,0x9, 0xb1,
+0x28,0x16,0xbc,0xbe,0x50,0xa, 0x2e,0x14,0x28,0x16,0x4, 0x7a,0x19,0xb0,0x80,0x2f,
+0x5, 0x21,0x80,0x2b,0x7e,0x37,0x21,0x3a,0x2e,0x37,0x20,0x5b,0xbd,0x23,0x28,0x1d,
+0xa, 0x3f,0x9, 0x73,0x1f,0x64,0x9, 0xb3,0x28,0x16,0xbe,0xb0,0x0, 0x28,0xa, 0x2e,
+0x34,0x28,0x16,0x14,0x7a,0x39,0xb0,0x80,0x6, 0x5, 0x21,0x80,0x2, 0x5, 0x21,0xb, 
+0xf0,0x7e,0x73,0x1e,0xae,0xbc,0x7f,0x28,0x3, 0x2, 0x29,0x85,0x53,0xdb,0xf0,0x7e,
+0x34,0x27,0xf2,0x12,0x45,0xf2,0x53,0xdc,0xe0,0x7e,0x73,0x21,0x39,0x7c,0xb7,0x42,
+0xdc,0x12,0x58,0xea,0x7e,0x73,0x1e,0xae,0xbe,0x71,0x21,0x68,0xb, 0x7c,0xad,0x1b,
+0xd0,0x4c,0xaa,0x68,0x3, 0x2, 0x28,0xff,0x6c,0xff,0xa, 0x3f,0x9, 0x73,0x1f,0x64,
+0x9, 0x73,0x28,0x16,0xa, 0x2f,0x19,0x72,0x21,0x11,0xb, 0xf0,0xbe,0xf0,0x24,0x40,
+0xe9,0x7e,0x73,0x2a,0xc3,0x7a,0x73,0x1f,0x3b,0xda,0x3b,0x22,0xca,0xf8,0x7c,0x7b,
+0xa5,0xbf,0x0, 0x7, 0x7e,0xb3,0x2b,0x61,0x2, 0x2c,0x8, 0xa5,0xbf,0x1, 0x7, 0x7e,
+0xb3,0x2b,0x5e,0x2, 0x2c,0x8, 0xa5,0xbf,0x2, 0x5, 0x74,0xff,0x2, 0x2c,0x8, 0xa5,
+0xbf,0x3, 0x7, 0x7e,0xb3,0x20,0x4d,0x2, 0x2c,0x8, 0xa5,0xbf,0x4, 0x7, 0x7e,0xb3,
+0x20,0x4e,0x2, 0x2c,0x8, 0xa5,0xbf,0x5, 0x7, 0x7e,0xb3,0x20,0x4f,0x2, 0x2c,0x8, 
+0xa5,0xbf,0x6, 0x7, 0x7e,0xb3,0x20,0x50,0x2, 0x2c,0x8, 0xa5,0xbf,0x7, 0x7, 0x7e,
+0xb3,0x20,0x51,0x2, 0x2c,0x8, 0xa5,0xbf,0x8, 0x7, 0x7e,0xb3,0x20,0x52,0x2, 0x2c,
+0x8, 0xa5,0xbf,0x9, 0x7, 0x7e,0xb3,0x20,0x53,0x2, 0x2c,0x8, 0xa5,0xbf,0xa, 0x7, 
+0x7e,0xb3,0x20,0x54,0x2, 0x2c,0x8, 0xa5,0xbf,0xb, 0x7, 0x7e,0xb3,0x20,0x55,0x2, 
+0x2c,0x8, 0xa5,0xbf,0xc, 0x7, 0x7e,0xb3,0x20,0x56,0x2, 0x2c,0x8, 0xa5,0xbf,0xd, 
+0x7, 0x7e,0xb3,0x20,0x57,0x2, 0x2c,0x8, 0xa5,0xbf,0xe, 0x7, 0x7e,0xb3,0x20,0x58,
+0x2, 0x2c,0x8, 0xa5,0xbf,0xf, 0x7, 0x7e,0xb3,0x20,0x59,0x2, 0x2c,0x8, 0xa5,0xbf,
+0x4c,0x7, 0x7e,0xb3,0x20,0x5a,0x2, 0x2c,0x8, 0xa5,0xbf,0x4e,0x7, 0x7e,0xb3,0x21,
+0x39,0x2, 0x2c,0x8, 0x7e,0xb3,0x2b,0x61,0xc4,0x54,0xf, 0x7c,0x6b,0x5e,0x60,0x7, 
+0xa5,0xbe,0x4, 0x4, 0x6c,0xff,0x80,0x10,0xa5,0xbe,0x6, 0x5, 0x7e,0xf0,0x1, 0x80,
+0x7, 0xa5,0xbe,0x7, 0x3, 0x7e,0xf0,0x2, 0xbe,0x70,0x10,0x40,0x1b,0xbe,0x70,0x38,
+0x38,0x16,0x74,0x28,0xac,0xbf,0xa, 0x37,0x2e,0x37,0x2b,0x5c,0x9e,0x34,0x0, 0x10,
+0x2d,0x35,0x7e,0x39,0xb0,0x2, 0x2c,0x8, 0xbe,0x70,0x50,0x40,0x19,0xbe,0x70,0x63,
+0x38,0x14,0x74,0x14,0xac,0xbf,0xa, 0x37,0x2d,0x35,0x9, 0xb3,0x20,0xd, 0x7e,0x70,
+0x87,0x12,0x51,0x4f,0x80,0x62,0xbe,0x70,0x78,0x40,0x13,0xbe,0x70,0x8b,0x38,0xe, 
+0x74,0x14,0xac,0xbf,0xa, 0x37,0x2d,0x35,0x9, 0xb3,0x20,0x15,0x80,0x4a,0xbe,0x70,
+0xa0,0x40,0x13,0xbe,0x70,0xb3,0x38,0xe, 0x74,0x14,0xac,0xbf,0xa, 0x37,0x2d,0x35,
+0x9, 0xb3,0x20,0x1d,0x80,0x32,0xbe,0x70,0xbf,0x40,0x13,0xbe,0x70,0xd2,0x38,0xe, 
+0x74,0x14,0xac,0xbf,0xa, 0x37,0x2d,0x35,0x9, 0xb3,0x20,0x22,0x80,0x1a,0xbe,0x70,
+0xd3,0x40,0x13,0xbe,0x70,0xe6,0x38,0xe, 0x74,0x14,0xac,0xbf,0xa, 0x37,0x2d,0x35,
+0x9, 0xb3,0x20,0x3e,0x80,0x2, 0x74,0xff,0xda,0xf8,0x22,0xca,0x3b,0x7d,0x73,0x6c,
+0xdd,0x75,0x21,0x0, 0x49,0x37,0x1, 0x4c,0x1e,0x34,0x1e,0x34,0x1e,0x34,0x1e,0x34,
+0x7a,0x35,0x22,0xe4,0x7e,0x79,0x70,0x12,0x59,0x6b,0x74,0x2, 0x9, 0x77,0x0, 0x2, 
+0x12,0x59,0x6b,0x74,0x3, 0x9, 0x77,0x0, 0x3, 0x12,0x59,0x6b,0x74,0x4, 0x9, 0x77,
+0x0, 0x4, 0x12,0x59,0x6b,0x74,0x5, 0x9, 0x77,0x0, 0x5, 0x12,0x59,0x6b,0x74,0x6, 
+0x9, 0x77,0x0, 0x6, 0x12,0x59,0x6b,0x74,0x7, 0x9, 0x77,0x0, 0x7, 0x12,0x59,0x6b,
+0x74,0x8, 0x9, 0x77,0x0, 0x8, 0x12,0x59,0x6b,0x74,0x9, 0x7e,0x70,0xff,0x12,0x59,
+0x6b,0x74,0x2, 0x7e,0x70,0x5d,0x12,0x59,0x6b,0x74,0xa, 0x7e,0x35,0x22,0x12,0x59,
+0x6b,0x74,0x1, 0x6c,0x77,0x12,0x59,0x6b,0x6c,0xcc,0x74,0xb, 0x7e,0x70,0x2, 0xac,
+0x7c,0x2d,0x37,0x49,0x33,0x0, 0xec,0xa, 0x36,0x12,0x59,0x6b,0x74,0xb, 0x7e,0x70,
+0x2, 0xac,0x7c,0x2d,0x37,0x49,0x33,0x0, 0xec,0x12,0x59,0x6b,0xb, 0xc0,0xbe,0xc0,
+0x30,0x78,0xd7,0x6c,0xcc,0x2, 0x2d,0x8b,0x9, 0x77,0x0, 0xeb,0xa, 0x37,0x9, 0x57,
+0x0, 0x5, 0xa, 0x25,0x9d,0x23,0xa, 0x3c,0xbd,0x32,0x40,0x3, 0x2, 0x2d,0x1e,0x7c,
+0xbd,0x3e,0xb0,0x3e,0xb0,0x24,0x10,0xa, 0x3c,0x2d,0x37,0x9, 0x73,0x0, 0x9b,0x12,
+0x59,0x6b,0x7c,0xbd,0x3e,0xb0,0x3e,0xb0,0x24,0x11,0xa, 0x3c,0x2d,0x37,0x9, 0x73,
+0x0, 0xb, 0x12,0x59,0x6b,0x7c,0xbd,0x3e,0xb0,0x3e,0xb0,0x24,0x12,0xa, 0x3c,0x2d,
+0x37,0x9, 0x73,0x0, 0x3b,0x12,0x59,0x6b,0x7c,0xbd,0x3e,0xb0,0x3e,0xb0,0x24,0x13,
+0xa, 0x3c,0x2d,0x37,0x9, 0x73,0x0, 0x6b,0x12,0x59,0x6b,0x2, 0x2d,0x87,0x9, 0x77,
+0x0, 0xeb,0xbe,0x71,0x21,0x38,0x3, 0x2, 0x2d,0x96,0x7c,0xbd,0x3e,0xb0,0x3e,0xb0,
+0x24,0x10,0x7e,0xa1,0x21,0xa, 0x3a,0x2d,0x37,0x9, 0x73,0x0, 0xcb,0x2e,0x70,0x80,
+0x12,0x59,0x6b,0x7c,0xbd,0x3e,0xb0,0x3e,0xb0,0x24,0x11,0x7e,0xa1,0x21,0xa, 0x3a,
+0x2d,0x37,0x9, 0x73,0x0, 0xd3,0x12,0x59,0x6b,0x7c,0xbd,0x3e,0xb0,0x3e,0xb0,0x24,
+0x12,0x7e,0xa1,0x21,0xa, 0x3a,0x2d,0x37,0x9, 0x73,0x0, 0xdb,0x12,0x59,0x6b,0x7c,
+0xbd,0x3e,0xb0,0x3e,0xb0,0x24,0x13,0x7e,0xa1,0x21,0xa, 0x3a,0x2d,0x37,0x9, 0x73,
+0x0, 0xe3,0x12,0x59,0x6b,0x5, 0x21,0xb, 0xd0,0xb, 0xc0,0x9, 0x77,0x0, 0x5, 0xbc,
+0x7c,0x28,0x3, 0x2, 0x2c,0xb8,0xda,0x3b,0x22,0xca,0x3b,0x7d,0x1, 0x7d,0x42,0x9, 
+0xa0,0x1e,0x1e,0x7e,0xc5,0x54,0x4d,0xcc,0x78,0x3, 0x2, 0x2f,0xb, 0x9, 0xf0,0x1e,
+0x1a,0x7d,0xf0,0x2e,0xf4,0x1d,0x40,0x7d,0xe0,0x7d,0xd0,0x2e,0xd4,0xd, 0x80,0xbe,
+0xc4,0x0, 0x1, 0x78,0x6, 0x3e,0xf0,0x3e,0xf0,0x3e,0xf0,0xbe,0xc4,0x0, 0x1, 0x68,
+0x6, 0xbe,0xc4,0x0, 0x5, 0x78,0x67,0x6d,0x22,0x80,0x57,0x7e,0xb4,0x0, 0x24,0xad,
+0xb2,0x7d,0x3b,0x6d,0x11,0x80,0x3f,0x7d,0xa3,0x3e,0xa4,0x7d,0xca,0x2d,0xcd,0xb, 
+0xc8,0xb0,0xa, 0xca,0xbd,0xbc,0x8, 0xe, 0xa, 0x9f,0x2d,0xae,0xb, 0xa8,0xc0,0x2d,
+0xc9,0x1b,0xa8,0xc0,0x80,0x1c,0xa, 0xca,0x6e,0xc4,0xff,0xff,0xb, 0xc4,0xbd,0xbc,
+0x58,0x10,0xa, 0xaf,0x7d,0xb3,0x3e,0xb4,0x2d,0xbe,0xb, 0xb8,0xc0,0x9d,0xca,0x1b,
+0xb8,0xc0,0xb, 0x34,0xb, 0x14,0x9, 0xb4,0x0, 0x1, 0xa, 0xcb,0xbd,0xc1,0x38,0xb7,
+0xb, 0x24,0x7e,0x49,0xb0,0xa, 0xcb,0xbd,0xc2,0x38,0xa0,0x2, 0x2f,0xb, 0x7e,0xc5,
+0x54,0xbe,0xc4,0x0, 0x2, 0x68,0x3, 0x2, 0x2f,0xb, 0x6d,0x22,0x2, 0x2e,0xff,0x7e,
+0xb4,0x0, 0x24,0xad,0xb2,0x7d,0x3b,0x6d,0x11,0x2, 0x2e,0xf0,0x7d,0xc3,0x5e,0xc4,
+0x0, 0x7, 0x2e,0xc4,0x59,0x48,0x7d,0x6c,0x7a,0xd1,0x82,0x7a,0xc1,0x83,0xe4,0x93,
+0x7c,0xeb,0x7d,0xc3,0x1e,0xc4,0x1e,0xc4,0x1e,0xc4,0x2d,0xcf,0x7e,0xc9,0xb0,0x5c,
+0xbe,0x68,0x3d,0x7d,0xa3,0x3e,0xa4,0x7d,0xca,0x2d,0xcd,0xb, 0xc8,0xb0,0xa, 0xca,
+0xbd,0xbc,0x8, 0xe, 0xa, 0x9f,0x2d,0xae,0xb, 0xa8,0xc0,0x2d,0xc9,0x1b,0xa8,0xc0,
+0x80,0x4a,0xa, 0xca,0x6e,0xc4,0xff,0xff,0xb, 0xc4,0xbd,0xbc,0x58,0x3e,0xa, 0xaf,
+0x7d,0xb3,0x3e,0xb4,0x2d,0xbe,0xb, 0xb8,0xc0,0x9d,0xca,0x1b,0xb8,0xc0,0x80,0x2c,
+0x7d,0xc3,0x5e,0xc4,0x0, 0x7, 0x2e,0xc4,0x59,0x48,0x7d,0x6c,0x7a,0xd1,0x82,0x7a,
+0xc1,0x83,0xe4,0x93,0x7c,0xeb,0x7d,0xc3,0x1e,0xc4,0x1e,0xc4,0x1e,0xc4,0x2d,0xc0,
+0x2e,0xc4,0x1d,0x40,0x7e,0xc9,0xb0,0x4c,0xbe,0x7a,0xc9,0xb0,0xb, 0x34,0xb, 0x14,
+0x9, 0xb4,0x0, 0x1, 0xa, 0xcb,0xbd,0xc1,0x28,0x3, 0x2, 0x2e,0x5c,0xb, 0x24,0x7e,
+0x49,0xb0,0xa, 0xcb,0xbd,0xc2,0x28,0x3, 0x2, 0x2e,0x4f,0xda,0x3b,0x22,0xca,0x3b,
+0x7d,0x73,0x6c,0xdd,0x7e,0xb3,0x20,0x14,0xf5,0x4e,0x75,0x42,0x0, 0x7e,0xc0,0x1, 
+0x80,0x19,0xe5,0x42,0xa, 0x3b,0x2d,0x37,0x7e,0x39,0x60,0xa, 0x2c,0x2d,0x27,0x7e,
+0x29,0x70,0xbc,0x76,0x40,0x3, 0x7a,0xc1,0x42,0xb, 0xc0,0xe5,0x4e,0xbc,0xbc,0x38,
+0xe1,0xe5,0x42,0xa, 0x3b,0x2d,0x37,0x7e,0x39,0xb0,0xf5,0x42,0x75,0x44,0x0, 0x7e,
+0xc0,0x1, 0x2, 0x30,0x6e,0x75,0x4d,0x0, 0x6d,0x33,0x7a,0x35,0x4f,0x6c,0xdd,0x7a,
+0x35,0x45,0x7a,0x35,0x47,0x75,0x43,0x0, 0x2, 0x30,0xe, 0x7e,0x71,0x43,0x74,0x2, 
+0xac,0x7b,0x9, 0xb3,0x1f,0x7e,0xf5,0x49,0x9, 0xb3,0x1f,0x7f,0xf5,0x4a,0xe5,0x43,
+0xa, 0x3b,0x2d,0x37,0x7e,0x39,0x70,0xbc,0x7c,0x68,0x3, 0x2, 0x30,0xc, 0xb, 0xd0,
+0xe5,0x49,0xa, 0x3b,0x2e,0x35,0x45,0x7a,0x35,0x45,0xe5,0x4a,0xa, 0x3b,0x2e,0x35,
+0x47,0x7a,0x35,0x47,0xe5,0x49,0xac,0xbd,0x7e,0x35,0x45,0x9d,0x35,0x12,0x58,0x85,
+0x7c,0xb7,0xf5,0x4b,0xe5,0x4a,0xac,0xbd,0x7e,0x35,0x47,0x9d,0x35,0x12,0x58,0x85,
+0x7c,0xb7,0xf5,0x4c,0x7e,0x91,0x4d,0xac,0x9d,0xe5,0x4b,0xa, 0x5b,0xbd,0x54,0x28,
+0x6, 0xa, 0x4d,0x8d,0x54,0xf5,0x4d,0x7e,0x91,0x4d,0xac,0x9d,0xe5,0x4c,0xa, 0x5b,
+0xbd,0x54,0x28,0x6, 0xa, 0x4d,0x8d,0x54,0xf5,0x4d,0x7e,0x61,0x4a,0x1e,0x60,0x7e,
+0x70,0x2, 0xac,0x67,0x7e,0x41,0x49,0x1e,0x40,0x7e,0x50,0x48,0xac,0x45,0x2d,0x23,
+0x49,0x32,0xe, 0xe, 0xbe,0x35,0x4f,0x8, 0x3, 0x7a,0x35,0x4f,0x5, 0x43,0xe5,0x4e,
+0xbe,0xb1,0x43,0x28,0x3, 0x2, 0x2f,0x6b,0xbe,0xd0,0x0, 0x28,0x4f,0xbe,0xd0,0x2, 
+0x28,0x6, 0x74,0x1, 0x7a,0xb3,0x29,0x10,0xa, 0x2d,0x7e,0x35,0x45,0x8d,0x32,0x7a,
+0x35,0x45,0xa, 0x2d,0x7e,0x35,0x47,0x8d,0x32,0x7a,0x35,0x47,0x7e,0x5, 0x45,0x7c,
+0x71,0x7e,0x61,0x44,0x74,0x2, 0xac,0xb6,0x19,0x75,0x28,0xc0,0x7e,0x25,0x47,0x7c,
+0x75,0x19,0x75,0x28,0xc1,0x7e,0x35,0x4f,0x1e,0x24,0x3e,0x24,0x1e,0x4, 0x7e,0x14,
+0x0, 0x48,0xad,0x10,0x2d,0x21,0x59,0x32,0xe, 0xe, 0x5, 0x44,0xb, 0xc0,0xe5,0x42,
+0xbc,0xbc,0x40,0x3, 0x2, 0x2f,0x55,0xe5,0x44,0xda,0x3b,0x22,0xca,0x7b,0xca,0x6b,
+0xca,0x5b,0xca,0x4b,0xca,0x2b,0xca,0x1b,0xca,0xb, 0xc0,0xd0,0xc0,0x83,0xc0,0x82,
+0x12,0x0, 0x58,0x7e,0x35,0x1a,0xb, 0x34,0x7a,0x35,0x1a,0xe5,0xcc,0x54,0x3, 0xb4,
+0x3, 0x2, 0x80,0x3, 0x2, 0x30,0xb1,0x7e,0x35,0x1a,0x2e,0x34,0x0, 0x3, 0x7a,0x35,
+0x1a,0xe5,0xcc,0x54,0x3, 0x68,0x3, 0x2, 0x30,0xc2,0x7e,0x35,0x1a,0xb, 0x34,0x7a,
+0x35,0x1a,0x7e,0x37,0x28,0x5a,0x4d,0x33,0x78,0x3, 0x2, 0x30,0xd3,0x1b,0x34,0x7a,
+0x37,0x28,0x5a,0x7e,0x35,0x1a,0xbe,0x34,0x2, 0x9b,0x50,0x3, 0x2, 0x30,0xf0,0x6d,
+0x33,0x7a,0x35,0x1a,0xe5,0xf, 0xbe,0xb0,0x64,0x40,0x3, 0x2, 0x30,0xf0,0x5, 0xf, 
+0x7e,0x37,0x1f,0x7c,0xb, 0x34,0x7a,0x37,0x1f,0x7c,0x7e,0x37,0x0, 0x80,0xbe,0x37,
+0x1f,0x7c,0x38,0x3, 0x2, 0x31,0xa, 0x12,0x0, 0x5e,0x7e,0x37,0x2c,0x4c,0xbe,0x34,
+0x0, 0x0, 0x38,0x3, 0x2, 0x31,0x1d,0x1b,0x34,0x7a,0x37,0x2c,0x4c,0x7e,0xb3,0x2c,
+0x30,0xb4,0xaa,0x2, 0x80,0x3, 0x2, 0x31,0x42,0x7e,0xa3,0x0, 0x86,0x7c,0xba,0x4, 
+0x7a,0xb3,0x0, 0x86,0xbe,0xa0,0x64,0x38,0x3, 0x2, 0x31,0x42,0x74,0x1, 0x7a,0xb3,
+0x2c,0x30,0xe5,0x19,0xbe,0xb1,0x12,0x38,0x3, 0x2, 0x31,0x6e,0x5, 0x12,0xe5,0xcc,
+0x54,0x3, 0xb4,0x3, 0x2, 0x80,0x3, 0x2, 0x31,0x60,0xe5,0x12,0x24,0x3, 0xf5,0x12,
+0xe5,0xcc,0x54,0x3, 0x68,0x3, 0x2, 0x31,0x71,0x5, 0x12,0x2, 0x31,0x71,0x75,0x11,
+0x1, 0x7e,0xb3,0x2b,0x5a,0x70,0x3, 0x2, 0x31,0xb8,0xbe,0xb0,0x18,0x40,0x3, 0x2, 
+0x31,0xb2,0x4, 0x7a,0xb3,0x2b,0x5a,0xe5,0xcc,0x54,0x3, 0xb4,0x3, 0x2, 0x80,0x3, 
+0x2, 0x31,0x9d,0x7e,0xb3,0x2b,0x5a,0x24,0x3, 0x7a,0xb3,0x2b,0x5a,0xe5,0xcc,0x54,
+0x3, 0x68,0x3, 0x2, 0x31,0xb8,0x7e,0xb3,0x2b,0x5a,0x4, 0x7a,0xb3,0x2b,0x5a,0x2, 
+0x31,0xb8,0x12,0x4f,0xda,0x12,0x58,0xde,0xd0,0x82,0xd0,0x83,0xd0,0xd0,0xda,0xb, 
+0xda,0x1b,0xda,0x2b,0xda,0x4b,0xda,0x5b,0xda,0x6b,0xda,0x7b,0x32,0xca,0x3b,0x7d,
+0xb2,0x6d,0xaa,0x7d,0xa, 0x7d,0x4a,0x7d,0x2a,0x6c,0xaa,0x7d,0xf3,0x7d,0xe3,0x2e,
+0xe4,0xd, 0x80,0x7d,0xda,0x7d,0xca,0x6c,0x77,0x7e,0x63,0x2b,0xf6,0xa, 0x86,0x7e,
+0x63,0x2b,0xf7,0xa, 0x96,0x9d,0x98,0x7d,0x79,0x7c,0x6f,0x7e,0xf3,0x2b,0xf8,0x2, 
+0x32,0xee,0x6d,0x44,0x7e,0x24,0x7f,0xff,0x7e,0xb3,0x2b,0xf6,0x7e,0xd0,0x24,0xac,
+0xdb,0xa, 0xdf,0x2d,0xd6,0x6c,0xee,0x80,0x3f,0x7e,0x13,0x2b,0xce,0xac,0x1e,0xa, 
+0xcf,0x2d,0xc0,0x7d,0xb, 0x2d,0xc, 0x7e,0x9, 0xb0,0xa, 0xab,0x3e,0xa4,0x3e,0xa4,
+0x3e,0xa4,0x7d,0xd, 0x3e,0x4, 0x7d,0x90,0x2d,0x9e,0xb, 0x98,0x90,0x2d,0xf, 0xb, 
+0x8, 0x0, 0x2d,0x9, 0x2d,0xa, 0x2e,0xd4,0x0, 0x24,0xbd,0x40,0x50,0x2, 0x7d,0x40,
+0xbd,0x20,0x28,0x2, 0x7d,0x20,0xb, 0xe0,0xbc,0x6e,0x38,0xbd,0x7d,0x94,0x9d,0x92,
+0xbe,0x97,0x2b,0xfa,0x28,0x3, 0x7e,0xa0,0x1, 0xbe,0xa0,0x1, 0x78,0x46,0x7e,0xd0,
+0x4, 0xac,0xdf,0x7d,0x96,0x2d,0x91,0xb, 0x98,0x90,0xbe,0x94,0x0, 0x1, 0x78,0x53,
+0x7e,0xd0,0x4, 0xac,0xdf,0x2d,0x61,0xb, 0x65,0xb, 0x68,0x90,0x7d,0x89,0xb, 0x84,
+0x1b,0x68,0x80,0xbe,0x97,0x2c,0x0, 0x28,0x3a,0x6d,0x99,0x74,0x4, 0xac,0xbf,0x2d,
+0x51,0x59,0x95,0x0, 0x2, 0x6d,0x99,0x74,0x4, 0xac,0xbf,0x2d,0x51,0x1b,0x58,0x90,
+0x6c,0xaa,0x80,0x1f,0x6d,0x99,0x7e,0xd0,0x4, 0xac,0xdf,0x7d,0x86,0x2d,0x81,0x59,
+0x98,0x0, 0x2, 0x7e,0x84,0x0, 0x1, 0x7e,0xd0,0x4, 0xac,0xdf,0x7d,0x96,0x2d,0x91,
+0x1b,0x98,0x80,0xbe,0xa0,0x1, 0x78,0x14,0x7e,0xd0,0x4, 0xac,0xdf,0x7d,0x96,0x2d,
+0x91,0xb, 0x98,0x90,0xbe,0x94,0x0, 0x1, 0x78,0x2, 0xb, 0x70,0xb, 0xf0,0x7e,0xb3,
+0x2b,0xf9,0xbc,0xbf,0x28,0x3, 0x2, 0x32,0x2, 0xbe,0x70,0x0, 0x28,0x3, 0x7e,0xa0,
+0x1, 0x7e,0x34,0x0, 0x1, 0x7a,0x37,0x2b,0xcb,0xbe,0xa0,0x1, 0x78,0x6, 0x7e,0x34,
+0x0, 0x2, 0x80,0x2, 0x6d,0x33,0x7a,0x37,0x2b,0xc5,0xda,0x3b,0x22,0xca,0x3b,0x7e,
+0xe0,0xff,0x6d,0x33,0x12,0x59,0x50,0x7c,0xfb,0x7e,0xb3,0x2c,0x29,0x60,0x3, 0x2, 
+0x33,0x35,0x7e,0xf0,0xff,0xbe,0xf0,0xff,0x78,0x3, 0x2, 0x33,0x7f,0x7e,0x34,0x7, 
+0xf0,0x12,0x59,0x50,0xf5,0x21,0x7e,0x34,0x7, 0xf1,0x12,0x59,0x50,0xf5,0x22,0x65,
+0x21,0xbe,0xb0,0xff,0x78,0x3, 0x2, 0x33,0x5c,0x7e,0xf0,0xff,0x75,0x22,0x0, 0x6d,
+0x66,0x7d,0x36,0xb, 0x36,0x12,0x59,0x50,0x62,0x22,0xb, 0x64,0xbe,0x64,0x4, 0x80,
+0x78,0xef,0xe5,0x22,0xbe,0xb1,0x21,0x78,0x3, 0x2, 0x33,0x7f,0x7e,0xf0,0xff,0xbe,
+0xf0,0xff,0x78,0x3, 0x2, 0x33,0x8c,0x74,0x4, 0x12,0x4b,0xed,0x74,0x26,0x7a,0xb3,
+0x20,0x4d,0x74,0x18,0x7a,0xb3,0x20,0x4e,0x74,0x3, 0x7a,0xb3,0x20,0x4f,0xe4,0x7a,
+0xb3,0x20,0x50,0x74,0x65,0x7a,0xb3,0x20,0x51,0x7e,0x34,0x21,0x34,0x7a,0x37,0x20,
+0x5b,0x7e,0x34,0x3, 0xe8,0x7a,0x37,0x21,0x3a,0x74,0x13,0x7a,0xb3,0x21,0x39,0xe4,
+0x7a,0xb3,0x21,0x3c,0x75,0x23,0x87,0x7e,0x14,0x3d,0xac,0x7e,0x4, 0x0, 0xff,0x7e,
+0x18,0x20,0x5d,0x74,0x26,0x12,0x4e,0x38,0x6c,0xee,0x7e,0x73,0x20,0x4d,0xbc,0x7e,
+0x28,0x3, 0x2, 0x33,0xed,0x74,0xff,0xa, 0x3e,0x19,0xb3,0x20,0x5d,0xa, 0x3e,0x2e,
+0x34,0x3e,0x28,0x7a,0x71,0x82,0x7a,0x61,0x83,0xe4,0x93,0xa, 0x3e,0x19,0xb3,0x20,
+0x8d,0x2e,0x34,0x3d,0xd4,0x7a,0x71,0x82,0x7a,0x61,0x83,0xe4,0x93,0xa, 0x3e,0x19,
+0xb3,0x20,0xe1,0xb, 0xe0,0xbe,0xe0,0x30,0x78,0xc0,0x6c,0xee,0xa, 0x3e,0x2e,0x34,
+0x3e,0x4, 0x7a,0x71,0x82,0x7a,0x61,0x83,0xe4,0x93,0xa, 0x3e,0x19,0xb3,0x20,0xbd,
+0xbe,0xf0,0xff,0x68,0x3, 0x2, 0x34,0x4c,0xa, 0x3e,0x2e,0x34,0x3e,0x58,0x7a,0x71,
+0x82,0x7a,0x61,0x83,0xe4,0x93,0xa, 0x3e,0x19,0xb3,0x21,0x11,0xb, 0xe0,0xbe,0xe0,
+0x24,0x78,0xc9,0xbe,0xf0,0xff,0x68,0x3, 0x2, 0x34,0x67,0x7e,0x34,0x21,0x3d,0x7e,
+0x24,0x3, 0x90,0xe4,0x12,0x58,0x95,0xda,0x3b,0x22,0x7e,0xb3,0x2c,0x49,0x54,0xfe,
+0x7a,0xb3,0x2c,0x49,0x74,0x14,0x7a,0xb3,0x2c,0x9, 0x74,0x3c,0x7a,0xb3,0x2c,0xa, 
+0x74,0xa0,0x7a,0xb3,0x2c,0xe, 0x74,0x1, 0x7a,0xb3,0x2c,0xf, 0x74,0xa, 0x7a,0xb3,
+0x2c,0x10,0x74,0x14,0x7a,0xb3,0x2c,0x11,0x74,0x28,0x7a,0xb3,0x2c,0x12,0x74,0x32,
+0x7a,0xb3,0x2c,0x20,0x74,0xff,0x7a,0xb3,0x2c,0x29,0x74,0x8, 0x7a,0xb3,0x2c,0x2c,
+0x74,0x1, 0x7a,0xb3,0x2c,0x2d,0xe4,0x7a,0xb3,0x2c,0x2e,0x74,0x18,0x7a,0xb3,0x2c,
+0x2f,0x74,0x1, 0x7a,0xb3,0x2c,0x30,0x74,0x5c,0x7a,0xb3,0x2c,0x31,0xe4,0x7a,0xb3,
+0x2c,0x32,0x7a,0xb3,0x2c,0x33,0x74,0x6, 0x7a,0xb3,0x2c,0x38,0x74,0xc8,0x7a,0xb3,
+0x2c,0x37,0x6d,0x33,0x7a,0x37,0x20,0x41,0x74,0x1, 0x7a,0xb3,0x20,0x43,0xe4,0x7a,
+0xb3,0x20,0x4a,0x74,0x5, 0x7a,0xb3,0x20,0x45,0x74,0x14,0x7a,0xb3,0x20,0x46,0x74,
+0x28,0x7a,0xb3,0x20,0x47,0x74,0x28,0x7a,0xb3,0x20,0x48,0x74,0xa, 0x7a,0xb3,0x20,
+0x49,0x74,0x1, 0x7a,0xb3,0x20,0x4b,0x7e,0x34,0x0, 0x50,0x7a,0x37,0x0, 0x6a,0x74,
+0x14,0x7a,0xb3,0x0, 0x6c,0x7e,0x34,0x0, 0x3c,0x7a,0x37,0x0, 0x6d,0x7e,0x34,0x7, 
+0xd0,0x7a,0x37,0x0, 0x73,0xe4,0x7a,0xb3,0x0, 0x79,0x74,0x3, 0x7a,0xb3,0x0, 0x7a,
+0x74,0x2, 0x7a,0xb3,0x0, 0x7b,0x74,0x4, 0x7a,0xb3,0x0, 0x7c,0x7e,0x34,0x0, 0x64,
+0x7a,0x37,0x0, 0x7d,0xe4,0x7a,0xb3,0x0, 0x7f,0x74,0xa, 0x7a,0xb3,0x0, 0x87,0x7e,
+0x34,0xa, 0x0, 0x7a,0x37,0x0, 0x88,0x74,0xa0,0x7a,0xb3,0x0, 0x8a,0x7e,0x34,0x0, 
+0xb4,0x7a,0x37,0x2b,0xfa,0xe4,0x7a,0xb3,0x2b,0xf6,0x74,0x26,0x7a,0xb3,0x2b,0xf7,
+0xe4,0x7a,0xb3,0x2b,0xf8,0x74,0x18,0x7a,0xb3,0x2b,0xf9,0x7e,0x34,0x0, 0xc8,0x7a,
+0x37,0x0, 0x8c,0xe4,0x7a,0xb3,0x2c,0x14,0x7a,0xb3,0x2c,0x34,0x7a,0xb3,0x2c,0x35,
+0x7e,0x73,0x21,0x39,0x7a,0x73,0x2c,0x13,0x7e,0x73,0x21,0x3c,0x7a,0x73,0x2c,0x16,
+0x7a,0xb3,0x2c,0x18,0x22,0xca,0x3b,0x7c,0xcb,0x7e,0x34,0x21,0x3d,0x7e,0x24,0x3, 
+0x90,0xe4,0x12,0x58,0x95,0x12,0x56,0x66,0x12,0x58,0xea,0x7e,0x34,0x1e,0xad,0x7e,
+0x24,0x0, 0x8e,0x12,0x46,0xa1,0xbe,0xb0,0xaa,0x68,0xf0,0x7e,0x34,0xe, 0xe, 0x7a,
+0x37,0x2b,0x67,0x6d,0x33,0x7d,0x73,0x6c,0xaa,0x4d,0x77,0x68,0x3, 0x2, 0x35,0xfb,
+0x6d,0x22,0x7e,0x30,0x2, 0xac,0x3a,0x59,0x21,0x2a,0x35,0x7e,0x14,0x0, 0x24,0xad,
+0x17,0x7d,0x41,0x3e,0x44,0x7e,0x50,0x2, 0xac,0x5a,0x2d,0x24,0x2e,0x27,0x2b,0x67,
+0xb, 0x28,0x20,0x7e,0x30,0x2, 0xac,0x3a,0x49,0x11,0x2a,0x35,0xbd,0x21,0x38,0x3, 
+0x2, 0x36,0x35,0xbe,0x24,0x27,0x10,0x40,0x3, 0x2, 0x36,0x35,0x7e,0x30,0x2, 0xac,
+0x3a,0x59,0x21,0x2a,0x35,0xb, 0xa0,0xbe,0xa0,0x18,0x78,0xad,0xb, 0x74,0xbe,0x74,
+0x0, 0x26,0x78,0xa3,0x7d,0x43,0x7d,0x73,0x6c,0xaa,0x7e,0x34,0x0, 0x24,0xad,0x37,
+0x7d,0x23,0x3e,0x24,0x7e,0x70,0x2, 0xac,0x7a,0x2d,0x32,0x2e,0x37,0x2b,0x67,0xb, 
+0x38,0x20,0xbe,0x24,0x27,0x10,0x38,0x3, 0x2, 0x36,0x70,0xb, 0x44,0x2, 0x36,0x98,
+0x7e,0x70,0x2, 0xac,0x7a,0x49,0x33,0x2a,0x35,0x9d,0x32,0x1e,0x34,0x1e,0x34,0x1e,
+0x34,0xbe,0x34,0x0, 0xff,0x38,0x3, 0x2, 0x36,0x8e,0x7e,0x34,0x0, 0xff,0x7c,0xb7,
+0x7d,0x24,0xb, 0x44,0x19,0xb2,0x21,0x3d,0xb, 0xa0,0xbe,0xa0,0x18,0x78,0xab,0xb, 
+0x74,0xbe,0x74,0x0, 0x26,0x78,0xa1,0x7e,0x34,0x20,0x4d,0x7a,0x37,0x2a,0x33,0x6c,
+0xdd,0x6d,0x77,0x7e,0x37,0x2a,0x33,0x7e,0x39,0x70,0x6c,0xd7,0xa, 0x3c,0x2d,0x37,
+0x7e,0x27,0x2a,0x33,0x7d,0x12,0xb, 0x14,0x7a,0x17,0x2a,0x33,0x7e,0x29,0xb0,0x12,
+0x54,0xca,0xb, 0x74,0xbe,0x74,0x4, 0x80,0x40,0xd9,0x7e,0x34,0x7, 0xf0,0x7c,0xbd,
+0x12,0x54,0xca,0x7e,0x34,0x7, 0xf1,0x74,0xff,0x9c,0xbd,0x12,0x54,0xca,0x74,0x1, 
+0xda,0x3b,0x22,0xca,0x79,0x7e,0xf1,0xcc,0x7e,0x37,0x20,0x41,0x4d,0x33,0x78,0x39,
+0x7e,0x53,0x27,0x7f,0xbe,0x50,0x0, 0x28,0x6, 0x75,0xf, 0x0, 0x2, 0x37,0xe3,0x7e,
+0xb3,0x20,0x43,0x20,0xe0,0x3, 0x2, 0x37,0xe3,0x7e,0x53,0x20,0x49,0xbe,0x51,0xf, 
+0x28,0x3, 0x2, 0x37,0xe3,0x75,0xf, 0x0, 0x7e,0x24,0x0, 0x1, 0x7a,0x27,0x20,0x41,
+0x74,0x1, 0x7a,0xb3,0x2c,0x2e,0x2, 0x37,0xe3,0xbe,0x34,0x0, 0x1, 0x78,0x1d,0x7e,
+0xb3,0x27,0x7f,0x70,0x3, 0x2, 0x37,0xe3,0x6d,0x22,0x7a,0x27,0x20,0x41,0xe4,0x7a,
+0xb3,0x2c,0x2e,0x75,0x12,0x29,0x75,0x11,0x1, 0x2, 0x37,0xe3,0xbe,0x34,0x0, 0x3, 
+0x68,0x3, 0x2, 0x37,0xe3,0x7e,0x34,0x4, 0x8f,0x12,0x58,0xf6,0x12,0x0, 0x5e,0xa9,
+0xd6,0xeb,0xa9,0xc6,0xac,0xa9,0xc6,0xec,0xc2,0x96,0xc2,0x89,0xd2,0xb8,0xa9,0xd0,
+0xb7,0xd2,0xa8,0x12,0x59,0x2c,0x60,0xfb,0x20,0x93,0xfd,0x43,0x87,0x2, 0x0, 0x0, 
+0x0, 0xc2,0xa8,0xc2,0x95,0xa9,0xc7,0xeb,0xa9,0xd7,0xac,0xa9,0xd7,0xec,0xd2,0x87,
+0x7e,0x34,0x4, 0x8f,0x12,0x58,0xf6,0x12,0x0, 0x5e,0x53,0xdb,0xf0,0x12,0x58,0xea,
+0x12,0x4f,0x74,0x6d,0x33,0x7a,0x37,0x20,0x41,0xe4,0x7a,0xb3,0x2c,0x2e,0x7e,0x34,
+0x0, 0x8e,0x12,0x52,0x16,0x7e,0x34,0x0, 0x14,0x7a,0x37,0x28,0x5a,0x7e,0x37,0x28,
+0x5a,0x4d,0x33,0x78,0xf8,0x7e,0x34,0x1e,0xad,0x7e,0x24,0x0, 0x8e,0x12,0x4c,0xe4,
+0x75,0x58,0x0, 0x6c,0xee,0xc2,0xcc,0x80,0x15,0xe4,0x12,0x58,0x43,0xa9,0x31,0xdb,
+0xd, 0x4c,0xee,0x78,0x9, 0x7e,0xe0,0x1, 0x53,0xcc,0xfc,0x43,0xcc,0x3, 0xe5,0x11,
+0x60,0xe7,0xd2,0xcc,0x75,0x12,0x0, 0x75,0x11,0x0, 0x7e,0xb3,0x27,0x83,0x54,0xef,
+0x7a,0xb3,0x27,0x83,0x7e,0x73,0x27,0x7f,0x7a,0x73,0x27,0x80,0x7a,0xf1,0xcc,0xda,
+0x79,0x22,0xca,0x3b,0x7c,0xeb,0x7e,0xa3,0x20,0x14,0x4c,0xaa,0x78,0xb, 0xe4,0x7a,
+0xb3,0x29,0x10,0x75,0x64,0x64,0x75,0x65,0x64,0xbe,0xa0,0x1, 0x38,0x3, 0x2, 0x39,
+0x40,0x7c,0xbe,0x12,0xc, 0x8e,0x7e,0xa3,0x27,0x80,0x4c,0xaa,0x68,0x16,0xe5,0x61,
+0x70,0x6, 0xe5,0x62,0x70,0x2, 0x80,0xc, 0xbe,0xa0,0x1, 0x28,0xc, 0xe5,0x64,0xbe,
+0xb0,0xf, 0x28,0x5, 0x7e,0xf0,0x1, 0x80,0x23,0x7e,0xf0,0x1, 0x7e,0xa3,0x20,0x14,
+0xbe,0xa3,0x27,0x80,0x78,0x6, 0x6c,0xee,0x6c,0xff,0x80,0x10,0x7c,0xba,0x9e,0xb1,
+0x61,0xbe,0xb3,0x27,0x80,0x78,0x5, 0x7e,0xe0,0x2, 0x6c,0xff,0x4c,0xff,0x78,0x5, 
+0x7c,0xbe,0x12,0xc, 0x8e,0xe5,0x60,0x7a,0xb3,0x20,0x14,0x7e,0x31,0x60,0x74,0x2, 
+0xac,0x3b,0x7e,0x24,0x28,0xc0,0x7e,0x34,0x1f,0x7e,0x12,0x58,0x16,0x75,0x64,0x64,
+0x75,0x65,0x64,0x6c,0xee,0x80,0x67,0x6c,0xdd,0x80,0x59,0x74,0x2, 0xac,0xbd,0x9, 
+0x75,0x1f,0x7e,0xa, 0x27,0x74,0x2, 0xac,0xbe,0x9, 0x75,0x1f,0x7e,0xa, 0x37,0x9d,
+0x32,0x12,0x58,0x85,0x7c,0xb7,0xf5,0x21,0x74,0x2, 0xac,0xbd,0x9, 0x75,0x1f,0x7f,
+0xa, 0x27,0x74,0x2, 0xac,0xbe,0x9, 0x75,0x1f,0x7f,0xa, 0x37,0x9d,0x32,0x12,0x58,
+0x85,0x7c,0xc7,0xe5,0x21,0xbe,0xb0,0x0, 0x28,0xa, 0xe5,0x64,0xbe,0xb1,0x21,0x28,
+0x3, 0x85,0x21,0x64,0xbe,0xc0,0x0, 0x28,0x9, 0xe5,0x65,0xbc,0xbc,0x28,0x3, 0x7a,
+0xc1,0x65,0xb, 0xd0,0x7e,0x73,0x20,0x14,0xbc,0x7d,0x38,0x9f,0xb, 0xe0,0x7e,0x73,
+0x20,0x14,0xbc,0x7e,0x38,0x91,0xe5,0x64,0xb4,0x64,0x3, 0x75,0x64,0x0, 0xe5,0x65,
+0xb4,0x64,0x3, 0x75,0x65,0x0, 0xe5,0x65,0xbe,0xb1,0x64,0x28,0x3, 0x85,0x65,0x64,
+0xda,0x3b,0x22,0x7e,0x34,0x28,0x16,0x7e,0x24,0x0, 0x24,0xe4,0x12,0x58,0x95,0x7e,
+0x34,0x27,0xf2,0x7e,0x24,0x0, 0x24,0xe4,0x12,0x58,0x95,0x6c,0xaa,0xa, 0x3a,0x9, 
+0xb3,0x20,0xbd,0xa, 0x4a,0x9, 0x74,0x1f,0x64,0xa, 0x47,0x19,0xb4,0x27,0xf2,0xa, 
+0x3a,0x9, 0xb3,0x21,0x11,0xa, 0x4a,0x9, 0x74,0x1f,0x64,0xa, 0x47,0x19,0xb4,0x28,
+0x16,0xb, 0xa0,0xbe,0xa0,0x18,0x78,0xd5,0x6c,0xaa,0xa, 0x3a,0x2e,0x34,0x7, 0x7b,
+0x7a,0x71,0x82,0x7a,0x61,0x83,0xe4,0x93,0xa, 0x4a,0x19,0xb4,0x28,0x43,0xb, 0xa0,
+0xbe,0xa0,0x9, 0x78,0xe5,0x6c,0xaa,0xe4,0xa, 0x4a,0x19,0xb4,0x28,0x4c,0xb, 0xa0,
+0xbe,0xa0,0x5, 0x78,0xf3,0x6c,0xaa,0x2, 0x39,0xea,0xa, 0x3a,0x9, 0x63,0x1f,0x64,
+0x7c,0x76,0x1e,0x70,0x1e,0x70,0x1e,0x70,0x5e,0x60,0x7, 0x7e,0x30,0x1, 0x7c,0xb6,
+0x70,0x3, 0x2, 0x39,0xda,0x3e,0x30,0x14,0x78,0xfb,0xa, 0x27,0x2e,0x24,0x28,0x4c,
+0x7e,0x29,0xb0,0x4c,0xb3,0x7a,0x29,0xb0,0xb, 0xa0,0x7e,0xb3,0x20,0x4e,0xbc,0xba,
+0x38,0xc8,0x7e,0x73,0x20,0x4f,0x7a,0x73,0x28,0x3a,0x7e,0x73,0x20,0x8d,0x7a,0x73,
+0x28,0x3b,0x7e,0x73,0x20,0xe1,0x7a,0x73,0x28,0x3c,0x7e,0x73,0x20,0x51,0x7a,0x73,
+0x28,0x3e,0x74,0x13,0x7a,0xb3,0x28,0x40,0x74,0x9, 0x7a,0xb3,0x28,0x42,0x74,0x2, 
+0x7a,0xb3,0x28,0x3f,0x74,0x1, 0x7a,0xb3,0x28,0x41,0x74,0x21,0x7a,0xb3,0x28,0x56,
+0x74,0x23,0x7a,0xb3,0x28,0x57,0xe4,0x7a,0xb3,0x28,0x55,0x7a,0xb3,0x28,0x54,0x7a,
+0xb3,0x28,0x53,0x7a,0xb3,0x28,0x51,0x74,0x7c,0x7a,0xb3,0x28,0x52,0x74,0x1, 0x7a,
+0xb3,0x28,0x58,0x74,0x1, 0x7a,0xb3,0x28,0x59,0x7e,0x34,0x27,0xf2,0x2, 0x45,0xf2,
+0xca,0x3b,0x7e,0xa3,0x20,0x14,0x7a,0xa1,0x22,0x7e,0x67,0x0, 0x6a,0x7e,0xb3,0x1e,
+0xad,0x7a,0xb3,0x2a,0x35,0x7e,0xb3,0x1e,0xae,0xf5,0x25,0xbe,0xa0,0x0, 0x38,0x3, 
+0x2, 0x3b,0x76,0x6c,0xff,0x6c,0xee,0x2, 0x3b,0x69,0x74,0x2, 0xac,0xbe,0x9, 0x75,
+0x1f,0x7e,0x1e,0x70,0x7a,0x73,0x2a,0x33,0x9, 0xb5,0x1f,0x7f,0x1e,0xb0,0xf5,0x23,
+0x74,0x2, 0xa, 0x3e,0x19,0xb3,0x20,0x17,0x7e,0x51,0x23,0x74,0x2, 0xac,0x5b,0x7e,
+0xa3,0x2a,0x33,0x7e,0x70,0x48,0xac,0x7a,0x2d,0x32,0x49,0x33,0xe, 0xe, 0xbd,0x36,
+0x50,0x3, 0x2, 0x3b,0x62,0xbe,0xa0,0x1, 0x28,0x23,0x7e,0xb3,0x2a,0x35,0xa, 0x2b,
+0x1b,0x25,0xa, 0x3a,0xbd,0x32,0x58,0x15,0xe5,0x23,0xbe,0xb0,0x1, 0x28,0xe, 0xe5,
+0x25,0xa, 0x2b,0x1b,0x25,0xe5,0x23,0xa, 0x3b,0xbd,0x32,0x48,0x8, 0x74,0x1, 0xa, 
+0x3e,0x19,0xb3,0x20,0x17,0x75,0x21,0x0, 0x80,0x44,0xbe,0xe1,0x21,0x68,0x3d,0x7e,
+0xa1,0x21,0x74,0x2, 0xa4,0x9, 0x75,0x1f,0x7e,0x1e,0x70,0x7a,0x73,0x2a,0x34,0x9, 
+0xb5,0x1f,0x7f,0x1e,0xb0,0xf5,0x24,0x7e,0xb3,0x2a,0x33,0x7e,0x60,0x3, 0x12,0x58,
+0x2d,0xb4,0x1, 0x18,0xe5,0x23,0x7e,0x71,0x24,0x7e,0x60,0x3, 0x12,0x58,0x2d,0xb4,
+0x1, 0xa, 0x74,0x1, 0xa, 0x3e,0x19,0xb3,0x20,0x17,0x80,0x9, 0x5, 0x21,0xe5,0x22,
+0xbe,0xb1,0x21,0x38,0xb5,0x7a,0xe3,0x20,0x3f,0x7a,0xf3,0x20,0x40,0x7e,0x34,0x0, 
+0x8e,0x7e,0x24,0x1e,0xad,0x7e,0x14,0x0, 0x6a,0x7e,0x4, 0x1f,0x7e,0x12,0x16,0x12,
+0xb, 0xf0,0xbe,0xf0,0xa, 0x50,0xb, 0xb, 0xe0,0xe5,0x22,0xbc,0xbe,0x28,0x3, 0x2, 
+0x3a,0x8a,0x7a,0xf3,0x20,0x14,0xda,0x3b,0x22,0xca,0xf8,0x7e,0x34,0xe, 0xe, 0x7a,
+0x37,0x2b,0x67,0x53,0xdb,0xf0,0x75,0x9, 0x1, 0x12,0x0, 0x6, 0x12,0x58,0xde,0x12,
+0x3c,0x8a,0x12,0x39,0x43,0x12,0x3e,0x7c,0x7e,0x34,0x25,0xa3,0x12,0x2c,0xb, 0x12,
+0x59,0x57,0x74,0x21,0x7a,0xb3,0x1f,0x3d,0x53,0xdb,0x7f,0x12,0x58,0xea,0x7e,0x73,
+0x1e,0xae,0x7a,0x73,0x2b,0xb7,0x7e,0x73,0x1e,0xad,0x7a,0x73,0x2b,0xb6,0x7e,0x34,
+0x4, 0x8f,0x12,0x58,0xf6,0x7e,0x34,0x0, 0x8e,0x12,0x52,0x16,0xe4,0x7a,0xb3,0x1f,
+0x3b,0x7e,0x73,0x21,0x39,0x7a,0x73,0x1f,0x3c,0x74,0x3, 0x7a,0xb3,0x2b,0xb4,0x7e,
+0x34,0x4, 0x8f,0x12,0x58,0xf6,0x7e,0xb3,0x2b,0xb3,0x60,0x3, 0x2, 0x3c,0x1f,0x75,
+0x68,0x1, 0x12,0x0, 0x5e,0x74,0x1, 0x7a,0xb3,0x2b,0xb3,0x7e,0x34,0x78,0x0, 0x12,
+0x56,0xa6,0x7e,0x34,0x7c,0x0, 0x12,0x56,0xa6,0x74,0x4, 0x12,0x35,0xb5,0x6d,0x33,
+0xe4,0x12,0x54,0xca,0x74,0x4, 0x12,0x4b,0xed,0x74,0xff,0x7a,0xb3,0x2b,0xb3,0x75,
+0x68,0x0, 0x7e,0xf3,0x2b,0xb4,0xbe,0xf0,0x3, 0x68,0x3, 0x2, 0x3c,0x7e,0x7e,0xb3,
+0x2b,0x61,0x30,0xe7,0xaa,0x12,0x3c,0x8a,0x12,0x59,0x2c,0x60,0xfb,0x53,0xdb,0xf0,
+0x12,0x39,0x43,0x12,0x3e,0x7c,0x7e,0x34,0x25,0xa3,0x12,0x2c,0xb, 0x12,0x59,0x57,
+0x74,0x21,0x7a,0xb3,0x1f,0x3d,0xe4,0x7a,0xb3,0x1f,0x3b,0x7e,0x34,0x1e,0xad,0x7e,
+0x24,0x0, 0x8e,0x12,0x46,0xa1,0x12,0x58,0xea,0x7e,0x34,0xe, 0xe, 0x7a,0x37,0x2b,
+0x67,0x7e,0xb3,0x2b,0x61,0x54,0x7f,0x7a,0xb3,0x2b,0x61,0x2, 0x3b,0xdf,0x7a,0xf3,
+0x2c,0x30,0x12,0x59,0x2c,0x60,0xfb,0xda,0xf8,0x22,0xca,0xd8,0xca,0x79,0x6c,0xff,
+0x7e,0xe0,0xff,0x6c,0xdd,0x74,0x1, 0x7a,0xb3,0x1f,0x3b,0x7e,0x73,0x21,0x39,0x7a,
+0x73,0x1f,0x3c,0x7e,0x73,0x20,0x4d,0x7a,0x73,0x1e,0xad,0x7e,0x73,0x20,0x4e,0x7a,
+0x73,0x1e,0xae,0x7e,0xa3,0x1e,0xae,0x7e,0xb3,0x1e,0xad,0xa4,0x7a,0x57,0x1e,0xaf,
+0x6c,0xaa,0x2, 0x3c,0xdb,0xa, 0x3a,0x9, 0xb3,0x20,0x5d,0xa, 0x4a,0x19,0xb4,0x1e,
+0xb1,0x9, 0xb3,0x20,0x8d,0x19,0xb4,0x1f,0x6, 0xb, 0xa0,0x7e,0xb3,0x1e,0xad,0xbc,
+0xba,0x38,0xe2,0x75,0x21,0x87,0x7e,0x14,0x3d,0x94,0x7e,0x4, 0x0, 0xff,0x7e,0x18,
+0x2a,0x33,0x74,0x18,0x12,0x4d,0xcd,0x6c,0xaa,0x2, 0x3d,0x12,0xa, 0x3a,0x9, 0xb3,
+0x2a,0x33,0xa, 0x4a,0x19,0xb4,0x1e,0xe1,0x9, 0xb3,0x2a,0x33,0x19,0xb4,0x1f,0x64,
+0xb, 0xa0,0x7e,0xb3,0x1e,0xae,0xbc,0xba,0x38,0xe2,0x6c,0xaa,0x2, 0x3d,0x52,0x6c,
+0xff,0x2, 0x3d,0x37,0xa, 0x3f,0x9, 0xb3,0x2a,0x33,0xbc,0xbe,0x40,0x3, 0x2, 0x3d,
+0x35,0x7c,0xeb,0x7c,0xdf,0xb, 0xf0,0x7e,0xb3,0x20,0x4e,0xbc,0xbf,0x38,0xe5,0x74,
+0xff,0xa, 0x4d,0x19,0xb4,0x2a,0x33,0x7e,0xe0,0xff,0xa, 0x3a,0x19,0xd3,0x1f,0x3e,
+0xb, 0xa0,0x7e,0xb3,0x20,0x4e,0xbc,0xba,0x38,0xc5,0x7e,0x73,0x20,0x50,0x7a,0x73,
+0x1f,0x5, 0x7e,0x73,0x1f,0x6, 0x7a,0x73,0x1f,0x3a,0x7e,0x73,0x20,0xe1,0x7a,0x73,
+0x1f,0x36,0x7e,0x73,0x20,0x51,0x7a,0x73,0x1f,0x37,0x7e,0x73,0x20,0x51,0x7a,0x73,
+0x1f,0x38,0x7e,0x73,0x20,0x51,0x7a,0x73,0x1f,0x39,0xe4,0x7a,0xb3,0x1f,0x62,0xda,
+0x79,0xda,0xd8,0x22,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,0xf, 0xe, 0xd, 0xc, 
+0xb, 0xa, 0x9, 0x8, 0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0, 0x0, 0x1, 0x2, 0x3, 
+0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10,0x11,0x12,0x13,
+0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,0x21,0x22,0x23,
+0x24,0x25,0x1e,0x64,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 0xa0,0x8c,0x8c,0x8b,0x89,0x88,0x86,0x85,0x83,0x82,0x81,0x7f,
+0x7e,0x7c,0x7b,0x79,0x78,0x76,0x75,0x73,0x72,0x70,0x6f,0x6e,0x8c,0x8c,0x8c,0x8c,
+0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x5e,0x56,0x55,0x54,0x53,0x52,0x51,0x50,
+0x4e,0x4c,0x4a,0x48,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,
+0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x5e,0x46,0x46,
+0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
+0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,
+0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x6c,0xaa,0xa, 0x3a,
+0x9, 0xb3,0x20,0x8d,0xa, 0x4a,0x19,0xb4,0x25,0xae,0x7e,0xb3,0x20,0x4d,0xbc,0xba,
+0x38,0x3, 0x2, 0x3e,0xb1,0xa, 0x3a,0x9, 0xb3,0x20,0xe1,0xa, 0x4a,0x19,0xb4,0x25,
+0xde,0x2e,0x34,0x49,0x1, 0x7a,0x71,0x82,0x7a,0x61,0x83,0xe4,0x93,0x19,0xb4,0x26,
+0xe, 0xbe,0xa0,0x26,0x40,0x3, 0x2, 0x3e,0xcf,0x7e,0x50,0x2, 0xac,0x5a,0x7d,0x12,
+0x2e,0x14,0x48,0xb5,0x7e,0x4, 0x0, 0xff,0xb, 0xa, 0x30,0x59,0x32,0x26,0x8f,0xb, 
+0xa0,0xbe,0xa0,0x30,0x78,0xa8,0x74,0x2, 0x7a,0xb3,0x25,0xa7,0x74,0x7f,0x7a,0xb3,
+0x25,0xa3,0x7e,0x34,0x0, 0xf0,0x7a,0x37,0x26,0xef,0x74,0xc8,0x7a,0xb3,0x25,0xab,
+0x74,0x21,0x7a,0xb3,0x25,0xa5,0x53,0xdc,0xe0,0x7e,0xb3,0x21,0x39,0x42,0xdc,0x74,
+0x5d,0x7a,0xb3,0x25,0xa6,0x7e,0xb3,0x20,0x4d,0x7a,0xb3,0x25,0xa8,0xe4,0x7a,0xb3,
+0x26,0x8e,0x7e,0xb3,0x20,0x4e,0xa, 0x4b,0x9, 0xb4,0x1f,0x63,0xbe,0xb3,0x1f,0x64,
+0x38,0x3, 0x2, 0x3f,0x3a,0x7e,0x73,0x1f,0x64,0x7a,0x73,0x25,0xa9,0x7e,0x73,0x20,
+0x4e,0xa, 0x37,0x9, 0x73,0x1f,0x63,0x2, 0x3f,0x42,0x7a,0xb3,0x25,0xa9,0x7e,0x73,
+0x1f,0x64,0x7a,0x73,0x25,0xaa,0x6c,0xaa,0x2, 0x3f,0x59,0xa, 0x3a,0x9, 0xb3,0x20,
+0x5d,0xa, 0x4a,0x19,0xb4,0x26,0x3e,0xb, 0xa0,0x7e,0xb3,0x20,0x4d,0xbc,0xba,0x38,
+0xea,0x22,0x74,0x26,0x7a,0xb3,0x2b,0xcd,0x74,0x18,0x7a,0xb3,0x2b,0xce,0xe4,0x7a,
+0xb3,0x2b,0xcf,0x7a,0xb3,0x2b,0xd0,0x7a,0xb3,0x2b,0xd1,0x7a,0xb3,0x2b,0xd2,0x7a,
+0xb3,0x2b,0xd3,0x74,0x3, 0x7a,0xb3,0x2b,0xd4,0x6d,0x11,0x7a,0x17,0x2b,0xf2,0x6d,
+0x33,0x7a,0x37,0x2b,0xd9,0xe4,0x7a,0xb3,0x2b,0xdb,0x7a,0x37,0x2b,0xd7,0x7a,0x17,
+0x2b,0xf4,0x7e,0x24,0x0, 0x64,0x7a,0x27,0x2b,0xdc,0x7e,0x24,0xff,0xb0,0x7a,0x27,
+0x2b,0xde,0x7e,0x24,0x0, 0x46,0x7a,0x27,0x2b,0xe0,0x7e,0x24,0x0, 0x14,0x7a,0x27,
+0x2b,0xe2,0x7e,0x24,0x0, 0x1e,0x7a,0x27,0x2b,0xe4,0x7a,0x37,0x2b,0xe6,0x7e,0x47,
+0x0, 0x6a,0x7e,0x54,0x0, 0x3, 0xad,0x54,0x7d,0x25,0x1e,0x24,0x1e,0x24,0x7a,0x53,
+0x2b,0xd6,0x7a,0x53,0x2b,0xd5,0x7e,0x24,0x1, 0x90,0x7a,0x27,0x2b,0xea,0x74,0x3c,
+0x7a,0xb3,0x2b,0xef,0x7a,0x17,0x2b,0xc5,0x7a,0x17,0x2b,0xc7,0x7a,0x17,0x2b,0xc9,
+0x7a,0x17,0x2b,0xcb,0x7a,0x27,0x2b,0xfe,0x7a,0x37,0x2b,0xfc,0x7e,0x34,0x3, 0xe8,
+0x7a,0x37,0x2c,0x0, 0x6c,0xaa,0x6d,0x33,0x7e,0x50,0x4, 0xac,0x5a,0x59,0x32,0x27,
+0x94,0x7e,0x34,0x0, 0x1, 0x59,0x32,0x27,0x92,0xb, 0xa0,0xbe,0xa0,0x18,0x40,0xe6,
+0x7a,0x37,0x2c,0x2, 0x74,0x8, 0x7a,0xb3,0x2c,0x4, 0x74,0x5, 0x7a,0xb3,0x2c,0x5, 
+0x74,0x5, 0x7a,0xb3,0x2c,0x6, 0x22,0x7e,0x24,0x2c,0x9, 0x7e,0xb3,0x2c,0x49,0x20,
+0xe0,0x3, 0x2, 0x41,0x2a,0x54,0xfe,0x7a,0xb3,0x2c,0x49,0x7e,0x29,0x70,0xbe,0x73,
+0x0, 0x6c,0x68,0xe, 0x7a,0x73,0x0, 0x6c,0xa, 0x37,0x3e,0x34,0x3e,0x34,0x7a,0x37,
+0x0, 0x6a,0x9, 0x72,0x0, 0x1, 0xa, 0x37,0xbe,0x37,0x0, 0x6d,0x68,0x4, 0x7a,0x37,
+0x0, 0x6d,0x9, 0x72,0x0, 0x5, 0xbe,0x73,0x0, 0x8a,0x68,0x14,0x7a,0x73,0x0, 0x8a,
+0xa, 0x37,0x3e,0x34,0x3e,0x34,0x3e,0x34,0x3e,0x34,0x3e,0x34,0x7a,0x37,0x0, 0x88,
+0x9, 0x72,0x0, 0x2e,0xa, 0x37,0xbe,0x37,0x0, 0x8c,0x68,0x4, 0x7a,0x37,0x0, 0x8c,
+0x9, 0x72,0x0, 0x25,0xa, 0x37,0xbe,0x37,0x20,0x41,0x68,0x4, 0x7a,0x37,0x20,0x41,
+0x9, 0x72,0x0, 0x6, 0xbe,0x73,0x20,0x43,0x68,0x4, 0x7a,0x73,0x20,0x43,0x9, 0x72,
+0x0, 0x8, 0xbe,0x73,0x20,0x46,0x68,0x16,0x7a,0x73,0x20,0x46,0xbe,0x70,0xf, 0x40,
+0x5, 0xe4,0x19,0xb2,0x0, 0x8, 0x7e,0x73,0x20,0x46,0x7a,0x73,0x20,0x45,0x9, 0x72,
+0x0, 0x9, 0xbe,0x73,0x20,0x48,0x68,0x8, 0x7a,0x73,0x20,0x48,0x7a,0x73,0x20,0x47,
+0x9, 0x72,0x0, 0x7, 0xbe,0x73,0x20,0x49,0x68,0x4, 0x7a,0x73,0x20,0x49,0x9, 0x72,
+0x0, 0x29,0xbe,0x73,0x20,0x4a,0x68,0x4, 0x7a,0x73,0x20,0x4a,0x9, 0x72,0x0, 0x24,
+0xbe,0x73,0x20,0x4b,0x68,0x4, 0x7a,0x73,0x20,0x4b,0x22,0xca,0x79,0x20,0x90,0x3, 
+0x2, 0x41,0xbc,0xc2,0x90,0x7e,0xb3,0x2b,0x5b,0x4, 0x7a,0xb3,0x2b,0x5b,0x7e,0xf3,
+0x2b,0x5b,0xbe,0xf0,0x1, 0x78,0x8, 0xe5,0x91,0x7a,0xb3,0x2b,0x65,0x80,0x36,0x7e,
+0xb3,0x2b,0x61,0xc4,0x54,0xf, 0x7c,0xeb,0x5e,0xe0,0x7, 0x78,0x10,0x7c,0xbf,0x2e,
+0xb3,0x2b,0x65,0x24,0xfe,0x7e,0x71,0x91,0x12,0x4f,0xc, 0x80,0x18,0xbe,0xe0,0x4, 
+0x40,0x13,0xbe,0xe0,0x5, 0x68,0xe, 0x7c,0xbf,0x2e,0xb3,0x2b,0x65,0x24,0xfe,0x7e,
+0x71,0x91,0x12,0x23,0x39,0x7e,0xb3,0x2b,0x61,0xc4,0x54,0xf, 0x7c,0x5b,0x5e,0x50,
+0x7, 0xa5,0xbd,0x0, 0x14,0xe4,0x12,0x49,0xcb,0xbe,0xb0,0x10,0x68,0x1e,0x7e,0xb3,
+0x2b,0x65,0x12,0x49,0xcb,0xf5,0x91,0x80,0x13,0xbe,0x50,0x4, 0x40,0xe, 0xbe,0x50,
+0x5, 0x68,0x9, 0x7e,0xb3,0x2b,0x65,0x12,0x2a,0x7c,0xf5,0x91,0x30,0x91,0x4a,0xc2,
+0x91,0x7e,0xb3,0x2b,0x59,0x4, 0x7a,0xb3,0x2b,0x59,0x7e,0xb3,0x2b,0x61,0xc4,0x54,
+0xf, 0x7c,0x5b,0x5e,0x50,0x7, 0xa5,0xbd,0x0, 0x18,0xe4,0x12,0x49,0xcb,0xbe,0xb0,
+0x10,0x68,0x26,0x7e,0xb3,0x2b,0x59,0x2e,0xb3,0x2b,0x65,0x12,0x49,0xcb,0xf5,0x91,
+0x80,0x17,0xbe,0x50,0x4, 0x40,0x12,0xbe,0x50,0x5, 0x68,0xd, 0x7e,0xb3,0x2b,0x59,
+0x2e,0xb3,0x2b,0x65,0x12,0x2a,0x7c,0xf5,0x91,0xda,0x79,0x22,0x7d,0x3, 0x6c,0x44,
+0x6c,0x55,0x6c,0x66,0x6c,0x77,0x2e,0x4, 0xd, 0x80,0x7e,0x30,0x1, 0x6c,0x22,0x80,
+0x5c,0x7e,0x90,0x24,0xac,0x92,0x6c,0xaa,0x80,0x49,0x7d,0xf4,0x3e,0xf4,0x2d,0xf0,
+0xb, 0xf8,0xe0,0xbe,0xe7,0x2b,0xdc,0x18,0xa, 0x6d,0xff,0x9e,0xf7,0x2b,0xdc,0xbd,
+0xef,0x58,0x2c,0x4c,0x33,0x68,0xc, 0x7c,0x4a,0x7c,0x5a,0x7c,0x62,0x7c,0x72,0x6c,
+0x33,0x80,0x1c,0xbc,0xa4,0x50,0x4, 0x7c,0x4a,0x80,0x6, 0xbc,0xa5,0x28,0x2, 0x7c,
+0x5a,0xbc,0x26,0x50,0x4, 0x7c,0x62,0x80,0x6, 0xbc,0x27,0x28,0x2, 0x7c,0x72,0xb, 
+0x44,0xb, 0xa0,0x7e,0xb3,0x2b,0xce,0xbc,0xba,0x38,0xaf,0xb, 0x20,0x7e,0xb3,0x2b,
+0xcd,0xbc,0xb2,0x38,0x9c,0x7e,0x33,0x2b,0xd4,0x7e,0x23,0x2b,0xce,0x7c,0xab,0x4c,
+0x22,0x68,0x3c,0xa, 0x43,0xa, 0x5, 0x2d,0x4, 0xa, 0x42,0x1b,0x44,0xbd,0x4, 0x38,
+0x4, 0x2c,0x53,0x80,0x2, 0x7c,0x59,0xbc,0x34,0x38,0x4, 0x9c,0x43,0x80,0x2, 0x6c,
+0x44,0xa, 0x43,0xa, 0x7, 0x2d,0x4, 0xa, 0x4a,0x1b,0x44,0xbd,0x4, 0x38,0x4, 0x2c,
+0x73,0x80,0x2, 0x7c,0x79,0xbc,0x36,0x38,0x4, 0x9c,0x63,0x80,0x2, 0x6c,0x66,0x7a,
+0x43,0x2b,0xd2,0x7a,0x53,0x2b,0xd1,0x7a,0x63,0x2b,0xd0,0x7a,0x73,0x2b,0xcf,0x22,
+0xca,0x79,0x7d,0x73,0x74,0x6, 0x9, 0x77,0x0, 0x49,0x12,0x56,0x25,0x74,0xa, 0x9, 
+0x77,0x0, 0x4a,0x12,0x56,0x25,0x74,0x8, 0x9, 0x77,0x0, 0x50,0x12,0x56,0x25,0x74,
+0xc, 0x9, 0x77,0x0, 0x4c,0x12,0x56,0x25,0x74,0x2a,0x9, 0x77,0x0, 0x4d,0x12,0x56,
+0x25,0x74,0x2e,0x9, 0x77,0x0, 0x4e,0x12,0x56,0x25,0x74,0x24,0x9, 0x77,0x0, 0x5f,
+0x12,0x56,0x25,0x74,0x2, 0x9, 0x77,0x0, 0x5b,0x12,0x56,0x25,0x74,0x4, 0x9, 0x77,
+0x0, 0x5a,0x12,0x56,0x25,0x74,0x28,0x12,0x56,0x86,0x7c,0x7b,0x5e,0x70,0xf, 0x9, 
+0xb7,0x0, 0x5e,0xc4,0x54,0xf0,0x2c,0x7b,0x74,0x28,0x12,0x56,0x25,0x74,0x26,0x9, 
+0x77,0x0, 0x5c,0x12,0x56,0x25,0x74,0x30,0x9, 0x77,0x0, 0x5d,0x12,0x56,0x25,0x74,
+0x1e,0x9, 0x77,0x0, 0x60,0x12,0x56,0x25,0x74,0x20,0x9, 0x77,0x0, 0x61,0x12,0x56,
+0x25,0x74,0x22,0x9, 0x77,0x0, 0x62,0x12,0x56,0x25,0x74,0x1c,0x9, 0x77,0x0, 0x63,
+0x12,0x56,0x25,0x74,0x18,0x9, 0x77,0x0, 0x64,0x12,0x56,0x25,0x74,0x2e,0x9, 0x77,
+0x0, 0x65,0x12,0x56,0x25,0x74,0x12,0x9, 0x77,0x0, 0x67,0x12,0x56,0x25,0x74,0xe, 
+0x9, 0x77,0x0, 0x66,0x12,0x56,0x25,0xda,0x79,0x22,0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 
+0xe, 0xf, 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x5, 0x6, 
+0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10,0x11,0x12,0x13,0x14,0x15,0x16,
+0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0xe, 
+0xf, 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x25,
+0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 
+0xc, 0xd, 0xe, 0xf, 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,
+0x1c,0x1d,0x1e,0x1f,0x20,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x0, 
+0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10,
+0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,
+0x21,0x22,0x23,0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 
+0xd, 0xe, 0xf, 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,
+0x1d,0x1e,0x1f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,
+0x2d,0x2e,0x2f,0xc2,0xd5,0x7c,0xb4,0x30,0xe7,0x8, 0xb2,0xd5,0x6e,0x24,0xff,0xff,
+0xb, 0x24,0x7c,0xb6,0x30,0xe7,0x12,0xb2,0xd5,0x6e,0x34,0xff,0xff,0xb, 0x34,0x8d,
+0x32,0x6e,0x24,0xff,0xff,0xb, 0x24,0x80,0x2, 0x8d,0x32,0x30,0xd5,0x6, 0x6e,0x34,
+0xff,0xff,0xb, 0x34,0x22,0x7d,0x51,0xad,0x3, 0x7d,0x2, 0x7d,0x21,0xad,0x5, 0x2d,
+0x12,0xad,0x35,0x2d,0x21,0x22,0x7d,0x2, 0xad,0x31,0xad,0x10,0x2d,0x21,0x22,0x6d,
+0x0, 0x74,0x10,0x4d,0x0, 0x78,0xb, 0x4d,0x22,0x78,0x27,0x8d,0x31,0x7d,0x12,0x6d,
+0x22,0x22,0x7d,0x43,0x7d,0x32,0x6d,0x22,0x2f,0x11,0x2d,0x44,0x50,0x2, 0xa5,0xf, 
+0xbf,0x10,0x40,0x4, 0x9f,0x10,0xb, 0x90,0x14,0x78,0xed,0x7f,0x1, 0x6d,0x22,0x7d,
+0x34,0x22,0x7d,0x41,0x7d,0x13,0x8d,0x24,0x7d,0x2, 0x2f,0x0, 0x40,0x4, 0xbd,0x4, 
+0x40,0x4, 0x9d,0x4, 0xb, 0x14,0x14,0x78,0xf1,0x7d,0x23,0x7d,0x31,0x7d,0x10,0x6d,
+0x0, 0x22,0x6c,0xaa,0x4d,0x11,0x68,0x1a,0x1e,0x54,0x68,0xe, 0xb, 0x38,0x20,0x1b,
+0x18,0x20,0xb, 0x35,0xb, 0x15,0x1b,0x54,0x78,0xf2,0x50,0x6, 0x7e,0x39,0x40,0x7a,
+0x19,0x40,0x22,0xca,0x3b,0x7c,0xfb,0x6c,0xee,0x6c,0xdd,0x4c,0xff,0x78,0xe, 0x7e,
+0xb3,0x2b,0xcd,0xf5,0x24,0x7e,0xb3,0x2b,0xce,0xf5,0x25,0x80,0xc, 0x7e,0xb3,0x2b,
+0xce,0xf5,0x24,0x7e,0xb3,0x2b,0xcd,0xf5,0x25,0x6c,0xcc,0x2, 0x45,0xe6,0x75,0x21,
+0x0, 0x80,0x60,0x4c,0xff,0x78,0xe, 0x7e,0x51,0x21,0x74,0x2, 0xac,0x5b,0x7e,0x70,
+0x48,0xac,0x7c,0x80,0xc, 0x7e,0x50,0x2, 0xac,0x5c,0x7e,0x71,0x21,0x74,0x48,0xac,
+0x7b,0x2d,0x32,0x49,0x33,0xe, 0xe, 0x7a,0x35,0x22,0x7e,0x37,0x2b,0xdc,0xbe,0x35,
+0x22,0x58,0xc, 0xb, 0xe0,0x7e,0x73,0x2c,0x5, 0xbc,0x7e,0x28,0x2d,0x80,0x2, 0x6c,
+0xee,0x7e,0x35,0x22,0xbe,0x34,0x0, 0x0, 0x58,0x15,0x12,0x58,0x85,0xbe,0x37,0x2b,
+0xdc,0x28,0xc, 0xb, 0xd0,0x7e,0x73,0x2c,0x5, 0xbc,0x7d,0x28,0xd, 0x80,0x2, 0x6c,
+0xdd,0x5, 0x21,0xe5,0x25,0xbe,0xb1,0x21,0x38,0x99,0x7e,0x73,0x2c,0x5, 0xbc,0x7e,
+0x28,0x4, 0xbc,0x7d,0x38,0xa, 0x7e,0x34,0x0, 0x1, 0x7a,0x37,0x2b,0xf2,0x80,0xf, 
+0x6c,0xee,0x6c,0xdd,0xb, 0xc0,0xe5,0x24,0xbc,0xbc,0x28,0x3, 0x2, 0x45,0x5e,0xda,
+0x3b,0x22,0xca,0x3b,0x7d,0x73,0xe4,0x12,0x59,0x36,0x9, 0xb7,0x0, 0x48,0x12,0x57,
+0xd1,0x74,0x1, 0x12,0x56,0xc5,0x12,0x58,0xc3,0x70,0x4, 0xe4,0x2, 0x46,0x9e,0x74,
+0x14,0x7e,0x70,0x7f,0x12,0x57,0xff,0x70,0x4, 0xe4,0x2, 0x46,0x9e,0x74,0x10,0x12,
+0x56,0x86,0x7c,0x7b,0x5e,0x70,0x3f,0x74,0x10,0x12,0x56,0x25,0x7d,0x37,0x7d,0x27,
+0x2e,0x24,0x0, 0x24,0x12,0x4a,0xe1,0x75,0x22,0x0, 0xe5,0x22,0xa, 0x3b,0x2d,0x37,
+0x9, 0x73,0x0, 0x51,0xa, 0x67,0x2e,0x64,0xc0,0x0, 0xa, 0x5c,0x7c,0x7d,0x12,0x55,
+0x1f,0x5, 0x22,0xe5,0x22,0xb4,0x9, 0xe2,0x75,0x22,0x0, 0x7e,0x71,0x22,0x74,0x2, 
+0xac,0x7b,0x2e,0x34,0x1d,0x4e,0x7e,0x24,0x0, 0xff,0xb, 0x1a,0x60,0xa, 0x5c,0x7c,
+0x7d,0x12,0x55,0x1f,0x5, 0x22,0xe5,0x22,0xb4,0xff,0xe0,0x7e,0x34,0x1f,0x4c,0x7e,
+0x24,0x0, 0xff,0xb, 0x1a,0x30,0xa, 0x56,0x12,0x55,0x1f,0x7d,0x37,0x12,0x42,0xe0,
+0xe4,0x12,0x56,0xc5,0x12,0x58,0xd1,0x60,0x4, 0x74,0x1, 0x80,0x1, 0xe4,0xda,0x3b,
+0x22,0x7d,0x43,0x9, 0x14,0x0, 0x1, 0x7e,0x49,0x20,0x9, 0x34,0x0, 0x8e,0x6c,0xaa,
+0xa9,0x33,0xdd,0x5, 0xa9,0xc3,0xdd,0x80,0x3, 0xa9,0xd3,0xdd,0x9, 0xb4,0x0, 0x35,
+0x9, 0x4, 0x0, 0x34,0xbc,0xb, 0x28,0x3, 0x7e,0xa0,0x1, 0x7a,0x11,0xc3,0x7a,0x21,
+0xc4,0x4c,0x33,0x68,0x3f,0x75,0xba,0x40,0x75,0xb9,0x0, 0x7d,0x32,0xa, 0x16,0x7c,
+0xb3,0xf5,0xbc,0x7c,0xb7,0xf5,0xbb,0x2e,0x34,0xd, 0x80,0xa, 0x16,0x7c,0xb3,0xf5,
+0xc1,0x7c,0xb7,0xf5,0xbd,0xbe,0xa0,0x1, 0x78,0x3, 0x75,0xc2,0x8, 0x43,0xc2,0x3, 
+0x80,0x3, 0x43,0xc2,0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe5,0xc2,0x30,
+0xe7,0xf0,0x80,0x33,0x75,0xba,0x40,0x75,0xb9,0x0, 0x7d,0x32,0x2e,0x34,0xd, 0x80,
+0xa, 0x26,0x7c,0xb5,0xf5,0xc1,0x7c,0xb7,0xf5,0xbd,0xbe,0xa0,0x1, 0x78,0x3, 0x75,
+0xc2,0x8, 0x43,0xc2,0x5, 0x80,0x3, 0x43,0xc2,0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0xe5,0xc2,0x30,0xe7,0xf0,0x75,0xc2,0x0, 0xe4,0x22,0xca,0x79,0x6d,0x11,
+0x6c,0x55,0x6c,0x44,0x1a,0x4b,0x7d,0x4, 0x1b,0x4, 0x7c,0x61,0x80,0x62,0x1a,0x7, 
+0x7d,0xf0,0x1b,0xf4,0x7d,0x7f,0x7c,0xaf,0x80,0x4a,0xbe,0x60,0x0, 0x48,0x43,0xbe,
+0x60,0x26,0x58,0x3e,0xbe,0xa0,0x0, 0x48,0x39,0xbe,0xa0,0x18,0x58,0x34,0xbc,0xb6,
+0x78,0x4, 0xbc,0x7a,0x68,0x2c,0x1a,0xda,0x3e,0xd4,0x1a,0xe6,0x7e,0xf4,0x0, 0x48,
+0xad,0xfe,0x7d,0xef,0x2d,0xed,0x49,0xfe,0xe, 0xe, 0xbe,0xf4,0x0, 0xf, 0x48,0x6, 
+0x2d,0x1f,0xb, 0x50,0x80,0xc, 0xbe,0xf4,0xff,0xf1,0x18,0x4, 0x2d,0x1f,0x80,0x2, 
+0xb, 0x40,0xb, 0xa0,0x7d,0xe0,0xb, 0xe5,0x1a,0xfa,0xbd,0xfe,0x48,0xac,0xb, 0x60,
+0x7d,0xe4,0xb, 0xe5,0x1a,0xf6,0xbd,0xfe,0x48,0x94,0x1a,0x37,0x3e,0x34,0x7e,0x54,
+0x0, 0x48,0xad,0x54,0x2d,0x35,0x49,0x33,0xe, 0xe, 0xbe,0x40,0x4, 0x50,0x14,0xbe,
+0x50,0x3, 0x28,0xf, 0xa, 0x55,0xad,0x53,0xbd,0x51,0x58,0x7, 0xa, 0x25,0x7d,0x31,
+0x12,0x44,0x73,0xda,0x79,0x22,0x75,0xdb,0x0, 0xc2,0xc8,0xa9,0xc7,0xcb,0x7e,0x34,
+0x4, 0x8f,0x12,0x58,0xf6,0x12,0x0, 0x40,0x12,0x59,0x65,0x12,0x59,0x77,0x12,0x59,
+0x1, 0x74,0xff,0x7a,0xb3,0x2c,0x29,0x12,0x33,0x1d,0x74,0x1, 0x7a,0xb3,0x2c,0x30,
+0x7e,0xb3,0x2c,0x30,0x24,0xfd,0x68,0x14,0x14,0x68,0x16,0x24,0xaf,0x68,0x33,0x24,
+0xab,0x68,0x13,0x24,0xa9,0x78,0xe9,0x12,0x18,0xa1,0x80,0xe4,0x12,0x3b,0x79,0x80,
+0xdf,0x12,0x51,0xd5,0x80,0xda,0x6d,0x33,0x7a,0x37,0x1f,0x7c,0x7e,0xb3,0x20,0x4c,
+0xbe,0xb0,0xaa,0x68,0xcb,0xe4,0x7a,0xb3,0x0, 0x86,0x74,0xaa,0x7a,0xb3,0x20,0x4c,
+0x80,0xbe,0x6d,0x33,0x7a,0x37,0x1f,0x7c,0x7e,0xb3,0x20,0x4c,0xb4,0xaa,0xb1,0x74,
+0x55,0x7a,0xb3,0x20,0x4c,0x7e,0x34,0x3, 0xe8,0x7a,0x37,0x2c,0x4e,0x7e,0x37,0x2c,
+0x4e,0x7d,0x23,0x1b,0x24,0x7a,0x27,0x2c,0x4e,0x4d,0x33,0x78,0xf0,0x12,0x57,0x20,
+0x75,0xe9,0xff,0x80,0x8b,0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 0x0, 0x17,0x32,0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
-0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10,0x10,0x10,
-0x1c,0x19,0x14,0x10,0xe, 0xc, 0xb, 0xa, 0x9, 0x8, 0x7, 0x6, 0x1, 0x2, 0x4, 0x8, 
-0x10,0x20,0x40,0x80,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0x8b,0x3d,0x8a,0x3e,0x89,0x3f,0xe4,0xf5,0x45,0xe5,0x45,0xc3,0x95,0x43,0x40,0x3, 
-0x2, 0xa, 0x56,0xab,0x3d,0xaa,0x3e,0xa9,0x3f,0x12,0x6, 0xad,0x12,0x1, 0x65,0xb4,
-0x1c,0x0, 0x40,0x3, 0x2, 0xa, 0x51,0x90,0x8, 0x2e,0xf8,0x28,0x28,0x73,0x2, 0x8, 
-0x82,0x2, 0x8, 0x89,0x2, 0x8, 0x91,0x2, 0x8, 0x99,0x2, 0x8, 0xa1,0x2, 0x8, 0xa9,
-0x2, 0x8, 0xb1,0x2, 0x8, 0xc7,0x2, 0x8, 0xdd,0x2, 0x8, 0xf3,0x2, 0x9, 0x9, 0x2, 
-0x9, 0x1f,0x2, 0x9, 0x42,0x2, 0x9, 0x65,0x2, 0x9, 0x88,0x2, 0x9, 0xab,0x2, 0x9, 
-0xc1,0x2, 0x9, 0xd7,0x2, 0x9, 0xed,0x2, 0xa, 0x3, 0x2, 0xa, 0x18,0x2, 0xa, 0x1f,
-0x2, 0xa, 0x26,0x2, 0xa, 0x2d,0x2, 0xa, 0x34,0x2, 0xa, 0x3b,0x2, 0xa, 0x42,0x2, 
-0xa, 0x49,0x12,0x6, 0xa7,0xe4,0x2, 0xa, 0x4e,0x12,0x6, 0xa7,0x74,0x1, 0x2, 0xa, 
-0x4e,0x12,0x6, 0xa7,0x74,0x2, 0x2, 0xa, 0x4e,0x12,0x6, 0xa7,0x74,0x3, 0x2, 0xa, 
-0x4e,0x12,0x6, 0xa7,0x74,0x4, 0x2, 0xa, 0x4e,0x12,0x6, 0xa7,0x74,0x5, 0x2, 0xa, 
-0x4e,0x12,0x6, 0xc1,0xb4,0x77,0x8, 0x12,0x6, 0xad,0x74,0x13,0x2, 0xa, 0x4e,0x12,
-0x6, 0xad,0x74,0x6, 0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x77,0x8, 0x12,0x6, 0xad,
-0x74,0x14,0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0x7, 0x2, 0xa, 0x4e,0x12,0x6, 0xc1,
-0xb4,0x77,0x8, 0x12,0x6, 0xad,0x74,0x15,0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0x8, 
-0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x77,0x8, 0x12,0x6, 0xad,0x74,0x16,0x2, 0xa, 
-0x4e,0x12,0x6, 0xad,0x74,0x9, 0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x77,0x8, 0x12,
-0x6, 0xad,0x74,0x17,0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0xa, 0x2, 0xa, 0x4e,0xe5,
-0x44,0xb4,0x77,0x8, 0x12,0x6, 0xa7,0x74,0x18,0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,
-0x78,0x8, 0x12,0x6, 0xad,0x74,0x13,0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0xb, 0x2, 
-0xa, 0x4e,0xe5,0x44,0xb4,0x77,0x8, 0x12,0x6, 0xa7,0x74,0x19,0x2, 0xa, 0x4e,0x12,
-0x6, 0xc1,0xb4,0x78,0x8, 0x12,0x6, 0xad,0x74,0x14,0x2, 0xa, 0x4e,0x12,0x6, 0xad,
-0x74,0xc, 0x2, 0xa, 0x4e,0xe5,0x44,0xb4,0x77,0x8, 0x12,0x6, 0xa7,0x74,0x1a,0x2, 
-0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x78,0x8, 0x12,0x6, 0xad,0x74,0x15,0x2, 0xa, 0x4e,
-0x12,0x6, 0xad,0x74,0xd, 0x2, 0xa, 0x4e,0xe5,0x44,0xb4,0x77,0x8, 0x12,0x6, 0xa7,
-0x74,0x1b,0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x78,0x8, 0x12,0x6, 0xad,0x74,0x16,
-0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0xe, 0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x78,
-0x8, 0x12,0x6, 0xad,0x74,0x17,0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0xf, 0x2, 0xa, 
-0x4e,0x12,0x6, 0xc1,0xb4,0x78,0x8, 0x12,0x6, 0xad,0x74,0x18,0x2, 0xa, 0x4e,0x12,
-0x6, 0xad,0x74,0x10,0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x78,0x8, 0x12,0x6, 0xad,
-0x74,0x19,0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0x11,0x2, 0xa, 0x4e,0x12,0x6, 0xc1,
-0xb4,0x78,0x8, 0x12,0x6, 0xad,0x74,0x1a,0x2, 0xa, 0x4e,0x12,0x6, 0xad,0x74,0x12,
-0x2, 0xa, 0x4e,0x12,0x6, 0xc1,0xb4,0x78,0x8, 0x12,0x6, 0xad,0x74,0x1b,0x2, 0xa, 
-0x4e,0x12,0x6, 0xad,0x74,0x13,0x80,0x36,0x12,0x6, 0xa7,0x74,0x14,0x80,0x2f,0x12,
-0x6, 0xa7,0x74,0x15,0x80,0x28,0x12,0x6, 0xa7,0x74,0x16,0x80,0x21,0x12,0x6, 0xa7,
-0x74,0x17,0x80,0x1a,0x12,0x6, 0xa7,0x74,0x18,0x80,0x13,0x12,0x6, 0xa7,0x74,0x19,
-0x80,0xc, 0x12,0x6, 0xa7,0x74,0x1a,0x80,0x5, 0x12,0x6, 0xa7,0x74,0x1b,0x12,0x1, 
-0xd7,0x5, 0x45,0x2, 0x8, 0x9, 0x22,0x8b,0x55,0x8a,0x56,0x89,0x57,0xe4,0xf5,0x5d,
-0xe5,0x5d,0xc3,0x95,0x5b,0x40,0x3, 0x2, 0xc, 0x53,0xab,0x55,0xaa,0x56,0xa9,0x57,
-0x12,0x6, 0xba,0x12,0x1, 0x65,0xb4,0x10,0x0, 0x40,0x3, 0x2, 0xc, 0x4e,0x90,0xa, 
-0x85,0xf8,0x28,0x28,0x73,0x2, 0xa, 0xb5,0x2, 0xa, 0xcf,0x2, 0xa, 0xf2,0x2, 0xb, 
-0x15,0x2, 0xb, 0x38,0x2, 0xb, 0x5b,0x2, 0xb, 0x7e,0x2, 0xb, 0xa1,0x2, 0xb, 0xc4,
-0x2, 0xb, 0xe7,0x2, 0xc, 0x9, 0x2, 0xc, 0x1d,0x2, 0xc, 0x31,0x2, 0xc, 0x38,0x2, 
-0xc, 0x3f,0x2, 0xc, 0x46,0xe5,0x5c,0xb4,0x77,0x5, 0x12,0x6, 0xcc,0x80,0x23,0x12,
-0x6, 0xca,0xb4,0x78,0x3, 0x2, 0xb, 0x30,0x12,0x6, 0xba,0xe4,0x2, 0xc, 0x4b,0xe5,
-0x5c,0xb4,0x77,0x8, 0x12,0x6, 0xb4,0x74,0x5, 0x2, 0xc, 0x4b,0x12,0x6, 0xca,0xb4,
-0x78,0x8, 0x12,0x6, 0xba,0x74,0x4, 0x2, 0xc, 0x4b,0x12,0x6, 0xba,0x74,0x1, 0x2, 
-0xc, 0x4b,0xe5,0x5c,0xb4,0x77,0x8, 0x12,0x6, 0xb4,0x74,0x6, 0x2, 0xc, 0x4b,0x12,
-0x6, 0xca,0xb4,0x78,0x8, 0x12,0x6, 0xba,0x74,0x5, 0x2, 0xc, 0x4b,0x12,0x6, 0xba,
-0x74,0x2, 0x2, 0xc, 0x4b,0xe5,0x5c,0xb4,0x77,0x8, 0x12,0x6, 0xb4,0x74,0x7, 0x2, 
-0xc, 0x4b,0x12,0x6, 0xca,0xb4,0x78,0x8, 0x12,0x6, 0xba,0x74,0x6, 0x2, 0xc, 0x4b,
-0x12,0x6, 0xba,0x74,0x3, 0x2, 0xc, 0x4b,0xe5,0x5c,0xb4,0x77,0x8, 0x12,0x6, 0xb4,
-0x74,0x8, 0x2, 0xc, 0x4b,0x12,0x6, 0xca,0xb4,0x78,0x8, 0x12,0x6, 0xba,0x74,0x7, 
-0x2, 0xc, 0x4b,0x12,0x6, 0xba,0x74,0x4, 0x2, 0xc, 0x4b,0xe5,0x5c,0xb4,0x77,0x8, 
-0x12,0x6, 0xb4,0x74,0x9, 0x2, 0xc, 0x4b,0x12,0x6, 0xca,0xb4,0x78,0x8, 0x12,0x6, 
-0xba,0x74,0x8, 0x2, 0xc, 0x4b,0x12,0x6, 0xba,0x74,0x5, 0x2, 0xc, 0x4b,0xe5,0x5c,
-0xb4,0x77,0x8, 0x12,0x6, 0xb4,0x74,0xa, 0x2, 0xc, 0x4b,0x12,0x6, 0xca,0xb4,0x78,
-0x8, 0x12,0x6, 0xba,0x74,0x9, 0x2, 0xc, 0x4b,0x12,0x6, 0xba,0x74,0x6, 0x2, 0xc, 
-0x4b,0xe5,0x5c,0xb4,0x77,0x8, 0x12,0x6, 0xb4,0x74,0xb, 0x2, 0xc, 0x4b,0x12,0x6, 
-0xca,0xb4,0x78,0x8, 0x12,0x6, 0xba,0x74,0xa, 0x2, 0xc, 0x4b,0x12,0x6, 0xba,0x74,
-0x7, 0x2, 0xc, 0x4b,0xe5,0x5c,0xb4,0x77,0x8, 0x12,0x6, 0xb4,0x74,0xc, 0x2, 0xc, 
-0x4b,0x12,0x6, 0xca,0xb4,0x78,0x8, 0x12,0x6, 0xba,0x74,0xb, 0x2, 0xc, 0x4b,0x12,
-0x6, 0xba,0x74,0x8, 0x2, 0xc, 0x4b,0xe5,0x5c,0xb4,0x77,0x8, 0x12,0x6, 0xb4,0x74,
-0xd, 0x2, 0xc, 0x4b,0x12,0x6, 0xca,0xb4,0x78,0x8, 0x12,0x6, 0xba,0x74,0xc, 0x2, 
-0xc, 0x4b,0x12,0x6, 0xba,0x74,0x9, 0x80,0x42,0x12,0x6, 0xca,0xb4,0x78,0x7, 0x12,
-0x6, 0xba,0x74,0xd, 0x80,0x35,0x12,0x6, 0xba,0x74,0xa, 0x80,0x2e,0x12,0x6, 0xca,
-0xb4,0x78,0x7, 0x12,0x6, 0xba,0x74,0xe, 0x80,0x21,0x12,0x6, 0xba,0x74,0xb, 0x80,
-0x1a,0x12,0x6, 0xb4,0x74,0xc, 0x80,0x13,0x12,0x6, 0xb4,0x74,0xd, 0x80,0xc, 0x12,
-0x6, 0xb4,0x74,0xe, 0x80,0x5, 0x12,0x6, 0xb4,0x74,0xf, 0x12,0x1, 0xd7,0x5, 0x5d,
-0x2, 0xa, 0x60,0x22,0xc0,0x0, 0xc0,0x3f,0xdf,0xbf,0xdf,0xbf,0xc0,0x1, 0xc0,0x82,
-0xc1,0x2, 0xc1,0x1, 0xc0,0x3f,0xdf,0x3d,0xde,0x3c,0xde,0xbe,0xc0,0x2, 0xc1,0x85,
-0xc2,0x85,0xc2,0x2, 0xc0,0x3e,0xde,0x3a,0xdd,0x3a,0xdd,0xbd,0xc0,0x3, 0xc2,0x87,
-0xc4,0x7, 0xc3,0x3, 0xc0,0x3d,0xdd,0x38,0xdb,0xb7,0xdc,0xbc,0xc0,0x4, 0xc3,0x8a,
-0xc5,0x8a,0xc4,0x4, 0xc0,0x3c,0xdc,0x35,0xda,0x35,0xdb,0xbb,0xc0,0x5, 0xc4,0x8c,
-0xc6,0x8d,0xc5,0x5, 0xc0,0x3b,0xdb,0x32,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8e,0xc5,0x86,0xc0,0x3a,0xda,0xb2,0xd8,0xb2,0xda,0xba,0xc0,0x6, 0xc5,0x8e,
-0xc7,0x8d,0xc5,0x5, 0xc0,0x3b,0xdb,0x34,0xd9,0xb4,0xdb,0xbb,0xc0,0x5, 0xc4,0x8b,
-0xc6,0xb, 0xc4,0x4, 0xc0,0x3c,0xdc,0x36,0xdb,0x36,0xdc,0xbc,0xc0,0x4, 0xc3,0x89,
-0xc4,0x88,0xc3,0x3, 0xc0,0x3d,0xdd,0x39,0xdc,0x39,0xdd,0xbd,0xc0,0x3, 0xc2,0x86,
-0xc3,0x6, 0xc2,0x2, 0xc0,0x3e,0xde,0x3b,0xdd,0xbc,0xde,0xbe,0xc0,0x2, 0xc1,0x83,
-0xc1,0x83,0xc1,0x1, 0xc0,0x3f,0xdf,0x3e,0xdf,0x3e,0xdf,0xbf,0xc0,0x0, 0xc0,0x81,
-0xc0,0x80,0xc0,0x0, 0x8b,0x33,0x8a,0x34,0x89,0x35,0xe5,0x37,0xd3,0x94,0xa, 0x50,
-0x36,0xed,0x94,0xf, 0x50,0x31,0xe5,0x37,0xc3,0x94,0xa, 0x50,0x2a,0xe5,0x37,0x90,
-0x7, 0x5, 0x93,0xff,0x24,0x4, 0xab,0x33,0x20,0xe0,0xd, 0xf1,0xec,0xfa,0xef,0xd1,
-0xac,0x54,0xf0,0xd1,0x98,0x4d,0x80,0xc, 0xd1,0x9d,0x54,0xf, 0xd1,0x98,0xff,0xed,
-0xc4,0x54,0xf0,0x4f,0x12,0x1, 0xc5,0x22,0x12,0x1, 0xc5,0xab,0x33,0xe5,0x35,0x24,
-0x10,0xf9,0xe4,0x35,0x34,0xfa,0xe5,0x37,0x90,0x7, 0x5, 0x93,0x24,0x4, 0xff,0xe4,
-0x33,0xa2,0xe7,0x13,0xfe,0xef,0x13,0x29,0xf9,0xea,0x3e,0xfa,0x2, 0x1, 0x4c,0xf1,
-0xcd,0xe4,0xf5,0x2d,0xe5,0x2d,0x20,0xe0,0x13,0xab,0x29,0xf1,0xaf,0xe5,0x2d,0xc3,
-0x13,0x7e,0x0, 0x29,0xf9,0xee,0x3a,0xfa,0xe4,0x12,0x1, 0xc5,0xe5,0x2d,0xc3,0x94,
-0xa, 0x50,0x1c,0x74,0x2d,0x25,0x2d,0xf1,0xe4,0xe0,0xff,0xe5,0x2d,0x90,0x7, 0x5, 
-0x93,0x24,0x4, 0xf5,0x82,0xe4,0x33,0xf5,0x83,0xf1,0xba,0xef,0x12,0x1, 0xd7,0x5, 
-0x2d,0xe5,0x2d,0xb4,0x10,0xbe,0xe4,0xf5,0x2d,0xe5,0x2d,0x20,0xe0,0x5, 0xf1,0xc1,
-0xe0,0x80,0x9, 0xe5,0x2d,0xf1,0xc1,0xe0,0x54,0xf0,0xff,0xc4,0x54,0xf, 0xf5,0x2c,
-0xe5,0x2d,0xc3,0x94,0xa, 0x50,0x2a,0xe5,0x2d,0x90,0x7, 0x5, 0x93,0xff,0x24,0x4, 
-0xab,0x29,0x20,0xe0,0x9, 0xf1,0xaf,0xef,0xd1,0xac,0x45,0x2c,0x80,0x10,0xf1,0xaf,
-0xe5,0x2d,0x90,0x7, 0x5, 0xd1,0xab,0xff,0xe5,0x2c,0xc4,0x54,0xf0,0x4f,0x12,0x1, 
-0xc5,0x5, 0x2d,0xe5,0x2d,0x64,0x10,0x70,0xb0,0x90,0xa, 0xe7,0xf1,0xb9,0x90,0x0, 
-0x18,0x12,0x1, 0xd7,0x90,0xb, 0x11,0xe0,0x90,0x0, 0x19,0xf1,0xdc,0x90,0x0, 0x1a,
-0x12,0x1, 0xd7,0x90,0x0, 0x1b,0xe4,0xf1,0xd4,0x90,0x0, 0x1c,0x12,0x1, 0xd7,0x90,
-0x0, 0x1e,0x74,0x13,0x12,0x1, 0xd7,0x90,0x0, 0x20,0x74,0x3, 0x12,0x1, 0xd7,0x90,
-0x0, 0x21,0x74,0x3f,0x12,0x1, 0xd7,0x90,0x0, 0x22,0x74,0x3f,0x12,0x1, 0xd7,0x90,
-0x0, 0x1d,0xf1,0xf5,0x74,0x1, 0x12,0x1, 0xd7,0x12,0x61,0x61,0x8f,0x2c,0x22,0xe5,
-0x2b,0x24,0x10,0xf9,0xe4,0x35,0x2a,0xfa,0x22,0xe0,0xab,0x29,0xaa,0x2a,0xa9,0x2b,
-0x22,0xc3,0x13,0x24,0x4b,0xf5,0x82,0xe4,0x34,0xb, 0xf5,0x83,0x22,0x8b,0x29,0x8a,
-0x2a,0x89,0x2b,0x22,0x12,0x1, 0xd7,0x90,0xa, 0xe9,0xe0,0x22,0x12,0x1, 0xd7,0x90,
-0xb, 0x3d,0xe0,0x22,0xf5,0x82,0xe4,0x34,0xb, 0xf5,0x83,0x22,0xe5,0x35,0x24,0x10,
-0xf9,0xe4,0x35,0x34,0x22,0x74,0xa, 0x12,0x1, 0xd7,0x90,0x0, 0x1f,0x22,0x7b,0x1, 
-0x7a,0xa, 0x79,0xe5,0xf1,0xfa,0x90,0x0, 0x52,0xf1,0xdf,0xf5,0x30,0x12,0x46,0x4f,
-0xf5,0x31,0x74,0x1, 0x12,0x65,0x30,0xe4,0x12,0x1, 0xd7,0xe4,0xf5,0x2d,0xab,0x21,
-0xe5,0x23,0x24,0x58,0x12,0x62,0x44,0xf5,0x83,0xed,0xf0,0x5, 0x2d,0xe5,0x2d,0xb4,
-0xe, 0xec,0xe4,0xf5,0x2f,0xf5,0x2d,0xb1,0x81,0xe0,0xff,0xc3,0x95,0x2f,0x40,0x2, 
-0x8f,0x2f,0x5, 0x2d,0xe5,0x2d,0xb4,0xf, 0xee,0xe5,0x2f,0xc3,0x94,0xf, 0x50,0x9, 
-0xc3,0x74,0xf, 0x95,0x2f,0xf5,0x2f,0x80,0x3, 0xe4,0xf5,0x2f,0xe4,0xf5,0x2d,0xab,
-0x21,0xe5,0x23,0x24,0x66,0x12,0x62,0x44,0xf5,0x83,0xed,0xf0,0x5, 0x2d,0xe5,0x2d,
-0xb4,0x8, 0xec,0x85,0x2f,0x2e,0xaf,0x2e,0x15,0x2e,0xef,0x70,0x2, 0x21,0xd6,0x12,
-0x0, 0x4e,0x12,0x47,0x5b,0xab,0x2a,0xaa,0x2b,0xa9,0x2c,0x12,0x61,0x61,0x12,0x45,
-0xc, 0x85,0x27,0x49,0x85,0x28,0x4a,0x85,0x29,0x4b,0xb1,0xb1,0x12,0x45,0xe2,0x60,
-0xf0,0xe4,0xf5,0x2d,0xb1,0xb1,0x12,0x66,0xf, 0x50,0x58,0xe4,0xfd,0xf1,0xdc,0xff,
-0xed,0xc3,0x9f,0x50,0x4a,0xe5,0x2d,0x70,0xc, 0x12,0x64,0xb0,0xe4,0xf0,0xed,0x51,
-0x23,0xe4,0xf0,0xa3,0xf0,0xb1,0x1c,0xe5,0x2d,0x12,0x4c,0x3c,0xed,0xb1,0x56,0xd3,
-0x94,0xf8,0xee,0x64,0x80,0x94,0xaa,0x50,0x23,0xc3,0xef,0x94,0x70,0xee,0x64,0x80,
-0x94,0x97,0x40,0x18,0xef,0x78,0x5, 0x12,0x46,0x55,0xd8,0xfb,0xff,0xed,0x51,0x23,
-0xee,0x8f,0xf0,0x12,0x2, 0x60,0x12,0x64,0xb0,0xe0,0x4, 0xf0,0xd, 0x80,0xae,0x5, 
-0x2d,0x80,0xa1,0xe4,0xf5,0x32,0xf5,0x2d,0xf1,0xdc,0xff,0xe5,0x2d,0xc3,0x9f,0x40,
-0x2, 0x21,0xce,0x74,0x8a,0x25,0x2d,0x12,0x64,0xb3,0xe0,0xfd,0x70,0x9, 0xe5,0x2d,
-0x51,0x23,0x12,0x66,0x9f,0x80,0x3a,0xe5,0x2d,0x51,0x23,0xc0,0x83,0xc0,0x82,0xe0,
-0xfe,0xa3,0xe0,0xff,0x7c,0x0, 0x12,0x2, 0xb, 0xd0,0x82,0xd0,0x83,0xee,0xf0,0xa3,
-0xef,0xf0,0xe5,0x2d,0x51,0x23,0xc0,0x83,0xc0,0x82,0xe0,0xfe,0xa3,0xe0,0x78,0x5, 
-0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xff,0xd0,0x82,0xd0,0x83,0xee,0xf0,0xa3,0xef,
-0xf0,0xf1,0x63,0x90,0x0, 0x73,0xb1,0x5c,0x90,0x0, 0xe, 0x12,0x65,0x84,0xe5,0x2d,
-0x51,0x23,0x12,0x66,0x21,0x50,0x12,0xb1,0x81,0xe0,0xc3,0x95,0x2f,0x50,0x6, 0xb1,
-0x81,0xe0,0x4, 0x80,0x2c,0x5, 0x32,0x80,0x41,0xf1,0x63,0x90,0x0, 0x73,0xb1,0x5c,
-0x90,0x0, 0xe, 0x12,0x2, 0xb7,0x2f,0xff,0xe5,0xf0,0x3e,0xfe,0xe5,0x2d,0x51,0x23,
-0x12,0x66,0x2a,0x40,0x23,0xb1,0x81,0xe0,0xd3,0x94,0x0, 0x40,0x17,0xb1,0x81,0xe0,
-0x14,0xf0,0xab,0x2a,0xaa,0x2b,0xa9,0x2c,0xb1,0x81,0xe0,0xfd,0x85,0x2d,0x37,0x12,
-0xe, 0x54,0x80,0x6, 0x5, 0x32,0x80,0x2, 0x5, 0x32,0x5, 0x2d,0x21,0x8, 0xf1,0xdc,
-0x65,0x32,0x60,0x2, 0x1, 0x76,0xe4,0xf5,0x2d,0x12,0x62,0x75,0xf5,0x83,0xe0,0xc4,
-0x54,0xf0,0xfd,0x74,0x6e,0x2f,0xf5,0x82,0x74,0xa, 0x3e,0xf5,0x83,0xe0,0x54,0xf, 
-0x4d,0xff,0xab,0x21,0xe5,0x23,0x24,0x66,0xf9,0xe4,0x35,0x22,0xfa,0xe5,0x2d,0x12,
-0x25,0xec,0xef,0x12,0x1, 0xc5,0x5, 0x2d,0xe5,0x2d,0xb4,0x8, 0xcc,0xb1,0xb1,0xe5,
-0x30,0x12,0x65,0x30,0xe5,0x31,0x12,0x1, 0xd7,0x7f,0x1, 0x22,0x12,0x4, 0xf2,0xe5,
-0x2f,0x25,0xe0,0x25,0xe0,0x24,0x36,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0x12,
-0x65,0xd1,0xe4,0x90,0xa, 0x4a,0xf0,0xf5,0x2a,0xb1,0x38,0x90,0x0, 0x4, 0x74,0xff,
-0x12,0x1, 0xd7,0xb1,0x63,0x74,0xff,0xf0,0xe5,0x2a,0x51,0x23,0x74,0xff,0xf0,0xa3,
-0xf0,0xb1,0x75,0xe4,0xf0,0x5, 0x2a,0xe5,0x2a,0xb4,0x5, 0xdd,0xb1,0x1c,0xb1,0x6f,
-0x70,0x2d,0x90,0x0, 0x42,0x12,0x1, 0x65,0x70,0x2, 0x81,0x72,0xe4,0xf5,0x2a,0xb1,
-0x1c,0x90,0x0, 0x2d,0xe5,0x2a,0x12,0x52,0x10,0xb1,0x1c,0x90,0x0, 0x37,0x75,0xf0,
-0x2, 0xe5,0x2a,0x12,0x52,0x13,0x5, 0x2a,0xe5,0x2a,0xb4,0x5, 0xe2,0x81,0x72,0xb1,
-0x1c,0x90,0x0, 0x42,0x12,0x1, 0x65,0x70,0x39,0xf5,0x2a,0xb1,0x1c,0xb1,0x6f,0xff,
-0xe5,0x2a,0xc3,0x9f,0x40,0x2, 0x81,0x72,0x75,0xf0,0x7, 0xe5,0x2a,0xb1,0x98,0xb1,
-0x5c,0x12,0x66,0x6, 0xb1,0x2f,0x90,0x0, 0x2, 0x12,0x2, 0xb7,0xff,0xe5,0x2a,0xb1,
-0x23,0x90,0x0, 0x4, 0xe5,0x2a,0x12,0x1, 0xd7,0xb1,0x75,0x74,0x1, 0xf0,0x5, 0x2a,
-0x80,0xc9,0xe4,0xf5,0x2a,0xb1,0x1c,0xb1,0x6f,0xff,0xe5,0x2a,0xc3,0x9f,0x50,0x66,
-0xe4,0xf5,0x2b,0xb1,0x1c,0x90,0x0, 0x37,0xe5,0x2b,0x12,0x65,0xa0,0x12,0x1b,0xf6,
-0xe5,0x2a,0x75,0xf0,0x7, 0x12,0x2e,0x6, 0xfa,0x90,0x0, 0x2, 0x12,0x2, 0xb7,0x12,
-0x47,0x7a,0xc0,0x6, 0xc0,0x7, 0xb1,0x1c,0x12,0x66,0x3b,0xb1,0x59,0x75,0xf0,0x7, 
-0xe5,0x2a,0xb1,0x98,0x12,0x65,0x84,0x12,0x0, 0x6, 0xd0,0xe0,0x2f,0xff,0xd0,0xe0,
-0x3e,0xfe,0xe5,0x2a,0x51,0x23,0x12,0x66,0x2a,0x40,0xe, 0xb1,0x63,0xe5,0x2b,0xf0,
-0xe5,0x2a,0x51,0x23,0xee,0xf0,0xa3,0xef,0xf0,0x5, 0x2b,0xe5,0x2b,0xc3,0x94,0x5, 
-0x40,0xa1,0x5, 0x2a,0x80,0x8f,0xe4,0xf5,0x2a,0xb1,0x1c,0xb1,0x6f,0xff,0xe5,0x2a,
-0xc3,0x9f,0x40,0x2, 0x61,0xf0,0x90,0xa, 0x4a,0x74,0x1, 0xf0,0xe4,0xf5,0x2b,0xb1,
-0x1c,0xb1,0x6f,0xff,0xe5,0x2b,0xc3,0x9f,0x50,0x31,0xe5,0x2a,0x65,0x2b,0x60,0x27,
-0x74,0x40,0x25,0x2b,0xb1,0x67,0xe0,0xff,0xb1,0x63,0xe0,0xb5,0x7, 0x19,0xe5,0x2b,
-0x51,0x23,0xe0,0xfe,0xa3,0xe0,0xff,0xe5,0x2a,0x51,0x23,0x12,0x66,0x21,0x40,0x7, 
-0xe4,0x90,0xa, 0x4a,0xf0,0x80,0x4, 0x5, 0x2b,0x80,0xc4,0x90,0xa, 0x4a,0xe0,0x64,
-0x1, 0x70,0x49,0xb1,0x63,0xe0,0x24,0x45,0xb1,0x79,0x74,0x1, 0xf0,0xb1,0x63,0xe0,
-0xfd,0xb1,0x38,0x90,0x0, 0x4, 0xed,0x12,0x1, 0xd7,0xb1,0x1c,0x75,0xf0,0x7, 0xe5,
-0x2a,0xb1,0x98,0xb1,0x5c,0xe9,0x24,0x2d,0xf9,0xe4,0x3a,0xfa,0xb1,0x63,0xe0,0xb1,
-0x95,0xb1,0x32,0x90,0x0, 0x2, 0xb1,0x5c,0xe5,0x29,0x24,0x37,0xf9,0xe4,0x35,0x28,
-0xfa,0xb1,0x63,0xe0,0xb1,0x95,0xee,0x8f,0xf0,0x12,0x3, 0x5b,0x5, 0x2a,0x61,0x49,
-0xe4,0xf5,0x2a,0xb1,0x1c,0xb1,0x6f,0xff,0xe5,0x2a,0xc3,0x9f,0x50,0x50,0xe5,0x2a,
-0x75,0xf0,0x7, 0x12,0x2e,0x6, 0xfa,0xf1,0xee,0xf4,0x70,0x3e,0xf5,0x2b,0x74,0x45,
-0x25,0x2b,0xb1,0x79,0xe0,0x70,0x2b,0x74,0x45,0x25,0x2b,0xb1,0x79,0x74,0x1, 0xf0,
-0xb1,0x1c,0x75,0xf0,0x7, 0xe5,0x2a,0xb1,0x98,0xb1,0x5c,0x12,0x66,0x3b,0xb1,0x2f,
-0x90,0x0, 0x2, 0x12,0x3f,0xa8,0xb1,0x23,0x90,0x0, 0x4, 0xe5,0x2b,0x12,0x1, 0xd7,
-0x80,0x8, 0x5, 0x2b,0xe5,0x2b,0x64,0x5, 0x70,0xc4,0x5, 0x2a,0x80,0xa5,0xe4,0xf5,
-0x2a,0xb1,0x75,0xe0,0x70,0x15,0xb1,0x1c,0x12,0x66,0x6, 0x12,0x52,0x13,0xb1,0x1c,
-0x90,0x0, 0x37,0x75,0xf0,0x2, 0xe5,0x2a,0x12,0x52,0x13,0x5, 0x2a,0xe5,0x2a,0xb4,
-0x5, 0xdf,0xb1,0x1c,0xb1,0x6f,0xf5,0x2b,0xe4,0xf5,0x2a,0xb1,0x75,0xe0,0x64,0x1, 
-0x70,0x2e,0xab,0x27,0xe5,0x29,0x24,0x28,0xf1,0xcd,0x12,0x1, 0x4c,0xb4,0x1, 0x5, 
-0x74,0x3, 0x12,0x1, 0xc5,0x12,0x1, 0x4c,0xff,0xb4,0x3, 0xb, 0x12,0x65,0x49,0xe5,
-0x2a,0x12,0x25,0xec,0xe4,0x80,0x38,0xef,0x70,0x38,0xf1,0xc7,0x74,0x2, 0x80,0x2f,
-0xab,0x27,0xe5,0x29,0x24,0x28,0xf1,0xcd,0x12,0x1, 0x4c,0xff,0x64,0x2, 0x60,0x3, 
-0xef,0x70,0x18,0xf1,0xc7,0x74,0x1, 0x12,0x1, 0xc5,0xaf,0x2b,0x5, 0x2b,0xef,0xb1,
-0x3a,0x90,0x0, 0x4, 0xe5,0x2a,0x12,0x1, 0xd7,0x80,0x7, 0xf1,0xc7,0x74,0x3, 0x12,
-0x1, 0xc5,0x12,0x65,0x49,0xaf,0x2a,0x7e,0x0, 0x12,0x63,0x7a,0x12,0x1, 0x4c,0xfd,
-0xe5,0x29,0x24,0x28,0x12,0x63,0x75,0xed,0x12,0x1, 0xc5,0x5, 0x2a,0xe5,0x2a,0x64,
-0x5, 0x60,0x2, 0x81,0x7b,0x22,0xef,0x25,0xe0,0xff,0xee,0x33,0xfe,0xe5,0x3f,0x2f,
-0xf5,0x82,0xe5,0x3e,0x3e,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0xff,0xab,0x27,0xaa,0x28,
-0xa9,0x29,0x22,0xae,0xf0,0xaa,0x28,0xa9,0x29,0x90,0x0, 0x37,0x75,0xf0,0x2, 0x12,
-0x5, 0x40,0xee,0x8f,0xf0,0x12,0x3, 0x5b,0xe5,0x2a,0x75,0xf0,0x7, 0xa4,0xab,0x27,
-0x25,0x29,0xf9,0xe5,0x28,0x35,0xf0,0xfa,0x22,0x90,0x3, 0x80,0x75,0xf0,0x20,0xe5,
-0x26,0x12,0x5, 0x40,0xe5,0x24,0x75,0xf0,0x2, 0x12,0x5, 0x40,0x12,0x2, 0xb7,0xff,
-0xae,0xf0,0x22,0x74,0x40,0x25,0x2a,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0x90,
-0x0, 0x41,0x2, 0x1, 0x65,0x74,0x45,0x25,0x2a,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,
-0x22,0x74,0x6e,0x25,0x2d,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0xe5,0x2f,0xab,
-0x2a,0xaa,0x2b,0xa9,0x2c,0x75,0xf0,0x2, 0xa4,0xf5,0x82,0x85,0xf0,0x83,0x22,0x85,
-0x27,0x33,0x85,0x28,0x34,0x85,0x29,0x35,0x85,0x2a,0x36,0x85,0x2b,0x37,0x85,0x2c,
-0x38,0xab,0x24,0xaa,0x25,0xa9,0x26,0x22,0xf1,0xfa,0xb1,0xb1,0x90,0x0, 0x49,0xe4,
-0x12,0x1, 0xd7,0xf1,0xe8,0xff,0x60,0x5, 0xd3,0x94,0x2, 0x40,0x9, 0xb1,0xb1,0x90,
-0x0, 0x4a,0xe4,0x2, 0x1, 0xd7,0xef,0x64,0x2, 0x70,0x39,0xb1,0xb1,0xf1,0xf4,0xc3,
-0x94,0x2, 0x50,0x30,0xf1,0x42,0x90,0x0, 0x2, 0xf1,0xc0,0x90,0x0, 0xa, 0xf1,0x59,
-0x90,0x0, 0x4, 0xf1,0xc0,0xb1,0xb1,0x90,0x0, 0xc, 0xf1,0x5f,0x90,0x0, 0x6, 0xf1,
-0xc0,0xab,0x24,0xe5,0x26,0x24,0x4f,0xf9,0xe4,0x35,0x25,0xfa,0x12,0x1, 0x4c,0x44,
-0x20,0x12,0x1, 0xc5,0xb1,0xb1,0x12,0x1e,0x6, 0xc4,0x54,0xf, 0x30,0xe0,0x9, 0xf1,
-0x42,0x90,0x0, 0x2, 0xf1,0xc0,0xe1,0xc, 0xb1,0xb1,0xf1,0xe8,0x64,0x2, 0x60,0x2, 
-0xe1,0xc, 0xf1,0xf4,0x64,0x2, 0x60,0x2, 0xe1,0xc, 0xb1,0x1c,0x12,0x1, 0x4c,0x64,
-0x1, 0x70,0x2, 0xe1,0x41,0xf1,0x63,0x90,0x0, 0x4, 0xb1,0x5c,0x12,0x2, 0x8c,0xfd,
-0xac,0xf0,0xc3,0xef,0x9d,0xf5,0x2b,0xee,0x9c,0xf5,0x2a,0x90,0x0, 0x2, 0xb1,0x5c,
-0x90,0x0, 0x6, 0x12,0x65,0x41,0xf5,0x2d,0xec,0x9e,0xf5,0x2c,0xb1,0xb1,0x90,0x0, 
-0x3, 0xb1,0x5c,0x90,0x0, 0xa, 0x12,0x65,0x41,0xf5,0x2f,0xec,0x9e,0xf5,0x2e,0x90,
-0x0, 0x5, 0xb1,0x5c,0x90,0x0, 0xc, 0x12,0x65,0x41,0xf5,0x31,0xec,0x9e,0xf5,0x30,
-0x12,0x65,0xcb,0x70,0x77,0xaf,0x2d,0xae,0x2c,0x12,0x0, 0x6, 0xc0,0x6, 0xc0,0x7, 
-0xaf,0x2b,0xae,0x2a,0x12,0x0, 0x6, 0xd0,0xe0,0x2f,0xf5,0x33,0xd0,0xe0,0x3e,0xf5,
-0x32,0xaf,0x31,0xae,0x30,0x12,0x0, 0x6, 0xc0,0x6, 0xc0,0x7, 0xaf,0x2f,0xae,0x2e,
-0x12,0x0, 0x6, 0xd0,0xe0,0x2f,0xff,0xd0,0xe0,0x3e,0xfe,0xb1,0x1c,0xf1,0xee,0x7c,
-0x0, 0x25,0x33,0xfd,0xec,0x35,0x32,0xfc,0xc3,0xef,0x9d,0xec,0x12,0x43,0x3b,0x40,
-0x9, 0xb1,0xb1,0x90,0x0, 0x49,0x74,0x48,0x80,0x1f,0xb1,0x1c,0xf1,0xee,0x2f,0xff,
-0xe4,0x3e,0xfe,0xc3,0xe5,0x33,0x9f,0xee,0x64,0x80,0xf8,0xe5,0x32,0x64,0x80,0x98,
-0x40,0xa, 0xb1,0xb1,0x90,0x0, 0x49,0x74,0x49,0x12,0x1, 0xd7,0xb1,0xb1,0x12,0x65,
-0xcb,0x60,0x2e,0x12,0x5b,0x70,0x44,0x2, 0x12,0x1, 0xc5,0xb1,0xb1,0xf1,0x42,0x90,
-0x0, 0x2, 0xf1,0xc0,0xb1,0xb1,0xf1,0xe8,0xb4,0x2, 0x16,0x90,0x0, 0xa, 0xf1,0x5f,
-0x90,0x0, 0x4, 0xf1,0xc0,0xb1,0xb1,0x90,0x0, 0xc, 0xf1,0x5f,0x90,0x0, 0x6, 0xf1,
-0xc0,0x22,0x90,0x0, 0x3, 0x12,0x2, 0xb7,0xff,0xab,0x21,0xaa,0x22,0xa9,0x23,0xe5,
-0xf0,0x8f,0xf0,0x12,0x3, 0x3c,0x90,0x0, 0x5, 0xab,0x24,0xaa,0x25,0xa9,0x26,0x12,
-0x2, 0xb7,0xff,0xab,0x21,0xaa,0x22,0xa9,0x23,0x22,0xf1,0xfa,0xb1,0xb1,0x12,0x4c,
-0x59,0xf1,0x63,0x90,0x0, 0x41,0x12,0x1, 0xd7,0xab,0x24,0x12,0x66,0x4d,0xfa,0xa8,
-0x23,0xac,0x22,0xad,0x21,0x12,0x65,0x3a,0xf1,0x63,0x51,0x2f,0xf1,0x63,0x90,0x0, 
-0x43,0x12,0x5, 0x6c,0x8b,0x2a,0x8a,0x2b,0x89,0x2c,0xf1,0x63,0x12,0x38,0xcc,0x12,
-0x66,0x4d,0xa8,0x1, 0xfc,0xad,0x24,0xf1,0x63,0x12,0x65,0x3a,0xf1,0x63,0xb1,0x6f,
-0x90,0x0, 0x42,0x12,0x1, 0xd7,0xb1,0x6f,0xb1,0xb1,0x90,0x0, 0x2d,0x2, 0x1, 0xd7,
-0xe5,0xf0,0x8f,0xf0,0x2, 0x3, 0x5b,0xab,0x27,0xe5,0x29,0x24,0x23,0xf9,0xe4,0x35,
-0x28,0xfa,0x7e,0x0, 0xe9,0x25,0x2a,0xf9,0xee,0x3a,0xfa,0x22,0x90,0x0, 0x1, 0xab,
-0x24,0xaa,0x25,0xa9,0x26,0x2, 0x1, 0x65,0x90,0x0, 0x4b,0x2, 0x1, 0x65,0x90,0x0, 
-0x4, 0x2, 0x1, 0x65,0x90,0x0, 0x4c,0x2, 0x1, 0x65,0x8b,0x21,0x8a,0x22,0x89,0x23,
-0x22,0xc3,0xee,0x94,0x0, 0x40,0x2, 0x80,0x3, 0xe4,0xfe,0xff,0xe4,0x7b,0x34,0x12,
-0x20,0x2b,0x12,0x4, 0xbb,0x70,0x3, 0x12,0x20,0x58,0xe4,0xff,0x7e,0x3, 0x12,0x20,
-0x4c,0x12,0x4, 0xbb,0x40,0xb, 0xe4,0x75,0x34,0xff,0x75,0x33,0x2, 0xf5,0x32,0xf5,
-0x31,0xae,0x33,0xaf,0x34,0x22,0x12,0x17,0xfa,0x12,0x15,0x1c,0x12,0x17,0xe8,0xf5,
-0x2f,0x12,0x17,0xf4,0xf5,0x30,0xe4,0xf5,0x2c,0xb1,0xf6,0x74,0xff,0xf0,0xb1,0xd6,
-0x12,0x12,0x25,0x12,0x66,0x5f,0x12,0x63,0x81,0x12,0x66,0x5f,0x5, 0x2c,0xe5,0x2c,
-0xb4,0x5, 0xe6,0xe5,0x2f,0x70,0x32,0xe5,0x30,0xd3,0x94,0x0, 0x50,0x2, 0x61,0xdb,
-0xe4,0xf5,0x2d,0xe5,0x2d,0x12,0x15,0x3a,0x90,0x0, 0x2a,0x74,0xff,0x12,0x1, 0xd7,
-0x5, 0x2d,0xe5,0x2d,0xb4,0x5, 0xec,0x12,0x63,0xa0,0x44,0x4, 0x12,0x1, 0xc5,0x54,
-0xf7,0x12,0x1, 0xc5,0x54,0xdf,0x2, 0x1, 0xc5,0xe4,0xf5,0x2d,0xe5,0x2d,0xc3,0x95,
-0x2f,0x50,0x28,0xe5,0x2d,0x75,0xf0,0x7, 0xa4,0xfd,0xac,0xf0,0x12,0x62,0xea,0x3c,
-0xfa,0xe9,0x24,0xa, 0x12,0x63,0xae,0xab,0x21,0xe5,0x23,0x2d,0xf9,0xe5,0x22,0x3c,
-0xfa,0xe9,0x24,0xc, 0x12,0x63,0xae,0x5, 0x2d,0x80,0xd1,0xe5,0x30,0x70,0x8, 0x12,
-0x63,0xa0,0x44,0x10,0x12,0x1, 0xc5,0xe4,0xf5,0x2c,0xf5,0x2d,0xe4,0xf5,0x2e,0xe5,
-0x2e,0xc3,0x95,0x2f,0x50,0x3a,0x71,0xe2,0xb1,0xc4,0xfd,0xe5,0x2d,0x12,0x15,0x3a,
-0xf1,0xf3,0xff,0x6d,0x70,0x26,0xef,0xf4,0x60,0x22,0xb1,0xef,0xef,0xf0,0x90,0x0, 
-0x26,0x12,0x15,0x5c,0xb1,0xd6,0x12,0x12,0x25,0xee,0xf0,0xa3,0xef,0xf0,0x90,0x0, 
-0x28,0x12,0x15,0x5c,0x12,0x63,0x81,0x12,0x66,0x6f,0x80,0x4, 0x5, 0x2e,0x80,0xbf,
-0x5, 0x2d,0xe5,0x2d,0x64,0x5, 0x70,0xb4,0xe4,0xf5,0x2d,0x85,0x2f,0x2e,0xe5,0x2e,
-0xc3,0x94,0x5, 0x50,0x3a,0x71,0xe2,0xb1,0xc4,0xfd,0xe5,0x2d,0x12,0x15,0x3a,0xf1,
-0xf3,0xff,0x6d,0x70,0x26,0xef,0xf4,0x60,0x22,0xb1,0xef,0xef,0xf0,0x90,0x0, 0x26,
-0x12,0x15,0x5c,0xb1,0xd6,0x12,0x12,0x25,0xee,0xf0,0xa3,0xef,0xf0,0x90,0x0, 0x28,
-0x12,0x15,0x5c,0x12,0x63,0x81,0x12,0x66,0x6f,0x80,0x4, 0x5, 0x2e,0x80,0xbf,0x5, 
-0x2d,0xe5,0x2d,0x64,0x5, 0x70,0xb4,0xe4,0xf5,0x2e,0xe4,0xf5,0x2d,0xe5,0x2d,0xc3,
-0x95,0x2c,0x50,0x11,0x71,0xe2,0xb1,0xc4,0xff,0xe5,0x2d,0xb1,0xf8,0xe0,0x6f,0x60,
-0x4, 0x5, 0x2d,0x80,0xe8,0xe5,0x2d,0x65,0x2c,0x70,0x23,0x12,0x65,0x6d,0xe5,0x2e,
-0x75,0xf0,0x7, 0x12,0x2e,0x6, 0xfa,0xc0,0x1, 0xb1,0xd6,0x24,0x36,0xf9,0x74,0xa, 
-0x35,0xf0,0xa8,0x1, 0xfc,0x7d,0x1, 0xd0,0x1, 0x12,0x3f,0xa1,0x5, 0x2c,0x5, 0x2e,
-0xe5,0x2e,0x64,0x5, 0x70,0xb4,0x12,0x66,0x56,0x7f,0x23,0x12,0x63,0x5f,0xe5,0x30,
-0x70,0x18,0x12,0x65,0x6d,0xc0,0x2, 0xc0,0x1, 0x12,0x66,0x56,0xa8,0x1, 0xfc,0xad,
-0x27,0xd0,0x1, 0xd0,0x2, 0x12,0x65,0x3a,0x61,0x5b,0x12,0x15,0x1c,0xd1,0x6, 0x13,
-0x13,0x13,0x54,0x1f,0x30,0xe0,0x2, 0x61,0x5b,0xe4,0xf5,0x2e,0xe5,0x2e,0xc3,0x95,
-0x2f,0x40,0x2, 0x61,0x5b,0xe4,0xf5,0x2d,0x71,0xe2,0xb1,0xc4,0xfd,0xe5,0x2d,0x12,
-0x15,0x3a,0xf1,0xf3,0x6d,0x60,0x7, 0x5, 0x2d,0xe5,0x2d,0xb4,0x5, 0xea,0x71,0xe2,
-0x90,0x0, 0xc, 0x12,0x15,0x5c,0xc0,0x6, 0xc0,0x7, 0xe5,0x2d,0x12,0x15,0x3a,0x71,
-0xf3,0xd0,0x7, 0xd0,0x6, 0xb1,0xdd,0xc0,0x6, 0xc0,0x7, 0x71,0xe2,0x90,0x0, 0xa, 
-0x12,0x15,0x5c,0xc0,0x6, 0xc0,0x7, 0xe5,0x2d,0x12,0x15,0x3a,0x90,0x0, 0x26,0x71,
-0xf6,0xd0,0x7, 0xd0,0x6, 0xb1,0xdd,0xd0,0xe0,0x2f,0xf5,0x2b,0xd0,0xe0,0x3e,0xf5,
-0x2a,0x12,0x15,0xb1,0x90,0x0, 0x1, 0x71,0xf6,0xae,0x4, 0x78,0x3, 0xce,0xc3,0x13,
-0xce,0x13,0xd8,0xf9,0x12,0x64,0xf3,0x50,0x5, 0x75,0x2c,0x4, 0x80,0x3c,0xed,0xae,
-0x4, 0x78,0x2, 0xce,0xc3,0x13,0xce,0x13,0xd8,0xf9,0x12,0x64,0xf3,0x50,0x5, 0x75,
-0x2c,0x3, 0x80,0x26,0x90,0x0, 0x1, 0x71,0xf6,0xec,0xc3,0x13,0xfe,0xed,0x13,0x12,
-0x64,0xf3,0x50,0x5, 0x75,0x2c,0x2, 0x80,0x11,0xc3,0xe5,0x2b,0x9d,0xe5,0x2a,0x9c,
-0x50,0x5, 0x75,0x2c,0x1, 0x80,0x3, 0xe4,0xf5,0x2c,0x71,0xe2,0x90,0x0, 0xa, 0x12,
-0x15,0x5c,0xc0,0x6, 0xc0,0x7, 0xe5,0x2d,0x12,0x15,0x3a,0x90,0x0, 0x26,0x71,0xf6,
-0xd0,0x7, 0xd0,0x6, 0x12,0x65,0x23,0x80,0x5, 0xce,0xc3,0x13,0xce,0x13,0xd8,0xf9,
-0xf5,0x2b,0x8e,0x2a,0xe5,0x2d,0x12,0x15,0x3a,0x90,0x0, 0x26,0x71,0xdc,0x90,0x0, 
-0xa, 0x12,0x64,0xc9,0x40,0xb, 0x12,0x15,0x3d,0x90,0x0, 0x26,0x12,0x66,0x33,0x80,
-0x9, 0x12,0x15,0x3d,0xe9,0x24,0x26,0x12,0x63,0xd3,0x71,0xe2,0x90,0x0, 0xc, 0x12,
-0x15,0x5c,0xc0,0x6, 0xc0,0x7, 0xe5,0x2d,0x12,0x15,0x3a,0x71,0xf3,0xd0,0x7, 0xd0,
-0x6, 0x12,0x65,0x23,0x80,0x5, 0xce,0xc3,0x13,0xce,0x13,0xd8,0xf9,0xf5,0x2b,0x8e,
-0x2a,0xe5,0x2d,0x12,0x15,0x3a,0x90,0x0, 0x28,0x71,0xdc,0x90,0x0, 0xc, 0x12,0x64,
-0xc9,0x40,0xb, 0x12,0x15,0x3d,0x90,0x0, 0x28,0x12,0x66,0x33,0x80,0x9, 0x12,0x15,
-0x3d,0xe9,0x24,0x28,0x12,0x63,0xd3,0x5, 0x2e,0x21,0xfc,0xe4,0xf5,0x2e,0xe5,0x2e,
-0x12,0x15,0x3a,0x90,0x0, 0x26,0x12,0x62,0xce,0x3e,0xfa,0x90,0x0, 0xa, 0xf1,0xe0,
-0x12,0x3f,0xbf,0xfa,0x90,0x0, 0x28,0x12,0x62,0xce,0x3e,0xfa,0x90,0x0, 0xc, 0xf1,
-0xe0,0x90,0x0, 0x2a,0x12,0x3c,0xb8,0xfd,0x12,0x64,0x37,0x90,0x0, 0xe, 0x12,0x65,
-0xfd,0x64,0x5, 0x70,0xc9,0x12,0x63,0xa0,0x44,0x1, 0x12,0x1, 0xc5,0xe5,0x2f,0xd3,
-0x94,0x0, 0x40,0x37,0xe4,0xf5,0x2e,0x71,0xe2,0x90,0x0, 0xa, 0x12,0x15,0x5c,0x11,
-0x1, 0x90,0x0, 0x3, 0xf1,0xca,0x12,0x64,0x37,0x90,0x0, 0xc, 0x12,0x15,0x5c,0xf1,
-0xf9,0x90,0x0, 0x5, 0xf1,0xca,0x12,0x64,0x37,0xb1,0xc4,0xfd,0x12,0x3f,0xbf,0xfa,
-0x90,0x0, 0x7, 0x12,0x65,0xfd,0xc3,0x94,0x5, 0x40,0xcc,0x22,0x12,0x2, 0xb7,0xfd,
-0xac,0xf0,0xe5,0x2e,0x75,0xf0,0x7, 0xa4,0xab,0x21,0x25,0x23,0xf9,0xe5,0x22,0x35,
-0xf0,0xfa,0x22,0x90,0x0, 0x28,0x12,0x2, 0xb7,0xfd,0xac,0xf0,0x22,0x12,0x17,0xfa,
-0xe4,0xf5,0x2d,0x12,0x5, 0x4c,0xaf,0x1, 0x8a,0x2f,0x8f,0x30,0x12,0x17,0x63,0xd1,
-0x6, 0x20,0xe0,0x10,0x13,0x13,0x54,0x3f,0x20,0xe0,0x9, 0xd1,0x6, 0xc3,0x13,0x20,
-0xe0,0x2, 0xa1,0xa5,0x20,0x1, 0x8, 0x75,0x2b,0xc, 0x75,0x2c,0x33,0x80,0x6, 0x75,
-0x2b,0xc, 0x75,0x2c,0x4d,0xe4,0xf5,0x27,0xb1,0xca,0x74,0xff,0xf0,0x5, 0x27,0xe5,
-0x27,0xb4,0x1a,0xf4,0xd1,0xc, 0x74,0xaa,0xf0,0xa3,0xf0,0xd1,0xc, 0xa3,0xa3,0x74,
-0x1a,0xf0,0x12,0x17,0x63,0x12,0x65,0xcb,0xff,0xe5,0x2c,0x24,0x4, 0xb1,0xce,0xef,
-0xf0,0xe4,0xf5,0x2e,0xf5,0x27,0x12,0x15,0xb1,0x12,0x1, 0x4c,0xff,0xe5,0x27,0xc3,
-0x9f,0x40,0x2, 0xa1,0x47,0xe5,0x27,0x71,0xe4,0x90,0x0, 0x7, 0x12,0x1, 0x65,0x54,
-0xf0,0xff,0xd3,0x94,0x0, 0x40,0x27,0xef,0x64,0xb0,0x60,0x2, 0xa1,0x43,0xd1,0x1c,
-0xff,0xe9,0x24,0x7, 0x12,0x5b,0x73,0x54,0xf, 0x12,0x1, 0xc5,0xab,0x21,0xe5,0x23,
-0x2f,0x71,0xec,0xd1,0x13,0xd1,0x23,0xe0,0x64,0x1, 0x60,0x2, 0xa1,0x43,0xe5,0x27,
-0x71,0xe4,0xd1,0x13,0xd1,0x23,0xe0,0x64,0x3, 0x70,0x2, 0xa1,0x43,0xe5,0x2e,0x25,
-0xe0,0x25,0xe0,0xf5,0x28,0x90,0x0, 0x5, 0x12,0x2, 0xb7,0x12,0x65,0x8f,0xb1,0xb0,
-0xef,0xf0,0xe5,0x28,0x24,0x6, 0xb1,0xb5,0xe5,0x2a,0xf0,0xe5,0x27,0x71,0xe4,0xf1,
-0xed,0x12,0x65,0x8f,0xff,0xe5,0x28,0x24,0x7, 0xb1,0xb5,0xef,0xf0,0xe5,0x28,0x24,
-0x8, 0xb1,0xb5,0xe5,0x2a,0xd1,0x1b,0x71,0xea,0x90,0x0, 0x7, 0x12,0x1, 0x65,0xc4,
-0x54,0xf0,0xff,0xe5,0x28,0x24,0x7, 0xb1,0xb5,0xe0,0x2f,0xd1,0x1b,0x71,0xea,0xd1,
-0x13,0xf4,0x60,0x17,0xd1,0x23,0xe0,0xff,0x64,0x1, 0x60,0x2, 0x5, 0x2d,0xef,0xc4,
-0x33,0x33,0x54,0xc0,0xb1,0xb0,0xe0,0x2f,0xf0,0x80,0x16,0xe5,0x28,0x24,0x5, 0xff,
-0xe4,0x33,0xfe,0xe5,0x2c,0x2f,0xf5,0x82,0xe5,0x2b,0x3e,0xf5,0x83,0xe0,0x24,0xc0,
-0xf0,0x5, 0x2e,0x5, 0x27,0x81,0x66,0xd1,0xc, 0xa3,0xa3,0xa3,0xe5,0x2d,0xf0,0xe5,
-0x2c,0x24,0x19,0xb1,0xce,0xe4,0xf0,0xf5,0x27,0xe5,0x2c,0x24,0x19,0xb1,0xce,0xc0,
-0x83,0xc0,0x82,0xe0,0xff,0xb1,0xca,0xe0,0xfe,0xef,0x6e,0xd0,0x82,0xd0,0x83,0xf0,
-0x5, 0x27,0xe5,0x27,0xb4,0x19,0xe2,0xb2,0x1, 0x7f,0x1, 0xb1,0xa7,0x12,0x17,0x63,
-0xd1,0x6, 0xff,0x13,0x13,0x54,0x3f,0x30,0xe0,0x9, 0xaa,0x2f,0xa9,0x30,0x7b,0x1, 
-0x12,0x51,0xbe,0x12,0x4a,0xb2,0x54,0xfe,0x12,0x1, 0xc5,0x54,0xfb,0x12,0x1, 0xc5,
-0x54,0xfd,0x2, 0x1, 0xc5,0xe4,0xff,0xef,0x70,0x3, 0xd2,0x98,0x22,0xc2,0x98,0x22,
-0xff,0xe5,0x28,0x24,0x5, 0xfd,0xe4,0x33,0xfc,0xe5,0x2c,0x2d,0xf5,0x82,0xe5,0x2b,
-0x3c,0xf5,0x83,0x22,0x90,0x0, 0xe, 0x2, 0x1, 0x65,0xe5,0x2c,0x25,0x27,0xf5,0x82,
-0xe4,0x35,0x2b,0xf5,0x83,0x22,0xe5,0x2c,0x75,0xf0,0x7, 0xa4,0x22,0xd3,0xef,0x9d,
-0xee,0x9c,0x40,0x3, 0x2, 0x3f,0xb8,0xc3,0xed,0x9f,0xff,0xec,0x9e,0xfe,0x22,0x90,
-0x0, 0x2a,0x12,0x1, 0x65,0xff,0xe5,0x2c,0x75,0xf0,0x7, 0xa4,0x24,0x3a,0xf5,0x82,
-0xe4,0x34,0xa, 0xf5,0x83,0x22,0x90,0x0, 0x4f,0x2, 0x1, 0x65,0x85,0x2c,0x82,0x85,
-0x2b,0x83,0x22,0x90,0x0, 0x7, 0x12,0x1, 0x65,0xff,0x22,0xf0,0xe5,0x27,0x75,0xf0,
-0x7, 0xa4,0x22,0xe5,0x30,0x24,0x23,0xf5,0x82,0xe4,0x35,0x2f,0xf5,0x83,0xe5,0x82,
-0x2f,0xf5,0x82,0xe4,0x35,0x83,0xf5,0x83,0x22,0x12,0x17,0xfa,0x12,0x17,0xe8,0xff,
-0x12,0x5, 0x4c,0xad,0x1, 0x8a,0x2a,0x8d,0x2b,0xef,0x70,0x2, 0xe1,0xa1,0xe4,0xf5,
-0x24,0xe5,0x24,0x71,0xe4,0x12,0x65,0xb0,0x60,0x4a,0x12,0x63,0xe7,0xe5,0x82,0x25,
-0x25,0xd1,0x31,0xe0,0xff,0x70,0x20,0xf1,0xed,0xfd,0xf1,0xb0,0xf1,0xe6,0xed,0xf0,
-0x90,0x0, 0x5, 0x12,0x2, 0xb7,0xfd,0xf1,0xa2,0xf1,0xe6,0xed,0xf0,0x74,0xb5,0x25,
-0x24,0xf1,0xc2,0xe4,0xf0,0x80,0x1d,0xef,0xb4,0x1, 0x19,0xf1,0xb0,0xf5,0x83,0xe0,
-0xff,0xa3,0xe0,0x90,0x0, 0x3, 0xcf,0x8f,0xf0,0x12,0x3, 0x5b,0xf1,0xa2,0x12,0x65,
-0x9, 0x12,0x3, 0x5b,0x5, 0x24,0xe5,0x24,0x64,0x5, 0x70,0xa5,0xe4,0xf5,0x24,0xe5,
-0x24,0x71,0xe4,0x12,0x65,0xb0,0x70,0x2, 0xe1,0x96,0x12,0x63,0xe7,0xe5,0x82,0x25,
-0x25,0xd1,0x31,0xe0,0x64,0x2, 0x60,0x2, 0xe1,0x96,0x90,0x0, 0x3, 0x12,0x15,0x5c,
-0xf1,0xb0,0x12,0x3b,0x1c,0xc3,0xef,0x9d,0xf5,0x27,0xee,0x9c,0xf5,0x26,0x90,0x0, 
-0x5, 0x12,0x15,0x5c,0xf1,0xa2,0x12,0x3b,0x1c,0xc3,0xef,0x9d,0xf5,0x29,0xee,0x9c,
-0xf5,0x28,0xaf,0x29,0xfe,0x12,0x0, 0x6, 0xc0,0x6, 0xc0,0x7, 0xaf,0x27,0xae,0x26,
-0x12,0x0, 0x6, 0xd0,0xe0,0x2f,0xff,0xd0,0xe0,0x3e,0xfe,0xc3,0xef,0x94,0x2, 0xee,
-0x64,0x80,0x94,0x80,0x50,0x62,0xf1,0xbe,0xe0,0xd3,0x94,0x78,0x40,0x3d,0xf1,0xb0,
-0x12,0x47,0x63,0xfd,0xac,0x6, 0xe5,0x26,0xa2,0xe7,0x13,0xfe,0xe5,0x27,0x12,0x65,
-0x61,0x50,0x3, 0xe4,0xfc,0xfd,0xf1,0xb0,0x12,0x66,0xa7,0xf1,0xa2,0x12,0x3b,0x1c,
-0xe5,0x28,0xa2,0xe7,0x13,0xfe,0xe5,0x29,0x12,0x65,0x61,0x50,0x3, 0xe4,0xfc,0xfd,
-0xf1,0xa2,0x12,0x66,0xa7,0xf1,0xbe,0xe4,0xf0,0x80,0x5, 0xf1,0xbe,0xe0,0x4, 0xf0,
-0xf1,0xb0,0x12,0x3b,0x1c,0xe5,0x24,0x71,0xe4,0x90,0x0, 0x3, 0xf1,0xe0,0xf1,0xa2,
-0x12,0x65,0x9, 0x12,0x3, 0x5b,0x80,0x1e,0xf1,0xbe,0xe4,0xf0,0xe5,0x24,0x71,0xe4,
-0xf1,0xed,0xff,0xf1,0xb0,0xf1,0xe6,0xef,0xf0,0x90,0x0, 0x5, 0x12,0x2, 0xb7,0xff,
-0xf1,0xa2,0xf1,0xe6,0xef,0xf0,0x5, 0x24,0xe5,0x24,0xc3,0x94,0x5, 0x50,0x2, 0xc1,
-0xaf,0x22,0xe5,0x25,0x25,0xe0,0x25,0xe0,0x24,0xa3,0xf5,0x82,0xe4,0x34,0xc, 0x22,
-0xe5,0x25,0x25,0xe0,0x25,0xe0,0x24,0xa1,0xf5,0x82,0xe4,0x34,0xc, 0x22,0x74,0xb5,
-0x25,0x25,0xf5,0x82,0xe4,0x34,0xc, 0xf5,0x83,0x22,0xac,0x6, 0xad,0x7, 0xe5,0x2e,
-0x75,0xf0,0x7, 0xa4,0xff,0xae,0xf0,0xab,0x27,0x25,0x29,0xf9,0xe5,0x28,0x3e,0xfa,
-0xec,0x8d,0xf0,0x2, 0x3, 0x5b,0xf5,0x83,0xe5,0xf0,0xf0,0xa3,0x22,0x90,0x0, 0x3, 
-0x2, 0x2, 0xb7,0x90,0x0, 0x2a,0x2, 0x1, 0x65,0xc3,0xee,0x94,0x0, 0x40,0x2, 0x80,
-0x3, 0xe4,0xfe,0xff,0xe4,0x7b,0x11,0x11,0x2b,0x12,0x4, 0xbb,0x70,0x2, 0x11,0x58,
-0xe4,0xff,0x7e,0x4, 0x11,0x4c,0x12,0x4, 0xbb,0x40,0xb, 0xe4,0x75,0x34,0xff,0x75,
-0x33,0x3, 0xf5,0x32,0xf5,0x31,0xae,0x33,0xaf,0x34,0x22,0xfc,0xfd,0x7a,0x1, 0xf9,
-0xf8,0x12,0x3, 0x88,0x8f,0x34,0x8e,0x33,0x8d,0x32,0x8c,0x31,0x78,0x8, 0x12,0x4, 
-0xcc,0x8f,0x34,0x8e,0x33,0x8d,0x32,0x8c,0x31,0xe4,0xff,0xfe,0xfd,0xfc,0xab,0x34,
-0xaa,0x33,0xa9,0x32,0xa8,0x31,0xc3,0x22,0x75,0x34,0x1, 0xf5,0x33,0xf5,0x32,0xf5,
-0x31,0x22,0x8e,0x25,0x8f,0x26,0x12,0x65,0xd1,0xc3,0xe5,0x25,0x94,0x0, 0x50,0x5, 
-0xe4,0xf5,0x25,0xf5,0x26,0xc3,0xec,0x94,0x0, 0x50,0x3, 0xe4,0xfc,0xfd,0xd3,0xe5,
-0x26,0x94,0x2f,0xe5,0x25,0x94,0x0, 0x50,0x17,0xe5,0x26,0x25,0xe0,0xff,0xe5,0x25,
-0x33,0xfe,0xef,0x24,0xd1,0x31,0x40,0x50,0x38,0xe4,0xf5,0x2a,0xf5,0x2b,0x80,0x31,
-0xc3,0xe5,0x26,0x94,0x50,0xe5,0x25,0x94,0x2, 0x40,0x2c,0xe5,0x26,0x24,0xb0,0xcf,
-0xe5,0x25,0x34,0xfd,0xcf,0x25,0x26,0xf5,0x2b,0xef,0x35,0x25,0xf5,0x2a,0xd3,0xe5,
-0x2b,0x94,0x7d,0xe5,0x2a,0x64,0x80,0x94,0x82,0x40,0x6, 0x75,0x2a,0x2, 0x75,0x2b,
-0x7f,0x85,0x2a,0x25,0x85,0x2b,0x26,0xd3,0xed,0x94,0x31,0xec,0x94,0x0, 0x50,0x11,
-0x12,0x3f,0xaf,0xef,0x24,0xcf,0x31,0x40,0x50,0x32,0xe4,0xf5,0x2a,0xf5,0x2b,0x80,
-0x2b,0xc3,0xed,0x94,0x8e,0xec,0x94,0x3, 0x40,0x26,0xed,0x24,0x72,0xff,0xec,0x34,
-0xfc,0xcf,0x2d,0xf5,0x2b,0xef,0x3c,0xf5,0x2a,0xd3,0xe5,0x2b,0x94,0xbd,0xe5,0x2a,
-0x64,0x80,0x94,0x83,0x40,0x6, 0x75,0x2a,0x3, 0x75,0x2b,0xbf,0xac,0x2a,0xad,0x2b,
-0x12,0x15,0x1c,0xe5,0x25,0x85,0x26,0xf0,0x12,0x3, 0x3c,0xab,0x27,0x74,0x2, 0x25,
-0x29,0xf9,0xf5,0x29,0xe4,0x35,0x28,0xfa,0xf5,0x28,0xec,0x8d,0xf0,0x2, 0x3, 0x3c,
-0xf5,0x2b,0xee,0x34,0xff,0xf5,0x2a,0xc3,0xe5,0x2b,0x94,0x2, 0xe5,0x2a,0x64,0x80,
-0x94,0x80,0x22,0x12,0x17,0xfa,0xe4,0xf5,0x24,0x12,0x17,0x63,0x12,0x4c,0x59,0xff,
-0xe5,0x24,0xc3,0x9f,0x50,0x22,0xe5,0x24,0x75,0xf0,0x7, 0x12,0x2e,0x6, 0xfa,0x90,
-0x0, 0xa, 0x12,0x15,0x5c,0x90,0x0, 0xc, 0x12,0x1b,0xf6,0xe9,0x24,0xa, 0xf9,0xe4,
-0x3a,0xfa,0x11,0x62,0x5, 0x24,0x80,0xd1,0x22,0x12,0x64,0x1a,0x74,0x5a,0x12,0x63,
-0x48,0x7a,0x9, 0x79,0x19,0x12,0x49,0x22,0xd1,0xff,0x12,0x28,0x4b,0x75,0x35,0x1, 
-0x75,0x36,0x8, 0x75,0x37,0xc6,0xb1,0xf4,0x12,0x38,0x1d,0x7b,0x1, 0x7a,0x9, 0x79,
-0xe8,0x12,0x51,0xbe,0xe4,0x90,0xc, 0xba,0xf0,0x7b,0x1, 0x7a,0x9, 0x79,0x3c,0x12,
-0xe, 0xbf,0x90,0xb, 0xf0,0x74,0xa, 0xf0,0x90,0xb, 0xf0,0xe0,0x70,0xfa,0x12,0x65,
-0xf6,0x7b,0x1, 0x7a,0x9, 0x79,0x5f,0xb1,0xfb,0x7b,0x1, 0x7a,0x9, 0x79,0x5f,0x91,
-0xc9,0x12,0x45,0xc, 0x90,0xb, 0x58,0x74,0x3, 0xf0,0x74,0xe8,0x12,0x28,0x3c,0x12,
-0x64,0x57,0x75,0x2b,0x9, 0x75,0x2c,0x3c,0x12,0xf, 0xfe,0x7e,0x0, 0x7f,0x83,0x12,
-0x47,0xc5,0x91,0xab,0x12,0x46,0xf9,0x12,0x36,0x69,0x90,0xa, 0xd8,0xf0,0xa3,0x74,
-0x64,0xf0,0x75,0x35,0x1, 0x75,0x36,0x0, 0x75,0x37,0x83,0xd1,0xff,0x12,0x45,0x3d,
-0xe4,0x90,0x0, 0x52,0xf0,0xa3,0x4, 0x12,0x65,0xec,0x12,0x37,0x44,0xe4,0x90,0xa, 
-0xe0,0xf0,0xa3,0xf0,0x90,0xc, 0x18,0xe0,0x64,0x1, 0x60,0x2, 0x81,0x60,0x12,0x36,
-0x6a,0x90,0xa, 0xd8,0xf0,0x74,0x64,0x12,0x63,0x48,0x7a,0x9, 0x79,0x19,0x12,0x3d,
-0xeb,0xe4,0xf5,0xd, 0xf5,0xc, 0x90,0xc, 0x16,0xe0,0x70,0x5, 0x90,0x8, 0x2c,0x80,
-0x3, 0x90,0x8, 0x2e,0xe0,0xf5,0xe, 0x90,0xc, 0x11,0xe0,0xf4,0x60,0x1b,0x7e,0x0, 
-0x7f,0x0, 0x7c,0x9, 0x7d,0x3c,0x7a,0x0, 0x7b,0x83,0x75,0x27,0x9, 0x75,0x28,0x5f,
-0x12,0x45,0xf2,0x90,0xc, 0x11,0x74,0xff,0xf0,0xd1,0xf6,0x12,0x45,0xe2,0x60,0xf9,
-0x90,0x8, 0x28,0xe0,0x90,0xc, 0x1a,0xf0,0x90,0x8, 0x33,0xe0,0xb4,0x1, 0x5, 0xe4,
-0xff,0x12,0x1d,0xa7,0x12,0x28,0x3e,0x12,0x64,0x42,0x75,0x2c,0x34,0x91,0xab,0x12,
-0x53,0x72,0x12,0x28,0x3e,0x12,0x64,0x57,0x75,0x2b,0x9, 0x75,0x2c,0x19,0xb1,0xf4,
-0x12,0x4c,0x5f,0x90,0x8, 0x27,0xe0,0x90,0xb, 0xf4,0xf0,0x90,0x8, 0x20,0xe0,0x90,
-0xb, 0xf5,0xf0,0x64,0x6, 0x70,0x51,0x12,0x64,0x7, 0x12,0x4, 0xa5,0x40,0x20,0x75,
-0x33,0x1, 0x75,0x34,0x0, 0x75,0x35,0x83,0x75,0x36,0x1, 0x75,0x37,0x9, 0x75,0x38,
-0x19,0x75,0x39,0x1, 0x75,0x3a,0x0, 0x75,0x3b,0x0, 0xb1,0xf4,0x12,0x2b,0xe, 0x90,
-0x8, 0x63,0xe0,0x20,0xe0,0x5, 0x91,0xab,0x12,0x3f,0xe8,0x12,0x64,0x61,0x12,0x65,
-0xd8,0x12,0x64,0x48,0x75,0x2c,0x34,0x91,0x9b,0x12,0x46,0x66,0x90,0x8, 0x63,0xe0,
-0x30,0xe0,0x5, 0xe4,0x90,0x8, 0x20,0xf0,0x90,0x8, 0x27,0xe0,0x70,0x10,0x90,0x8, 
-0x20,0xe0,0xb4,0x4, 0x9, 0x90,0xa, 0xe0,0xe4,0xf0,0xa3,0x74,0xa, 0xf0,0xd3,0x90,
-0xa, 0xe1,0xe0,0x94,0x0, 0x90,0xa, 0xe0,0xe0,0x94,0x0, 0x40,0x12,0xa3,0xe0,0x24,
-0xff,0xf0,0x90,0xa, 0xe0,0xe0,0x34,0xff,0xf0,0x90,0x8, 0x20,0x74,0x4, 0xf0,0x91,
-0xa2,0x12,0x4a,0xd3,0x90,0x9, 0x16,0xef,0x12,0x28,0x3d,0x12,0x64,0x42,0x75,0x2c,
-0x34,0x91,0xab,0x12,0x5b,0x7a,0xb1,0xf4,0x31,0x53,0x90,0x8, 0x20,0xe0,0xb4,0x6, 
-0xe, 0x90,0x8, 0x61,0xe0,0xd3,0x94,0x1, 0x40,0x5, 0xe4,0x90,0x8, 0x20,0xf0,0x12,
-0x64,0x61,0x75,0x27,0x1, 0x75,0x28,0x9, 0x75,0x29,0x19,0xd1,0xff,0x12,0x3b,0x24,
-0x90,0x8, 0x27,0xe0,0x70,0xf, 0x90,0x8, 0x62,0xe0,0xff,0x90,0x8, 0x61,0xe0,0xd3,
-0x9f,0x40,0x7, 0x80,0x0, 0x91,0xa2,0x12,0x3c,0xc5,0x90,0x8, 0x61,0xe0,0xa3,0xf0,
-0x90,0x9, 0x11,0xf0,0x91,0x9b,0x91,0x65,0x91,0x9b,0xb1,0x9e,0x90,0x9, 0x11,0xe0,
-0x90,0x8, 0x61,0xf0,0x90,0xa, 0x2b,0x74,0x1, 0xf0,0xa3,0x74,0xa, 0xf0,0xa3,0x74,
-0x2e,0xf0,0x75,0x24,0x1, 0x75,0x25,0x8, 0x75,0x26,0x34,0x7b,0x1, 0x7a,0x9, 0x79,
-0xe8,0x12,0x17,0x6a,0x90,0x8, 0xc6,0x74,0x1, 0xf0,0xa3,0x74,0x9, 0xf0,0xa3,0x74,
-0xe8,0xf0,0x90,0x8, 0x61,0xe0,0x90,0x9, 0x11,0xf0,0x12,0x65,0xe2,0x75,0x27,0x1, 
-0x75,0x28,0x8, 0x75,0x29,0xc6,0xb1,0xf4,0x12,0x18,0x36,0x75,0x24,0x1, 0x75,0x25,
-0x8, 0x75,0x26,0xc6,0x12,0x63,0x53,0x7a,0x9, 0x79,0xe0,0x12,0x15,0xb8,0x91,0x9b,
-0x12,0x1e,0x39,0x12,0x65,0xe2,0x91,0x9b,0x12,0x1b,0xfd,0x75,0x24,0x1, 0x75,0x25,
-0x8, 0x75,0x26,0x29,0x12,0x65,0xd8,0x75,0x2a,0x1, 0x75,0x2b,0x0, 0x75,0x2c,0x83,
-0x75,0x2d,0x1, 0x75,0x2e,0x8, 0x75,0x2f,0x34,0x91,0x9b,0x12,0x47,0xf5,0x41,0x34,
-0xf1,0xdf,0x2, 0x0, 0x18,0x12,0x17,0xfa,0x12,0x17,0xe8,0x70,0x23,0x12,0x17,0xf4,
-0xff,0xd3,0x94,0x0, 0x40,0x1a,0xe5,0x13,0x70,0x12,0x90,0x0, 0x4b,0xef,0x12,0x1, 
-0xd7,0x12,0x5b,0x70,0x44,0x8, 0x12,0x1, 0xc5,0x5, 0x13,0x22,0xe4,0xf5,0x13,0x22,
-0xe4,0xf5,0x13,0x12,0x4a,0xb2,0x54,0xf7,0x2, 0x1, 0xc5,0x7b,0x1, 0x7a,0x8, 0x79,
-0xc6,0x22,0x75,0x24,0x1, 0x75,0x25,0x8, 0x75,0x26,0x34,0x7b,0x1, 0x7a,0x0, 0x79,
-0x83,0x22,0x7b,0x1, 0x7a,0x8, 0x79,0x29,0x12,0xe, 0xbf,0x7b,0x1, 0x7a,0x8, 0x79,
-0x4c,0xb1,0xfb,0x7b,0x1, 0x7a,0x8, 0x79,0x4c,0x12,0xf, 0xcd,0xe4,0xf5,0x2c,0x12,
-0xf, 0xba,0x85,0x2c,0x82,0x12,0x2f,0x64,0xfd,0xaf,0x2c,0x12,0x0, 0x1e,0xe5,0x2c,
-0x24,0x1c,0x12,0x66,0x87,0xb1,0xe5,0x12,0x65,0xa6,0x24,0x38,0xb1,0xde,0x12,0x65,
-0xa6,0x24,0x54,0x12,0x66,0x7f,0xb1,0xe5,0xd1,0xe9,0x94,0x1c,0x40,0xd1,0x90,0x0, 
-0x70,0x12,0x62,0x86,0xfd,0x7f,0x7e,0x12,0x0, 0x1e,0x12,0xf, 0xba,0x90,0x0, 0x71,
-0x12,0x1, 0x65,0xfd,0x7f,0x7f,0x12,0x0, 0x1e,0x12,0xf, 0xba,0x90,0x0, 0x73,0x12,
-0x1, 0x65,0xfd,0x7f,0x81,0x12,0x0, 0x1e,0x12,0xf, 0xba,0x90,0x0, 0x74,0x12,0x1, 
-0x65,0x7f,0x82,0x12,0x66,0x77,0xe5,0x2c,0x24,0x83,0xff,0xab,0x29,0xe5,0x2b,0x24,
-0x75,0xb1,0xe5,0xd1,0xe9,0x94,0x4, 0x40,0xed,0xe4,0xf5,0x2c,0xe5,0x2c,0x24,0x87,
-0xff,0xab,0x29,0xe5,0x2b,0x24,0x79,0xb1,0xe5,0xd1,0xe9,0x94,0x2, 0x40,0xed,0x12,
-0xf, 0xba,0x90,0x0, 0x7b,0x12,0x1, 0x65,0xfd,0x7f,0x89,0x12,0x0, 0x1e,0x12,0xf, 
-0xba,0x90,0x0, 0x7c,0x12,0x1, 0x65,0x7f,0x8c,0x12,0x66,0x77,0xe5,0x2c,0x24,0x8d,
-0xff,0xab,0x29,0xe5,0x2b,0x24,0x7d,0xb1,0xe5,0xd1,0xe9,0x94,0x3, 0x40,0xed,0x12,
-0xf, 0xba,0x90,0x0, 0x80,0x12,0x1, 0x65,0xfd,0x7f,0x90,0x2, 0x0, 0x1e,0x12,0x17,
-0xf4,0xff,0xd3,0x94,0x0, 0x50,0x36,0x12,0x17,0xe8,0xd3,0x9f,0x40,0x1d,0x90,0x0, 
-0x50,0x12,0x1, 0x65,0xff,0x90,0xc, 0xba,0xe0,0xc3,0x9f,0x50,0x13,0xe0,0x4, 0xf0,
-0x12,0x17,0xf4,0x90,0x0, 0x4b,0x12,0x1, 0xd7,0x80,0x5, 0xe4,0x90,0xc, 0xba,0xf0,
-0x12,0x17,0xe8,0x70,0x8, 0x12,0x5b,0x70,0x54,0xfe,0x12,0x1, 0xc5,0x22,0xff,0xab,
-0x29,0xe5,0x2b,0x24,0x38,0xf9,0xe4,0x35,0x2a,0xfa,0xe5,0x2c,0x7c,0x0, 0x29,0xf9,
-0xec,0x3a,0xfa,0x22,0x7b,0x1, 0x7a,0x8, 0x79,0x34,0x22,0x12,0xf, 0xcd,0x78,0x2d,
-0x7c,0x0, 0x7d,0x0, 0x7b,0xff,0x7a,0x7, 0x79,0x51,0x7e,0x0, 0x7f,0x1c,0x12,0x1, 
-0x26,0xe4,0xf5,0x2c,0x12,0x29,0xe6,0xe0,0xff,0xc3,0x94,0x1c,0x50,0x55,0x12,0x64,
-0x77,0x12,0xf, 0xb9,0x8f,0x82,0x75,0x83,0x0, 0x12,0x1, 0xd7,0xe5,0x2c,0x20,0xe0,
-0xf, 0x12,0x64,0x6b,0xe0,0x54,0xf, 0xff,0xe9,0x24,0x1c,0xf9,0xe4,0x3a,0x80,0x10,
-0xe5,0x2c,0x12,0x64,0x6b,0xe0,0xc4,0x54,0xf, 0x12,0x66,0x87,0xf9,0xe4,0x35,0x2a,
-0xfa,0x12,0x29,0xe6,0xe0,0xb1,0xec,0xef,0x12,0x1, 0xc5,0x74,0x2d,0x25,0x2c,0xf8,
-0xe6,0x12,0x66,0x7f,0xf9,0xe4,0x35,0x2a,0xfa,0x12,0x29,0xe6,0xe0,0xb1,0xec,0xef,
-0x12,0x1, 0xc5,0x90,0xa, 0xe9,0xe0,0xb1,0xde,0xef,0x12,0x1, 0xc5,0x5, 0x2c,0xe5,
-0x2c,0x64,0x1c,0x70,0x8f,0x12,0xf, 0xba,0x90,0x0, 0x70,0xe4,0x12,0x1, 0xd7,0x90,
-0x0, 0x71,0x74,0x7, 0x12,0x1, 0xd7,0x90,0x0, 0x72,0x74,0x17,0x12,0x1, 0xd7,0x90,
-0x0, 0x73,0x74,0x2, 0x12,0x1, 0xd7,0x90,0x0, 0x74,0x74,0x7f,0x12,0x1, 0xd7,0xe4,
-0xfd,0x12,0x29,0xf2,0x12,0xf, 0xba,0x7d,0x1, 0x12,0x29,0xf2,0x12,0xf, 0xba,0x90,
-0x0, 0x7b,0x74,0xf, 0x12,0x1, 0xd7,0x90,0x0, 0x7c,0x74,0x21,0x12,0x66,0x97,0xff,
-0x90,0x0, 0x7d,0x12,0x1, 0xd7,0x90,0x0, 0x7e,0xef,0x12,0x1, 0xd7,0x90,0x0, 0x7f,
-0xef,0x12,0x2f,0x4b,0x74,0x5d,0x2, 0x1, 0xd7,0x12,0x1, 0x4c,0xfd,0x12,0x0, 0x1e,
-0x5, 0x2c,0xe5,0x2c,0xc3,0x22,0x75,0x49,0x1, 0x75,0x4a,0x0, 0x75,0x4b,0x83,0x7b,
-0x1, 0x7a,0x0, 0x79,0x0, 0x22,0x75,0xf, 0x4, 0x75,0x10,0x3, 0x12,0x64,0x1a,0xa3,
-0x74,0x5a,0xf0,0x12,0x37,0xec,0x12,0x30,0x0, 0xd1,0xff,0x12,0x28,0x4b,0x7b,0x1, 
-0x7a,0x8, 0x79,0x29,0x12,0xe, 0xbf,0x12,0x65,0xf6,0x91,0xbb,0x12,0x45,0xc, 0x90,
-0x0, 0x1, 0xe0,0x90,0xc, 0x96,0xf0,0x90,0x0, 0x0, 0xe0,0x90,0xc, 0x95,0xf0,0x12,
-0x46,0xe7,0xe4,0x90,0x0, 0x52,0xf0,0xa3,0x12,0x65,0xec,0x90,0xc, 0x93,0x74,0x3, 
-0xf0,0x12,0x46,0xe7,0x90,0xc, 0x92,0xe0,0x70,0x2d,0x12,0x0, 0x4e,0x90,0xc, 0x92,
-0x74,0x1, 0xf0,0x7f,0x0, 0x7e,0x7c,0x12,0x53,0x20,0x12,0x64,0x61,0x75,0x27,0x4, 
-0xd1,0xff,0x12,0x43,0x43,0xe4,0xfd,0xff,0xfe,0x12,0x44,0xcf,0x7f,0x4, 0x12,0x35,
-0x74,0x90,0xc, 0x92,0x74,0xff,0xf0,0x90,0xc, 0x93,0xe0,0x64,0x3, 0x70,0x48,0x90,
-0xc, 0x6c,0xe0,0xff,0xc4,0x13,0x13,0x13,0x54,0x1, 0x30,0xe0,0xb4,0xd1,0xff,0x12,
-0x28,0x4b,0x12,0x47,0x5b,0x91,0xb2,0x12,0x45,0xc, 0x90,0xc, 0x9b,0xe0,0x90,0x0, 
-0x52,0x70,0x3, 0xf0,0x80,0x3, 0x74,0x1, 0xf0,0xe4,0x90,0x0, 0x53,0xf0,0x12,0x65,
-0xf6,0xd1,0xf6,0x12,0x45,0xe2,0x60,0xf9,0x75,0xf, 0x4, 0x75,0x10,0x3, 0x90,0xc, 
-0x6c,0xe0,0x54,0x7f,0xf0,0xe1,0x51,0x90,0xc, 0x93,0xe0,0x90,0xc, 0x18,0xf0,0xe4,
-0xff,0xfd,0xfc,0xe5,0xdb,0x20,0xe1,0xf, 0xf, 0xbf,0xff,0x5, 0xd, 0xbd,0x0, 0x1, 
-0xc, 0xbc,0x3, 0xef,0xbd,0xe8,0xec,0x53,0xdb,0xfe,0x53,0xdb,0xfd,0xc2,0xba,0x22,
-0x12,0x46,0xe7,0x12,0x64,0x1a,0xa3,0x74,0x5a,0xf0,0x12,0x26,0xff,0x11,0x4b,0x12,
-0x24,0xb2,0x53,0xdb,0xf0,0x12,0x45,0xc, 0x90,0xb, 0x58,0x74,0x1, 0xf0,0x74,0x2c,
-0x11,0x3c,0x12,0x64,0x57,0x75,0x2b,0x8, 0x75,0x2c,0x29,0x12,0xf, 0xfe,0x12,0x27,
-0xdf,0x12,0x37,0x44,0x90,0xc, 0x6c,0xe0,0x54,0x8f,0xf0,0x22,0xa3,0xf0,0x75,0x24,
-0x1, 0x75,0x25,0x0, 0x75,0x26,0x0, 0x75,0x27,0x1, 0x22,0x12,0xf, 0xcd,0x75,0x47,
-0xff,0xe4,0xf5,0x48,0x75,0x49,0xff,0xf5,0x4a,0xf5,0x58,0x75,0x59,0x0, 0x75,0x5a,
-0x4b,0xf1,0xf1,0x12,0xf, 0xba,0x90,0x0, 0x52,0xe4,0x12,0x65,0x33,0x74,0x1, 0x12,
-0x66,0x97,0x90,0x0, 0x54,0x12,0x1, 0xd7,0x90,0xa, 0xe5,0xe0,0x12,0x1, 0xc5,0x90,
-0xa, 0xe6,0x12,0xf, 0xb9,0x12,0x4a,0xa3,0xe4,0xf5,0x2c,0x12,0xf, 0xba,0x12,0x1, 
-0x4c,0xff,0xe5,0x2c,0xc3,0x9f,0x50,0x31,0x12,0x64,0x77,0xe0,0xff,0xe9,0x24,0x31,
-0xf9,0xe4,0x3a,0xfa,0xe5,0x2c,0xfd,0x12,0x25,0xec,0x31,0xe2,0xe0,0xff,0xab,0x29,
-0xe5,0x2b,0x24,0x4, 0xf9,0xe4,0x35,0x2a,0xfa,0xe9,0x2d,0xf9,0xec,0x3a,0xfa,0x31,
-0xe2,0xe0,0xff,0x74,0x2e,0x31,0xc3,0x80,0xc2,0xe4,0xf5,0x2c,0x90,0x0, 0x1, 0x12,
-0x62,0x86,0xff,0xe5,0x2c,0xc3,0x9f,0x50,0x17,0x31,0xcb,0xe9,0x24,0x20,0xf9,0xe4,
-0x3a,0x12,0x25,0xe9,0xef,0x12,0x1, 0xc5,0x31,0xcb,0x74,0x3d,0x31,0xc3,0x80,0xdc,
-0xe4,0xf5,0x2c,0x90,0xa, 0xe6,0xe0,0xff,0xe5,0x2c,0xc3,0x9f,0x50,0x3e,0xe4,0xf5,
-0x2d,0x90,0xa, 0xe6,0xe0,0xff,0xe5,0x2d,0xc3,0x9f,0x50,0x15,0x74,0x3d,0x25,0x2d,
-0xf8,0xe6,0xff,0xc3,0x95,0x49,0x50,0x5, 0x8f,0x49,0x85,0x2d,0x4a,0x5, 0x2d,0x80,
-0xe0,0x74,0x3d,0x25,0x4a,0xf8,0x76,0xff,0x75,0x49,0xff,0xab,0x29,0xe5,0x2b,0x24,
-0x72,0x31,0xd3,0xe5,0x4a,0x12,0x1, 0xc5,0x5, 0x2c,0x80,0xb7,0xe4,0xf5,0x2c,0x90,
-0xa, 0xe5,0xe0,0xff,0xe5,0x2c,0xc3,0x9f,0x50,0x3e,0xe4,0xf5,0x2d,0x90,0xa, 0xe5,
-0xe0,0xff,0xe5,0x2d,0xc3,0x9f,0x50,0x15,0x74,0x2e,0x25,0x2d,0xf8,0xe6,0xff,0xc3,
-0x95,0x47,0x50,0x5, 0x8f,0x47,0x85,0x2d,0x48,0x5, 0x2d,0x80,0xe0,0x74,0x2e,0x25,
-0x48,0xf8,0x76,0xff,0x75,0x47,0xff,0xab,0x29,0xe5,0x2b,0x24,0x56,0x31,0xd3,0xe5,
-0x48,0x12,0x1, 0xc5,0x5, 0x2c,0x80,0xb7,0x90,0xa, 0xe8,0x12,0xf, 0xb9,0x90,0x0, 
-0x30,0x12,0x1, 0xd7,0x90,0x0, 0x31,0x12,0x1, 0x65,0x90,0x0, 0x51,0x12,0xf, 0xdc,
-0x90,0x0, 0x4d,0x12,0xf, 0xd4,0xff,0x90,0x0, 0x4e,0x12,0x1, 0xd7,0x90,0x0, 0x4f,
-0xef,0x12,0x1, 0xd7,0x90,0x0, 0x50,0xef,0x12,0x1, 0xd7,0x90,0x0, 0x82,0x74,0x1, 
-0x2, 0x1, 0xd7,0x25,0x2c,0xf8,0xa6,0x7, 0x5, 0x2c,0x22,0x74,0x4b,0x25,0x2c,0xf8,
-0xe6,0xff,0x22,0xf9,0xe4,0x35,0x2a,0xfa,0x7e,0x0, 0xe9,0x25,0x2c,0xf9,0xee,0x3a,
-0xfa,0x22,0xef,0x12,0x1, 0xc5,0x74,0xf5,0x25,0x2c,0xf5,0x82,0xe4,0x34,0xa, 0xf5,
-0x83,0x22,0x8b,0x49,0x8a,0x4a,0x89,0x4b,0x8d,0x4c,0x90,0xa, 0x36,0x12,0x4, 0xfe,
-0x0, 0x0, 0x0, 0x0, 0x90,0xa, 0x3a,0x12,0x4, 0xfe,0x0, 0x0, 0x0, 0x1, 0x75,0x58,
-0x1, 0x75,0x59,0xa, 0x75,0x5a,0x42,0xf1,0xf1,0x90,0xa, 0xe5,0xe0,0xf5,0x4e,0xa3,
-0xe0,0xf5,0x4d,0xe5,0x4c,0x70,0x39,0xf5,0x4f,0xe5,0x4f,0xc3,0x95,0x4e,0x50,0x1d,
-0x51,0xc6,0xc0,0x0, 0xc0,0x1, 0xa3,0x71,0x2, 0x74,0xf5,0x25,0x4f,0x31,0xea,0xe0,
-0xf9,0xf8,0x12,0x4, 0xdf,0xd0,0x1, 0xd0,0x0, 0x51,0xd5,0x80,0xdc,0xe4,0xf5,0x4f,
-0x51,0xea,0x78,0x8, 0x12,0x4, 0xcc,0x51,0xe1,0xe5,0x4f,0xb4,0x4, 0xf2,0x80,0x3d,
-0xe4,0xf5,0x4f,0xe5,0x4f,0xc3,0x95,0x4d,0x50,0x22,0x51,0xc6,0xc0,0x0, 0xc0,0x1, 
-0xa3,0x71,0x2, 0x74,0x42,0x25,0x4f,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0xe0,0xf9,
-0xf8,0x12,0x4, 0xdf,0xd0,0x1, 0xd0,0x0, 0x51,0xd5,0x80,0xd7,0xe4,0xf5,0x4f,0x51,
-0xea,0x78,0x8, 0x12,0x4, 0xcc,0x51,0xe1,0xe5,0x4f,0xb4,0x2, 0xf2,0xe5,0x4c,0x70,
-0x12,0xf5,0x4f,0x12,0x64,0x25,0x24,0x75,0xf1,0x59,0x12,0x25,0xec,0xf1,0xb0,0xb4,
-0x4, 0xf1,0x22,0xe4,0xf5,0x4f,0x12,0x64,0x25,0x24,0x79,0xf1,0x59,0x12,0x25,0xec,
-0xf1,0xb0,0xb4,0x2, 0xf1,0x22,0x90,0xa, 0x36,0xe0,0xf8,0xa3,0xe0,0xf9,0xa3,0xe0,
-0xfa,0xa3,0xe0,0xfb,0x22,0xeb,0x4f,0xff,0xea,0x4e,0xfe,0xe9,0x4d,0xfd,0xe8,0x4c,
-0xfc,0x90,0xa, 0x36,0x12,0x4, 0xf2,0x5, 0x4f,0x22,0x90,0xa, 0x36,0xa3,0xa3,0xa3,
-0xe0,0xff,0x74,0x3e,0x25,0x4f,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0xef,0xf0,0x90,
-0xa, 0x36,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0xe0,0xfe,0xa3,0xe0,0xff,0x22,0x8b,0x30,
-0x8a,0x31,0x89,0x32,0x12,0x4c,0x59,0xf5,0x42,0x12,0x4d,0x67,0xf5,0x43,0xe5,0x42,
-0xd3,0x94,0x0, 0x50,0x8, 0xe5,0x43,0x94,0x0, 0x50,0x2, 0xa1,0xc2,0xf1,0xc3,0x74,
-0x1, 0x12,0x1, 0x92,0x90,0x0, 0x82,0x12,0x1, 0x65,0x64,0x5, 0x60,0x2, 0xa1,0xcb,
-0xf1,0xc3,0xf1,0x4b,0x12,0x1, 0x65,0x60,0x2, 0x81,0x20,0x90,0x0, 0x81,0x12,0x4f,
-0x81,0x60,0x2, 0x81,0x20,0x90,0x0, 0x83,0xf1,0x4b,0xe5,0x42,0x12,0x1, 0xd7,0x90,
-0x0, 0x81,0xe5,0x43,0x12,0x1, 0xd7,0xe4,0xf5,0x3c,0xe5,0x42,0x25,0x43,0xff,0xe4,
-0x33,0xfe,0xc3,0xe5,0x3c,0xf1,0x90,0x98,0x40,0x2, 0xa1,0xcb,0xe5,0x3c,0xc3,0x95,
-0x42,0x50,0x29,0xe5,0x32,0x24,0x30,0xf9,0xe4,0x35,0x31,0xd1,0x0, 0xb1,0xe7,0xab,
-0x30,0xaa,0x31,0xa9,0x32,0x75,0xf0,0x2, 0xe5,0x3c,0x12,0x15,0x98,0xf1,0x9f,0xe5,
-0x3c,0x75,0xf0,0x2, 0xd1,0x6, 0xfa,0x90,0x0, 0x1, 0x80,0x3c,0xab,0x30,0xe5,0x32,
-0x24,0x58,0xf9,0xe4,0x35,0x31,0xfa,0xc3,0xe5,0x3c,0x95,0x42,0xfd,0xe4,0x94,0x0, 
-0xfc,0xed,0xae,0x4, 0x78,0x3, 0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0x29,0xf9,0xea,
-0x3e,0xb1,0xe7,0x12,0x3f,0xaf,0xab,0x30,0xe5,0x32,0x2f,0xf9,0xe5,0x31,0x3e,0xfa,
-0x90,0x0, 0x87,0xf1,0x9f,0x90,0x0, 0x88,0x12,0x1, 0x65,0xc3,0x13,0xf5,0x40,0xb1,
-0xd3,0xa3,0xe5,0x41,0xf0,0xb1,0xd3,0xe5,0x40,0xf0,0xb1,0xdb,0x74,0x1, 0xf0,0xab,
-0x33,0xaa,0x34,0xa9,0x35,0xe5,0x41,0xf1,0xa7,0xe5,0x40,0x12,0x65,0xa0,0x12,0x2, 
-0xb7,0xff,0xb1,0xd3,0xa3,0xa3,0xe5,0xf0,0xf0,0xa3,0xef,0xf0,0x5, 0x3c,0x61,0x6a,
-0x90,0x0, 0x81,0xb1,0xf1,0xff,0x90,0x0, 0x80,0x12,0x1, 0x65,0x2f,0xf5,0x3d,0xe4,
-0xf5,0x3c,0xf1,0x74,0x98,0x40,0x2, 0xa1,0x6e,0xe5,0x3c,0xc3,0x9d,0x50,0x4, 0xb1,
-0xfa,0x80,0x11,0xb1,0xee,0xf1,0xcd,0xef,0x78,0x3, 0xc3,0x33,0xce,0x33,0xce,0xd8,
-0xf9,0x12,0x64,0xe5,0xb1,0xe7,0xf1,0xd8,0xb1,0xd2,0xa3,0xe0,0x75,0xf0,0x20,0xb1,
-0xcc,0xe0,0x12,0x15,0x95,0x12,0x2, 0xb7,0xf5,0x3f,0x85,0xf0,0x3e,0xb1,0xdb,0xe0,
-0x70,0x4, 0x15,0x3d,0xa1,0x6a,0xe4,0xf5,0x47,0xf5,0x46,0xf1,0x52,0x12,0x1, 0x4c,
-0xff,0xe5,0x46,0xc3,0x9f,0x40,0x2, 0xa1,0x20,0xb1,0xd3,0xa3,0xe0,0xff,0x65,0x46,
-0x70,0x2, 0xa1,0x1c,0xf1,0xd8,0xfa,0x75,0xf0,0x20,0xef,0xb1,0xcc,0xe0,0x12,0x15,
-0x95,0x12,0x1b,0xf6,0xb1,0xd3,0xa3,0xe0,0x75,0xf0,0x10,0xa4,0xff,0xb1,0xd3,0xe0,
-0x2f,0x12,0x43,0x2b,0xf1,0xea,0x33,0xaa,0x34,0xa9,0x35,0xf1,0xbc,0x2d,0xfd,0xec,
-0x35,0xf0,0xfc,0xc0,0x4, 0xc0,0x5, 0xe5,0x46,0xf1,0xa7,0xc0,0x83,0xc0,0x82,0xb1,
-0xd3,0xe0,0xff,0xd0,0x82,0xd0,0x83,0x12,0x41,0xf, 0x12,0x1b,0xf6,0xef,0xfb,0x7a,
-0x0, 0xe5,0x46,0x75,0xf0,0x10,0xa4,0x2b,0xff,0xea,0x35,0xf0,0xf1,0xea,0x33,0xab,
-0x33,0xaa,0x34,0xf1,0xbc,0x12,0x65,0xc4,0xc3,0xd0,0xe0,0x9f,0xff,0xd0,0xe0,0x9e,
-0xfe,0xb1,0xee,0xfd,0xe5,0x3c,0xc3,0x9d,0x50,0x12,0xd1,0x10,0x12,0x2, 0x8c,0xfd,
-0xd3,0xef,0x9d,0xe5,0xf0,0x12,0x43,0x3b,0x40,0x2, 0x5, 0x47,0x5, 0x46,0x81,0x7b,
-0xf1,0x52,0x12,0x1, 0x4c,0xc3,0x13,0xff,0xe5,0x47,0xc3,0x9f,0x40,0xe, 0x90,0x7, 
-0x9d,0x12,0x4f,0x8a,0x64,0x6, 0x60,0x4, 0xb1,0xdb,0xe4,0xf0,0xb1,0xd3,0xa3,0x71,
-0x7, 0xc3,0xe5,0x3f,0x9f,0xff,0xe5,0x3e,0x9e,0xfe,0x12,0x0, 0x6, 0x8e,0x3e,0x8f,
-0x3f,0xd1,0x10,0x90,0x0, 0x20,0x12,0x1, 0x65,0xff,0xd3,0xe5,0x3f,0x9f,0x74,0x80,
-0xf8,0x65,0x3e,0x98,0x40,0x4, 0xb1,0xdb,0xe4,0xf0,0x5, 0x3c,0x81,0x32,0xe5,0x3d,
-0x70,0xb, 0xab,0x30,0xaa,0x31,0xa9,0x32,0x90,0x0, 0x80,0x80,0x4b,0xf1,0x6a,0x12,
-0x1, 0x65,0xc3,0x94,0x4, 0x40,0x34,0xe4,0xf5,0x3c,0xf1,0x74,0x98,0x50,0x3c,0xe5,
-0x3c,0xc3,0x9d,0x50,0x4, 0xb1,0xfa,0x80,0x11,0xb1,0xee,0xf1,0xcd,0xef,0x78,0x3, 
-0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0x12,0x64,0xe5,0xb1,0xe7,0xb1,0xdb,0xe0,0xb4,
-0x1, 0x5, 0xb1,0xdb,0x74,0x2, 0xf0,0x5, 0x3c,0x80,0xcf,0xf1,0x6a,0x74,0x1, 0x2, 
-0x1, 0x92,0xf1,0x6a,0xe4,0xf1,0x4b,0xe4,0x12,0x4f,0x93,0x22,0xa4,0x29,0xf9,0xe5,
-0xf0,0x3a,0xfa,0x85,0x45,0x82,0x85,0x44,0x83,0xa3,0x22,0xe5,0x45,0x24,0x7, 0xf5,
-0x82,0xe4,0x35,0x44,0xf5,0x83,0x22,0xaf,0x1, 0xf5,0x44,0x8f,0x45,0x22,0x90,0x0, 
-0x80,0xab,0x30,0xaa,0x31,0xa9,0x32,0x2, 0x1, 0x65,0xe9,0x24,0x30,0xf9,0xe4,0x3a,
-0xfa,0xe5,0x3c,0x75,0xf0,0x8, 0xa4,0x29,0xf9,0xea,0x35,0xf0,0x22,0xfd,0xd1,0x74,
-0xab,0x36,0xaa,0x37,0xa9,0x38,0x22,0x8b,0x36,0x8a,0x37,0x89,0x38,0x90,0x0, 0x19,
-0x12,0x1, 0x65,0x7f,0x6, 0xd1,0xd, 0x90,0x0, 0x1a,0x12,0x1, 0x65,0xfd,0x7f,0xa, 
-0xd1,0xe, 0x90,0x0, 0x20,0x12,0x1, 0x65,0xfd,0x7f,0x8, 0xd1,0xe, 0x90,0x0, 0x1c,
-0x12,0x1, 0x65,0xfd,0x7f,0xc, 0xd1,0xe, 0x90,0x0, 0x1d,0x12,0x1, 0x65,0xfd,0x7f,
-0x2a,0xd1,0x74,0x12,0x4f,0x75,0xfd,0x7f,0x2e,0xd1,0x74,0xe4,0xfd,0x7f,0x1c,0xd1,
-0xe, 0x90,0x0, 0x21,0x12,0x1, 0x65,0x7f,0x2, 0xd1,0xd, 0x90,0x0, 0x22,0x12,0x1, 
-0x65,0xfd,0x7f,0x4, 0xf1,0x98,0xef,0x44,0x40,0xf5,0xa1,0xe5,0xdb,0x30,0xe3,0xfb,
-0x53,0xdb,0xf3,0x8d,0xa1,0xe5,0xdb,0x30,0xe3,0xfb,0x53,0xdb,0xf3,0x43,0xab,0x4, 
-0x22,0x8b,0x36,0x8a,0x37,0x89,0x38,0xe4,0xf5,0x3c,0xd1,0x10,0xf1,0x61,0xfd,0xe4,
-0xff,0x12,0x61,0x2c,0x8e,0x3d,0x8f,0x3e,0xe5,0x3c,0x70,0x3, 0x43,0x3d,0x20,0xf1,
-0x3e,0x94,0x10,0x40,0xe5,0x75,0x3c,0x10,0xe4,0xfd,0x7f,0xc0,0xf1,0x43,0x94,0x20,
-0x40,0xf6,0xe4,0xf5,0x3c,0xf1,0x52,0xf1,0x61,0xfe,0x54,0xf, 0xff,0xee,0xc4,0x54,
-0xf, 0xfd,0x12,0x61,0x38,0x8e,0x3d,0x8f,0x3e,0xf1,0x3e,0x94,0x8, 0x40,0xe6,0x75,
-0x3c,0x8, 0xe4,0xfd,0x7f,0xc0,0xf1,0x43,0x94,0x20,0x40,0xf6,0xe4,0xf5,0x3c,0x75,
-0xf0,0x2, 0xe5,0x3c,0xa4,0x24,0x54,0xf5,0x82,0xe5,0xf0,0x34,0xc, 0xf5,0x83,0xe4,
-0x93,0xf5,0x3d,0x74,0x1, 0x93,0xf5,0x3e,0xf1,0x3e,0x94,0xff,0x40,0xe1,0x90,0xe, 
-0x52,0xe4,0x93,0xfc,0x74,0x1, 0x93,0xfd,0xec,0xff,0xf1,0x98,0x8f,0xa1,0xe5,0xdb,
-0x30,0xe3,0xfb,0x85,0xa1,0x11,0x53,0xdb,0xf3,0x8d,0xa1,0xe5,0xdb,0x30,0xe3,0xfb,
-0x85,0xa1,0x12,0x53,0xdb,0xf3,0x43,0xab,0x4, 0xae,0x11,0xaf,0x12,0x22,0xe5,0x3d,
-0xff,0xad,0x3e,0xf1,0x1a,0x5, 0x3c,0xe5,0x3c,0xc3,0x22,0x12,0x1, 0xd7,0x90,0x0, 
-0x80,0x22,0xab,0x39,0xaa,0x3a,0xa9,0x3b,0x22,0xf9,0xe4,0x35,0x4a,0xfa,0xe5,0x4f,
-0x22,0x85,0x3c,0x82,0x75,0x83,0x0, 0x2, 0x1, 0x65,0xab,0x30,0xaa,0x31,0xa9,0x32,
-0x90,0x0, 0x83,0x22,0xab,0x30,0xaa,0x31,0xa9,0x32,0x90,0x0, 0x81,0x12,0x1, 0x65,
-0xff,0x90,0x0, 0x80,0x12,0x1, 0x65,0xfd,0x2f,0xff,0xe4,0x33,0xfe,0xe5,0x3c,0xc3,
-0x9f,0xee,0x64,0x80,0xf8,0x74,0x80,0x22,0x53,0xab,0x3, 0x53,0xdb,0xf3,0x22,0x12,
-0x1, 0x65,0xc3,0x13,0xf5,0x41,0x22,0x90,0x3, 0x80,0x75,0xf0,0x20,0x2, 0x5, 0x40,
-0xef,0x12,0x1, 0xc5,0x5, 0x4f,0xe5,0x4f,0x22,0x33,0xaa,0x22,0x8f,0x82,0xf5,0x83,
-0x2, 0x2, 0xb7,0xab,0x30,0xaa,0x31,0xa9,0x32,0x90,0x0, 0x82,0x22,0xff,0xc3,0xe5,
-0x3c,0x9f,0xff,0xe4,0x94,0x0, 0xfe,0x22,0xab,0x33,0xe5,0x35,0x24,0x80,0xf9,0xe5,
-0x34,0x34,0x3, 0x22,0xaf,0x3c,0xef,0x33,0x95,0xe0,0xfe,0xef,0x25,0xe0,0xff,0xee,
-0x22,0x75,0x5b,0xa, 0x75,0x5c,0x77,0x7b,0xff,0x7a,0x7, 0x79,0x5, 0x2, 0xa, 0x57,
-0xe4,0x90,0xc, 0x9c,0xf0,0x90,0xc, 0x6f,0xf0,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,0x83,
-0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x0, 0xc0,0x0, 0xc0,0x1, 0xc0,0x2, 0xc0,0x3, 0xc0,
-0x4, 0xc0,0x5, 0xc0,0x6, 0xc0,0x7, 0x11,0xf9,0x90,0xb, 0xf0,0xe0,0x60,0x2, 0x14,
-0xf0,0x90,0xa, 0xdf,0xe0,0x4, 0xf0,0x70,0x6, 0x90,0xa, 0xde,0xe0,0x4, 0xf0,0x90,
-0xa, 0xd8,0xe0,0xfe,0xa3,0xe0,0xff,0xc3,0x90,0xa, 0xdf,0xe0,0x9f,0x90,0xa, 0xde,
-0xe0,0x9e,0x50,0x3, 0x12,0x0, 0x4e,0x90,0xa, 0xe3,0xe0,0xfe,0xa3,0xe0,0xff,0x4e,
-0x60,0x16,0xef,0x64,0x1, 0x4e,0x70,0x2, 0xd2,0x0, 0x90,0xa, 0xe4,0xe0,0x24,0xff,
-0xf0,0x90,0xa, 0xe3,0xe0,0x34,0xff,0xf0,0x12,0x64,0x7, 0x12,0x4, 0xa5,0x40,0xe, 
-0x90,0xa, 0xdc,0xe0,0x4, 0xf0,0x70,0x6, 0x90,0xa, 0xdb,0xe0,0x4, 0xf0,0x90,0xc, 
-0x18,0xe0,0xb4,0xaa,0xf, 0x90,0xa, 0xda,0xe0,0xff,0x4, 0xf0,0xef,0xd3,0x94,0x64,
-0x40,0x2, 0xf1,0x44,0xe5,0xd, 0xc3,0x95,0xe, 0x50,0x12,0x5, 0xd, 0xe5,0xc9,0x54,
-0x3, 0xff,0xbf,0x1, 0xb, 0x74,0x3, 0x25,0xd, 0xf5,0xd, 0x80,0x3, 0x75,0xc, 0x1, 
-0x90,0xc, 0x68,0xe0,0xff,0x60,0xe, 0xc3,0x94,0x28,0x50,0x5, 0xe0,0x4, 0xf0,0x80,
-0x4, 0x31,0x4, 0x11,0x0, 0xd0,0x7, 0xd0,0x6, 0xd0,0x5, 0xd0,0x4, 0xd0,0x3, 0xd0,
-0x2, 0xd0,0x1, 0xd0,0x0, 0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,
-0xe5,0x92,0x60,0x4, 0xd2,0xae,0xd2,0xbe,0x22,0xc2,0x8e,0x75,0xa6,0xf0,0x75,0xa5,
-0x5f,0xd2,0x8e,0x22,0xe4,0x90,0xc, 0x6b,0xf0,0x90,0xc, 0x67,0x51,0x74,0x70,0x5, 
-0xa3,0x51,0x7d,0x80,0x9, 0x51,0x75,0xff,0xbf,0x4, 0x3, 0xa3,0x51,0x84,0xe4,0x90,
-0xc, 0x69,0xf0,0x90,0xc, 0x68,0xf0,0x90,0xc, 0x33,0x74,0xaa,0xf0,0xa3,0xf0,0x90,
-0xc, 0x4d,0xf0,0xa3,0xf0,0x22,0x71,0xc1,0xff,0xc3,0x94,0x80,0x40,0x10,0xef,0xd3,
-0x94,0xbf,0x50,0xa, 0x74,0x71,0x2f,0xf5,0x82,0xe4,0x34,0xb, 0x21,0xe7,0xa8,0x16,
-0xe6,0x24,0x4, 0x60,0xb, 0x24,0xfc,0x70,0xe, 0x90,0xc, 0x6c,0xe0,0xff,0x21,0xef,
-0x90,0xc, 0x18,0xe0,0xff,0x21,0xef,0x30,0x1, 0x8, 0x75,0xa, 0xc, 0x75,0xb, 0x33,
-0x80,0x6, 0x75,0xa, 0xc, 0x75,0xb, 0x4d,0xa8,0x16,0xe6,0xfe,0x24,0xfe,0x60,0x2b,
-0x24,0xfb,0x50,0x34,0x24,0xfe,0x24,0xfc,0x50,0x38,0x24,0xfe,0x24,0xfc,0x50,0x3e,
-0x24,0xfe,0x24,0xfc,0x50,0x41,0x24,0xfe,0x24,0xfc,0x50,0x44,0x24,0x1e,0x70,0x4d,
-0xe5,0xb, 0x24,0x4, 0xf5,0x82,0xe4,0x35,0xa, 0x80,0x3c,0x85,0xb, 0x82,0x85,0xa, 
-0x83,0xa3,0xa3,0xa3,0xe0,0xff,0x80,0x37,0xee,0x24,0x2, 0xff,0xe4,0x33,0x31,0xf6,
-0x80,0x25,0xa8,0x16,0xe6,0x25,0xb, 0xf5,0x82,0xe4,0x35,0xa, 0x80,0x19,0xa8,0x16,
-0xe6,0x24,0xfe,0x31,0xf2,0x80,0x10,0xa8,0x16,0xe6,0x24,0xfc,0x31,0xf2,0x80,0x7, 
-0xa8,0x16,0xe6,0x24,0xfa,0x31,0xf2,0xf5,0x83,0xe0,0xff,0x80,0x2, 0x7f,0x0, 0x5, 
-0x16,0x22,0xff,0xe4,0x34,0xff,0xfe,0xe5,0xb, 0x2f,0xf5,0x82,0xe5,0xa, 0x3e,0x22,
-0x30,0x95,0x54,0x90,0xc, 0x69,0xe0,0x4, 0xf0,0xe0,0xff,0xb4,0x1, 0x8, 0x90,0xc, 
-0x6d,0xe5,0x95,0xf0,0x80,0x29,0x90,0xc, 0x6c,0xe0,0xfe,0xc4,0x54,0x7, 0x70,0xc, 
-0xa3,0xe0,0x2f,0x24,0xfe,0xff,0xad,0x95,0xd1,0xe4,0x80,0x13,0x51,0x75,0xff,0xbf,
-0x4, 0xd, 0x90,0xc, 0x69,0x71,0xb9,0x24,0xfe,0xff,0xad,0x95,0x12,0x50,0x4c,0x51,
-0x75,0xfd,0x70,0xb, 0x71,0xaf,0x60,0xf, 0x90,0xc, 0x6d,0x51,0x7d,0x80,0x8, 0xbd,
-0x4, 0x5, 0x90,0xc, 0x6d,0x51,0x84,0x30,0x94,0x19,0x90,0xc, 0x67,0xe0,0x4, 0x51,
-0x74,0xfd,0x70,0x8, 0x71,0xaf,0x60,0xb, 0x71,0xb6,0x80,0x12,0xbd,0x4, 0x4, 0x71,
-0xb6,0x51,0x85,0x22,0xf0,0x90,0xc, 0x6c,0xe0,0xc4,0x54,0x7, 0x22,0xe0,0xff,0x31,
-0x36,0x8f,0x95,0x22,0xe0,0xff,0x51,0x8b,0x8f,0x95,0x22,0x71,0xc1,0xfe,0x12,0x5, 
-0x9c,0x32,0xb6,0x0, 0x32,0xbd,0x1, 0x32,0xc4,0x2, 0x32,0xc8,0x3, 0x32,0xcf,0x4, 
-0x32,0xd6,0x5, 0x32,0xdd,0x6, 0x32,0xe4,0x7, 0x32,0xeb,0x4c,0x32,0xf9,0x4e,0x32,
-0xf2,0xea,0x0, 0x0, 0x33,0x0, 0x90,0xc, 0x6c,0xe0,0xff,0x61,0xac,0x90,0xc, 0x6a,
-0xe0,0xff,0x61,0xac,0x7f,0xff,0x61,0xac,0x90,0xa, 0xe5,0xe0,0xff,0x61,0xac,0x90,
-0xa, 0xe6,0xe0,0xff,0x61,0xac,0x90,0xa, 0xe7,0xe0,0xff,0x61,0xac,0x90,0xa, 0xe8,
-0xe0,0xff,0x61,0xac,0x90,0xa, 0xe9,0xe0,0xff,0x61,0xac,0x90,0xa, 0xf2,0xe0,0xff,
-0x61,0xac,0x90,0xc, 0x9b,0xe0,0xff,0x61,0xac,0x90,0xb, 0x57,0xe0,0xff,0x61,0xac,
-0xee,0xc3,0x94,0x10,0x40,0x1e,0xa8,0x16,0xe6,0xff,0x94,0x24,0x50,0x16,0xe5,0x9, 
-0x2f,0xf5,0x82,0xe4,0x35,0x8, 0xf5,0x83,0xe5,0x82,0x24,0xf0,0xf5,0x82,0xe5,0x83,
-0x34,0xff,0x61,0xa4,0xa8,0x16,0xe6,0xff,0xc3,0x94,0x50,0x40,0x15,0xef,0xd3,0x94,
-0x77,0x50,0xf, 0x74,0xa5,0x2f,0x12,0x51,0xa2,0xe0,0xff,0x7d,0x77,0x12,0x0, 0x26,
-0x80,0x6a,0xa8,0x16,0xe6,0xff,0xc3,0x94,0x78,0x40,0x10,0xef,0xd3,0x94,0x9f,0x50,
-0xa, 0x74,0x99,0x2f,0xf5,0x82,0xe4,0x34,0xa, 0x80,0x49,0xa8,0x16,0xe6,0xff,0xc3,
-0x94,0xa0,0x40,0x10,0xef,0xd3,0x94,0xbe,0x50,0xa, 0x74,0x8d,0x2f,0xf5,0x82,0xe4,
-0x34,0xa, 0x80,0x30,0xa8,0x16,0xe6,0xff,0xc3,0x94,0xbf,0x40,0x10,0xef,0xd3,0x94,
-0xd2,0x50,0xa, 0x74,0x7e,0x2f,0xf5,0x82,0xe4,0x34,0xa, 0x80,0x17,0xa8,0x16,0xe6,
-0xff,0xc3,0x94,0xd3,0x40,0x14,0xef,0xd3,0x94,0xe1,0x50,0xe, 0x74,0x78,0x2f,0xf5,
-0x82,0xe4,0x34,0xa, 0xf5,0x83,0xe0,0xff,0x80,0x2, 0x7f,0xff,0x5, 0x16,0x22,0xff,
-0x31,0x36,0xef,0x64,0x10,0x22,0x90,0xc, 0x67,0xe0,0xff,0x90,0xc, 0x6d,0xe0,0x2f,
-0x22,0x15,0x16,0xa8,0x16,0xa6,0x7, 0xa8,0x16,0xe6,0x22,0xe4,0x90,0xc, 0x6c,0xf0,
-0x71,0xd4,0x21,0x4, 0x75,0x32,0x70,0x75,0x90,0x4, 0x7f,0x0, 0x7e,0x78,0x91,0x17,
-0x8f,0x33,0x7f,0x1, 0x7e,0x78,0x91,0x17,0xe5,0x33,0xf4,0x60,0xa, 0xe5,0x33,0x6f,
-0xff,0xbf,0xff,0x3, 0x85,0x33,0x32,0xe5,0x32,0xc3,0x13,0x54,0xf, 0xc4,0x54,0xf0,
-0xf5,0x93,0xd2,0xac,0x53,0xe8,0x3f,0x43,0xe8,0xc0,0xd2,0xec,0xd2,0xb9,0xc2,0xc1,
-0x43,0xb9,0x10,0x53,0xa9,0xef,0x22,0xe4,0xfd,0xab,0x7, 0xaa,0x6, 0xc2,0xaf,0x43,
-0xfc,0x3, 0xed,0xc4,0x54,0xf0,0xf5,0xf8,0x8a,0xf9,0x8b,0xfa,0x43,0xfc,0x3, 0x44,
-0xe0,0xf5,0xf8,0xaf,0xfb,0xf1,0x55,0xd2,0xaf,0x22,0x12,0x47,0x72,0x80,0xd8,0x75,
-0x40,0x0, 0x75,0x41,0x0, 0x75,0x42,0x2e,0x75,0x43,0xf, 0x75,0x44,0x77,0x7b,0xff,
-0x7a,0x6, 0x79,0xf6,0x12,0x8, 0x0, 0xe4,0xff,0xfe,0x91,0x3a,0x8f,0x2d,0x90,0xc, 
-0x11,0xe0,0x70,0x3, 0x75,0x2d,0xff,0xe5,0x2d,0xf4,0x60,0x49,0x7f,0xf0,0x7e,0x3, 
-0x91,0x3a,0x8f,0x29,0x7f,0xf1,0x7e,0x3, 0x91,0x3a,0x8f,0x2a,0xe5,0x29,0x45,0x2a,
-0xf4,0x60,0x3, 0x75,0x2d,0xff,0xe4,0xf5,0x2a,0xf5,0x2b,0xf5,0x2c,0xe5,0x2c,0x24,
-0x4, 0xff,0xe4,0x35,0x2b,0xfe,0x91,0x3a,0xef,0x62,0x2a,0x5, 0x2c,0xe5,0x2c,0x70,
-0x2, 0x5, 0x2b,0xc3,0x94,0xb, 0xe5,0x2b,0x94,0x1, 0x40,0xe1,0xe5,0x29,0x65,0x2a,
-0x60,0x3, 0x75,0x2d,0xff,0x90,0xa, 0xe5,0x74,0xf, 0xf0,0xa3,0x74,0xa, 0xf0,0xa3,
-0x74,0x2, 0xf0,0x90,0xb, 0x57,0x74,0x5, 0xf0,0xe4,0x90,0xa, 0xe8,0xf0,0xa3,0x74,
-0x3e,0xf0,0x90,0xa, 0xf3,0x12,0x66,0x9f,0x90,0xb, 0x58,0xf1,0x4b,0xe4,0xff,0x90,
-0xa, 0xe5,0xe0,0xfe,0xef,0xc3,0x9e,0x40,0xb, 0x74,0xf5,0x2f,0x12,0x29,0xea,0x74,
-0xff,0xf0,0x80,0xe, 0x74,0x2e,0x2f,0xf8,0xe6,0xfe,0x74,0xf5,0x2f,0x12,0x29,0xea,
-0xee,0xf0,0xef,0x90,0x7, 0xf, 0x93,0xfe,0x74,0x11,0x2f,0x12,0x64,0x7b,0xee,0xf0,
-0xf, 0xbf,0x1c,0xcb,0xe4,0xff,0xef,0x90,0x7, 0x3b,0x93,0xfe,0x74,0x3d,0x2f,0x12,
-0x64,0x6f,0xee,0xf0,0xf, 0xbf,0xe, 0xee,0xe4,0xff,0xef,0x90,0x7, 0x2b,0x93,0xfe,
-0x74,0x2d,0x2f,0x12,0xf, 0xe4,0xee,0xf0,0xf, 0xbf,0x10,0xee,0xe4,0xff,0xef,0x90,
-0x7, 0x49,0x93,0xfe,0x74,0x4b,0x2f,0x12,0xf, 0xc5,0xee,0xf0,0xf, 0xbf,0x8, 0xee,
-0xe4,0xf5,0x2b,0xf5,0x2c,0x74,0x5a,0x25,0x2c,0x12,0x47,0x8e,0x5, 0x2c,0xe5,0x2c,
-0x70,0x2, 0x5, 0x2b,0x64,0x96,0x45,0x2b,0x70,0xeb,0xe5,0x2d,0xf4,0x60,0x4, 0x7f,
-0x4, 0xb1,0x74,0x22,0x8f,0x3d,0x75,0x3e,0xb, 0x75,0x3f,0x4b,0xb1,0xd9,0xb1,0xb1,
-0x70,0x2, 0x5, 0x3e,0xb1,0xcd,0x70,0x2, 0x5, 0x40,0xc3,0x94,0x8, 0xe5,0x40,0x94,
-0x0, 0x40,0xeb,0x75,0x3e,0xb, 0x75,0x3f,0x5a,0xb1,0xd9,0xb1,0xb1,0x70,0x2, 0x5, 
-0x3e,0xb1,0xcd,0x70,0x2, 0x5, 0x40,0xc3,0x94,0x96,0xe5,0x40,0x94,0x0, 0x40,0xeb,
-0x22,0xaf,0x3d,0x7e,0x0, 0xe5,0x41,0x25,0x3d,0xcf,0xee,0x35,0x40,0xcf,0x25,0x43,
-0xcf,0x35,0x42,0xfe,0x91,0x3a,0x5, 0x3f,0xe5,0x3f,0xac,0x3e,0x22,0x14,0xf5,0x82,
-0x8c,0x83,0xef,0xf0,0x5, 0x41,0xe5,0x41,0x22,0x75,0x42,0xa, 0x75,0x43,0xe5,0xc3,
-0xe5,0x3f,0x95,0x43,0xff,0xe5,0x3e,0x95,0x42,0xf5,0x42,0x8f,0x43,0xe4,0xf5,0x40,
-0xf5,0x41,0x22,0x12,0x46,0xe7,0xd1,0x71,0xf1,0x37,0x7f,0x1, 0x12,0x60,0xf7,0x71,
-0xcb,0x91,0x3f,0xf1,0x44,0x90,0xc, 0x18,0xe0,0x24,0xfd,0x60,0x14,0x14,0x60,0x16,
-0x24,0xaf,0x60,0x2e,0x24,0xab,0x60,0x13,0x24,0xa9,0x70,0xe9,0x12,0x21,0x89,0x80,
-0xe4,0x12,0x27,0x6, 0x80,0xdf,0x12,0x28,0x0, 0x80,0xda,0xd1,0x69,0x90,0xa, 0xe2,
-0xe0,0x64,0xaa,0x60,0xd0,0xe4,0x90,0xa, 0xda,0xf0,0x90,0xa, 0xe2,0x74,0xaa,0xf0,
-0x80,0xc3,0xd1,0x69,0x90,0xa, 0xe2,0xe0,0xb4,0xaa,0xba,0x74,0x55,0xf0,0x90,0xc, 
-0xc8,0xf1,0x4b,0x90,0xc, 0xc8,0x74,0xff,0xf5,0xf0,0x12,0x2, 0x76,0x45,0xf0,0x70,
-0xf2,0x12,0x53,0x23,0x75,0xe9,0xff,0x80,0x9c,0xe4,0x90,0xa, 0xde,0xf0,0xa3,0xf0,
-0x22,0x2, 0x0, 0x19,0x8d,0x69,0xef,0xc3,0x94,0xa, 0x50,0xa, 0x74,0x92,0x2f,0xf5,
-0x82,0xe4,0x34,0xc, 0x80,0x4e,0xef,0x24,0xf6,0xf5,0x6a,0xc3,0x94,0xb, 0x74,0x80,
-0x94,0x81,0x50,0x45,0xe5,0x6a,0xb4,0x4f,0x1d,0x90,0xc, 0x6e,0xe0,0x60,0xb, 0x7f,
-0x1, 0x12,0x1d,0xa7,0xe4,0x90,0xc, 0x6e,0xf0,0x22,0xe4,0xff,0x12,0x1d,0xa7,0x90,
-0xc, 0x6e,0x74,0x1, 0xf0,0x22,0xe5,0x6a,0xc3,0x94,0x10,0x40,0x15,0xe5,0x6a,0xd3,
-0x94,0x1f,0x50,0xe, 0x7d,0x77,0xaf,0x69,0x12,0x6, 0xd3,0xd1,0xda,0xf5,0x83,0xef,
-0xf0,0x22,0xd1,0xda,0xf5,0x83,0xe5,0x69,0xf0,0x22,0x74,0xe5,0x25,0x6a,0xf5,0x82,
-0xe4,0x34,0xa, 0x22,0x8f,0x67,0x8d,0x68,0xe5,0x67,0xc3,0x94,0x80,0x40,0xe, 0xe5,
-0x67,0xd3,0x94,0xbf,0x50,0x7, 0xe5,0x67,0x24,0x80,0xff,0x80,0x36,0xe5,0x67,0x24,
-0x4, 0x60,0x2c,0x24,0xfc,0x70,0x2f,0x12,0x51,0xaa,0xf5,0x68,0xb4,0x4, 0xf, 0x90,
-0xc, 0x18,0xe0,0x7d,0x3, 0xb4,0x3, 0x2, 0x80,0xd, 0x7f,0x27,0x80,0x15,0x90,0xc, 
-0x18,0xe0,0x7d,0x1, 0xb4,0x3, 0x4, 0x7f,0x1, 0xc1,0x74,0x7f,0x27,0x80,0x4, 0xad,
-0x68,0x7f,0x27,0x12,0x4f,0xa7,0x22,0x12,0x52,0x2e,0xc2,0x8e,0x43,0xa2,0x10,0x11,
-0xfb,0xd2,0xab,0x22,0x90,0xc, 0x18,0x74,0x1, 0xf0,0x22,0x74,0x3, 0xf0,0xa3,0x74,
-0xe8,0xf0,0x22,0xf1,0x97,0x43,0xfc,0x3, 0xe4,0xf5,0xf8,0x22,0xab,0x7, 0xaa,0x6, 
-0xc2,0xaf,0xf1,0x55,0x8a,0xf9,0x8b,0xfa,0x8d,0xfb,0x43,0xfc,0x3, 0x75,0xf8,0x82,
-0x7f,0xa, 0xf1,0x97,0xd2,0xf8,0x7f,0x4, 0xf1,0x97,0xd2,0xfe,0x7f,0x26,0xf1,0x97,
-0xc2,0xfe,0xc2,0xf9,0x7f,0xc, 0xf1,0x97,0xc2,0xf8,0x7f,0x1, 0xf1,0x53,0xd2,0xaf,
-0x22,0x7f,0xfa,0xf1,0x97,0x7f,0xfa,0xae,0x7, 0x1f,0xee,0x60,0xf, 0x0, 0x0, 0x0, 
-0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80,0xeb,0x22,0xad,0x7, 0xac,
-0x6, 0xc2,0xaf,0xf1,0x55,0x8c,0xf9,0x8d,0xfa,0x43,0xfc,0x3, 0x75,0xf8,0x88,0x7f,
-0x14,0xf1,0x97,0x75,0xf8,0x89,0x7f,0x2d,0xf1,0xd9,0xc2,0xfb,0x7f,0x14,0xf1,0x97,
-0xc2,0xf8,0x7f,0xa, 0xf1,0x53,0xd2,0xaf,0x22,0xad,0x7, 0xaf,0x5, 0x1d,0xef,0x60,
-0xa, 0xf1,0x91,0x7f,0xfa,0xf1,0x97,0xf1,0x91,0x80,0xf0,0x22,0x90,0xc, 0x93,0x74,
-0x3, 0xf0,0xe4,0x90,0xc, 0x9a,0xf0,0x90,0xc, 0x92,0x74,0xff,0xf0,0x90,0xc, 0x9b,
-0x74,0x1, 0xf0,0x22,0x74,0xff,0xf5,0xf0,0x12,0x3, 0x3c,0x90,0x0, 0x2, 0x74,0xff,
-0xf5,0xf0,0x12,0x3, 0x5b,0x90,0x0, 0x4, 0x74,0xff,0x2, 0x1, 0xd7,0x8b,0x32,0x8a,
-0x33,0x89,0x34,0xe4,0xf5,0x38,0xf5,0x39,0x12,0x64,0xa1,0x70,0x2, 0x5, 0x38,0x64,
-0x92,0x45,0x38,0x70,0xf3,0xab,0x35,0xaa,0x36,0xa9,0x37,0xe4,0xf5,0x38,0xf5,0x39,
-0x12,0x64,0xa1,0x70,0x2, 0x5, 0x38,0x64,0x53,0x45,0x38,0x70,0xf3,0xe4,0xf5,0x38,
-0xf5,0x39,0xab,0x32,0xe5,0x34,0x24,0xa, 0xf9,0xe4,0x35,0x33,0xfa,0xae,0x38,0xaf,
-0x39,0x7c,0x0, 0x7d,0x7, 0x11,0xc2,0x11,0xb2,0x24,0x3, 0x11,0xb9,0x11,0xb2,0x24,
-0x26,0x11,0xb9,0x11,0x4, 0x5, 0x39,0xe5,0x39,0x70,0x2, 0x5, 0x38,0xc3,0x94,0x5, 
-0xe5,0x38,0x94,0x0, 0x40,0xcc,0xab,0x35,0xaa,0x36,0xa9,0x37,0x90,0x0, 0x51,0x74,
-0x1, 0x12,0x1, 0xd7,0xe4,0xf5,0xd, 0xf5,0xe, 0xf5,0xc, 0x12,0x46,0xe8,0xe4,0xa3,
-0xf0,0x90,0xa, 0xe2,0xf0,0xa3,0xf0,0xa3,0xf0,0xc2,0x0, 0x90,0xa, 0xdb,0xf0,0xa3,
-0xf0,0x22,0x11,0x4, 0xab,0x35,0xe5,0x37,0x22,0xf9,0xe4,0x35,0x36,0xfa,0xae,0x38,
-0xaf,0x39,0x12,0x1, 0xf9,0xe9,0x2f,0xf9,0xea,0x3e,0xfa,0x22,0x12,0x65,0xd1,0xe4,
-0xf5,0x2f,0xf5,0x30,0x12,0x15,0x6f,0xf5,0x31,0x70,0x42,0xf5,0x2d,0xe5,0x2d,0xfd,
-0x33,0x95,0xe0,0xfc,0xf1,0xaf,0x74,0xc9,0x2f,0xf5,0x82,0x74,0xa, 0x12,0x47,0x6a,
-0x90,0xa, 0xaa,0x75,0xf0,0x7, 0xed,0x12,0x5, 0x40,0xec,0x75,0xf0,0x7, 0xa4,0x25,
-0x83,0xf5,0x83,0x74,0xff,0xf0,0x71,0x4, 0xfe,0x74,0xd3,0x2f,0xf5,0x82,0x74,0xa, 
-0x3e,0xf5,0x83,0x74,0x2, 0xf0,0x5, 0x2d,0xe5,0x2d,0xb4,0x5, 0xc0,0xe4,0xf5,0x2d,
-0x12,0x15,0x1c,0x12,0x15,0x6f,0xfd,0x71,0x4, 0xfe,0xc3,0xef,0x9d,0x74,0x80,0xf8,
-0x6e,0x98,0x40,0x2, 0x41,0xcd,0x7c,0x0, 0x7d,0x7, 0x11,0xc2,0x12,0x17,0xee,0xff,
-0xf4,0x70,0x2, 0x41,0xc9,0x12,0x63,0x6f,0x12,0x1, 0x4c,0x60,0x6, 0x64,0x2, 0x60,
-0x2, 0x41,0xc9,0xe4,0xf5,0x2e,0x91,0xa7,0xff,0x51,0xe8,0xe0,0x6f,0x60,0x2, 0x41,
-0xbe,0x90,0x0, 0x2, 0x12,0x15,0x5c,0xe5,0x2e,0x75,0xf0,0x7, 0xa4,0x24,0xa8,0xf5,
-0x82,0xe4,0x34,0xa, 0x71,0x1c,0xf1,0xb7,0x12,0x0, 0x6, 0xc0,0x6, 0xc0,0x7, 0x12,
-0x15,0x1c,0x71,0x4, 0x8f,0x82,0xf5,0x83,0x74,0x7, 0x12,0x5, 0x2f,0x12,0x15,0x5c,
-0xe5,0x2e,0x75,0xf0,0x7, 0xa4,0x24,0xa6,0xf5,0x82,0xe4,0x34,0xa, 0x71,0x1c,0xf1,
-0xb7,0x12,0x0, 0x6, 0xd0,0xe0,0x2f,0xf5,0x30,0xd0,0xe0,0x3e,0xf5,0x2f,0x51,0xe8,
-0xe0,0xff,0xf1,0xdd,0xd3,0x94,0x0, 0x40,0xe, 0xef,0x51,0xfa,0xf1,0xc9,0x51,0xe8,
-0xe0,0xf1,0xdd,0x14,0xf0,0x41,0xc9,0x51,0xe8,0x51,0xf8,0x71,0x1c,0xd3,0x94,0x64,
-0xec,0x94,0x0, 0x40,0xd, 0xd3,0xe5,0x30,0x94,0x64,0xe5,0x2f,0x94,0x0, 0x40,0x2, 
-0x80,0x22,0xed,0x24,0x32,0xff,0xe4,0x3c,0xfe,0xd3,0xe5,0x30,0x9f,0xe5,0x2f,0x9e,
-0x40,0x15,0x51,0xe8,0x51,0xf8,0xf5,0x83,0xe0,0xfc,0xa3,0xe0,0xd3,0x94,0x32,0xec,
-0x94,0x0, 0x40,0x3, 0xef,0x41,0xb8,0x51,0xe8,0xe0,0xfd,0x51,0xfa,0xf5,0x83,0xa3,
-0xe0,0x12,0x65,0x99,0xff,0x5, 0x82,0xd5,0x82,0x2, 0x15,0x83,0x15,0x82,0xe0,0xc4,
-0x54,0xf0,0x48,0xfe,0xc3,0xe5,0x30,0x9f,0xe5,0x2f,0x9e,0x50,0x3, 0xed,0x41,0xb8,
-0xab,0x2a,0xaa,0x2b,0xa9,0x2c,0x90,0x0, 0x6, 0x12,0x2, 0xb7,0xff,0xd3,0xe5,0x30,
-0x9f,0xe5,0x2f,0x95,0xf0,0x40,0x6e,0x91,0xa7,0xff,0x12,0x63,0x6f,0x12,0x1, 0x4c,
-0x70,0x4, 0x74,0x3, 0x80,0x2, 0x74,0x1, 0x12,0x1, 0xc5,0x91,0xa7,0xfd,0xe5,0x29,
-0x24,0x28,0xf9,0xe4,0x35,0x28,0x12,0x52,0x1e,0xf1,0xbf,0xfa,0x78,0x36,0x7c,0xa, 
-0x7d,0x1, 0xf1,0xa1,0xe5,0x31,0xd3,0x94,0x0, 0x40,0x3a,0x15,0x31,0xe5,0x31,0x12,
-0x15,0x3a,0xc0,0x3, 0xc0,0x2, 0xc0,0x1, 0x71,0x4, 0xfe,0x7c,0x0, 0x7d,0x7, 0x12,
-0x1, 0xf9,0xf1,0xc1,0xa8,0x1, 0xfc,0xad,0x3, 0xd0,0x1, 0xd0,0x2, 0xd0,0x3, 0xf1,
-0xa1,0xe5,0x31,0x75,0xf0,0x7, 0xa4,0x25,0x29,0xf9,0xe5,0x28,0x35,0xf0,0x7f,0x7, 
-0x12,0x63,0x5f,0x15,0x2d,0x51,0xe8,0xe0,0x51,0xfa,0xf1,0xc9,0x80,0xb, 0x5, 0x2e,
-0xe5,0x2e,0xc3,0x94,0x5, 0x50,0x2, 0x21,0x56,0x5, 0x2d,0x21,0x20,0x12,0x15,0x1c,
-0x90,0x0, 0x41,0xe5,0x31,0x12,0x1, 0xd7,0x78,0xa6,0x7c,0xa, 0x7d,0x1, 0x12,0x15,
-0x1c,0x7e,0x0, 0x7f,0x23,0x2, 0x1, 0x26,0xe5,0x2e,0x75,0xf0,0x7, 0xa4,0x24,0xaa,
-0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0xe0,0xff,0x25,0xe0,0x24,0xc9,0xf5,0x82,
-0xe4,0x34,0xa, 0x22,0xaf,0x2d,0xef,0x33,0x95,0xe0,0x22,0xe5,0x2d,0x25,0xe0,0xff,
-0xe5,0x2c,0x33,0xfe,0xe5,0x31,0x2f,0xf5,0x82,0xe5,0x30,0x3e,0xf5,0x83,0xe0,0xfc,
-0xa3,0xe0,0xfd,0x22,0x12,0x17,0xfa,0x12,0x15,0xb1,0x90,0x7, 0x9d,0x12,0x1, 0x65,
-0xff,0xf5,0x34,0x12,0x15,0x1c,0x90,0x0, 0x15,0x12,0x1, 0x65,0xf5,0x35,0x90,0x0, 
-0x16,0x12,0x1, 0x65,0xf5,0x36,0xef,0x70,0x2, 0x81,0x89,0x12,0x15,0xb1,0x90,0x7, 
-0x9d,0x12,0x1, 0x65,0xb4,0x4, 0x8, 0xe5,0x35,0x25,0xe0,0x25,0xe0,0xf5,0x35,0xae,
-0x2, 0xaf,0x1, 0x8e,0x2e,0x8f,0x2f,0x12,0x4f,0x9d,0xf5,0x30,0x8f,0x31,0xe5,0x26,
-0x24,0x60,0xf9,0xe5,0x25,0x34,0x7, 0xaf,0x1, 0xf5,0x32,0x8f,0x33,0xe4,0xf5,0x2a,
-0x12,0x17,0x63,0x12,0x1, 0x4c,0xff,0xe5,0x2a,0xc3,0x9f,0x40,0x2, 0x81,0x89,0xe5,
-0x2a,0x75,0xf0,0x10,0xa4,0x85,0xf0,0x2c,0xf5,0x2d,0xe4,0xf5,0x2b,0x12,0x17,0x63,
-0x12,0x47,0xbf,0xff,0xe5,0x2b,0xc3,0x9f,0x40,0x2, 0x81,0x85,0xe5,0x34,0xb4,0x3, 
-0x2, 0x81,0x46,0xe5,0x34,0xb4,0x2, 0x11,0x91,0x8a,0xf5,0x83,0xc0,0x83,0xc0,0x82,
-0x91,0x9c,0xd5,0x82,0x2, 0x15,0x83,0x81,0x6d,0xe5,0x34,0xb4,0x5, 0x4, 0x71,0xb, 
-0x80,0x2e,0xe5,0x34,0x64,0x6, 0x70,0x69,0xe5,0x2d,0xae,0x2c,0x78,0x3, 0xce,0xc3,
-0x13,0xce,0x13,0xd8,0xf9,0xf1,0xd3,0x12,0x63,0x34,0xfe,0xef,0x5e,0x60,0x32,0x12,
-0x63,0x1, 0x40,0x13,0xe5,0x35,0xfd,0xe5,0x2d,0x25,0xe0,0xff,0xe5,0x2c,0x33,0xfe,
-0x91,0x93,0xf5,0x83,0xec,0x80,0x47,0x71,0xb, 0x12,0x64,0xd7,0xf1,0x99,0x50,0x69,
-0x91,0x93,0xf5,0x83,0xc0,0x83,0xc0,0x82,0x91,0x9c,0xd5,0x82,0x2, 0x15,0x83,0x80,
-0x4c,0xe5,0x2d,0xae,0x2c,0x78,0x3, 0xce,0xc3,0x13,0xce,0x13,0xd8,0xf9,0xf1,0xd3,
-0xc0,0x83,0xc0,0x82,0x12,0x63,0x34,0xfe,0xef,0x4e,0xd0,0x82,0xd0,0x83,0xf0,0x80,
-0x38,0x12,0x63,0x1, 0x40,0xf, 0xe5,0x35,0xfd,0x91,0x8a,0xf5,0x83,0xe4,0x8d,0xf0,
-0x12,0x2, 0x60,0x80,0x24,0x71,0xb, 0x12,0x64,0xd7,0xf1,0x99,0x50,0x1b,0x91,0x93,
-0xf5,0x83,0xc0,0x83,0xc0,0x82,0x91,0x9c,0xd5,0x82,0x2, 0x15,0x83,0x15,0x82,0xe0,
-0x9e,0xd0,0x82,0xd0,0x83,0xf0,0xa3,0xef,0xf0,0x5, 0x2d,0xe5,0x2d,0x70,0x2, 0x5, 
-0x2c,0x5, 0x2b,0x61,0x9d,0x5, 0x2a,0x61,0x80,0x22,0xe5,0x2d,0x25,0xe0,0xff,0xe5,
-0x2c,0x33,0xfe,0xe5,0x2f,0x2f,0xf5,0x82,0xe5,0x2e,0x3e,0x22,0x7e,0x0, 0xc3,0xa3,
-0xe0,0x95,0x35,0xff,0x5, 0x82,0x22,0xaf,0x2d,0xef,0x33,0x95,0xe0,0xfe,0x7c,0x0, 
-0x7d,0x7, 0x12,0x1, 0xf9,0x90,0x0, 0x4, 0xab,0x27,0xe5,0x29,0x2f,0xf9,0xe5,0x28,
-0x3e,0xfa,0x2, 0x1, 0x65,0x12,0x17,0xfa,0xe4,0xf5,0x29,0xe5,0x29,0xc3,0x94,0x5, 
-0x50,0x10,0xe5,0x26,0x24,0x30,0xf9,0xe4,0x35,0x25,0xfa,0xe5,0x29,0x12,0x2e,0x3, 
-0x80,0x14,0xe5,0x29,0x75,0xf0,0x8, 0xa4,0x24,0x30,0xff,0xe4,0x35,0xf0,0xfe,0xe5,
-0x26,0x2f,0xf9,0xe5,0x25,0x3e,0xaf,0x1, 0xf5,0x2a,0x8f,0x2b,0xb1,0xde,0x64,0x2, 
-0x60,0x2, 0xa1,0xd3,0xe5,0x2b,0x24,0x7, 0x12,0x63,0xeb,0xe4,0xf0,0xf1,0x7f,0xa3,
-0xe0,0x24,0xfe,0xf5,0x27,0xf1,0x7f,0xa3,0xe0,0x24,0x2, 0xff,0xe4,0xad,0x27,0xf1,
-0x8e,0x40,0x2, 0xa1,0xd3,0xf1,0x7f,0xe0,0x24,0xfe,0xf5,0x28,0xf1,0x7f,0xe0,0x24,
-0x2, 0xff,0xe4,0x33,0xfe,0xad,0x28,0xf1,0x90,0x40,0x2, 0xa1,0xcf,0xc3,0xe5,0x27,
-0x64,0x80,0x94,0x80,0x50,0x2, 0xa1,0xcb,0xe5,0x27,0x64,0x80,0x94,0x9c,0x50,0x7b,
-0xc3,0xe5,0x28,0x64,0x80,0x94,0x80,0x40,0x72,0xe5,0x28,0x64,0x80,0x94,0x90,0x50,
-0x6a,0xab,0x21,0xe5,0x23,0x24,0x80,0xf9,0xe5,0x22,0x12,0x63,0xc7,0x78,0x5, 0xc3,
-0x33,0xce,0x33,0xce,0xd8,0xf9,0x29,0xf9,0xea,0x3e,0xfa,0xf1,0xaf,0x11,0xc5,0x12,
-0x2, 0x8c,0xfd,0xaf,0x27,0x12,0x62,0xba,0xab,0x28,0xeb,0x33,0x95,0xe0,0xfa,0xef,
-0x2b,0xff,0xee,0x3a,0x12,0x2f,0xea,0x33,0x12,0x17,0x63,0x8f,0x82,0xf5,0x83,0xe5,
-0xf0,0x8d,0xf0,0x12,0x2, 0xef,0xe9,0x24,0x80,0xf9,0xea,0x12,0x63,0xc7,0x78,0x5, 
-0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0x29,0xf9,0xea,0x3e,0xfa,0xaf,0x28,0x12,0x2f,
-0xe6,0x33,0xfe,0x11,0xc5,0xe4,0xf5,0xf0,0x12,0x3, 0x3c,0x5, 0x28,0xa1,0x2c,0x5, 
-0x27,0xa1,0x15,0x5, 0x29,0xe5,0x29,0x64,0xa, 0x60,0x2, 0x81,0xcb,0x22,0xe5,0x2b,
-0x24,0x7, 0xf5,0x82,0xe4,0x35,0x2a,0xf5,0x83,0xe0,0x22,0x12,0x17,0xfa,0x75,0x2a,
-0xb, 0x75,0x2b,0xf1,0x90,0xc, 0x31,0xe0,0x20,0xe0,0x2, 0xe1,0x77,0x54,0xfe,0xf0,
-0x90,0x0, 0x2, 0x12,0x1, 0x65,0xff,0x85,0x2b,0x82,0x85,0x2a,0x83,0xe0,0x6f,0x60,
-0x15,0xe0,0xff,0x90,0x0, 0x2, 0x12,0x1, 0xd7,0xef,0x75,0xf0,0x4, 0xa4,0xff,0xe5,
-0xf0,0x8f,0xf0,0x12,0x3, 0x3c,0x12,0x17,0x63,0x12,0x1f,0xed,0xff,0xf1,0x7f,0xe0,
-0xfd,0x7c,0x0, 0x6f,0x70,0x2, 0xe5,0xf0,0x60,0x6, 0x90,0x0, 0x3, 0x12,0x1f,0xe0,
-0x12,0x15,0x1c,0x90,0x0, 0x3, 0xf1,0x78,0x24,0x5, 0xb1,0xe2,0xfe,0x6f,0x60,0x14,
-0x90,0x0, 0x3, 0xf1,0x87,0x24,0x5, 0xb1,0xe2,0x75,0xf0,0x20,0xa4,0xff,0x90,0x0, 
-0x1, 0x12,0x17,0xc0,0x12,0x15,0x1c,0x90,0x0, 0x5, 0xf1,0x78,0x24,0x17,0xb1,0xe2,
-0xfe,0x6f,0x60,0xf, 0x90,0x0, 0x5, 0xf1,0x87,0x24,0x17,0xb1,0xe2,0x90,0x0, 0x4, 
-0x12,0x1, 0xd7,0x12,0x15,0x1c,0x90,0x0, 0x6, 0xf1,0xa8,0x24,0x2e,0xb1,0xe2,0xfd,
-0x7c,0x0, 0x6f,0x70,0x2, 0xe5,0xf0,0x60,0x6, 0x90,0x0, 0x6, 0x12,0x1f,0xe0,0x12,
-0x15,0xb1,0x12,0x1, 0x4c,0xff,0xe5,0x2b,0x24,0x25,0xb1,0xe2,0xfe,0x6f,0x60,0x4, 
-0xee,0x12,0x1, 0xc5,0x12,0x17,0xdc,0xff,0xe5,0x2b,0x24,0x6, 0xb1,0xe2,0xfe,0x6f,
-0x60,0x4, 0xee,0x12,0x4a,0xa3,0x90,0x0, 0x4, 0xf1,0x78,0x24,0x8, 0xb1,0xe2,0xfe,
-0x6f,0x60,0x27,0x90,0x0, 0x4, 0xf1,0x87,0x24,0x8, 0xb1,0xe2,0xc3,0x94,0xf, 0x40,
-0x9, 0xe5,0x2b,0x24,0x8, 0x12,0x63,0xeb,0xe4,0xf0,0xe5,0x2b,0x24,0x8, 0xb1,0xe2,
-0x90,0x7, 0x6d,0x93,0x90,0x0, 0x3, 0x12,0x1, 0xd7,0x12,0x15,0xb1,0x90,0x0, 0x6, 
-0xf1,0x78,0x24,0x9, 0xb1,0xe2,0xfe,0x6f,0x60,0xf, 0x90,0x0, 0x6, 0xf1,0x87,0x24,
-0x9, 0xb1,0xe2,0x90,0x0, 0x5, 0x12,0x1, 0xd7,0x12,0x15,0xb1,0x90,0x0, 0x8, 0x12,
-0x1, 0x65,0xff,0xb1,0xde,0xfe,0x6f,0x60,0x7, 0x90,0x0, 0x8, 0xee,0x12,0x1, 0xd7,
-0x90,0x0, 0xa, 0xf1,0x78,0x24,0x24,0xb1,0xe2,0xfe,0x6f,0x60,0x7, 0x90,0x0, 0xa, 
-0xee,0x12,0x1, 0xd7,0x12,0x17,0x63,0x90,0x0, 0xb, 0xf1,0xa8,0x24,0x33,0xb1,0xe2,
-0xfd,0x7c,0x0, 0x6f,0x70,0x2, 0xe5,0xf0,0x60,0x6, 0x90,0x0, 0xb, 0x12,0x1f,0xe0,
-0x12,0x17,0x63,0x90,0x0, 0xd, 0xf1,0x78,0x24,0x34,0xb1,0xe2,0xfe,0x6f,0x60,0x7, 
-0x90,0x0, 0xd, 0xee,0x12,0x1, 0xd7,0x22,0x12,0x1, 0x65,0xff,0xe5,0x2b,0x22,0x85,
-0x2b,0x82,0x85,0x2a,0x83,0xa3,0x22,0xee,0x12,0x1, 0xd7,0xe5,0x2b,0x22,0x33,0xfe,
-0xed,0x33,0x95,0xe0,0xfc,0xd3,0xed,0x9f,0xee,0x64,0x80,0xf8,0xec,0x64,0x80,0x98,
-0x22,0x7e,0x0, 0x7f,0x7, 0x2, 0x1, 0x26,0x12,0x2, 0xb7,0xff,0xe5,0x2b,0x22,0xed,
-0x25,0xe0,0xff,0xec,0x33,0xfe,0x22,0xc3,0xef,0x9d,0xff,0xee,0x9c,0xfe,0x22,0xab,
-0x27,0xe5,0x29,0x2f,0xf9,0xe5,0x28,0x3e,0x22,0xf5,0x83,0xe5,0x2f,0xf0,0xa3,0xe5,
-0x30,0xf0,0x22,0x25,0x33,0xf5,0x82,0xe5,0x32,0x3e,0xf5,0x83,0x22,0x24,0xd3,0xf5,
-0x82,0xe4,0x34,0xa, 0xf5,0x83,0xe0,0x22,0x12,0x17,0xfa,0xe4,0xf5,0x24,0xe4,0xf5,
-0x25,0x12,0x17,0x63,0x12,0x41,0x2, 0x12,0x2, 0xb7,0x12,0x47,0x9b,0x40,0x2, 0x1, 
-0xe9,0xe4,0xf5,0x27,0x85,0x25,0x26,0x12,0x17,0x63,0x12,0x15,0x49,0xb1,0x1, 0x94,
-0x80,0x50,0x5, 0x75,0x27,0x1, 0x80,0xb, 0xe5,0x26,0xd3,0x94,0x0, 0x40,0x4, 0x15,
-0x26,0x80,0xe4,0xe5,0x27,0x70,0x21,0xe5,0x25,0x4, 0xf5,0x26,0xe5,0x26,0xc3,0x94,
-0xf, 0x50,0x15,0x12,0x17,0x63,0x12,0x15,0x49,0xb1,0x1, 0x94,0x80,0x50,0x5, 0x75,
-0x27,0x1, 0x80,0x4, 0x5, 0x26,0x80,0xe4,0xe5,0x27,0x64,0x1, 0x60,0x2, 0x1, 0xe9,
-0x12,0x17,0x63,0x31,0x2, 0x12,0x1b,0xf6,0x71,0x23,0x12,0x2f,0xea,0x12,0x2f,0xb9,
-0xae,0xf0,0x2d,0xf5,0x29,0xec,0x3e,0xf5,0x28,0xe5,0x26,0x31,0x4, 0x12,0x1b,0xf6,
-0xe5,0x26,0x71,0x25,0x12,0x2f,0xea,0x12,0x2f,0xb9,0xae,0xf0,0x2d,0xf5,0x2b,0xec,
-0x3e,0xf5,0x2a,0xe5,0x26,0xb1,0x30,0x12,0x2f,0xea,0x33,0x8f,0x82,0xf5,0x83,0x12,
-0x1b,0xf6,0x71,0x23,0x12,0x2f,0xea,0x12,0x2f,0xb9,0xf1,0x7a,0xc0,0x6, 0xc0,0x7, 
-0xc3,0xe5,0x29,0x95,0x2b,0xff,0xe5,0x28,0x95,0x2a,0xfe,0x12,0x0, 0x6, 0xd0,0x5, 
-0xd0,0x4, 0xd3,0xef,0x9d,0xec,0x71,0x3b,0x40,0x2f,0xab,0x21,0xf1,0x84,0xfa,0xe5,
-0x25,0xb1,0x30,0xfe,0xef,0x78,0x3, 0xd1,0x55,0xd8,0xfc,0x12,0xe, 0xb7,0xff,0xe5,
-0x25,0xc4,0x54,0xf0,0x25,0x24,0x54,0x7, 0xfe,0x74,0x1, 0xa8,0x6, 0x8, 0x80,0x2, 
-0xc3,0x33,0xd8,0xfc,0xf4,0x5f,0x12,0x1, 0xc5,0x5, 0x25,0xe5,0x25,0xc3,0x94,0xf, 
-0x50,0x3, 0x2, 0x3f,0xf1,0x5, 0x24,0xe5,0x24,0xc3,0x94,0xa, 0x50,0x3, 0x2, 0x3f,
-0xee,0x22,0xe5,0x25,0x90,0x3, 0x80,0x75,0xf0,0x20,0x12,0x5, 0x40,0xe5,0x24,0x75,
-0xf0,0x2, 0x2, 0x5, 0x40,0x8b,0x46,0x8a,0x47,0x89,0x48,0x75,0x4f,0x20,0x90,0x0, 
-0x55,0x12,0x1, 0x65,0xf5,0x57,0xf1,0xbf,0xf5,0x5e,0x12,0x1, 0x4c,0xf5,0x5f,0x85,
-0x5e,0x60,0xe5,0x5e,0x25,0xe0,0xf5,0x61,0xd1,0x4f,0xf5,0x62,0x90,0x0, 0x52,0x12,
-0x1, 0x65,0xf5,0x65,0x90,0x0, 0x82,0x12,0x1, 0x65,0xf5,0x66,0xab,0x49,0xaa,0x4a,
-0xa9,0x4b,0x90,0x7, 0xa5,0xe5,0x15,0x12,0x1, 0xd7,0xf1,0xa5,0xef,0x70,0x3, 0x7f,
-0xaa,0x22,0xab,0x49,0xaa,0x4a,0xa9,0x4b,0x90,0x7, 0x9a,0x12,0x5, 0x6c,0xaf,0x1, 
-0x8a,0x63,0x8f,0x64,0xaf,0x5f,0x7e,0x0, 0xab,0x46,0xe5,0x48,0x24,0x56,0xf9,0xe4,
-0x78,0x6b,0x7c,0x0, 0x91,0xe0,0xaf,0x5e,0x7e,0x0, 0xab,0x46,0xe5,0x48,0x24,0x72,
-0xf9,0xe4,0x78,0x87,0x7c,0x0, 0x91,0xe0,0xe5,0x57,0x54,0x30,0x60,0x75,0x75,0x4c,
-0x10,0x75,0x4d,0x0, 0xe4,0x25,0x4b,0xf9,0xe5,0x4a,0x34,0x7, 0xaf,0x1, 0xf5,0x5a,
-0x8f,0x5b,0xe4,0xf5,0x4e,0xe5,0x4e,0xc3,0x95,0x5e,0x50,0x57,0x71,0x1c,0xe0,0xfe,
-0xa3,0xe0,0xff,0x91,0xf8,0x25,0x4e,0xf8,0xe6,0x31,0xf, 0xee,0xf0,0xa3,0xef,0xf0,
-0xe5,0x57,0x30,0xe5,0x14,0x71,0x1c,0xe5,0x60,0x91,0xd4,0xe5,0x5b,0x24,0x20,0x91,
-0xf0,0xe6,0x31,0xf, 0xee,0xf0,0xa3,0xef,0xf0,0xe5,0x57,0x54,0x30,0x64,0x30,0x70,
-0x1c,0x71,0x1c,0x75,0xf0,0x2, 0xe5,0x61,0x91,0xd7,0xe5,0x5b,0x24,0x40,0x91,0xf0,
-0x74,0x87,0x25,0x4e,0xf8,0xe6,0x31,0xf, 0xee,0xf0,0xa3,0xef,0xf0,0xb1,0x24,0x5, 
-0x4e,0x80,0xa2,0xe5,0x57,0x54,0x3, 0xf5,0x56,0x70,0x2, 0x61,0x17,0xe5,0x66,0xb4,
-0x1, 0x8, 0x75,0x4c,0x10,0x75,0x4d,0x60,0x80,0x6, 0x75,0x4c,0x10,0x75,0x4d,0x48,
-0x85,0x4c,0x50,0x85,0x4d,0x51,0xe5,0x4b,0x24,0x80,0xf9,0xe5,0x4a,0x34,0x3, 0xaf,
-0x1, 0xf5,0x52,0x8f,0x53,0x85,0x4a,0x54,0x85,0x4b,0x55,0xe4,0xf5,0x4e,0xe5,0x4e,
-0xc3,0x95,0x5f,0x40,0x2, 0x61,0x17,0x85,0x4f,0xf0,0x91,0xe8,0xff,0xae,0xf0,0x25,
-0x53,0xfd,0xe5,0x52,0x3e,0xf5,0x58,0x8d,0x59,0xe5,0x55,0x2f,0xff,0xe5,0x54,0x3e,
-0xf5,0x5a,0x8f,0x5b,0xe4,0xfd,0xed,0xc3,0x95,0x5e,0x50,0x7d,0x71,0x1c,0xe0,0xf5,
-0x5c,0xa3,0xe0,0xf5,0x5d,0xe5,0x65,0x70,0x29,0x85,0x5e,0xf0,0x91,0xe8,0x25,0x64,
-0xf5,0x82,0xe5,0x63,0x35,0xf0,0xf5,0x83,0x74,0x87,0x2d,0xf8,0xe6,0x25,0x82,0x12,
-0x1e,0x31,0xe0,0x75,0xf0,0x8, 0xa4,0xae,0xf0,0x25,0x5d,0xf5,0x5d,0xee,0x35,0x5c,
-0xf5,0x5c,0xe5,0x62,0x60,0x2a,0x91,0xf8,0x2d,0xf8,0xe6,0xff,0x31,0xf, 0xe0,0xfa,
-0xa3,0xe0,0xfb,0xc3,0xe5,0x5d,0x9b,0xfb,0xe5,0x5c,0x9a,0xfa,0x85,0x58,0x83,0x85,
-0x59,0x82,0x75,0xf0,0x2, 0xef,0x12,0x5, 0x40,0xea,0xf0,0xa3,0xeb,0xf0,0x80,0x14,
-0x85,0x59,0x82,0x85,0x58,0x83,0x74,0x87,0x2d,0xf8,0xe6,0x31,0xf, 0xe5,0x5c,0xf0,
-0xa3,0xe5,0x5d,0xf0,0xb1,0x24,0xd, 0x41,0x76,0xe5,0x66,0xb4,0x1, 0x4, 0x74,0x20,
-0x80,0x2, 0x74,0x48,0x25,0x51,0xf5,0x51,0xe4,0x35,0x50,0xf5,0x50,0x85,0x50,0x4c,
-0x85,0x51,0x4d,0x5, 0x4e,0x41,0x4e,0xb1,0xc, 0x7f,0x0, 0x22,0x85,0x4d,0x82,0x85,
-0x4c,0x83,0x22,0xe5,0x25,0x75,0xf0,0x10,0xa4,0x25,0x24,0x7a,0x0, 0xff,0xea,0x35,
-0xf0,0x22,0xfe,0xa3,0xe0,0xff,0xd3,0x95,0x30,0xe5,0x2f,0x64,0x80,0xf8,0xee,0x64,
-0x80,0x98,0x22,0x12,0x17,0xfa,0xe4,0xf5,0x42,0xf5,0x43,0x74,0x5a,0x25,0x43,0xf1,
-0x8e,0x5, 0x43,0xe5,0x43,0x70,0x2, 0x5, 0x42,0x64,0x96,0x45,0x42,0x70,0xec,0x12,
-0x27,0xdf,0xb1,0xc, 0x85,0x24,0x49,0x85,0x25,0x4a,0x85,0x26,0x4b,0x12,0x17,0x63,
-0xb1,0xe2,0x60,0xf0,0xe5,0x26,0x24,0x80,0xf9,0xe5,0x25,0x34,0x3, 0xaf,0x1, 0xf5,
-0xf, 0x8f,0x10,0xe4,0xf5,0x2a,0xf5,0x2b,0xe4,0xf5,0x41,0xe5,0x2b,0x45,0x2a,0x70,
-0x6, 0x91,0xc7,0xe4,0xf6,0x8, 0xf6,0xe5,0x2b,0xae,0x2a,0x78,0x5, 0xc3,0x33,0xce,
-0x33,0xce,0xd8,0xf9,0xb1,0x18,0x31,0xf, 0xe0,0xfe,0xa3,0xe0,0xff,0x91,0xc7,0xe6,
-0xfc,0x8, 0xe6,0xfd,0xd3,0xef,0x9d,0xee,0x9c,0x40,0xf, 0xef,0x94,0x1c,0xee,0x94,
-0x25,0x50,0x7, 0x91,0xc7,0xa6,0x6, 0x8, 0xa6,0x7, 0x5, 0x41,0xe5,0x41,0xb4,0xa, 
-0xba,0x5, 0x2b,0xe5,0x2b,0x70,0x2, 0x5, 0x2a,0x64,0xf, 0x45,0x2a,0x70,0xa9,0xe4,
-0xf5,0x44,0xf5,0x45,0xf5,0x2a,0xf5,0x2b,0xe4,0xf5,0x41,0xe5,0x2b,0xae,0x2a,0x78,
-0x5, 0xc3,0x33,0xce,0x33,0xce,0xd8,0xf9,0xb1,0x18,0x91,0xd4,0xd3,0x94,0x1c,0xee,
-0x94,0x25,0x40,0xa, 0x5, 0x45,0xe5,0x45,0x70,0x2, 0x5, 0x44,0x80,0x45,0x91,0xc7,
-0xe6,0xfc,0x8, 0xe6,0xc3,0x9f,0xf5,0x43,0xec,0x9e,0xf5,0x42,0xe5,0x43,0xae,0x42,
-0x78,0x3, 0xce,0xc3,0x13,0xce,0x13,0xd8,0xf9,0xf5,0x43,0x8e,0x42,0xd3,0x94,0xff,
-0xe5,0x42,0x94,0x0, 0x40,0x6, 0x75,0x42,0x0, 0x75,0x43,0xff,0x5, 0x45,0xe5,0x45,
-0xac,0x44,0x70,0x2, 0x5, 0x44,0x14,0x24,0x5a,0xf5,0x82,0x74,0xb, 0x3c,0xf5,0x83,
-0xe5,0x43,0xf0,0x5, 0x41,0xe5,0x41,0x64,0xa, 0x70,0x90,0x5, 0x2b,0xe5,0x2b,0x70,
-0x2, 0x5, 0x2a,0x64,0xf, 0x45,0x2a,0x60,0x2, 0x61,0xe8,0x75,0x28,0xa, 0x75,0x29,
-0xe5,0xe4,0xf5,0x2c,0xf5,0x2a,0xf5,0x2b,0x85,0x29,0x82,0x85,0x28,0x83,0xe0,0x62,
-0x2c,0x7e,0x0, 0xe5,0x2b,0x25,0x27,0xff,0xee,0x35,0x2a,0xfe,0x5, 0x29,0xe5,0x29,
-0xac,0x28,0x70,0x2, 0x5, 0x28,0x14,0xf5,0x82,0x8c,0x83,0xe0,0xfd,0x91,0xcf,0x5, 
-0x2b,0xe5,0x2b,0x70,0x2, 0x5, 0x2a,0xc3,0x94,0xb, 0xe5,0x2a,0x94,0x1, 0x40,0xc8,
-0xad,0x2c,0x7f,0xf0,0x7e,0x3, 0x91,0xcf,0xc3,0x74,0xff,0x95,0x2c,0xfd,0x7f,0xf1,
-0x7e,0x3, 0x91,0xcf,0x7f,0x1, 0x22,0xe5,0x41,0x25,0xe0,0x24,0x2d,0xf8,0x22,0xf1,
-0x72,0x2, 0x37,0x5c,0x75,0xf0,0x2, 0x12,0x5, 0x40,0xe0,0xfe,0xa3,0xe0,0xff,0x22,
-0x35,0x47,0xfa,0x7d,0x0, 0x2, 0x1, 0x26,0x74,0x6b,0x25,0x4e,0xf8,0xe6,0xa4,0x22,
-0xf5,0x82,0xe4,0x35,0x5a,0xf5,0x83,0x22,0x85,0x5b,0x82,0x85,0x5a,0x83,0x74,0x87,
-0x22,0x12,0x0, 0x6, 0xc3,0xef,0x94,0x14,0xee,0x64,0x80,0x22,0x53,0xdb,0xfd,0xd2,
-0xba,0x43,0xdb,0x1, 0x43,0xdb,0x20,0x22,0x25,0x10,0xf5,0x82,0xe5,0xf, 0x3e,0xf5,
-0x83,0xe5,0x41,0x22,0x74,0x2, 0x25,0x4d,0xf5,0x4d,0xe4,0x35,0x4c,0xf5,0x4c,0x22,
-0x75,0xf0,0x10,0xa4,0x25,0x24,0x7c,0x0, 0xff,0xec,0x35,0xf0,0x22,0x8b,0x32,0x8a,
-0x33,0x89,0x34,0xd1,0x4f,0xf5,0x3f,0x90,0x0, 0x52,0x12,0x1, 0x65,0xf5,0x40,0x90,
-0x0, 0x53,0xe4,0x12,0x1, 0xd7,0x90,0x0, 0x52,0xe4,0x12,0x1, 0xd7,0xe5,0x37,0x24,
-0x80,0xf9,0xe5,0x36,0x34,0x3, 0xaf,0x1, 0xf5,0x3d,0x8f,0x3e,0x85,0x36,0x3b,0x85,
-0x37,0x3c,0x75,0x38,0x1, 0x85,0x35,0x49,0x85,0x36,0x4a,0x85,0x37,0x4b,0xab,0x32,
-0xaa,0x33,0xa9,0x34,0xb1,0xe2,0x60,0xed,0xe4,0xf5,0x39,0xf5,0x3a,0xb1,0xe8,0xe5,
-0x3e,0x2f,0xf5,0x82,0xe5,0x3d,0xf1,0x62,0x78,0x2, 0xd1,0x55,0xd8,0xfc,0xfd,0xac,
-0x6, 0xb1,0xe8,0xe5,0x3c,0x2f,0xf5,0x82,0xe5,0x3b,0x3e,0xf5,0x83,0xec,0x8d,0xf0,
-0x12,0x2, 0x60,0x5, 0x3a,0xe5,0x3a,0x70,0x2, 0x5, 0x39,0xb4,0xc0,0xcf,0xe5,0x39,
-0xb4,0x1, 0xca,0x5, 0x38,0xe5,0x38,0xd3,0x94,0x4, 0x40,0xa9,0xab,0x32,0xaa,0x33,
-0xa9,0x34,0x90,0x0, 0x53,0xe5,0x3f,0x12,0x1, 0xd7,0x90,0x0, 0x52,0xe5,0x40,0x2, 
-0x1, 0xd7,0x31,0x15,0xef,0x64,0xaa,0x22,0xe5,0x3a,0x25,0xe0,0xff,0xe5,0x39,0x33,
-0xfe,0x22,0x8e,0x21,0x8f,0x22,0x8c,0x23,0x8d,0x24,0x8a,0x25,0x8b,0x26,0xf1,0x5b,
-0x12,0x34,0x3f,0xaa,0x21,0xa9,0x22,0x7b,0x1, 0x12,0x28,0x4b,0xaa,0x23,0xa9,0x24,
-0x7b,0x1, 0x12,0xe, 0xbf,0xe5,0x22,0x24,0x55,0xf5,0x82,0xe4,0x35,0x21,0xf5,0x83,
-0x74,0x21,0xf0,0xaa,0x27,0xa9,0x28,0x7b,0x1, 0x12,0x25,0xfb,0xaa,0x27,0xa9,0x28,
-0x7b,0x1, 0x12,0x24,0xc9,0xb1,0xc, 0xaa,0x25,0xa9,0x26,0x7b,0x1, 0xd1,0xe5,0xaa,
-0x21,0xa9,0x22,0x7b,0x1, 0xc0,0x3, 0x8b,0x35,0xd1,0x5f,0xd0,0x3, 0xa1,0x3d,0x90,
-0x0, 0x53,0x2, 0x1, 0x65,0xce,0xa2,0xe7,0x13,0xce,0x13,0x22,0x85,0x24,0x35,0x85,
-0x25,0x36,0x85,0x26,0x37,0x22,0x12,0x17,0xfa,0x90,0x0, 0x2f,0xf1,0x52,0x30,0xe0,
-0x34,0x12,0x17,0x63,0x90,0x0, 0x4d,0x12,0x2, 0xb7,0xc3,0x94,0x3c,0xe5,0xf0,0x94,
-0x0, 0x50,0xc, 0x90,0x0, 0x4d,0xe4,0x75,0xf0,0x1, 0x12,0x2, 0xef,0x80,0x16,0x12,
-0x15,0xb1,0xd1,0xe5,0xd1,0x5c,0x12,0x15,0x1c,0xb1,0x3d,0x90,0xa, 0xe3,0x74,0x5, 
-0xf0,0xa3,0x74,0xdc,0xf0,0xab,0x2a,0xaa,0x2b,0xa9,0x2c,0x90,0x0, 0x2f,0x12,0x1, 
-0x65,0x20,0xe0,0x30,0x12,0x17,0x63,0x90,0x0, 0x4d,0xe4,0xf5,0xf0,0x12,0x3, 0x5b,
-0xf1,0x4f,0xff,0x70,0x8, 0x90,0xa, 0xe3,0xf0,0xa3,0xf0,0xc2,0x0, 0x30,0x0, 0x14,
-0xc2,0x0, 0xef,0xd3,0x94,0x0, 0x40,0xc, 0x12,0x15,0xb1,0xd1,0xe5,0xd1,0x5c,0x12,
-0x15,0x1c,0xb1,0x3d,0x22,0xd1,0xf9,0xe4,0x90,0xa, 0xde,0xf0,0xa3,0xf0,0x90,0xa, 
-0xd8,0x74,0xd, 0xf0,0xa3,0x74,0xac,0xf0,0x22,0x90,0xc, 0x12,0x74,0x30,0xf0,0xa3,
-0x74,0x3, 0xf0,0xae,0x2, 0xaf,0x1, 0xad,0x7, 0xac,0x6, 0xe9,0x24,0x60,0xf9,0xea,
-0x34,0x7, 0xfa,0xe4,0xf5,0x32,0xf5,0x33,0xe5,0x33,0x25,0xe0,0xff,0xe5,0x32,0x33,
-0xfe,0xed,0x2f,0xf5,0x82,0xec,0xf1,0x6a,0xe5,0x33,0xae,0x32,0x78,0x3, 0xce,0xc3,
-0x13,0xce,0x13,0xd8,0xf9,0xf5,0x82,0x8e,0x83,0x74,0xff,0x12,0x1, 0xd7,0x5, 0x33,
-0xe5,0x33,0x70,0x2, 0x5, 0x32,0xb4,0xc0,0xcf,0xe5,0x32,0xb4,0x1, 0xca,0x22,0x90,
-0x0, 0x2d,0xab,0x2a,0xaa,0x2b,0xa9,0x2c,0x2, 0x1, 0x65,0x12,0x27,0xdf,0x53,0xdb,
-0xf0,0x22,0x3e,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0x22,0x3e,0xf5,0x83,0xe4,0xf0,0xa3,
-0xf0,0x22,0xe4,0x2f,0xff,0xee,0x34,0x7c,0xfe,0x22,0xc3,0x9d,0xff,0xe5,0xf0,0x9c,
-0xfe,0x2, 0x0, 0x6, 0xe5,0x23,0x24,0x60,0xf9,0xe5,0x22,0x34,0x7, 0x22,0xf5,0x82,
-0xe4,0x34,0xb, 0xf5,0x83,0xe4,0xf0,0x22,0x12,0x2, 0x8c,0xc3,0x94,0xce,0xe5,0xf0,
-0x64,0x80,0x94,0x7f,0x22,0xe5,0xdb,0x20,0xe1,0x3, 0x7f,0x0, 0x22,0x53,0xdb,0xfd,
-0x7f,0x1, 0x22,0x33,0xfe,0xab,0x2a,0xe5,0x2c,0x2f,0xf9,0xe5,0x2b,0x3e,0xfa,0x90,
-0x0, 0x1, 0x2, 0x1, 0x65,0xef,0x24,0x9f,0xf1,0xdf,0xef,0x24,0x9e,0xf1,0xdf,0xef,
-0x24,0x9d,0xf5,0x82,0xee,0x34,0x7, 0xf5,0x83,0x74,0x1, 0xf0,0xef,0x24,0xa4,0xf5,
-0x82,0xee,0x34,0x7, 0xf5,0x83,0xe4,0xf0,0x22,0xe5,0xe8,0x54,0xc0,0x64,0xc0,0x60,
-0x3, 0x12,0x33,0xcb,0x22,0x12,0x17,0xfa,0x85,0xc9,0x30,0x12,0x15,0xb1,0x12,0x1, 
-0x4c,0xff,0x70,0x3d,0x12,0x17,0x63,0x12,0x17,0xe8,0xd3,0x94,0x0, 0x40,0x7, 0x12,
-0x15,0xb1,0x31,0x1b,0x1, 0xc9,0x12,0x17,0xdc,0x20,0xe0,0x2, 0x1, 0xc9,0x90,0x0, 
-0x8, 0x12,0x1, 0x65,0xfe,0x90,0x0, 0x7, 0x74,0x1, 0x12,0x1, 0x92,0x6e,0x60,0x2, 
-0x1, 0xc9,0x12,0x15,0xb1,0x90,0x0, 0x7, 0x12,0x1, 0xd7,0x74,0x1, 0x31,0x13,0x1, 
-0xc9,0xef,0xb4,0x1, 0x12,0x12,0x17,0x63,0x12,0x17,0xe8,0x60,0x7c,0x12,0x15,0xb1,
-0x31,0x12,0x75,0xd, 0x1e,0x80,0x72,0x12,0x15,0xb1,0x12,0x1, 0x4c,0x64,0x3, 0x70,
-0x68,0xff,0x51,0xa9,0x12,0x46,0xe7,0x12,0x0, 0x4e,0xe5,0xdb,0x30,0xe1,0xfb,0xc2,
-0x89,0xd2,0xa8,0x20,0x96,0xfd,0x43,0x87,0x2, 0xc2,0xa8,0x12,0x46,0xe7,0x12,0x0, 
-0x4e,0x53,0xdb,0xf0,0x12,0x45,0xc, 0x85,0x21,0x35,0x85,0x22,0x36,0x85,0x23,0x37,
-0xab,0x2d,0xaa,0x2e,0xa9,0x2f,0x12,0x38,0x1d,0x12,0x15,0xb1,0x31,0x12,0xae,0x2b,
-0xaf,0x2c,0x12,0x47,0xc5,0xab,0x2a,0xaa,0x2b,0xa9,0x2c,0x12,0x46,0xf9,0x90,0xb, 
-0xf0,0x74,0xa, 0xf0,0x90,0xb, 0xf0,0xe0,0x70,0xfa,0x85,0x2a,0x35,0x85,0x2b,0x36,
-0x85,0x2c,0x37,0x12,0x15,0x1c,0x12,0x45,0x3d,0xe4,0xf5,0x31,0xe5,0xc, 0x70,0x22,
-0xff,0x51,0xc0,0xe5,0xdb,0x30,0xe1,0xf4,0xc2,0xcd,0x12,0x15,0xb1,0x12,0x1, 0x4c,
-0xb4,0x1, 0xe9,0xe5,0x31,0x70,0xe5,0x75,0x31,0x1, 0x53,0xc9,0xfc,0x43,0xc9,0x1, 
-0x80,0xda,0xe4,0xf5,0xd, 0xf5,0xc, 0x85,0x30,0xc9,0xd2,0xcd,0x51,0xb2,0x54,0xef,
-0x12,0x1, 0xc5,0x12,0x17,0x63,0x12,0x17,0xe8,0x90,0x0, 0x4c,0x12,0x1, 0xd7,0x2, 
-0x47,0xe9,0xe4,0x12,0x1, 0xc5,0x90,0xc, 0x16,0xf0,0x22,0x90,0x0, 0x7, 0xe4,0x2, 
-0x1, 0xd7,0x12,0x17,0xfa,0x90,0xb, 0xf1,0x74,0x14,0xf0,0xa3,0x74,0x3c,0xf0,0xe4,
-0x90,0xb, 0xf4,0xf0,0xa3,0x74,0x6, 0xf0,0x74,0xa0,0x51,0x7c,0x74,0xc8,0xf0,0xa3,
-0x74,0x6, 0xf0,0xa3,0x74,0x28,0xf0,0x90,0xc, 0x8, 0x74,0x32,0xf0,0x90,0xc, 0x11,
-0x74,0xff,0xf0,0x90,0xc, 0x14,0x74,0x55,0xf0,0xa3,0x74,0x1, 0xf0,0xe4,0xa3,0xf0,
-0x74,0x22,0x51,0x7c,0x74,0x79,0xf0,0xe4,0xa3,0xf0,0xa3,0xf0,0x90,0xc, 0x20,0x4, 
-0xf0,0x90,0xc, 0x1f,0x74,0xc8,0xf0,0x90,0xc, 0x24,0x74,0x64,0xf0,0xa3,0x74,0x28,
-0xf0,0x12,0x15,0xb1,0xe4,0x12,0x1, 0xc5,0x12,0x15,0xb1,0x4, 0x51,0xa3,0x90,0x0, 
-0x9, 0xe4,0x12,0x1, 0xd7,0x74,0x10,0x51,0x8e,0x74,0x6, 0x12,0x1, 0xd7,0x74,0x28,
-0x51,0x84,0x74,0x28,0x12,0x1, 0xd7,0x90,0x0, 0x8, 0x74,0xc8,0x12,0x1, 0xd7,0x90,
-0x0, 0xa, 0x74,0x1, 0x12,0x1, 0xd7,0x31,0x1b,0x12,0x17,0x63,0xe4,0x75,0xf0,0x50,
-0x12,0x3, 0x3c,0x12,0x17,0x63,0x90,0x0, 0x2, 0x74,0x14,0x12,0x1, 0xd7,0x90,0x0, 
-0x3, 0xe4,0x75,0xf0,0x3c,0x12,0x3, 0x5b,0x90,0x0, 0x22,0x74,0x10,0x12,0x1, 0xd7,
-0x90,0x0, 0x15,0x74,0x3, 0x12,0x1, 0xd7,0x90,0x0, 0x16,0x74,0x3, 0x12,0x1, 0xd7,
-0x90,0x0, 0x1a,0xe4,0x12,0x1, 0xd7,0x90,0x0, 0x1b,0x74,0xe, 0x12,0x1, 0xd7,0x90,
-0x0, 0x17,0xe4,0x12,0x1, 0xd7,0x90,0x0, 0x1c,0xe4,0x75,0xf0,0xfa,0x12,0x3, 0x5b,
-0x90,0x0, 0x1e,0x12,0xf, 0xf5,0x74,0x5, 0x12,0x1, 0xd7,0x90,0x0, 0x20,0x74,0x23,
-0x12,0x1, 0xd7,0x51,0x98,0x74,0x3, 0x12,0x1, 0xd7,0x90,0x0, 0x11,0xe4,0x12,0x1, 
-0xd7,0x90,0x0, 0x12,0x74,0x4, 0x12,0x1, 0xd7,0x90,0x0, 0x13,0x51,0x75,0x90,0x0, 
-0xb, 0x51,0x75,0x90,0x0, 0xd, 0x74,0x28,0x12,0x1, 0xd7,0x12,0x15,0x1c,0x74,0x5, 
-0x12,0x1, 0xc5,0x12,0x15,0x1c,0x90,0x0, 0x1, 0x74,0xa, 0x75,0xf0,0x0, 0x12,0x3, 
-0x5b,0x74,0xa0,0x51,0x8e,0x74,0x32,0x12,0x1, 0xd7,0x74,0x32,0x51,0x84,0xe4,0x75,
-0xf0,0xc8,0x2, 0x3, 0x5b,0xe4,0x75,0xf0,0x64,0x2, 0x3, 0x5b,0xa3,0xf0,0xa3,0x74,
-0x1, 0xf0,0xa3,0x22,0x90,0x0, 0x5, 0x12,0x1, 0xd7,0x90,0x0, 0x6, 0x22,0x90,0x0, 
-0x3, 0x12,0x1, 0xd7,0x90,0x0, 0x4, 0x22,0x90,0x0, 0xf, 0xe4,0x12,0x1, 0xd7,0x90,
-0x0, 0x10,0x22,0x90,0x0, 0x1, 0x2, 0x1, 0xd7,0xef,0x70,0x3, 0xd2,0x84,0x22,0xc2,
-0x84,0x22,0xab,0x21,0xe5,0x23,0x24,0x4f,0xf9,0xe4,0x35,0x22,0xfa,0x2, 0x1, 0x4c,
-0xef,0x70,0x3, 0x43,0x87,0x1, 0xbf,0x1, 0x3, 0x43,0x87,0x2, 0xbf,0x2, 0x3, 0x43,
-0x87,0x2, 0x22,0x12,0x17,0xfa,0xe4,0xf5,0x2b,0x12,0x15,0xb1,0x91,0x59,0x60,0x8, 
-0x90,0x0, 0x2e,0x12,0x1, 0x65,0x60,0x3, 0x7f,0x0, 0x22,0x12,0x1, 0x4c,0xc3,0x13,
-0xf5,0x28,0x12,0x47,0xbf,0xc3,0x13,0xf5,0x29,0xe4,0xf5,0x2a,0xf5,0x27,0x12,0x17,
-0x63,0x91,0x3a,0x75,0xf0,0x2, 0xe5,0x27,0x12,0x15,0x59,0x12,0x0, 0x6, 0xd3,0x12,
-0x45,0x5, 0x94,0x80,0x40,0x2, 0x5, 0x2a,0x91,0x32,0x40,0xe2,0xe5,0x2a,0xd3,0x94,
-0x6, 0x40,0x4, 0x91,0x45,0xf5,0x2b,0xe4,0xf5,0x2a,0xe5,0x28,0xd3,0x94,0x0, 0x40,
-0x3e,0xe4,0xf5,0x27,0x12,0x17,0x63,0x91,0x3a,0x75,0xf0,0x2, 0xe5,0x27,0x12,0x15,
-0x59,0x12,0x0, 0x6, 0xc0,0x6, 0xc0,0x7, 0xe5,0x28,0x75,0xf0,0x20,0xa4,0x24,0x60,
-0x91,0x50,0x12,0x17,0x63,0x75,0xf0,0x2, 0xe5,0x27,0x12,0x15,0x59,0x12,0x0, 0x6, 
-0xd0,0x5, 0xd0,0x4, 0x12,0x3f,0x95,0x40,0x2, 0x5, 0x2a,0x91,0x32,0x40,0xc5,0xe5,
-0x2a,0xd3,0x94,0x6, 0x40,0x4, 0x91,0x45,0xf5,0x2b,0xe4,0xf5,0x2a,0xe5,0x28,0xc3,
-0x94,0xe, 0x50,0x3e,0xe4,0xf5,0x27,0x12,0x17,0x63,0x91,0x3a,0x75,0xf0,0x2, 0xe5,
-0x27,0x12,0x15,0x59,0x12,0x0, 0x6, 0xc0,0x6, 0xc0,0x7, 0xe5,0x28,0x75,0xf0,0x20,
-0xa4,0x24,0xa0,0x91,0x50,0x12,0x17,0x63,0x75,0xf0,0x2, 0xe5,0x27,0x12,0x15,0x59,
-0x12,0x0, 0x6, 0xd0,0x5, 0xd0,0x4, 0x12,0x3f,0x95,0x40,0x2, 0x5, 0x2a,0x91,0x32,
-0x40,0xc5,0xe5,0x2a,0xd3,0x94,0x6, 0x40,0x4, 0x91,0x45,0xf5,0x2b,0xe5,0x29,0xd3,
-0x94,0x0, 0x40,0x24,0xe5,0x28,0x75,0xf0,0x20,0x12,0x1b,0xe7,0xe5,0x29,0x75,0xf0,
-0x2, 0xa4,0x24,0x7e,0xff,0xe5,0xf0,0x34,0x3, 0xfe,0x12,0x38,0xc5,0x12,0x47,0x98,
-0x50,0x6, 0x74,0xa, 0x25,0x2b,0xf5,0x2b,0xe5,0x29,0x24,0x1, 0xff,0xe4,0x33,0xfe,
-0xc3,0xef,0x94,0xf, 0xee,0x64,0x80,0x94,0x80,0x50,0x24,0xe5,0x28,0x75,0xf0,0x20,
-0x12,0x1b,0xe7,0xe5,0x29,0x75,0xf0,0x2, 0xa4,0x24,0x82,0xff,0xe5,0xf0,0x34,0x3, 
-0xfe,0x12,0x38,0xc5,0x12,0x47,0x98,0x50,0x6, 0x74,0xa, 0x25,0x2b,0xf5,0x2b,0xaf,
-0x2b,0x22,0x5, 0x27,0xe5,0x27,0xc3,0x94,0xa, 0x22,0xe5,0x28,0x90,0x3, 0x80,0x75,
-0xf0,0x20,0x2, 0x5, 0x40,0xe5,0x2a,0x24,0xfa,0x75,0xf0,0xa, 0xa4,0x25,0x2b,0x22,
-0xf5,0x82,0x74,0x3, 0x35,0xf0,0xf5,0x83,0x22,0x90,0x0, 0x2d,0x2, 0x1, 0x65,0x12,
-0x17,0xfa,0x75,0x2f,0x1, 0x12,0x15,0x9f,0xb1,0x6d,0x8f,0x2d,0x12,0x15,0x9f,0xd1,
-0x6c,0x8f,0x2e,0x12,0x15,0x1c,0x90,0x7, 0xa4,0x12,0x1, 0x65,0xff,0x70,0x49,0x4, 
-0xb1,0x61,0xe5,0x2d,0xb4,0x2, 0xd, 0x90,0x7, 0x9d,0x74,0x6, 0x12,0x1, 0xd7,0xe4,
-0xf5,0x2f,0x80,0x2e,0x12,0x17,0x63,0x91,0x59,0x70,0x1f,0xb1,0x67,0x70,0x1b,0x90,
-0xc, 0xc7,0xe0,0xc3,0x94,0x2, 0x40,0xa, 0xe4,0xf0,0x12,0x15,0x1c,0x90,0x7, 0xa4,
-0x80,0x45,0x90,0xc, 0xc7,0xe0,0x4, 0xf0,0xa1,0x4b,0x12,0x15,0x1c,0x74,0x4, 0xb1,
-0x61,0xe4,0x90,0xc, 0xc7,0xf0,0xa1,0x4b,0xef,0x64,0x1, 0x70,0x53,0x12,0x15,0x1c,
-0xb1,0x61,0xe5,0x2e,0x60,0x5, 0x90,0x7, 0xa4,0x80,0x5d,0xe5,0x2d,0xb4,0x2, 0x6, 
-0x90,0x7, 0x9d,0xe4,0x80,0x62,0x12,0x17,0x63,0x91,0x59,0x70,0xd, 0xb1,0x67,0x70,
-0x9, 0x12,0x15,0x1c,0x90,0x7, 0x9d,0x4, 0x80,0x4e,0x85,0x27,0x33,0x85,0x28,0x34,
-0x85,0x29,0x35,0x85,0x2a,0x36,0x85,0x2b,0x37,0x85,0x2c,0x38,0x85,0x24,0x39,0x85,
-0x25,0x3a,0x85,0x26,0x3b,0x12,0x17,0x63,0x12,0x2b,0xe, 0xe4,0xf5,0x2f,0x80,0x2b,
-0x12,0x15,0x1c,0x90,0x7, 0xa4,0x12,0x1, 0x65,0xb4,0x3, 0x1f,0xe5,0x2e,0x24,0xfe,
-0x60,0xa, 0x4, 0x70,0xe, 0x90,0x7, 0x9d,0x74,0x3, 0x80,0xc, 0x90,0x7, 0x9d,0x74,
-0x2, 0x80,0x5, 0x90,0x7, 0xa4,0x74,0x1, 0x12,0x1, 0xd7,0xe5,0x2f,0xb4,0x1, 0x10,
-0x12,0x17,0x63,0x90,0x0, 0x80,0xe4,0xf1,0x93,0x90,0x0, 0x82,0xe4,0x12,0x1, 0xd7,
-0x22,0x90,0x7, 0x9d,0x2, 0x1, 0xd7,0x90,0x0, 0x86,0x2, 0x1, 0x65,0x12,0x1, 0x4c,
-0xf5,0x39,0x90,0xc, 0xc6,0xe0,0xc3,0x94,0x1, 0x50,0x5, 0xe0,0x4, 0xf0,0xc1,0x50,
-0xe4,0x90,0xc, 0xc6,0xf0,0xaa,0x34,0xa9,0x35,0xae,0x2, 0xaf,0x1, 0x8e,0x3f,0x8f,
-0x40,0xf1,0x9d,0xf5,0x41,0x8f,0x42,0xe4,0xf5,0x39,0xe4,0xf5,0x3b,0xf5,0x3c,0x75,
-0x3d,0x7f,0x75,0x3e,0xff,0x90,0x0, 0x1a,0xf1,0x78,0xfd,0x75,0xf0,0x10,0xa4,0xff,
-0xae,0xf0,0xe5,0x39,0x7a,0x0, 0x2f,0xf5,0x44,0xea,0x3e,0xf5,0x43,0x8d,0x3a,0x90,
-0x0, 0x1b,0xd1,0x63,0xff,0xe5,0x3a,0xd3,0x9f,0x50,0x4b,0xe5,0x44,0x25,0xe0,0xff,
-0xe5,0x43,0x33,0xfe,0xe5,0x40,0x2f,0xf5,0x82,0xe5,0x3f,0x12,0x3b,0x1b,0xe5,0x42,
-0x2f,0xf5,0x82,0xe5,0x41,0x12,0x47,0x62,0x2d,0xff,0xee,0x3c,0xfe,0xd3,0xef,0x95,
-0x3c,0xee,0x95,0x3b,0x40,0x4, 0x8e,0x3b,0x8f,0x3c,0xc3,0xef,0x95,0x3e,0xee,0x95,
-0x3d,0x50,0x4, 0x8e,0x3d,0x8f,0x3e,0x74,0x10,0x25,0x44,0xf5,0x44,0xe4,0x35,0x43,
-0xf5,0x43,0x5, 0x3a,0x80,0xa9,0x12,0x2e,0x10,0x90,0x0, 0x1c,0x12,0x2, 0xb7,0xff,
-0xc3,0xe5,0x3c,0x95,0x3e,0xfd,0xe5,0x3b,0x95,0x3d,0xfc,0xd3,0xed,0x9f,0xec,0x95,
-0xf0,0x40,0x8, 0x90,0xc, 0xc5,0x74,0x2, 0xf0,0x80,0xa, 0x5, 0x39,0xe5,0x39,0x64,
-0xa, 0x60,0x2, 0xa1,0x9a,0xe5,0x39,0xb4,0xa, 0x6, 0x90,0xc, 0xc5,0x74,0x1, 0xf0,
-0x90,0xc, 0xc5,0xe0,0xff,0x22,0xab,0x33,0xaa,0x34,0xa9,0x35,0xe4,0x12,0x1, 0xd7,
-0x90,0x0, 0x1f,0xab,0x36,0xaa,0x37,0xa9,0x38,0x2, 0x1, 0x65,0x8b,0x30,0x8a,0x31,
-0x89,0x32,0x12,0x1, 0x4c,0x13,0x13,0x54,0x3f,0xf5,0x3b,0x12,0x47,0xbf,0x13,0x13,
-0x54,0x3f,0xf5,0x3c,0xe4,0xf5,0x3d,0xf5,0x3e,0xf5,0x3f,0xf5,0x39,0xab,0x30,0xaa,
-0x31,0xa9,0x32,0x12,0x1, 0x4c,0xff,0xe5,0x39,0xc3,0x9f,0x50,0x4e,0xe4,0xf5,0x3a,
-0x90,0x0, 0x1, 0xf1,0x81,0xff,0xe5,0x3a,0xc3,0x9f,0x50,0x37,0xf1,0x58,0xfd,0xd3,
-0xef,0x9d,0x74,0x80,0xf8,0x65,0xf0,0x98,0x40,0x4, 0x5, 0x3d,0x80,0x1b,0xf1,0x58,
-0xfd,0xc3,0xe4,0x9d,0xfd,0xe4,0x94,0x0, 0xfc,0xc3,0xef,0x9d,0xec,0x64,0x80,0xf8,
-0xe5,0xf0,0x64,0x80,0x98,0x50,0x2, 0x5, 0x3e,0x5, 0x3f,0xe5,0x3c,0x25,0x3a,0xf5,
-0x3a,0x80,0xbd,0xe5,0x3b,0x25,0x39,0xf5,0x39,0x80,0xa2,0xe5,0x3f,0xc3,0x13,0xff,
-0xe5,0x3d,0xd3,0x9f,0x40,0x1d,0x90,0x7, 0x9f,0xd1,0x56,0xfe,0x90,0x7, 0x9e,0xf1,
-0x8a,0xc3,0x9e,0x90,0x7, 0x9e,0x50,0x2, 0x80,0x21,0xe4,0x12,0x1, 0xd7,0x75,0x14,
-0x1, 0x80,0x38,0xe5,0x3e,0xd3,0x9f,0x40,0x22,0x90,0x7, 0x9e,0xd1,0x56,0xff,0xf1,
-0x4e,0x12,0x1, 0x65,0xc3,0x9f,0x90,0x7, 0x9f,0x50,0x7, 0x74,0x1, 0x12,0x1, 0x92,
-0x80,0x19,0xe4,0x12,0x1, 0xd7,0x75,0x14,0x2, 0x80,0x10,0xf1,0x4e,0xe4,0x12,0x1, 
-0xd7,0x90,0x7, 0x9e,0xe4,0x12,0x1, 0xd7,0xe4,0xf5,0x14,0xaf,0x14,0x22,0xab,0x33,
-0xaa,0x34,0xa9,0x35,0x90,0x7, 0x9f,0x22,0xab,0x33,0xaa,0x34,0xa9,0x35,0x90,0x3, 
-0x80,0x75,0xf0,0x20,0xe5,0x39,0x12,0x5, 0x40,0x75,0xf0,0x2, 0xe5,0x3a,0x12,0x5, 
-0x40,0x12,0x2, 0xb7,0xff,0x90,0x0, 0x1e,0xab,0x36,0xaa,0x37,0xa9,0x38,0x2, 0x1, 
-0x65,0xab,0x30,0xaa,0x31,0xa9,0x32,0x2, 0x1, 0x65,0xab,0x33,0xaa,0x34,0xa9,0x35,
-0x2, 0x1, 0x65,0x12,0x1, 0xd7,0x90,0x0, 0x81,0xe4,0x2, 0x1, 0xd7,0xe9,0x24,0x80,
-0xf9,0xea,0x34,0x3, 0xaf,0x1, 0x22,0xef,0xd3,0x94,0x3f,0x50,0x2d,0xef,0x24,0xfd,
-0x60,0x28,0x14,0x60,0x25,0x24,0xe1,0x60,0x21,0x24,0xfd,0x60,0x1d,0x24,0xfe,0x60,
-0x19,0x24,0xf9,0x60,0x15,0x80,0x0, 0x74,0xf1,0x2f,0xf5,0x82,0xe4,0x34,0xb, 0xf5,
-0x83,0xed,0xf0,0x90,0xc, 0x31,0xe0,0x44,0x1, 0xf0,0x22,0xc0,0xe0,0xc0,0xf0,0xc0,
-0x83,0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x0, 0xc0,0x0, 0xc0,0x1, 0xc0,0x2, 0xc0,0x3, 
-0xc0,0x4, 0xc0,0x5, 0xc0,0x6, 0xc0,0x7, 0xe5,0xc9,0x54,0x3, 0xff,0xbf,0x1, 0x6, 
-0x53,0xc9,0xfc,0x43,0xc9,0x2, 0x12,0x32,0x0, 0x30,0x95,0x2, 0xc2,0x95,0x30,0x94,
-0x2, 0xc2,0x94,0x90,0xc, 0x68,0x74,0x1, 0xf0,0xd0,0x7, 0xd0,0x6, 0xd0,0x5, 0xd0,
-0x4, 0xd0,0x3, 0xd0,0x2, 0xd0,0x1, 0xd0,0x0, 0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,
-0xf0,0xd0,0xe0,0x32,0xc0,0xe0,0xc0,0x83,0xc0,0x82,0xc2,0x93,0x90,0xc, 0x67,0xe4,
-0xf0,0x90,0xc, 0x69,0xf0,0xd0,0x82,0xd0,0x83,0xd0,0xe0,0x32,0x8f,0x67,0x8d,0x68,
-0xe5,0x67,0x12,0x5, 0x9c,0x50,0x7d,0x0, 0x50,0xa2,0x1, 0x50,0xb9,0x2, 0x50,0xd1,
-0x3, 0x50,0xd6,0x4, 0x50,0xdb,0x5, 0x50,0xe0,0x6, 0x50,0xe5,0x7, 0x50,0xea,0x4c,
-0x50,0xf4,0x4e,0x50,0xf9,0x4f,0x50,0xef,0xea,0x0, 0x0, 0x51,0x16,0x31,0xaa,0xf5,
-0x68,0x64,0x4, 0x60,0xd, 0x90,0xc, 0x18,0xe0,0x7d,0x1, 0xb4,0x3, 0x2, 0x80,0x30,
-0x80,0xb, 0x90,0xc, 0x18,0xe0,0x7d,0x3, 0xb4,0x3, 0x2, 0x80,0x23,0x7f,0x27,0x2, 
-0x4f,0xa7,0x90,0xc, 0x6a,0xe5,0x68,0xf0,0xe0,0x75,0xf0,0x20,0xa4,0xae,0xf0,0x25,
-0x10,0xf5,0x9, 0xee,0x35,0xf, 0xf5,0x8, 0x22,0xe5,0x68,0xb4,0x4, 0x6, 0x7d,0x4, 
-0x7f,0x1, 0x80,0xa, 0xe5,0x68,0x64,0x5, 0x60,0x2, 0x21,0xa1,0xfd,0xff,0x2, 0x36,
-0x74,0x90,0xa, 0xe5,0x21,0x9e,0x90,0xa, 0xe6,0x21,0x9e,0x90,0xa, 0xe7,0x21,0x9e,
-0x90,0xa, 0xe8,0x21,0x9e,0x90,0xa, 0xe9,0x21,0x9e,0x90,0xa, 0xf2,0x21,0x9e,0x90,
-0xc, 0x9b,0x21,0x9e,0x90,0xb, 0x57,0x21,0x9e,0x90,0xc, 0x32,0xe0,0x60,0xb, 0x7f,
-0x1, 0x12,0x1d,0xa7,0xe4,0x90,0xc, 0x32,0xf0,0x22,0xe4,0xff,0x12,0x1d,0xa7,0x90,
-0xc, 0x32,0x74,0x1, 0xf0,0x22,0xe5,0x67,0xc3,0x94,0x50,0x40,0x17,0xe5,0x67,0xd3,
-0x94,0x77,0x50,0x10,0x7d,0x77,0xaf,0x68,0x12,0x6, 0xd3,0x74,0xa5,0x25,0x67,0x31,
-0xa2,0xef,0xf0,0x22,0xe5,0x67,0xc3,0x94,0x78,0x40,0x14,0xe5,0x67,0xd3,0x94,0x9f,
-0x50,0xd, 0x74,0x99,0x25,0x67,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x80,0x4f,0xe5,
-0x67,0xc3,0x94,0xa0,0x40,0x14,0xe5,0x67,0xd3,0x94,0xbe,0x50,0xd, 0x74,0x8d,0x25,
-0x67,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x80,0x34,0xe5,0x67,0xc3,0x94,0xbf,0x40,
-0x14,0xe5,0x67,0xd3,0x94,0xd2,0x50,0xd, 0x74,0x7e,0x25,0x67,0xf5,0x82,0xe4,0x34,
-0xa, 0xf5,0x83,0x80,0x19,0xe5,0x67,0xc3,0x94,0xd3,0x40,0x15,0xe5,0x67,0xd3,0x94,
-0xe1,0x50,0xe, 0x74,0x78,0x25,0x67,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0xe5,0x68,
-0xf0,0x22,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0x7b,0x1, 0x7a,0xc, 0x79,0x6c,
-0xe5,0x68,0x12,0x1, 0xc5,0x53,0x68,0x70,0xe5,0x68,0xc4,0x54,0xf, 0x22,0x8b,0x31,
-0x8a,0x32,0x89,0x33,0xe4,0xff,0xab,0x31,0xe5,0x33,0x24,0x28,0xf9,0xe4,0x35,0x32,
-0xfa,0xef,0xfd,0x12,0x25,0xec,0x74,0x3, 0x12,0x1, 0xc5,0xab,0x31,0xe5,0x33,0x24,
-0x23,0xf9,0xe4,0x35,0x32,0x51,0x1e,0x90,0x0, 0x2d,0x51,0x9, 0x90,0x0, 0x37,0x51,
-0x9, 0xf, 0xbf,0x5, 0xd1,0xab,0x31,0xaa,0x32,0xa9,0x33,0x90,0x0, 0x41,0xe4,0x12,
-0x1, 0xd7,0x90,0x0, 0x42,0xe4,0x2, 0x1, 0xd7,0xab,0x31,0xaa,0x32,0xa9,0x33,0xef,
-0x75,0xf0,0x2, 0x12,0x5, 0x40,0x74,0x7f,0x75,0xf0,0xff,0x2, 0x3, 0x5b,0xfa,0xe9,
-0x2d,0xf9,0xec,0x3a,0xfa,0x74,0x3, 0x2, 0x1, 0xc5,0x53,0xdb,0xbf,0x22,0x51,0x2a,
-0x7f,0x1, 0x51,0x4d,0x51,0x85,0x51,0x60,0x51,0x45,0x7f,0x1, 0xef,0x70,0x3, 0xc2,
-0xaf,0x22,0xd2,0xaf,0x22,0x75,0x92,0xe8,0xd2,0xae,0xd2,0xbe,0x22,0x53,0xc9,0xf8,
-0xef,0x70,0x5, 0x43,0xc9,0x3, 0x80,0x3, 0x43,0xc9,0x2, 0xc2,0xce,0xc2,0xca,0x22,
-0xe4,0xff,0xa2,0xaf,0x33,0xfe,0xc2,0x88,0xd2,0xa8,0xc2,0xaf,0x30,0x89,0x6, 0xc2,
-0x89,0xe4,0xff,0x80,0x1, 0xf, 0xef,0xd3,0x94,0xfa,0x40,0xf0,0xee,0x24,0xff,0x92,
-0xaf,0x75,0xf7,0xff,0x22,0x85,0xe6,0x21,0xe4,0xf5,0x22,0x75,0x99,0x1, 0xd2,0x98,
-0x7f,0x2, 0x7e,0x78,0x12,0x34,0x17,0x8f,0x23,0x7f,0x3, 0x7e,0x78,0x12,0x34,0x17,
-0xe5,0x23,0xf4,0x60,0xa, 0xe5,0x23,0x6f,0xff,0xbf,0xff,0x3, 0x85,0x23,0x22,0xe5,
-0x21,0xb4,0xff,0x3, 0x75,0x21,0x6a,0xe5,0x22,0xb4,0x1, 0xf, 0xe5,0x21,0x64,0x6a,
-0x60,0x18,0xe5,0x21,0xb4,0x6b,0x2, 0x80,0x11,0x80,0xb, 0xe5,0x21,0x64,0x6a,0x60,
-0x5, 0xe5,0x21,0xb4,0x6b,0x4, 0x53,0xea,0x7f,0x22,0x43,0xea,0x80,0x22,0xc0,0xe0,
-0xc0,0xf0,0xc0,0x83,0xc0,0x82,0xc0,0xd0,0x75,0xd0,0x0, 0xc0,0x0, 0xc0,0x1, 0xc0,
-0x2, 0xc0,0x3, 0xc0,0x4, 0xc0,0x5, 0xc0,0x6, 0xc0,0x7, 0x12,0x30,0xf0,0x90,0xc, 
-0x6c,0xe0,0x54,0xfd,0xf0,0xd0,0x7, 0xd0,0x6, 0xd0,0x5, 0xd0,0x4, 0xd0,0x3, 0xd0,
-0x2, 0xd0,0x1, 0xd0,0x0, 0xd0,0xd0,0xd0,0x82,0xd0,0x83,0xd0,0xf0,0xd0,0xe0,0x32,
-0x2, 0x37,0xad,0x7d,0x66,0x7f,0xf8,0x7e,0x6f,0x12,0x37,0x5c,0x7d,0xbb,0x7f,0xf9,
-0x7e,0x6f,0x2, 0x37,0x5c,0x7e,0x0, 0x7c,0x0, 0x12,0x1d,0xdd,0xeb,0xfd,0xd3,0xef,
-0x9d,0xee,0x9c,0x7f,0x0, 0x50,0x2, 0x7f,0x1, 0x22,0x3e,0xf5,0x83,0x7b,0x2, 0xaf,
-0x41,0xe0,0xfd,0x71,0x35,0xef,0x22,0xfd,0xaf,0x3d,0x71,0x35,0xef,0x22,0xaf,0x42,
-0xe0,0xfd,0x71,0x35,0xef,0x22,0x12,0x1, 0x65,0xaf,0x3c,0xfd,0x7b,0x2, 0x71,0x35,
-0xef,0x22,0x12,0x17,0xfa,0xe4,0xf5,0x2d,0xf5,0x2e,0xf5,0x2f,0x12,0x64,0x92,0xf5,
-0x3b,0x75,0x3c,0xff,0xf5,0x41,0xf5,0x42,0x12,0x15,0x1c,0x90,0x0, 0xb, 0x12,0x2, 
-0xb7,0xf5,0x46,0x85,0xf0,0x45,0xe4,0xf5,0x47,0xf5,0x48,0x12,0x1f,0xed,0xf5,0x4a,
-0x85,0xf0,0x49,0x12,0x65,0x55,0xf5,0x43,0x8f,0x44,0xe4,0xf5,0x2d,0x12,0x15,0xb1,
-0x12,0x66,0xf, 0x40,0x3, 0x2, 0x58,0x43,0xe5,0x2d,0x75,0xf0,0x10,0xa4,0x85,0xf0,
-0x3f,0xf5,0x40,0xe4,0xf5,0x2e,0x12,0x17,0xdc,0xff,0xe5,0x2e,0xc3,0x9f,0x40,0x3, 
-0x2, 0x58,0x3e,0x12,0x5a,0x87,0x12,0x65,0xba,0x95,0x46,0xee,0x95,0x45,0x40,0x2, 
-0x5, 0x47,0x12,0x5a,0x87,0x12,0x65,0xba,0x95,0x4a,0xe5,0x49,0x12,0x43,0x3b,0x50,
-0x3, 0x2, 0x58,0x31,0xe5,0x2d,0x70,0x6, 0xf5,0x2f,0xf5,0x30,0x80,0x15,0xe5,0x40,
-0x24,0xf0,0xff,0xe5,0x3f,0x34,0xff,0x12,0x2f,0xea,0x12,0x5a,0x8e,0xf5,0x2f,0xa3,
-0xe0,0xf5,0x30,0x12,0x15,0xb1,0x12,0x1, 0x4c,0x14,0xb5,0x2d,0x7, 0xe4,0xf5,0x31,
-0xf5,0x32,0x80,0x14,0xe5,0x40,0x24,0x10,0xff,0xe4,0x35,0x3f,0x12,0x2f,0xea,0x12,
-0x5a,0x8e,0xf5,0x31,0xa3,0xe0,0xf5,0x32,0xe5,0x2e,0x70,0x6, 0xf5,0x35,0xf5,0x36,
-0x80,0x15,0xe5,0x40,0x24,0xff,0xff,0xe5,0x3f,0x34,0xff,0x12,0x2f,0xea,0x12,0x5a,
-0x8e,0xf5,0x35,0xa3,0xe0,0xf5,0x36,0x12,0x47,0xbf,0x14,0xb5,0x2e,0x7, 0xe4,0xf5,
-0x33,0xf5,0x34,0x80,0x14,0xe5,0x40,0x24,0x1, 0xff,0xe4,0x35,0x3f,0x12,0x2f,0xea,
-0x12,0x5a,0x8e,0xf5,0x33,0xa3,0xe0,0xf5,0x34,0x12,0x5a,0x87,0xfe,0xc3,0xee,0x64,
-0x80,0x94,0x80,0x50,0x2b,0xe5,0x30,0x95,0x32,0xe5,0x31,0x12,0x62,0xf8,0x40,0x6, 
-0x85,0x31,0x2f,0x85,0x32,0x30,0xd3,0xe5,0x30,0x95,0x34,0xe5,0x33,0x12,0x62,0xf8,
-0x40,0x6, 0x85,0x33,0x2f,0x85,0x34,0x30,0xd3,0x12,0x62,0xf2,0x40,0x32,0x80,0x2a,
-0xc3,0xe5,0x30,0x95,0x32,0xe5,0x31,0x12,0x62,0xf8,0x50,0x6, 0x85,0x31,0x2f,0x85,
-0x32,0x30,0xc3,0xe5,0x30,0x95,0x34,0xe5,0x33,0x12,0x62,0xf8,0x50,0x6, 0x85,0x33,
-0x2f,0x85,0x34,0x30,0xc3,0x12,0x62,0xf2,0x50,0x6, 0x85,0x35,0x2f,0x85,0x36,0x30,
-0xe5,0x2d,0x25,0xe0,0xf5,0x41,0xe5,0x2e,0x25,0xe0,0xf5,0x42,0xc3,0xee,0x64,0x80,
-0x94,0x80,0x40,0x2, 0xa1,0xbc,0x12,0x5a,0x87,0x12,0x43,0x32,0x40,0x2, 0xa1,0xb1,
-0xc3,0xe4,0x95,0x4a,0xfd,0xe4,0x95,0x49,0xfc,0xd3,0xef,0x9d,0xec,0x12,0x43,0x3b,
-0x40,0x2, 0xa1,0xb1,0xe5,0x48,0x70,0x9, 0x90,0xa, 0x86,0xe5,0x41,0xf0,0xa3,0xa1,
-0xac,0xe5,0x48,0xc3,0x94,0x5, 0x40,0x5, 0x75,0x48,0x5, 0xa1,0xb1,0xe4,0xf5,0x3c,
-0x12,0x66,0x18,0xed,0x95,0x48,0x74,0x80,0xf8,0x6c,0x98,0x50,0x5f,0x12,0x3f,0xaf,
-0x12,0x66,0x67,0x71,0x4a,0x60,0x51,0x12,0x2f,0xe4,0x33,0xfe,0x12,0x65,0x79,0xaf,
-0x42,0x71,0x51,0x60,0x43,0xaf,0x3c,0x12,0x63,0xcc,0x25,0xe0,0xfd,0xee,0x33,0xfc,
-0x74,0x86,0x2d,0xf5,0x82,0x74,0xa, 0x12,0x5a,0xc4,0xff,0x74,0x87,0x2d,0xf5,0x82,
-0x74,0xa, 0x12,0x5a,0x63,0xfe,0xa3,0xe0,0xff,0xc3,0x12,0x3f,0x96,0x50,0x14,0x12,
-0x2f,0xe4,0x33,0xfe,0x12,0x66,0x67,0x3e,0xf5,0x83,0xe5,0x41,0xf0,0x12,0x65,0x79,
-0xe5,0x42,0xf0,0x75,0x3c,0xff,0x80,0x4, 0x5, 0x3c,0x80,0x94,0xe5,0x48,0xb5,0x3c,
-0x10,0x12,0x5b,0x5b,0xe5,0x41,0xf0,0xe5,0x48,0x12,0x5b,0x4f,0xe5,0x42,0xf0,0x5, 
-0x48,0x5, 0x40,0xe5,0x40,0x70,0x2, 0x5, 0x3f,0x2, 0x58,0x39,0x12,0x5a,0x87,0xfe,
-0xa3,0xe0,0xff,0xc3,0x12,0x43,0x37,0x50,0x3, 0x2, 0x58,0x31,0xef,0x95,0x4a,0xe5,
-0x49,0x12,0x43,0x3b,0x50,0x3, 0x2, 0x58,0x31,0xe5,0x3b,0x70,0xa, 0x90,0xa, 0x36,
-0xe5,0x41,0xf0,0xa3,0x2, 0x58,0x2c,0xe5,0x3b,0xc3,0x94,0x14,0x40,0x6, 0x75,0x3b,
-0x14,0x2, 0x58,0x31,0xe4,0xf5,0x3c,0x12,0x66,0x18,0xed,0x95,0x3b,0x74,0x80,0xf8,
-0x6c,0x98,0x40,0x3, 0x2, 0x58,0x1d,0xed,0x25,0xe0,0xff,0xec,0x12,0x5a,0xcf,0x71,
-0x4a,0x60,0x35,0x12,0x2f,0xe4,0x12,0x5a,0xd9,0x71,0x5e,0x60,0x2b,0x12,0x5a,0xaf,
-0x12,0x66,0x44,0x12,0x5a,0x63,0xfe,0xa3,0xe0,0xff,0xc3,0x12,0x3f,0x96,0x40,0x3, 
-0x2, 0x58,0x13,0x12,0x2f,0xe4,0x12,0x5a,0xcf,0x3e,0xf5,0x83,0xe5,0x41,0xf0,0x12,
-0x5a,0xdb,0xe5,0x42,0xf0,0x2, 0x58,0x13,0x12,0x2f,0xe4,0x12,0x5a,0xcf,0x3e,0xf5,
-0x83,0x7b,0x6, 0x71,0x4f,0x70,0x3, 0x2, 0x58,0x18,0x12,0x2f,0xe4,0x12,0x5a,0xd9,
-0x71,0x5e,0x70,0x3, 0x2, 0x58,0x18,0x12,0x2f,0xe4,0x12,0x5a,0xcf,0x3e,0xf5,0x83,
-0xe0,0xfd,0xc3,0x13,0x25,0x2d,0xf5,0x3d,0x12,0x5a,0xdb,0xe0,0xc3,0x13,0x25,0x2e,
-0xf5,0x3e,0xe4,0xf5,0x2f,0xf5,0x30,0xc3,0xe5,0x30,0x95,0x3b,0x74,0x80,0xf8,0x65,
-0x2f,0x98,0x50,0x39,0xaf,0x3c,0x12,0x63,0xcc,0x65,0x30,0x70,0x3, 0xee,0x65,0x2f,
-0x60,0x21,0x12,0x66,0x8f,0x12,0x5a,0xcf,0x3e,0xf5,0x83,0xe0,0xaf,0x3d,0x71,0x6b,
-0x60,0x11,0x12,0x66,0x8f,0x12,0x5a,0xd9,0xaf,0x3e,0x71,0x60,0x60,0x5, 0x75,0x3d,
-0xff,0x80,0xa, 0x5, 0x30,0xe5,0x30,0x70,0x2, 0x5, 0x2f,0x80,0xba,0xe5,0x3d,0xf4,
-0x70,0x3, 0x2, 0x58,0x18,0x12,0x5a,0xaf,0x12,0x66,0x44,0x3c,0xf5,0x83,0xe0,0xc3,
-0x13,0xf9,0x12,0x5a,0x69,0xfe,0xa3,0xe0,0xff,0x12,0x3f,0x95,0x40,0x15,0x12,0x2f,
-0xe4,0x12,0x5a,0xcf,0x3e,0x12,0x5a,0xc5,0xff,0xe9,0x2f,0x12,0x45,0x36,0x12,0x2f,
-0xea,0x80,0x7, 0xe5,0x40,0x25,0xe0,0xff,0xe5,0x3f,0x12,0x5a,0x8e,0xf5,0x31,0xa3,
-0xe0,0xf5,0x32,0xe5,0x32,0xae,0x31,0x78,0x2, 0x12,0x46,0x55,0xd8,0xfb,0xfd,0xac,
-0x6, 0xe5,0x31,0xa2,0xe7,0x13,0xfe,0xe5,0x32,0x13,0x2d,0xf5,0x32,0xee,0x3c,0xf5,
-0x31,0x12,0x15,0x1c,0x12,0x2, 0x8c,0xff,0xae,0xf0,0xc3,0xe5,0x32,0x9f,0xe5,0x31,
-0x9e,0x50,0x4, 0x8e,0x31,0x8f,0x32,0xaf,0x3d,0x12,0x63,0xcc,0x24,0x1, 0xff,0xe4,
-0x3e,0x12,0x5b,0x2e,0x12,0x62,0xc0,0xe5,0x3e,0xc3,0x13,0xfd,0x7c,0x0, 0x2f,0xff,
-0xec,0x3e,0x12,0x2f,0xea,0x12,0x5a,0x8e,0xfa,0xa3,0xe0,0xfb,0xe5,0x3d,0xa2,0xe7,
-0x13,0xf9,0xff,0x12,0x62,0xbb,0xef,0x2d,0xff,0xec,0x3e,0x12,0x2f,0xea,0x12,0x5a,
-0x8e,0xfe,0xa3,0xe0,0x2b,0xf5,0x34,0xee,0x3a,0xf5,0x33,0xa2,0xe7,0x13,0xf5,0x33,
-0xe5,0x34,0x13,0xf5,0x34,0xaf,0x3d,0x12,0x63,0xcc,0x24,0x1, 0xff,0xe4,0x3e,0x12,
-0x5b,0x2e,0x12,0x65,0x99,0xfd,0xee,0xc4,0x54,0xf0,0x48,0xfc,0x12,0x5b,0x27,0x2d,
-0xff,0xee,0x3c,0x12,0x2f,0xea,0x12,0x5a,0x8e,0xfc,0xa3,0xe0,0xfd,0xe9,0xff,0x33,
-0x95,0xe0,0xfe,0xef,0x12,0x65,0x99,0xfb,0xee,0xc4,0x54,0xf0,0x48,0xfa,0x12,0x5b,
-0x27,0x2b,0xff,0xee,0x3a,0x12,0x2f,0xea,0x12,0x5a,0x8e,0xfe,0xa3,0xe0,0x2d,0xf5,
-0x36,0xee,0x3c,0xf5,0x35,0xa2,0xe7,0x13,0xf5,0x35,0xe5,0x36,0x13,0xf5,0x36,0x25,
-0x34,0xff,0xe5,0x33,0x35,0x35,0x12,0x5b,0x2e,0xc3,0x95,0x32,0xe5,0x31,0x12,0x43,
-0x3b,0x40,0x15,0x12,0x2f,0xe4,0x51,0xcf,0x3e,0xf5,0x83,0xe5,0x3d,0xf0,0x51,0xdb,
-0xe5,0x3e,0xf0,0x75,0x3c,0xff,0x80,0x5, 0x5, 0x3c,0x2, 0x55,0xf7,0xe5,0x3b,0xb5,
-0x3c,0xf, 0x12,0x12,0x23,0xe5,0x41,0xf0,0xe5,0x3b,0x51,0x57,0xe5,0x42,0xf0,0x5, 
-0x3b,0x5, 0x40,0xe5,0x40,0x70,0x2, 0x5, 0x3f,0x5, 0x2e,0x2, 0x53,0xc6,0x5, 0x2d,
-0x2, 0x53,0xad,0xe5,0x3b,0xd3,0x94,0x5, 0x50,0x2, 0x21,0x92,0xe4,0xf5,0x3d,0xf5,
-0x2d,0x12,0x47,0x4f,0xff,0xe5,0x2d,0xc3,0x9f,0x40,0x2, 0x21,0x4, 0x75,0x37,0x3, 
-0x75,0x38,0xff,0xe4,0xf5,0x42,0xf5,0x2e,0xe5,0x2e,0xc3,0x95,0x3b,0x50,0x43,0xe5,
-0x2e,0x51,0x57,0x51,0xe6,0xe0,0xc3,0x12,0x2f,0xd1,0x12,0x0, 0x6, 0xc0,0x6, 0xc0,
-0x7, 0xe5,0x2e,0x12,0x12,0x23,0x51,0xf6,0xe0,0xc3,0x12,0x2f,0xd1,0x12,0x0, 0x6, 
-0xd0,0xe0,0x2f,0xf5,0x3a,0xd0,0xe0,0x3e,0xf5,0x39,0xc3,0xe5,0x3a,0x95,0x38,0xe5,
-0x39,0x95,0x37,0x50,0x9, 0x85,0x39,0x37,0x85,0x3a,0x38,0x85,0x2e,0x42,0x5, 0x2e,
-0x80,0xb6,0xe5,0x42,0x12,0x12,0x23,0x51,0xc7,0xff,0xe5,0x42,0x51,0x57,0xe0,0xc3,
-0x13,0x7c,0x0, 0x2f,0xff,0xec,0x35,0xf0,0x12,0x2f,0xea,0x51,0x8e,0x12,0x15,0x18,
-0x71,0x44,0x40,0x2c,0xe5,0x42,0x12,0x12,0x23,0xe0,0xfd,0xaf,0x3d,0x12,0x2f,0xe6,
-0x33,0xfe,0x74,0x5e,0x2f,0xf5,0x82,0x74,0xa, 0x71,0x1f,0x51,0x57,0xe0,0xfd,0x74,
-0x5f,0x2f,0xf5,0x82,0x74,0xa, 0x71,0x1f,0x12,0x12,0x23,0x74,0xff,0xf0,0x5, 0x3d,
-0x5, 0x2d,0x1, 0x51,0x85,0x3d,0x2d,0xe5,0x2d,0xc3,0x94,0x5, 0x50,0x63,0xe4,0xf5,
-0x2f,0xf5,0x30,0xf5,0x3e,0xf5,0x2e,0xe5,0x2e,0xc3,0x95,0x3b,0x50,0x3c,0xe5,0x2e,
-0x12,0x12,0x23,0xe0,0xff,0xf4,0x60,0x2e,0xef,0x51,0xc8,0xff,0xe5,0x2e,0x51,0x57,
-0xe0,0xfd,0xc3,0x13,0x7a,0x0, 0x2f,0xff,0xea,0x35,0xf0,0x12,0x2f,0xea,0x51,0x8e,
-0x12,0x43,0x32,0x40,0x11,0xe5,0x2e,0x12,0x12,0x23,0xe0,0xf5,0x41,0x8d,0x42,0x8e,
-0x2f,0x8f,0x30,0x85,0x2e,0x3e,0x5, 0x2e,0x80,0xbd,0xe5,0x2d,0x51,0xa3,0xe5,0x41,
-0x71,0x35,0xe5,0x42,0xf0,0xe5,0x3e,0x12,0x12,0x23,0x74,0xff,0xf0,0x5, 0x2d,0x80,
-0x96,0xe4,0xf5,0x2d,0xe5,0x2d,0x51,0xa3,0xe0,0xff,0xe5,0x2d,0x12,0x12,0x23,0xef,
-0x71,0x35,0xe0,0xff,0x51,0x55,0xef,0xf0,0x5, 0x2d,0xe5,0x2d,0xb4,0x5, 0xe5,0x75,
-0x3b,0x5, 0xe4,0xf5,0x2d,0x51,0xf8,0x74,0xff,0xf0,0x51,0xe8,0x74,0xff,0xf0,0x5, 
-0x2d,0xe5,0x2d,0xb4,0x5, 0xef,0xe5,0x3b,0xd3,0x94,0x0, 0x40,0x3c,0xe4,0xf5,0x2d,
-0xe5,0x2d,0xc3,0x95,0x3b,0x50,0x32,0xe5,0x2d,0x12,0x12,0x23,0xe0,0xff,0xe5,0x2d,
-0x12,0x15,0x8f,0xef,0x12,0x1, 0xd7,0x51,0x55,0x71,0x17,0x12,0x2e,0x6, 0xfa,0x90,
-0x0, 0x1, 0xed,0x12,0x1, 0xd7,0xe5,0x2d,0x12,0x12,0x23,0x51,0xf6,0xef,0xf0,0x51,
-0x55,0x51,0xe6,0xef,0xf0,0x5, 0x2d,0x80,0xc7,0xe5,0x48,0xd3,0x94,0x0, 0x40,0x28,
-0xe4,0xf5,0x2d,0xe5,0x2d,0xc3,0x95,0x48,0x50,0x1e,0xe5,0x2d,0x71,0x5b,0x71,0x17,
-0x71,0xb, 0x90,0x0, 0x87,0xed,0x12,0x1, 0xd7,0xe5,0x2d,0x71,0x4f,0xe0,0x90,0x0, 
-0x88,0x12,0x1, 0xd7,0x5, 0x2d,0x80,0xdb,0x90,0x0, 0x86,0xe5,0x48,0x71,0x67,0x90,
-0x0, 0x2d,0xe5,0x3b,0x12,0x1, 0xd7,0xe9,0x24,0x2f,0x71,0x73,0x54,0xfe,0x12,0x1, 
-0xc5,0x12,0x15,0x1c,0x90,0x0, 0xd, 0x12,0x1, 0x65,0xff,0xe5,0x47,0xd3,0x9f,0x40,
-0x13,0xab,0x2a,0xe5,0x2c,0x24,0x2f,0xf9,0xe4,0x35,0x2b,0xfa,0x12,0x1, 0x4c,0x44,
-0x1, 0x12,0x1, 0xc5,0x22,0xe5,0x2d,0x25,0xe0,0x24,0x37,0xf5,0x82,0xe4,0x34,0xa, 
-0xf5,0x83,0x22,0x3c,0xf5,0x83,0xe0,0xc3,0x13,0x7c,0x0, 0x2f,0xff,0xec,0x35,0xf0,
-0xfe,0xef,0x25,0xe0,0xff,0xee,0x33,0xfe,0xe5,0x44,0x2f,0xf5,0x82,0xe5,0x43,0x3e,
-0xf5,0x83,0xe0,0xfc,0xa3,0xe0,0xfd,0xe5,0x40,0x25,0xe0,0xff,0xe5,0x3f,0x33,0xfe,
-0xe5,0x44,0x2f,0xf5,0x82,0xe5,0x43,0x3e,0xf5,0x83,0xe0,0x22,0x12,0x4, 0xf2,0xe5,
-0x2f,0x25,0xe0,0x25,0xe0,0x24,0x5e,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0xaf,
-0x3c,0xef,0x33,0x95,0xe0,0xfe,0xef,0x25,0xe0,0xfd,0xee,0x33,0xfc,0x74,0x36,0x2d,
-0xf5,0x82,0x74,0xa, 0x3c,0xf5,0x83,0xe0,0xc3,0x13,0x75,0xf0,0x10,0xa4,0x22,0x33,
-0xfe,0x74,0x36,0x2f,0xf5,0x82,0x74,0xa, 0x22,0x33,0xfe,0x74,0x37,0x2f,0xf5,0x82,
-0x74,0xa, 0x3e,0xf5,0x83,0x22,0xe0,0xff,0xe5,0x2d,0x25,0xe0,0x24,0xbc,0xf5,0x82,
-0xe4,0x34,0xc, 0xf5,0x83,0x22,0xe0,0xff,0xe5,0x2d,0x25,0xe0,0x24,0xbb,0xf5,0x82,
-0xe4,0x34,0xc, 0xf5,0x83,0x22,0xe5,0x2f,0x75,0xf0,0x7, 0xa4,0xab,0x2a,0x25,0x2c,
-0xf9,0xe5,0x2b,0x35,0xf0,0xfa,0x22,0xe0,0xfd,0xe5,0x2d,0x75,0xf0,0x2, 0x22,0x3e,
-0xf5,0x83,0xed,0xf0,0xe5,0x42,0x22,0xe5,0x3e,0x24,0x1, 0xff,0xe4,0x33,0xa2,0xe7,
-0x13,0xfe,0xef,0x13,0x22,0xf0,0xe5,0x2d,0x25,0xe0,0x24,0x5f,0xf5,0x82,0xe4,0x34,
-0xa, 0xf5,0x83,0x22,0x12,0x2, 0x8c,0xfd,0xc3,0xef,0x9d,0xee,0x95,0xf0,0x22,0x25,
-0xe0,0x24,0x87,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0x25,0xe0,0x24,0x86,0xf5,
-0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0xab,0x2a,0xaa,0x2b,0xa9,0x2c,0x2, 0x1, 0xd7,
-0xe9,0x24,0x4f,0xf9,0xe4,0x3a,0xfa,0x2, 0x1, 0x4c,0x12,0x17,0xfa,0xe4,0xf5,0x2d,
-0xf5,0x2e,0x12,0x64,0x92,0xf5,0x37,0xf5,0x38,0xf5,0x3c,0xf5,0x3d,0x12,0x15,0x1c,
-0x90,0x0, 0x13,0x12,0x2, 0xb7,0xf5,0x44,0x85,0xf0,0x43,0x90,0x0, 0x22,0x12,0x1, 
-0x65,0xf5,0x47,0x12,0x65,0x55,0xf5,0x3e,0x8f,0x3f,0x12,0x47,0x84,0xaf,0x1, 0xf5,
-0x40,0x8f,0x41,0xe4,0xf5,0x2f,0x71,0x6, 0x12,0x4a,0x98,0xe4,0x12,0x1, 0xd7,0x5, 
-0x2f,0xe5,0x2f,0xb4,0x5, 0xf0,0x12,0x47,0x4f,0x70,0x3, 0x2, 0x60,0xd0,0xe4,0xf5,
-0x2f,0x12,0x47,0x4f,0xff,0xe5,0x2f,0xc3,0x9f,0x40,0x2, 0xe1,0x9b,0x12,0x12,0x1f,
-0x12,0x4, 0xfe,0x0, 0x0, 0x0, 0x0, 0x12,0x60,0xd1,0x12,0x4, 0xfe,0x0, 0x0, 0x0, 
-0x0, 0x51,0x9f,0x12,0x4, 0xfe,0x0, 0x0, 0x0, 0x0, 0x12,0x62,0xac,0xf5,0x83,0x12,
-0x4, 0xfe,0x0, 0x0, 0x0, 0x0, 0x90,0xa, 0x86,0x74,0x2, 0xf0,0xf5,0xf0,0xe5,0x2f,
-0x12,0x15,0x98,0x12,0x1, 0x65,0x12,0x64,0x83,0x40,0xd, 0x12,0x15,0xb1,0x12,0x1, 
-0x4c,0x12,0x63,0xf3,0x94,0x0, 0x50,0x6, 0x12,0x15,0x1c,0x12,0x64,0xfc,0x12,0x60,
-0xe1,0x12,0x64,0x83,0x40,0xa, 0x12,0x17,0xdc,0x12,0x63,0xf3,0x94,0x0, 0x50,0x6, 
-0x12,0x15,0x1c,0x12,0x64,0xfc,0x12,0x60,0xe1,0x12,0x65,0x16,0xe5,0x2f,0x12,0x15,
-0x98,0x12,0x1, 0x65,0x51,0xc8,0x12,0x65,0xc4,0xe4,0xf5,0x42,0x12,0x15,0x6, 0x71,
-0x44,0x40,0x3, 0x75,0x42,0x1, 0x12,0x15,0x8d,0x12,0x1, 0x65,0x12,0x64,0x4f,0xfe,
-0xc3,0xef,0x9e,0xf5,0x2d,0x12,0x15,0x8d,0x12,0x1, 0x65,0x12,0x64,0x4f,0x2f,0xff,
-0xe4,0x33,0xfe,0xad,0x2d,0x12,0x3f,0x90,0x40,0x2, 0xe1,0x97,0xe5,0x2f,0x75,0xf0,
-0x2, 0x12,0x2e,0x6, 0x12,0x47,0xbe,0x12,0x64,0x4f,0xfe,0xc3,0xef,0x9e,0xf5,0x2e,
-0x12,0x60,0xe1,0x12,0x64,0x4f,0x2f,0xff,0xe4,0xad,0x2e,0x12,0x3f,0x8e,0x40,0x2, 
-0xe1,0x93,0xc3,0xe5,0x2d,0x64,0x80,0x94,0x80,0x50,0x2, 0xe1,0x8f,0x12,0x15,0xb1,
-0x12,0x1, 0x4c,0xad,0x2d,0x12,0x63,0x91,0x40,0x2, 0xe1,0x8f,0xc3,0xe5,0x2e,0x64,
-0x80,0x94,0x80,0x50,0x2, 0xe1,0x8f,0x12,0x47,0xbf,0xff,0xad,0x2e,0x12,0x63,0x92,
-0x40,0x2, 0xe1,0x8f,0xaf,0x2d,0x12,0x62,0xba,0xef,0x2d,0xf5,0x3b,0xee,0x3c,0xf5,
-0x3a,0xe5,0x3b,0x25,0xe0,0xff,0xe5,0x3a,0x33,0xfe,0xe5,0x3f,0x2f,0xf5,0x82,0xe5,
-0x3e,0x12,0x47,0x62,0xff,0xc3,0x95,0x47,0xf5,0x46,0xee,0x94,0x0, 0xf5,0x45,0xd3,
-0xe5,0x46,0x94,0x0, 0xe5,0x45,0x64,0x80,0x94,0x80,0x50,0x2, 0xe1,0x8f,0xef,0x95,
-0x44,0xee,0x95,0x43,0x40,0xa, 0x71,0x6, 0x90,0x0, 0x10,0x74,0x1, 0x12,0x1, 0x92,
-0xe5,0x42,0xb4,0x1, 0x2a,0xe5,0x3b,0xae,0x3a,0x78,0x3, 0xce,0xc3,0x13,0xce,0x13,
-0xd8,0xf9,0x25,0x41,0xf5,0x82,0xe5,0x40,0x3e,0xf5,0x83,0xc0,0x83,0xc0,0x82,0xe0,
-0xff,0xe5,0x3b,0x12,0x63,0x38,0xf4,0xfe,0xef,0x5e,0xd0,0x82,0xd0,0x83,0xf0,0xe5,
-0x2d,0x25,0xe0,0xf5,0x3c,0xe5,0x2e,0x25,0xe0,0xf5,0x3d,0x12,0x15,0x8d,0x12,0x53,
-0x66,0x70,0x2, 0xc1,0x1, 0x12,0x60,0xe1,0x7b,0x2, 0x12,0x53,0x57,0x70,0x2, 0xc1,
-0x1, 0x12,0x12,0x1f,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0xc0,0x0, 0xc0,0x1, 0xc0,
-0x2, 0xc0,0x3, 0x12,0x62,0x8f,0xd0,0x3, 0xd0,0x2, 0xd0,0x1, 0xd0,0x0, 0x12,0x62,
-0x37,0xd0,0x82,0xd0,0x83,0x12,0x62,0xa9,0xf5,0x83,0xc0,0x83,0xc0,0x82,0x12,0x2a,
-0xc9,0xae,0x45,0x12,0x63,0x2d,0xeb,0x25,0x46,0x12,0x62,0x39,0xd0,0x82,0xd0,0x83,
-0x12,0x4, 0xf2,0x12,0x60,0xd1,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0xc0,0x0, 0xc0,
-0x1, 0xc0,0x2, 0xc0,0x3, 0xae,0x45,0xaf,0x46,0xab,0x7, 0xaf,0x2d,0x12,0x62,0x97,
-0xd0,0x3, 0xd0,0x2, 0xd0,0x1, 0xd0,0x0, 0x12,0x62,0x37,0xd0,0x82,0xd0,0x83,0x12,
-0x4, 0xf2,0xe5,0x2f,0x25,0xe0,0x25,0xe0,0x24,0x5e,0xf5,0x82,0xe4,0x34,0xa, 0xe1,
-0x74,0xe4,0xf5,0x39,0x12,0x47,0x4f,0xad,0x39,0x12,0x63,0x91,0x50,0x60,0xe5,0x2f,
-0x65,0x39,0x60,0x56,0xed,0x25,0xe0,0xff,0xec,0x33,0x8f,0x82,0xf5,0x83,0x12,0x53,
-0x66,0x60,0x15,0xaf,0x39,0x12,0x2f,0xe6,0x12,0x47,0xb3,0xfd,0x7b,0x2, 0x12,0x53,
-0x58,0x60,0x5, 0x75,0x39,0xff,0x80,0x36,0xaf,0x39,0x12,0x2f,0xe6,0x33,0xab,0x2a,
-0xaa,0x2b,0xa9,0x2c,0x8f,0x82,0xf5,0x83,0x12,0x1, 0x65,0xfd,0x7b,0x4, 0xaf,0x3c,
-0x12,0x53,0x35,0xef,0x60,0x14,0xaf,0x39,0x12,0x2f,0xe6,0x12,0x47,0xb3,0x7b,0x4, 
-0x12,0x53,0x57,0x60,0x5, 0xe4,0xf5,0x39,0x80,0x4, 0x5, 0x39,0x80,0x96,0xe5,0x39,
-0x60,0x2, 0xc1,0xfa,0x12,0x60,0xd1,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0xc0,0x0, 
-0xc0,0x1, 0xc0,0x2, 0xc0,0x3, 0xae,0x45,0xaf,0x46,0x12,0x63,0x2d,0x12,0x64,0xbb,
-0xaf,0x2d,0x12,0x62,0x9f,0xd0,0x3, 0xd0,0x2, 0xd0,0x1, 0xd0,0x0, 0x12,0x62,0x37,
-0xd0,0x82,0xd0,0x83,0x12,0x12,0x1c,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0xc0,0x0, 
-0xc0,0x1, 0xc0,0x2, 0xc0,0x3, 0xae,0x45,0xaf,0x46,0x12,0x63,0x2d,0x12,0x64,0xbb,
-0xaf,0x2e,0x12,0x62,0x9f,0xd0,0x3, 0xd0,0x2, 0xd0,0x1, 0xd0,0x0, 0x12,0x62,0x37,
-0xd0,0x82,0xd0,0x83,0x51,0x9c,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0x12,0x63,0x23,
-0x12,0x62,0x37,0xd0,0x82,0xd0,0x83,0x12,0x62,0xa9,0xf5,0x83,0xc0,0x83,0xc0,0x82,
-0x12,0x2a,0xc9,0x12,0x63,0x23,0xeb,0x2f,0xe1,0x85,0xe5,0x39,0xf4,0x70,0x2, 0xe1,
-0x8f,0x12,0x60,0xd1,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0xc0,0x0, 0xc0,0x1, 0xc0,
-0x2, 0xc0,0x3, 0xae,0x45,0xaf,0x46,0xab,0x7, 0xaa,0x6, 0xea,0x33,0x95,0xe0,0xf9,
-0xf8,0xaf,0x2d,0x12,0x62,0x9f,0xd0,0x3, 0xd0,0x2, 0xd0,0x1, 0xd0,0x0, 0x12,0x62,
-0x37,0xd0,0x82,0xd0,0x83,0x12,0x12,0x1c,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0xc0,
-0x0, 0xc0,0x1, 0xc0,0x2, 0xc0,0x3, 0x12,0x62,0x8f,0xd0,0x3, 0xd0,0x2, 0xd0,0x1, 
-0xd0,0x0, 0x12,0x62,0x37,0xd0,0x82,0xd0,0x83,0x51,0x9c,0xc0,0x83,0xc0,0x82,0x12,
-0x2a,0xc9,0xae,0x45,0x12,0x63,0x2d,0xeb,0x25,0x46,0x12,0x62,0x39,0xd0,0x82,0xd0,
-0x83,0x12,0x62,0xa9,0xf5,0x83,0xc0,0x83,0xc0,0x82,0x12,0x2a,0xc9,0xae,0x45,0x12,
-0x63,0x2d,0xeb,0x25,0x46,0x12,0x62,0x39,0xd0,0x82,0xd0,0x83,0x12,0x4, 0xf2,0x5, 
-0x2e,0x81,0xa0,0x5, 0x2d,0x81,0x75,0x5, 0x2f,0x61,0xd1,0xe4,0xf5,0x2f,0x12,0x47,
-0x4f,0xff,0xe5,0x2f,0xc3,0x9f,0x40,0x3, 0x2, 0x60,0xc8,0xe5,0x2f,0x75,0xf0,0x2, 
-0x12,0x2e,0x6, 0x12,0x47,0xbe,0x12,0x65,0x16,0xe5,0x2f,0x12,0x15,0x98,0x12,0x1, 
-0x65,0x51,0xc8,0x12,0x65,0xc4,0x12,0x15,0x6, 0x71,0x44,0x50,0x3, 0x2, 0x60,0xc3,
-0x12,0x12,0x1f,0xc0,0x83,0xc0,0x82,0x12,0x2b,0x2, 0x78,0x6, 0x12,0x4, 0xdf,0xd0,
-0x82,0xd0,0x83,0x12,0x62,0xa9,0xf5,0x83,0x12,0x2a,0xc9,0x12,0x12,0x1f,0x12,0x2b,
-0x2, 0x12,0x4, 0x13,0xef,0x24,0x20,0xf5,0x31,0xe4,0x3e,0xf5,0x30,0x12,0x60,0xd1,
-0xc0,0x83,0xc0,0x82,0x12,0x2b,0x2, 0x78,0x6, 0x12,0x4, 0xdf,0xd0,0x82,0xd0,0x83,
-0x12,0x5a,0x9c,0x12,0x2a,0xc9,0x11,0xd1,0x12,0x2b,0x2, 0x12,0x4, 0x13,0xef,0x24,
-0x20,0xf5,0x35,0xe4,0x3e,0xf5,0x34,0xe5,0x38,0x12,0x5b,0x8, 0x90,0x0, 0xa, 0xe5,
-0x30,0x85,0x31,0xf0,0x12,0x3, 0x5b,0x90,0x0, 0xc, 0xe5,0x34,0x85,0x35,0xf0,0x12,
-0x3, 0x5b,0x12,0x5a,0x9f,0xc0,0x83,0xc0,0x82,0xe0,0xfc,0xa3,0xe0,0xfd,0xa3,0x12,
-0x15,0x17,0x90,0x0, 0x12,0x12,0x1, 0x65,0xf9,0xf8,0x12,0x4, 0xcc,0xd0,0x82,0xd0,
-0x83,0x12,0x5a,0x9c,0x12,0x2b,0x2, 0xe4,0x7b,0x7f,0xfa,0xf9,0xf8,0xc3,0x12,0x4, 
-0xbb,0x50,0xa, 0x12,0x5a,0x9f,0x12,0x4, 0xfe,0x0, 0x0, 0x0, 0x7f,0x12,0x5a,0x9f,
-0xa3,0xa3,0xa3,0xe0,0xfd,0xe5,0x38,0x12,0x5b,0x8, 0x90,0x0, 0xf, 0xed,0x12,0x1, 
-0xd7,0xe5,0x2f,0x75,0xf0,0x7, 0x90,0x0, 0x10,0x11,0xe9,0xfd,0xe5,0x38,0x75,0xf0,
-0x7, 0xa4,0x12,0x5b,0xe, 0x90,0x0, 0x10,0xed,0x12,0x4a,0x9c,0x12,0x1, 0x65,0xd3,
-0x94,0xf, 0x40,0xd, 0xe5,0x38,0x12,0x5b,0x8, 0x90,0x0, 0x10,0x74,0xf, 0x12,0x1, 
-0xd7,0x5, 0x38,0x5, 0x2f,0x2, 0x5f,0x9e,0x90,0x0, 0x2d,0xe5,0x38,0x12,0x5b,0x67,
-0x22,0xe5,0x2f,0x25,0xe0,0x25,0xe0,0x24,0x4a,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,
-0x22,0xe5,0x2f,0x75,0xf0,0x2, 0x90,0x0, 0x1, 0xa4,0xab,0x2a,0x25,0x2c,0xf9,0xe5,
-0x2b,0x35,0xf0,0xfa,0x2, 0x1, 0x65,0xbf,0x1, 0x5, 0x43,0xdb,0x80,0x80,0x6, 0xef,
-0x70,0x3, 0x53,0xdb,0x7f,0xc2,0xea,0x43,0xdb,0x10,0xd2,0xd9,0xc2,0xdd,0xc2,0xdc,
-0xc2,0xdb,0xc2,0xda,0xd2,0xd8,0x75,0xab,0x6, 0xe4,0xf5,0x9a,0x53,0xdb,0xfd,0xd2,
-0xed,0xd2,0xba,0xc2,0xc2,0x43,0xa9,0x4, 0x43,0xb9,0x4, 0x22,0xef,0x31,0x40,0xed,
-0x2b,0xfb,0xe4,0x3a,0xfe,0xaf,0x3, 0x22,0xac,0x7, 0xed,0x31,0x40,0xec,0x80,0xf0,
-0x7b,0x0, 0x7a,0xc0,0x75,0xf0,0x80,0xa4,0x2b,0xfb,0xe5,0xf0,0x3a,0xfa,0x22,0x53,
-0xc9,0x7, 0x43,0xc9,0x30,0x75,0xeb,0x80,0xef,0x25,0xe0,0x4, 0x25,0xeb,0xf5,0xeb,
-0x22,0x8b,0x33,0x8a,0x34,0x89,0x35,0xe4,0xff,0x51,0x8, 0xab,0x33,0xaa,0x34,0xa9,
-0x35,0x90,0x0, 0x18,0x12,0x1, 0x65,0xff,0x31,0x4f,0x7f,0x1, 0x31,0xba,0x31,0xf7,
-0xef,0x70,0x2, 0xff,0x22,0x7d,0x7f,0x7f,0x14,0x31,0xe5,0xef,0x70,0x2, 0xff,0x22,
-0x12,0xf, 0xec,0x85,0x33,0x39,0xf5,0x3a,0x89,0x3b,0xab,0x33,0xaa,0x34,0xa9,0x35,
-0x12,0x2e,0x91,0xab,0x33,0xaa,0x34,0xa9,0x35,0x12,0x2e,0x17,0xe4,0xff,0x31,0xba,
-0x31,0xdc,0xef,0x7f,0x0, 0x60,0x2, 0x7f,0x1, 0x22,0xef,0x24,0xfe,0x60,0xb, 0x14,
-0x60,0xc, 0x24,0x2, 0x70,0xc, 0x7d,0x9, 0x80,0xa, 0x7d,0x6, 0x80,0x6, 0x7d,0x3, 
-0x80,0x2, 0xe4,0xfd,0xe5,0xdc,0x54,0xf0,0x2d,0xf5,0xdc,0x22,0xe4,0xfd,0x51,0x1, 
-0x60,0x2, 0x7f,0x1, 0x22,0xae,0x5, 0xac,0x7, 0x12,0x2e,0x74,0x51,0x13,0xef,0x7f,
-0x0, 0xb5,0x6, 0x2, 0x7f,0x1, 0x22,0x7d,0x3, 0xe4,0x51,0x1, 0x60,0x2, 0x7f,0x1, 
-0x22,0xff,0x31,0xe5,0xef,0x7f,0x0, 0x22,0xef,0x70,0x4, 0x53,0xdb,0xbf,0x22,0x43,
-0xdb,0x40,0x22,0x12,0x2f,0x98,0xef,0x44,0x80,0xf5,0xa1,0xe5,0xdb,0x30,0xe3,0xfb,
-0x53,0xdb,0xf3,0xe4,0xf5,0xa1,0xe5,0xdb,0x30,0xe3,0xfb,0xaf,0xa1,0x43,0xab,0x4, 
-0x22,0xc2,0xc2,0x53,0xdb,0xbf,0x32,0xeb,0x2f,0xff,0xea,0x3e,0xfe,0xe9,0x3d,0xfd,
-0xe8,0x3c,0xfc,0x22,0xf9,0xe4,0x35,0x22,0xfa,0x7e,0x0, 0xe9,0x25,0x2d,0xf9,0xee,
-0x3a,0xfa,0x12,0x1, 0x4c,0x54,0xf, 0xfd,0xe5,0x2d,0x25,0xe0,0xff,0xee,0x33,0xfe,
-0x74,0x6e,0x2f,0xf5,0x82,0x74,0xa, 0x3e,0xf5,0x83,0xed,0xf0,0x12,0x1, 0x4c,0x54,
-0xf0,0xc4,0x54,0xf, 0xfd,0xe5,0x2d,0x25,0xe0,0xff,0xe4,0x33,0xfe,0x74,0x6f,0x2f,
-0xf5,0x82,0x74,0xa, 0x3e,0x22,0xab,0x29,0xaa,0x2a,0xa9,0x2b,0x2, 0x1, 0x65,0xae,
-0x45,0xaf,0x46,0xab,0x7, 0xaf,0x2e,0xaa,0x6, 0xea,0x33,0x95,0xe0,0xf9,0xf8,0xef,
-0x33,0x95,0xe0,0xfe,0xfd,0xfc,0x2, 0x3, 0x88,0x12,0x4, 0xf2,0xe5,0x2f,0x25,0xe0,
-0x25,0xe0,0x24,0x72,0xf5,0x82,0xe4,0x34,0xa, 0x22,0xef,0x33,0x95,0xe0,0xfe,0xef,
-0xc4,0xf8,0x54,0xf, 0xc8,0x68,0xff,0xee,0xc4,0x54,0xf0,0x48,0xfe,0x22,0x12,0x2, 
-0xb7,0xff,0xe5,0xf0,0xc4,0xf8,0x54,0xf0,0xc8,0x68,0xfc,0xef,0xc4,0x54,0xf, 0x48,
-0xfd,0xe5,0x2e,0x75,0xf0,0x7, 0xa4,0xff,0xae,0xf0,0xab,0x21,0x25,0x23,0xf9,0xe5,
-0x22,0x22,0xe5,0x30,0x95,0x36,0xe5,0x35,0x64,0x80,0xf8,0xe5,0x2f,0x64,0x80,0x98,
-0x22,0xe5,0x2d,0x25,0xe0,0xff,0xe5,0x2c,0x33,0xfe,0xe5,0x31,0x2f,0xf5,0x82,0xe5,
-0x30,0x3e,0xf5,0x83,0xe0,0xfe,0xa3,0xe0,0xd3,0x95,0x36,0x74,0x80,0xf8,0xee,0x64,
-0x80,0x98,0x22,0xe5,0x45,0xa2,0xe7,0x13,0xfe,0xe5,0x46,0x13,0xff,0xee,0x33,0x95,
-0xe0,0xfd,0xfc,0x22,0xe0,0xff,0xe5,0x2d,0x7c,0x0, 0x54,0x7, 0x24,0x7c,0xf5,0x82,
-0xec,0x34,0x7, 0xf5,0x83,0xe4,0x93,0x22,0xa3,0xf0,0x75,0x24,0x1, 0x75,0x25,0x8, 
-0x75,0x26,0x29,0x75,0x27,0x1, 0x75,0x28,0xa, 0x75,0x29,0x2e,0x7b,0x1, 0x22,0xa8,
-0x1, 0xfc,0xad,0x27,0x7b,0x1, 0x7a,0xa, 0x79,0x36,0x7e,0x0, 0x2, 0x1, 0x26,0x7e,
-0x0, 0xe5,0x29,0x24,0x23,0xf9,0xe4,0x35,0x28,0xfa,0xe9,0x2f,0xf9,0xee,0x3a,0xfa,
-0x22,0xe5,0x2c,0x75,0xf0,0x7, 0xa4,0x24,0x38,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,
-0x22,0xff,0xed,0x33,0x95,0xe0,0xfc,0xc3,0xed,0x9f,0x74,0x80,0xf8,0x6c,0x98,0x22,
-0xab,0x27,0xe5,0x29,0x24,0x4f,0xf9,0xe4,0x35,0x28,0xfa,0x2, 0x1, 0x4c,0xf9,0xe4,
-0x3a,0xfa,0x12,0x2, 0x8c,0xc4,0xf8,0x54,0xf, 0xc8,0x68,0xff,0xe5,0xf0,0xc4,0x54,
-0xf0,0x48,0x8f,0xf0,0x2, 0x3, 0x3c,0x34,0x3, 0xfa,0xaf,0x27,0xef,0x33,0x95,0xe0,
-0xfe,0xef,0x22,0xf9,0xe4,0x3a,0xfa,0x12,0x2, 0x8c,0xc3,0x95,0x2b,0xff,0xe5,0xf0,
-0x95,0x2a,0x8f,0xf0,0x2, 0x3, 0x3c,0xe5,0x2b,0x24,0x23,0xf5,0x82,0xe4,0x35,0x2a,
-0xf5,0x83,0x22,0x24,0xff,0xff,0xe4,0x34,0xff,0xcf,0xc3,0x95,0x3b,0xcf,0x95,0x3a,
-0xfe,0xd3,0xef,0x94,0x0, 0xee,0x22,0x90,0xa, 0xdb,0xe0,0xfe,0xa3,0xe0,0xff,0xe4,
-0xfc,0xfd,0x7b,0x40,0x7a,0x9c,0xf9,0xf8,0xd3,0x22,0x90,0x8, 0x1d,0x74,0x1, 0xf0,
-0xa3,0x74,0xb, 0xf0,0x22,0x74,0x3e,0x25,0x4f,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,
-0xe0,0xff,0xab,0x49,0xe5,0x4b,0x22,0xab,0x21,0xe5,0x23,0x2f,0xf9,0xe5,0x22,0x3e,
-0xfa,0x22,0x75,0x28,0x9, 0x75,0x29,0x19,0x75,0x2a,0x1, 0x75,0x2b,0x8, 0x22,0xc3,
-0x13,0xff,0x90,0xa, 0x86,0xe0,0x22,0x75,0x28,0x0, 0x75,0x29,0x83,0x75,0x2a,0x1, 
-0x22,0x75,0x24,0x1, 0x75,0x25,0x0, 0x75,0x26,0x83,0x22,0xc3,0x13,0x24,0x3d,0xf5,
-0x82,0xe4,0x34,0xb, 0xf5,0x83,0x22,0x74,0x11,0x25,0x2c,0xf5,0x82,0xe4,0x34,0xb, 
-0xf5,0x83,0x22,0xc3,0x13,0x75,0x3a,0x0, 0xf5,0x3b,0xd3,0x94,0x0, 0xe5,0x3a,0x94,
-0x0, 0x22,0xf5,0x30,0xf5,0x31,0xf5,0x32,0xf5,0x33,0xf5,0x34,0xf5,0x35,0xf5,0x36,
-0x22,0xe4,0x12,0x1, 0xc5,0x4, 0x29,0xf9,0xe4,0x3a,0xfa,0x5, 0x39,0xe5,0x39,0x22,
-0x74,0x8a,0x2d,0xf5,0x82,0xe4,0x34,0xa, 0xf5,0x83,0x22,0x78,0x1, 0x12,0x4, 0xcc,
-0xa8,0x4, 0xa9,0x5, 0xaa,0x6, 0xab,0x7, 0x22,0x12,0x2, 0xb7,0xd3,0x9d,0xe5,0xf0,
-0x9c,0xe5,0x2d,0x75,0xf0,0x7, 0x22,0xc3,0xe4,0x95,0x36,0xfb,0xe4,0x94,0x0, 0xfa,
-0xc3,0xed,0x9b,0xea,0x22,0xff,0xe9,0x24,0x58,0xf9,0xe4,0x3a,0xfa,0xe9,0x2f,0xf9,
-0xea,0x3e,0x22,0xff,0xc3,0xe5,0x2b,0x9f,0xe5,0x2a,0x9e,0x22,0x90,0x0, 0x10,0x12,
-0x1, 0x65,0xc3,0x13,0x90,0xa, 0x86,0xf0,0x22,0xf5,0x83,0xe0,0xff,0xa3,0xe0,0x90,
-0x0, 0x5, 0xcf,0x8f,0xf0,0x22,0xc3,0x13,0xfd,0x7c,0x0, 0xaa,0x2b,0xa9,0x2c,0x75,
-0xf0,0x2, 0x22,0x12,0x1d,0xdd,0x8e,0x2a,0x8f,0x2b,0xe5,0x2b,0xa8,0x2c,0x8, 0x22,
-0x90,0x0, 0x52,0x12,0x1, 0xd7,0x90,0x0, 0x53,0x22,0x7e,0x0, 0x7f,0x23,0x2, 0x1, 
-0x26,0x12,0x2, 0xb7,0xac,0xf0,0xc3,0x9f,0x22,0xab,0x27,0xe5,0x29,0x24,0x23,0xf9,
-0xe4,0x35,0x28,0xfa,0x22,0xe5,0x23,0x24,0x80,0xf9,0xe5,0x22,0x34,0x3, 0xaf,0x1, 
-0x22,0x13,0x2d,0xfd,0xee,0x3c,0xfc,0xc3,0x64,0x80,0x94,0x80,0x22,0xab,0x21,0xe5,
-0x23,0x24,0xa, 0xf9,0xe4,0x35,0x22,0xfa,0x22,0x74,0x87,0x2f,0xf5,0x82,0x74,0xa, 
-0x3e,0xf5,0x83,0x22,0x12,0x2, 0xb7,0xc3,0x9f,0xff,0xe5,0xf0,0x9e,0xfe,0x22,0xf5,
-0x2a,0x85,0xf0,0x29,0xe5,0x29,0x54,0xf, 0x22,0xc4,0xf8,0x54,0xf, 0xc8,0x68,0x22,
-0x75,0xf0,0x2, 0x2, 0x5, 0x40,0x12,0x1, 0x4c,0xfd,0x12,0x0, 0x1e,0xe5,0x2c,0x22,
-0x90,0x0, 0x7, 0x12,0x1, 0x65,0xf5,0x25,0xf4,0x22,0xfe,0xa3,0xe0,0xff,0x12,0x0, 
-0x6, 0xd3,0xef,0x22,0x2d,0xff,0xec,0x35,0xf0,0xfe,0x22,0x90,0x0, 0x49,0x2, 0x1, 
-0x65,0x8b,0x27,0x8a,0x28,0x89,0x29,0x22,0x75,0x27,0x1, 0x75,0x28,0x0, 0x75,0x29,
-0x0, 0x22,0x75,0x24,0x1, 0x75,0x25,0xa, 0x75,0x26,0x2e,0x22,0xf0,0x90,0xb, 0x57,
-0xe0,0x90,0x0, 0x54,0xf0,0x22,0x90,0x0, 0x55,0x74,0x21,0xf0,0x22,0xed,0x12,0x1, 
-0xd7,0x5, 0x2e,0xe5,0x2e,0x22,0x90,0x0, 0x2d,0x75,0xf0,0x2, 0xe5,0x2a,0x22,0x12,
-0x1, 0x4c,0xff,0xe5,0x2d,0xc3,0x9f,0x22,0xad,0x3c,0xed,0x33,0x95,0xe0,0xfc,0xc3,
-0x22,0xe0,0xfc,0xa3,0xe0,0xc3,0x9f,0xec,0x9e,0x22,0xe0,0xfc,0xa3,0xe0,0xd3,0x9f,
-0xec,0x9e,0x22,0xe5,0x2a,0x85,0x2b,0xf0,0x2, 0x2, 0xef,0x90,0x0, 0x2d,0x75,0xf0,
-0x2, 0xe5,0x2b,0x22,0xff,0x74,0x37,0x2d,0xf5,0x82,0x74,0xa, 0x22,0xe5,0x26,0x24,
-0xa, 0xf9,0xe4,0x35,0x25,0x22,0xe5,0x29,0x24,0x26,0xf9,0xe4,0x35,0x28,0x22,0x74,
-0x7f,0xf0,0xa3,0x74,0xff,0xf0,0x22,0x74,0x86,0x2f,0xf5,0x82,0x74,0xa, 0x22,0xee,
-0xf0,0xa3,0xef,0xf0,0x5, 0x2c,0x22,0xfd,0x12,0x0, 0x1e,0xe4,0xf5,0x2c,0x22,0xff,
-0xab,0x29,0xe5,0x2b,0x24,0x54,0x22,0xff,0xab,0x29,0xe5,0x2b,0x24,0x1c,0x22,0xe5,
-0x30,0x25,0xe0,0xff,0xe5,0x2f,0x22,0x12,0x1, 0xd7,0x90,0xb, 0x57,0xe0,0x22,0x74,
-0x21,0xf0,0xa3,0x74,0x34,0xf0,0x22,0xf5,0x83,0xec,0xf0,0xa3,0xed,0xf0,0x22,0x66,
-0xaf,0x99,0x50,0x34,0xcb,0x22,0x79,
-
+0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
+0x0, 0xca,0x3b,0x7c,0xab,0x7d,0x72,0x7d,0x63,0xe5,0x10,0xb4,0x1, 0x21,0x7e,0x73,
+0x0, 0x85,0x4c,0x77,0x78,0x3, 0x2, 0x49,0xc8,0xe5,0x58,0x70,0x12,0x4c,0x77,0x78,
+0x3, 0x2, 0x49,0xc8,0x7e,0x37,0x2b,0xcb,0x4d,0x33,0x78,0x3, 0x2, 0x49,0xc8,0xe5,
+0x58,0x70,0xd, 0x7e,0x37,0x2b,0xc5,0x4d,0x33,0x78,0x5, 0x75,0x58,0x1, 0x80,0xa, 
+0xe5,0x58,0xbe,0xb0,0x1, 0x68,0x3, 0x75,0x58,0x2, 0x7e,0x37,0x2b,0xc5,0x4d,0x33,
+0x78,0x43,0xbe,0xa0,0x0, 0x28,0x8, 0x7e,0x37,0x2c,0x2, 0x4d,0x33,0x68,0xc, 0xe5,
+0x58,0xbe,0xb0,0x2, 0x68,0x5, 0xe5,0x59,0xb4,0x1, 0x2a,0x5, 0x5f,0x7e,0x73,0x2c,
+0x6, 0xbe,0x71,0x5f,0x50,0x22,0x75,0x5f,0x0, 0x7d,0x37,0x12,0x52,0x16,0x7d,0x36,
+0x7d,0x27,0x12,0x4c,0xe4,0xe5,0x58,0xb4,0x2, 0x3, 0x75,0x58,0x1, 0x75,0x59,0x0, 
+0x75,0x51,0x0, 0x80,0x3, 0x75,0x5f,0x0, 0xda,0x3b,0x22,0xbe,0xb0,0x80,0x40,0xc, 
+0xbe,0xb0,0xbf,0x38,0x7, 0xa, 0x3b,0x9, 0xb3,0x2b,0x89,0x22,0x7c,0xab,0xb, 0xa2,
+0x68,0x9, 0x1b,0xa2,0x78,0xa, 0x7e,0xb3,0x2b,0x61,0x22,0x7e,0xb3,0x2c,0x30,0x22,
+0xb4,0x3, 0x11,0x30,0x0, 0x6, 0x7e,0x34,0x2a,0xd5,0x80,0x4, 0x7e,0x34,0x2b,0x17,
+0x7a,0x37,0x2b,0x63,0xbe,0xb0,0x3, 0x40,0x10,0xbe,0xb0,0x3e,0x38,0xb, 0xa, 0x3b,
+0x2e,0x37,0x2b,0x63,0x9, 0xb3,0x0, 0x2, 0x22,0x1b,0xb1,0x68,0x1d,0x4, 0x78,0x34,
+0x30,0x0, 0x6, 0x7e,0x34,0x2a,0xd5,0x80,0x4, 0x7e,0x34,0x2b,0x17,0x7a,0x37,0x2b,
+0x63,0x7e,0x37,0x2b,0x63,0x9, 0xb3,0x0, 0x4, 0x22,0x30,0x0, 0x6, 0x7e,0x34,0x2a,
+0xd5,0x80,0x4, 0x7e,0x34,0x2b,0x17,0x7a,0x37,0x2b,0x63,0x7e,0x37,0x2b,0x63,0x9, 
+0xb3,0x0, 0x3, 0x22,0xe4,0x22,0x7d,0x1, 0x7d,0x12,0x7d,0x23,0xbe,0x24,0x0, 0x0, 
+0x50,0x2, 0x6d,0x22,0xbe,0x14,0x0, 0x0, 0x50,0x2, 0x6d,0x11,0xbe,0x24,0x0, 0x3f,
+0x38,0x14,0x7d,0x32,0x3e,0x34,0x9e,0x34,0x0, 0x3f,0xbe,0x34,0x0, 0x2, 0x58,0x2, 
+0x6d,0x33,0x7d,0x23,0x80,0x1a,0xbe,0x24,0x5, 0xc0,0x40,0x14,0x7d,0x32,0x9e,0x34,
+0x5, 0xc0,0x2d,0x32,0xbe,0x34,0x5, 0xfd,0x8, 0x4, 0x7e,0x34,0x5, 0xff,0x7d,0x23,
+0xbe,0x14,0x0, 0x3f,0x38,0x14,0x7d,0x31,0x3e,0x34,0x9e,0x34,0x0, 0x3f,0xbe,0x34,
+0x0, 0x2, 0x58,0x2, 0x6d,0x33,0x7d,0x13,0x80,0x1a,0xbe,0x14,0x9, 0x40,0x40,0x14,
+0x7d,0x31,0x9e,0x34,0x9, 0x40,0x2d,0x31,0xbe,0x34,0x9, 0x7d,0x8, 0x4, 0x7e,0x34,
+0x9, 0x7f,0x7d,0x13,0x1b,0x8, 0x20,0x7d,0x20,0xb, 0x25,0x7d,0x2, 0x1b,0x28,0x10,
+0x22,0xca,0x3b,0x7d,0x72,0x7d,0x63,0x75,0x25,0x0, 0xe4,0x7e,0xa1,0x25,0xa, 0x3a,
+0x2d,0x36,0x7e,0x39,0x70,0x12,0x57,0x3b,0x7a,0x35,0x23,0xe5,0x25,0x70,0xa, 0x7e,
+0x35,0x23,0x4e,0x34,0x20,0x0, 0x7a,0x35,0x23,0x7e,0x35,0x23,0xa, 0x56,0x12,0x55,
+0x1f,0x5, 0x25,0xe5,0x25,0xb4,0x24,0xd2,0x75,0x25,0x24,0x80,0x9, 0x74,0xc0,0x6c,
+0x77,0x12,0x55,0x1f,0x5, 0x25,0xe5,0x25,0xbe,0xb0,0x24,0x40,0xf0,0x75,0x25,0x0, 
+0xe5,0x25,0xa, 0x3b,0x2d,0x37,0x7e,0x39,0xb0,0x9, 0x73,0x0, 0x1, 0x12,0x57,0xba,
+0x7a,0x35,0x23,0xa, 0x56,0x12,0x55,0x1f,0x5, 0x25,0x5, 0x25,0xe5,0x25,0xb4,0x24,
+0xdf,0x75,0x25,0x12,0x74,0xc0,0x6c,0x77,0x12,0x55,0x1f,0x5, 0x25,0xe5,0x25,0xbe,
+0xb0,0x13,0x40,0xf0,0xda,0x3b,0x22,0xca,0x3b,0x7d,0x81,0x7d,0x43,0x7e,0x89,0xa0,
+0x9, 0x32,0x0, 0x96,0xa, 0x3a,0x6c,0x22,0x80,0x36,0x7e,0x10,0x2, 0xac,0x12,0x7d,
+0x90,0x2d,0x92,0x7e,0x99,0x10,0x1e,0x10,0x9, 0x9, 0x0, 0x1, 0x1e,0x0, 0x7e,0xd0,
+0x48,0xac,0xd1,0x7e,0xf0,0x2, 0xac,0xf0,0x7d,0xf7,0x2d,0xf6,0x2d,0xf4,0x49,0x9f,
+0xd, 0x80,0xbe,0x94,0x0, 0x0, 0x8, 0x6, 0xbd,0x93,0x28,0x2, 0x7d,0x39,0xb, 0x20,
+0xbc,0x32,0x38,0xc6,0x49,0x28,0x0, 0x1, 0xad,0x32,0xa, 0x36,0xa, 0x2a,0xbd,0x23,
+0x28,0x2, 0xa, 0x3a,0x9, 0xb8,0x0, 0x9, 0xb4,0x1, 0xd, 0x49,0x28,0x0, 0x7, 0x4d,
+0x22,0x78,0x5, 0xe4,0x19,0xb8,0x0, 0x9, 0x9, 0xb8,0x0, 0x9, 0x60,0x8, 0x7e,0x27,
+0x2c,0x4a,0xbd,0x23,0x50,0x4, 0x7a,0x37,0x2c,0x4a,0xda,0x3b,0x22,0xca,0x69,0xca,
+0xf8,0x7c,0xfb,0x7e,0x34,0x21,0x11,0x7a,0x35,0x23,0x7e,0x34,0x20,0x4d,0x7a,0x35,
+0x25,0x7e,0x34,0x21,0x11,0x9e,0x35,0x25,0x7a,0x35,0x25,0x6d,0x66,0xa, 0x3f,0x2d,
+0x36,0x2e,0x35,0x25,0x12,0x59,0x50,0x7e,0x35,0x23,0x7a,0x39,0xb0,0x7e,0x35,0x23,
+0xb, 0x34,0x7a,0x35,0x23,0xb, 0x64,0xbe,0x64,0x0, 0x24,0x78,0xe0,0x7e,0x34,0x21,
+0x3d,0x7a,0x35,0x23,0x7e,0x34,0x20,0x4d,0x7a,0x35,0x25,0x7e,0x34,0x21,0x3d,0x9e,
+0x35,0x25,0x7a,0x35,0x25,0x6d,0x66,0xa, 0x3f,0x2d,0x36,0x2e,0x35,0x25,0x12,0x59,
+0x50,0x7e,0x35,0x23,0x7a,0x39,0xb0,0x7e,0x35,0x23,0xb, 0x34,0x7a,0x35,0x23,0xb, 
+0x64,0xbe,0x64,0x3, 0x90,0x40,0xe0,0xda,0xf8,0xda,0x69,0x22,0x7e,0x50,0x64,0x6c,
+0x66,0x7e,0x70,0x64,0x6c,0xaa,0x7e,0x43,0x20,0x14,0x6c,0x33,0x80,0x2b,0x7e,0x10,
+0x2, 0xac,0x13,0x9, 0x20,0x1f,0x7e,0x1e,0x20,0x9, 0x10,0x1f,0x7f,0x1e,0x10,0xbc,
+0x25,0x50,0x2, 0x7c,0x52,0xbc,0x26,0x28,0x2, 0x7c,0x62,0xbc,0x17,0x50,0x2, 0x7c,
+0x71,0xbc,0x1a,0x28,0x2, 0x7c,0xa1,0xb, 0x30,0xbc,0x43,0x38,0xd1,0xbc,0x56,0x38,
+0x31,0xbc,0x7a,0x38,0x2d,0xa, 0x15,0xa, 0x26,0x9d,0x21,0xbe,0x24,0x0, 0x6, 0x50,
+0xc, 0xa, 0x7, 0xa, 0x1a,0x9d,0x10,0xbe,0x14,0x0, 0xa, 0x38,0x12,0xbe,0x24,0x0, 
+0xa, 0x28,0xf, 0xa, 0x27,0xa, 0x3a,0x9d,0x32,0xbe,0x34,0x0, 0x6, 0x50,0x3, 0x74,
+0x1, 0x22,0xe4,0x22,0xca,0x3b,0x7d,0x62,0x7d,0x73,0x9, 0x77,0x0, 0x8e,0x7a,0x73,
+0x2a,0x37,0xe4,0x19,0xb7,0x0, 0x8e,0x7d,0x36,0x2e,0x34,0xd, 0x80,0x7a,0x37,0x2a,
+0x35,0x7a,0x67,0x2a,0x33,0x75,0x21,0x1, 0x12,0x59,0x2c,0x60,0xfb,0x7d,0x37,0x7d,
+0x26,0x12,0x46,0xa1,0x12,0x58,0xea,0x6d,0x33,0x7a,0x35,0x22,0x7e,0x25,0x22,0x3e,
+0x24,0x7d,0x32,0x2e,0x37,0x2a,0x35,0xb, 0x38,0x10,0xe, 0x14,0xe, 0x14,0x2e,0x27,
+0x2a,0x33,0xb, 0x28,0x30,0x2d,0x31,0x1b,0x28,0x30,0x7e,0x35,0x22,0xb, 0x34,0x7a,
+0x35,0x22,0xbe,0x34,0x6, 0xc0,0x78,0xd4,0x5, 0x21,0xe5,0x21,0xbe,0xb0,0x4, 0x28,
+0xb7,0x7e,0x73,0x2a,0x37,0x19,0x77,0x0, 0x8e,0xda,0x3b,0x22,0xca,0x3b,0x6c,0xff,
+0x80,0x51,0x74,0x2, 0xac,0xbf,0x9, 0x65,0x1f,0x7e,0x1e,0x60,0x7a,0x61,0x21,0x9, 
+0xe5,0x1f,0x7f,0x1e,0xe0,0x7e,0x50,0x2, 0xac,0x5e,0x7e,0x70,0x48,0xac,0x67,0x2d,
+0x32,0x49,0x63,0xe, 0xe, 0xbe,0x64,0x0, 0x64,0x28,0x2, 0x80,0x37,0x7d,0x36,0x9e,
+0x34,0x0, 0x46,0x12,0x58,0x85,0xbe,0x34,0x0, 0xa, 0x18,0x15,0x7e,0xa1,0x5e,0x7c,
+0xba,0x4, 0xf5,0x5e,0xbe,0xa0,0x14,0x28,0x21,0x75,0x59,0x1, 0x75,0x5e,0x0, 0x80,
+0x19,0xb, 0xf0,0x7e,0x73,0x20,0x14,0xbc,0x7f,0x38,0xa7,0xbe,0x70,0x0, 0x28,0xa, 
+0xbc,0x7f,0x78,0x6, 0x75,0x5e,0x0, 0x75,0x59,0x0, 0xda,0x3b,0x22,0xca,0x79,0x7c,
+0xab,0x6c,0x99,0x80,0x5c,0xe5,0x21,0xb4,0x87,0x11,0xa, 0xf9,0x2d,0xf1,0x7d,0xe0,
+0x7e,0x7b,0xb0,0xa, 0xfb,0x2e,0xf4,0x43,0xbe,0x80,0x31,0xe5,0x21,0xb4,0x8a,0x11,
+0xa, 0xf9,0x2d,0xf1,0x7d,0xe0,0x7e,0x7b,0xb0,0xa, 0xfb,0x2e,0xf4,0x43,0xaa,0x80,
+0x1b,0xe5,0x21,0xbe,0xb0,0x88,0x68,0x5, 0xe5,0x21,0xb4,0x89,0x28,0xa, 0xf9,0x2d,
+0xf1,0x7d,0xe0,0x7e,0x7b,0xb0,0xa, 0xfb,0x2e,0xf4,0x44,0x1f,0x7d,0x7f,0x7a,0xf1,
+0x82,0x7a,0xe1,0x83,0xe4,0x93,0xa, 0xf9,0x2d,0xf3,0x7d,0xe2,0x7a,0x7b,0xb0,0xb, 
+0x90,0xbc,0xa9,0x38,0xa0,0xda,0x79,0x22,0xca,0x79,0x7c,0xab,0x6c,0x99,0x80,0x5c,
+0xe5,0x23,0xb4,0x87,0x11,0xa, 0xf9,0x2d,0xf1,0x7d,0xe0,0x7e,0x7b,0xb0,0xa, 0xfb,
+0x2e,0xf4,0x43,0xf9,0x80,0x31,0xe5,0x23,0xb4,0x8a,0x11,0xa, 0xf9,0x2d,0xf1,0x7d,
+0xe0,0x7e,0x7b,0xb0,0xa, 0xfb,0x2e,0xf4,0x43,0xd9,0x80,0x1b,0xe5,0x23,0xbe,0xb0,
+0x88,0x68,0x5, 0xe5,0x23,0xb4,0x89,0x28,0xa, 0xf9,0x2d,0xf1,0x7d,0xe0,0x7e,0x7b,
+0xb0,0xa, 0xfb,0x2e,0xf4,0x44,0x43,0x7d,0x7f,0x7a,0xf1,0x82,0x7a,0xe1,0x83,0xe4,
+0x93,0xa, 0xf9,0x2d,0xf3,0x7d,0xe2,0x7a,0x7b,0xb0,0xb, 0x90,0xbc,0xa9,0x38,0xa0,
+0xda,0x79,0x22,0x6c,0xaa,0x74,0x3, 0xa, 0x2a,0x2d,0x23,0x19,0xb2,0x0, 0x50,0x74,
+0x3, 0xa, 0x2a,0x2d,0x23,0x19,0xb2,0x0, 0x46,0x7e,0x24,0x7f,0xff,0x7e,0x30,0x2, 
+0xac,0x3a,0x7d,0x1, 0x2d,0x3, 0x59,0x20,0x0, 0x5a,0x7d,0x1, 0x2d,0x3, 0x59,0x20,
+0x0, 0x6e,0x74,0x7f,0xa, 0xa, 0x2d,0x3, 0x19,0xb0,0x0, 0xae,0x2d,0x13,0x59,0x21,
+0x0, 0x9a,0xe4,0xa, 0x2a,0x2d,0x23,0x19,0xb2,0x0, 0xcc,0xa, 0x2a,0x2d,0x23,0x19,
+0xb2,0x0, 0xb8,0xa, 0x2a,0x2d,0x23,0x19,0xb2,0x0, 0xc2,0xb, 0xa0,0xbe,0xa0,0xa, 
+0x40,0xa3,0xe4,0x19,0xb3,0x0, 0x82,0x19,0xb3,0x0, 0x83,0x22,0xca,0x79,0xbe,0xb0,
+0x80,0x40,0x9, 0xbe,0xb0,0xbf,0x38,0x4, 0x24,0x80,0x80,0x52,0xb, 0xb2,0x68,0x4c,
+0x1b,0xb2,0x78,0x4d,0x7e,0x74,0x2b,0x61,0x7a,0x79,0x70,0x5e,0x70,0x70,0x7c,0xb7,
+0xc4,0x54,0xf, 0x7c,0x7b,0xbe,0x70,0x4, 0x40,0x1a,0xbe,0x70,0x5, 0x68,0x15,0x7e,
+0xb3,0x2c,0x30,0xb4,0x3, 0x7, 0x74,0x1, 0x7e,0x70,0x3, 0x80,0x13,0x74,0x27,0x7e,
+0x70,0x3, 0x80,0x1a,0x7e,0xb3,0x2c,0x30,0xb4,0x3, 0xa, 0x74,0x1, 0x7e,0x70,0x1, 
+0x12,0x50,0x80,0x80,0xc, 0x74,0x27,0x7e,0x70,0x1, 0x80,0x2, 0x74,0x27,0x12,0x54,
+0xf5,0xda,0x79,0x22,0x7e,0x34,0x1f,0x7e,0x7e,0x24,0x0, 0xc3,0xe4,0x12,0x58,0x95,
+0x7e,0x34,0x26,0xf1,0x7e,0x24,0x0, 0x97,0xe4,0x12,0x58,0x95,0x6d,0x11,0x7e,0x34,
+0x0, 0x7, 0xad,0x31,0x2e,0x34,0x1f,0xce,0x12,0x0, 0x2e,0x7e,0x34,0x0, 0x7, 0xad,
+0x31,0x2e,0x34,0x26,0xf1,0x12,0x0, 0x2e,0x7e,0x34,0x0, 0x7, 0xad,0x31,0x2e,0x34,
+0x27,0x37,0x12,0x0, 0x2e,0xb, 0x14,0xbe,0x14,0x0, 0xa, 0x40,0xd1,0x75,0x12,0x0, 
+0x75,0x19,0x0, 0x75,0x11,0x0, 0x75,0xf, 0x0, 0x7e,0x34,0x4, 0x8f,0x12,0x58,0xf6,
+0xe4,0x7a,0xb3,0x0, 0x86,0x7a,0xb3,0x20,0x4c,0x22,0xca,0xf8,0x6d,0x33,0x7a,0x37,
+0x2b,0x5f,0xe4,0x7a,0xb3,0x2b,0x59,0x7e,0xb3,0x2b,0x61,0xc4,0x54,0xf, 0x7c,0xfb,
+0x5e,0xf0,0x7, 0x78,0xb, 0x7e,0xb3,0x2b,0x65,0x12,0x49,0xcb,0xf5,0x91,0x80,0x13,
+0xbe,0xf0,0x4, 0x40,0xe, 0xbe,0xf0,0x5, 0x68,0x9, 0x7e,0xb3,0x2b,0x65,0x12,0x2a,
+0x7c,0xf5,0x91,0xe4,0x7a,0xb3,0x2b,0x5b,0x7a,0xb3,0x2b,0x5a,0x74,0xaa,0x7a,0xb3,
+0x2a,0xd5,0x74,0xaa,0x7a,0xb3,0x2a,0xd6,0x74,0xaa,0x7a,0xb3,0x2b,0x17,0x74,0xaa,
+0x7a,0xb3,0x2b,0x18,0xda,0xf8,0x22,0x6c,0xaa,0x7e,0x71,0x5d,0x7c,0xb7,0x4, 0xf5,
+0x5d,0xbe,0x70,0x32,0x28,0x6, 0x75,0x5d,0x0, 0x75,0x5c,0x0, 0xe5,0x5d,0xbe,0xb0,
+0x32,0x50,0xb, 0x7e,0xb3,0x20,0x14,0xbe,0xb1,0x5b,0x78,0x2, 0x5, 0x5c,0xe5,0x5d,
+0xb4,0x32,0xa, 0xe5,0x5c,0xbe,0xb0,0x1e,0x50,0x3, 0x7e,0xa0,0x1, 0x7e,0xb3,0x20,
+0x14,0xf5,0x5b,0xbe,0xa0,0x1, 0x78,0x4, 0x75,0x51,0x1, 0x22,0x75,0x51,0x0, 0x22,
+0xca,0x79,0xbe,0xb0,0xa, 0x50,0x8, 0xa, 0x2b,0x19,0x72,0x2b,0xb3,0x80,0x35,0xa, 
+0x7b,0x9e,0x74,0x0, 0xa, 0xbe,0x74,0x4, 0x80,0x50,0x29,0xbe,0x74,0x0, 0x4f,0x78,
+0x5, 0x12,0x57,0x70,0x80,0x1e,0xbe,0x74,0x0, 0x10,0x40,0x14,0xbe,0x74,0x0, 0x36,
+0x38,0xe, 0x7c,0xb7,0x7e,0x70,0x87,0x12,0x51,0xc, 0x19,0xb7,0x20,0x4d,0x80,0x4, 
+0x19,0x77,0x20,0x4d,0xda,0x79,0x22,0x7e,0x73,0x20,0x14,0x7a,0x73,0x25,0x4f,0x7e,
+0x24,0x1f,0xce,0x7e,0x34,0x24,0xcd,0x7e,0x14,0x0, 0x46,0x12,0x58,0x16,0x7e,0x34,
+0x24,0xcd,0x12,0x0, 0x66,0x7e,0x37,0x25,0x51,0x12,0x1f,0x4e,0x7e,0x24,0x24,0xcd,
+0x7e,0x34,0x1f,0xce,0x7e,0x14,0x0, 0x46,0x12,0x58,0x16,0x7e,0x73,0x25,0x4f,0x7a,
+0x73,0x25,0x50,0x7e,0x73,0x25,0x4f,0x7a,0x73,0x20,0x14,0x22,0x7c,0xab,0xa5,0xbf,
+0x87,0x15,0xbe,0xa0,0x1c,0x40,0x5, 0x2e,0xa0,0xa, 0x80,0x8, 0xbe,0xa0,0x7, 0x40,
+0x3, 0x2e,0xa0,0x5, 0x7c,0xba,0x22,0xa5,0xbf,0x8a,0x15,0xbe,0xa0,0x16,0x40,0x5, 
+0x2e,0xa0,0xf, 0x80,0x8, 0xbe,0xa0,0x6, 0x40,0x3, 0x2e,0xa0,0x8, 0x7c,0xba,0x22,
+0xbe,0x70,0x88,0x68,0x4, 0xa5,0xbf,0x89,0x3, 0x7c,0xba,0x22,0x74,0xff,0x22,0x7c,
+0xab,0xa5,0xbf,0x87,0x15,0xbe,0xa0,0x26,0x40,0x5, 0x9e,0xa0,0xa, 0x80,0x8, 0xbe,
+0xa0,0xc, 0x40,0x3, 0x9e,0xa0,0x5, 0x7c,0xba,0x22,0xa5,0xbf,0x8a,0x15,0xbe,0xa0,
+0x25,0x40,0x5, 0x9e,0xa0,0xf, 0x80,0x8, 0xbe,0xa0,0xe, 0x40,0x3, 0x9e,0xa0,0x8, 
+0x7c,0xba,0x22,0xbe,0x70,0x88,0x68,0x4, 0xa5,0xbf,0x89,0x3, 0x7c,0xba,0x22,0x74,
+0xff,0x22,0x7e,0x27,0x2b,0xf2,0x4d,0x22,0x78,0x1b,0xe4,0x7a,0xb3,0x2b,0xcf,0x7a,
+0xb3,0x2b,0xd0,0x7a,0xb3,0x2b,0xd1,0x7a,0xb3,0x2b,0xd2,0x7a,0xb3,0x2b,0xd3,0x6d,
+0x11,0x7a,0x17,0x2b,0xf4,0x7e,0x17,0x2b,0xf4,0x4d,0x11,0x78,0x17,0xbe,0x24,0x0, 
+0x1, 0x78,0x11,0x12,0x42,0xc, 0x7e,0x34,0x0, 0x1, 0x7a,0x37,0x2b,0xf4,0x74,0x1, 
+0x7a,0xb3,0x2b,0xd3,0x22,0x7e,0x34,0x4, 0x8f,0x12,0x58,0xf6,0x53,0xdb,0xf0,0x12,
+0x3c,0x8a,0x12,0x39,0x43,0x12,0x3e,0x7c,0x7e,0x34,0x25,0xa3,0x12,0x2c,0xb, 0x12,
+0x59,0x57,0x12,0x58,0xea,0x7e,0x34,0x1, 0x2c,0x7a,0x37,0x21,0x3a,0x12,0x28,0xc1,
+0x12,0x59,0x2c,0x60,0xfb,0x74,0x1, 0x7a,0xb3,0x2c,0x30,0x7e,0xb3,0x2b,0x61,0x54,
+0x8f,0x7a,0xb3,0x2b,0x61,0x22,0x7d,0x23,0x2e,0x24,0x1d,0x40,0x6d,0x11,0x6d,0x55,
+0x7d,0x1, 0x3e,0x4, 0x2d,0x3, 0x1b,0x8, 0x50,0x7d,0x1, 0x5e,0x4, 0x0, 0x7, 0x2e,
+0x4, 0x59,0x48,0x7a,0x11,0x82,0x7a,0x1, 0x83,0x93,0x7c,0xb, 0x7d,0x51,0x1e,0x54,
+0x1e,0x54,0x1e,0x54,0x2d,0x52,0x7e,0x59,0x10,0x4c,0x10,0x7a,0x59,0x10,0xb, 0x14,
+0xbe,0x14,0x6, 0xc0,0x40,0xc8,0x22,0xc2,0xaf,0x75,0xf3,0x0, 0xa, 0x56,0x1e,0x54,
+0x1e,0x54,0x3e,0x54,0x3e,0x54,0xf5,0xf1,0x75,0xf2,0x0, 0x75,0xf9,0x0, 0x75,0xf9,
+0x10,0x75,0xf9,0x50,0x74,0xa, 0x12,0x57,0x89,0x75,0xf9,0x51,0x74,0x32,0x12,0x55,
+0x71,0x75,0xf9,0x11,0x74,0xa, 0x12,0x57,0x89,0x75,0xf9,0x10,0x75,0xf9,0x0, 0x74,
+0x1, 0x12,0x57,0x89,0xd2,0xaf,0x22,0xca,0x7b,0xca,0x6b,0xca,0x5b,0xca,0x4b,0xca,
+0x2b,0xca,0x1b,0xca,0xb, 0xc0,0xd0,0xc0,0x83,0xc0,0x82,0xe5,0xcc,0x54,0x3, 0xb4,
+0x3, 0x6, 0x53,0xcc,0xfc,0x43,0xcc,0x2, 0x12,0x41,0x2b,0x74,0x1, 0x7a,0xb3,0x2b,
+0x5a,0xd0,0x82,0xd0,0x83,0xd0,0xd0,0xda,0xb, 0xda,0x1b,0xda,0x2b,0xda,0x4b,0xda,
+0x5b,0xda,0x6b,0xda,0x7b,0x32,0x7e,0xa3,0x27,0x80,0xbe,0xa0,0x0, 0x38,0x34,0xbe,
+0xa3,0x27,0x7f,0x50,0x19,0x7e,0xb3,0x27,0x86,0xbe,0xb3,0x2c,0x50,0x28,0x14,0x7e,
+0xb3,0x2c,0x50,0x4, 0x7a,0xb3,0x2c,0x50,0x7a,0xa3,0x27,0x7f,0x80,0x5, 0xe4,0x7a,
+0xb3,0x2c,0x50,0x7e,0xb3,0x27,0x7f,0x70,0xa, 0x7e,0xb3,0x27,0x83,0x54,0xfe,0x7a,
+0xb3,0x27,0x83,0x22,0x12,0x56,0x66,0x53,0xdb,0xf0,0x12,0x33,0x1d,0x12,0x3c,0x8a,
+0x12,0x39,0x43,0x74,0x21,0x7a,0xb3,0x1f,0x3d,0x12,0x3e,0x7c,0x7e,0x34,0x25,0xa3,
+0x12,0x2c,0xb, 0x12,0x59,0x57,0x12,0x58,0xea,0x7e,0x34,0x0, 0x8e,0x12,0x52,0x16,
+0x7e,0x34,0x4, 0x8f,0x12,0x58,0xf6,0x7e,0x34,0x1e,0xad,0x7e,0x24,0x0, 0x8e,0x2, 
+0x4c,0xe4,0x6c,0xaa,0x7e,0x14,0x0, 0x1, 0x7e,0x53,0x2b,0xf8,0x80,0x12,0x7e,0x10,
+0x4, 0xac,0x15,0x2d,0x3, 0xb, 0x8, 0x0, 0x4d,0x0, 0x78,0x2, 0xb, 0xa0,0xb, 0x50,
+0x7e,0x43,0x2b,0xf9,0xbc,0x45,0x38,0xe6,0x7e,0xb3,0x2b,0xce,0xa, 0x3b,0x7e,0x24,
+0x0, 0x3, 0x12,0x44,0x73,0xa, 0xa, 0xbd,0x3, 0x8, 0x2, 0x6d,0x11,0x7d,0x31,0x22,
+0xca,0x79,0x7e,0x77,0x2b,0xd7,0x2e,0x77,0x2b,0xd9,0x7e,0x73,0x2c,0x4, 0xa, 0x37,
+0xbe,0x37,0x2b,0xd9,0x50,0x9, 0xe4,0x12,0x45,0x33,0x74,0x1, 0x12,0x45,0x33,0x7e,
+0x37,0x2b,0xf2,0xbe,0x34,0x0, 0x1, 0x78,0x10,0x7e,0x37,0x2b,0xe0,0x1e,0x34,0xbd,
+0x37,0x28,0x6, 0x6d,0x33,0x7a,0x37,0x2b,0xf2,0xda,0x79,0x22,0x12,0x55,0xe1,0x7e,
+0x73,0x20,0x14,0x7a,0x73,0x27,0x7f,0x12,0x54,0x3, 0x12,0x52,0xd6,0x7e,0x73,0x27,
+0x7f,0x7a,0x73,0x20,0x14,0x7e,0x34,0x0, 0x87,0x7a,0x37,0x25,0x51,0x12,0x50,0xc7,
+0x7e,0x34,0x24,0xcd,0x7a,0x37,0x27,0x84,0x7e,0x73,0x20,0x14,0x7a,0x73,0x27,0x7f,
+0x2, 0x8, 0x0, 0x7e,0xb3,0x27,0x7f,0x70,0x22,0x7e,0xa3,0x27,0x80,0xbe,0xa0,0x0, 
+0x28,0x19,0xe5,0x67,0x70,0x11,0x7a,0xa3,0x27,0x7f,0x7e,0xb3,0x27,0x83,0x44,0x8, 
+0x7a,0xb3,0x27,0x83,0x5, 0x67,0x22,0x75,0x67,0x0, 0x22,0x75,0x67,0x0, 0x7e,0xb3,
+0x27,0x83,0x54,0xf7,0x7a,0xb3,0x27,0x83,0x22,0xca,0x7b,0xca,0x6b,0xca,0x5b,0xca,
+0x4b,0xca,0x2b,0xca,0x1b,0xca,0xb, 0xc0,0xd0,0xc0,0x83,0xc0,0x82,0x12,0x59,0x22,
+0x7e,0xb3,0x2b,0x61,0x54,0xfd,0x7a,0xb3,0x2b,0x61,0xd0,0x82,0xd0,0x83,0xd0,0xd0,
+0xda,0xb, 0xda,0x1b,0xda,0x2b,0xda,0x4b,0xda,0x5b,0xda,0x6b,0xda,0x7b,0x32,0x74,
+0x3c,0x7a,0xb3,0x27,0x88,0x74,0x6, 0x7a,0xb3,0x27,0x8b,0x7e,0x34,0x0, 0x99,0x7a,
+0x37,0x27,0x89,0x7e,0x34,0x0, 0x96,0x7a,0x37,0x27,0x8c,0x74,0x5, 0x7a,0xb3,0x27,
+0x8e,0xe4,0x7a,0xb3,0x27,0x91,0x6d,0x33,0x7a,0x37,0x27,0x8f,0x22,0x7c,0xab,0xc2,
+0xaf,0xa, 0x26,0x7c,0xb5,0xf5,0xf1,0x7c,0xb7,0xf5,0xf2,0x75,0xf3,0x80,0x75,0xf4,
+0x0, 0x75,0xf5,0x0, 0x7a,0xa1,0xf6,0xa9,0x37,0xf5,0xfc,0xa9,0x36,0xf5,0xfc,0x74,
+0xa, 0x12,0x57,0x89,0x43,0xfa,0x80,0xd2,0xaf,0x22,0xca,0x69,0xca,0xf8,0x7c,0xfb,
+0x7d,0x63,0x74,0x1, 0x12,0x57,0x56,0xe5,0x9, 0xb4,0x1, 0x10,0xe5,0x68,0xb4,0x1, 
+0xb, 0x7d,0x36,0x2e,0x34,0x78,0x0, 0x7c,0xbf,0x12,0x54,0x9d,0xe4,0x12,0x57,0x56,
+0xda,0xf8,0xda,0x69,0x22,0xbe,0xb0,0x3f,0x38,0x24,0xbe,0xb0,0x26,0x68,0x1f,0xbe,
+0xb0,0x28,0x68,0x1a,0xbe,0xb0,0x23,0x68,0x15,0xbe,0xb0,0x2f,0x68,0x10,0xa, 0x2b,
+0x19,0x72,0x2c,0x9, 0x7e,0xb3,0x2c,0x49,0x44,0x1, 0x7a,0xb3,0x2c,0x49,0x22,0x53,
+0xd7,0x3, 0x53,0xdb,0xf3,0xf5,0xd6,0xe5,0xdb,0x30,0xe3,0xfb,0xe5,0xd6,0xf5,0x1c,
+0x53,0xdb,0xf3,0x7a,0x71,0xd6,0xe5,0xdb,0x30,0xe3,0xfb,0xe5,0xd6,0xf5,0x1d,0x53,
+0xdb,0xf3,0x43,0xd7,0x4, 0x7e,0x35,0x1c,0x22,0xc2,0xaf,0xa, 0x56,0xf5,0xf1,0x7c,
+0xb7,0xf5,0xf2,0x75,0xf3,0x80,0x75,0xf4,0x0, 0x75,0xf5,0x1, 0xa9,0x37,0xf5,0xfc,
+0xa9,0x36,0xf5,0xfc,0x74,0x2, 0x12,0x57,0x89,0xe5,0xf6,0x43,0xfa,0x80,0xd2,0xaf,
+0x22,0x7c,0x6b,0x80,0x19,0x74,0xfa,0x12,0x57,0x89,0x74,0xfa,0x12,0x57,0x89,0x74,
+0xfa,0x12,0x57,0x89,0x74,0xfa,0x12,0x57,0x89,0x74,0xfa,0x12,0x57,0x89,0x7c,0x76,
+0x1b,0x60,0xa5,0xbf,0x0, 0xdf,0x22,0xbe,0x34,0x0, 0x7, 0x40,0x6, 0x9e,0x34,0x0, 
+0x7, 0x80,0x2, 0x6d,0x33,0x7e,0x24,0x0, 0x87,0xad,0x32,0x7c,0x76,0x7c,0x65,0xa, 
+0x24,0xbe,0x18,0x3, 0x20,0x40,0x4, 0x7e,0x18,0x3, 0x1f,0x22,0xbe,0x34,0x0, 0x7, 
+0x40,0x6, 0x9e,0x34,0x0, 0x7, 0x80,0x2, 0x6d,0x33,0x7e,0x24,0x0, 0x88,0xad,0x32,
+0x7c,0x76,0x7c,0x65,0xa, 0x24,0xbe,0x18,0x5, 0x0, 0x40,0x4, 0x7e,0x18,0x4, 0xff,
+0x22,0x6c,0xaa,0x80,0x16,0x7e,0x30,0x7, 0xac,0x3a,0x49,0x31,0x1f,0xce,0x49,0x21,
+0x1f,0xd0,0x2e,0x14,0x1f,0xce,0x12,0x4a,0x56,0xb, 0xa0,0x7e,0xb3,0x20,0x14,0xbc,
+0xba,0x38,0xe2,0x22,0xa9,0xc6,0xdb,0x74,0x1, 0x12,0x56,0x46,0xa9,0xc7,0xeb,0xa9,
+0xd7,0xac,0xa9,0xd7,0xec,0xd2,0x87,0x75,0x9a,0xd0,0xa9,0xd1,0x99,0xd2,0x9c,0xa9,
+0xd6,0xdf,0xd2,0xaf,0x22,0x53,0xd7,0x3, 0x53,0xdb,0xf3,0x44,0x40,0xf5,0xd6,0xe5,
+0xdb,0x30,0xe3,0xfb,0x53,0xdb,0xf3,0x7a,0x71,0xd6,0xe5,0xdb,0x30,0xe3,0xfb,0x53,
+0xdb,0xf3,0x43,0xd7,0x4, 0x22,0xd2,0xcf,0x53,0xcc,0xfc,0x1b,0xb1,0x68,0xc, 0x14,
+0x68,0xe, 0xb, 0xb1,0x78,0xd, 0x43,0xcc,0x2, 0x80,0x8, 0x43,0xcc,0x3, 0x80,0x3, 
+0x43,0xcc,0x1, 0xc2,0xca,0x22,0x6c,0x77,0x6d,0x22,0x80,0xe, 0xb, 0x70,0xa5,0xbf,
+0xff,0x2, 0xb, 0x24,0xbe,0x24,0x3, 0xe8,0x68,0x3, 0x30,0x1, 0xef,0x53,0xdb,0xfe,
+0x53,0xdb,0xfd,0xc2,0xeb,0x22,0x53,0xd7,0x3, 0x53,0xdb,0xf3,0x44,0x80,0xf5,0xd6,
+0xe5,0xdb,0x30,0xe3,0xfb,0x53,0xdb,0xf3,0x75,0xd6,0x0, 0xe5,0xdb,0x30,0xe3,0xfb,
+0xe5,0xd6,0x43,0xd7,0x4, 0x22,0xca,0x79,0x7d,0x73,0x74,0x1, 0x12,0x57,0x56,0xe5,
+0x9, 0xb4,0x1, 0xa, 0xe5,0x68,0xb4,0x1, 0x5, 0x7d,0x37,0x12,0x52,0x57,0xe4,0x12,
+0x57,0x56,0xda,0x79,0x22,0xbe,0xb0,0x3, 0x28,0x9, 0xbe,0xb0,0x20,0x50,0x4, 0x7c,
+0xab,0x80,0x2, 0x6c,0xaa,0xe5,0xdc,0x54,0xe0,0xa, 0x2b,0xa, 0x3a,0x2d,0x32,0x7c,
+0xb7,0xf5,0xdc,0x22,0x1, 0x18,0x0, 0xf, 0x0, 0xb4,0x0, 0xdc,0x0, 0xc, 0x0, 0x78,
+0x0, 0xa0,0x0, 0x7, 0x0, 0x32,0x0, 0x78,0x0, 0x5, 0x0, 0xf, 0x0, 0x3c,0x0, 0x3, 
+0x0, 0x0, 0x7e,0x27,0x2b,0xc5,0xbe,0x24,0x0, 0x2, 0x78,0x2, 0x80,0xc, 0x9, 0xb3,
+0x0, 0x96,0x70,0x6, 0x7e,0x34,0x0, 0x1, 0x80,0x2, 0x6d,0x33,0x7a,0x35,0x54,0x22,
+0x74,0x1, 0x12,0x57,0x56,0x7e,0x34,0x6f,0xf8,0x74,0x66,0x12,0x54,0x9d,0x7e,0x34,
+0x6f,0xf9,0x74,0xbb,0x12,0x54,0x9d,0xe4,0x2, 0x57,0x56,0x7c,0xa7,0xa, 0x3b,0x3e,
+0x34,0x3e,0x34,0x3e,0x34,0x3e,0x34,0x3e,0x34,0x3e,0x34,0x3e,0x34,0x2e,0x34,0xc0,
+0x0, 0xa, 0x2a,0x2d,0x32,0x22,0x75,0xfd,0xd, 0xb4,0x1, 0xa, 0x75,0xfe,0x84,0x75,
+0xfd,0xf, 0x75,0xfe,0x28,0x22,0x75,0xfe,0x0, 0x75,0xfd,0xf, 0x75,0xfe,0x0, 0x22,
+0x7e,0xb3,0x2b,0xc3,0x60,0x8, 0x74,0x1, 0x12,0x59,0x40,0xe4,0x80,0x6, 0xe4,0x12,
+0x59,0x40,0x74,0x1, 0x7a,0xb3,0x2b,0xc3,0x22,0x7c,0xab,0x80,0xc, 0x0, 0x0, 0x0, 
+0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7c,0x7a,0x1b,0xa0,0xa5,0xbf,0x0, 
+0xec,0x22,0x74,0x2, 0x7a,0xb3,0x1e,0xa8,0x74,0xa, 0x7a,0xb3,0x1e,0xac,0x6d,0x33,
+0x7a,0x35,0x52,0x7a,0x35,0x54,0x7a,0x35,0x56,0x22,0xa, 0x37,0x3e,0x34,0x3e,0x34,
+0x3e,0x34,0x3e,0x34,0x3e,0x34,0x3e,0x34,0x2e,0x34,0xc0,0x0, 0xa, 0x2b,0x2d,0x32,
+0x22,0x53,0xcb,0xe0,0x43,0xcb,0x6, 0x53,0xca,0xf0,0xa, 0x3b,0x3e,0x34,0xb, 0x34,
+0x7c,0xb7,0x42,0xca,0x75,0xea,0x7, 0x22,0x43,0xdb,0x10,0xd2,0xd9,0xc2,0xdd,0xc2,
+0xdc,0xc2,0xdb,0xc2,0xda,0xd2,0xd8,0x75,0xd7,0x6, 0xc2,0xea,0x2, 0x58,0xb4,0x7c,
+0x67,0x7c,0xab,0x12,0x56,0x25,0x7c,0xba,0x12,0x56,0x86,0x7c,0x7b,0xbc,0x67,0x78,
+0x3, 0x74,0x1, 0x22,0xe4,0x22,0x7d,0x3, 0x80,0xa, 0x7e,0x29,0xb0,0x7a,0x9, 0xb0,
+0xb, 0x24,0xb, 0x4, 0x7d,0x51,0x1b,0x14,0x4d,0x55,0x78,0xee,0x22,0x7c,0xa6,0x7c,
+0x57,0xa, 0x3b,0xa, 0x25,0x12,0x58,0x75,0xa, 0x2a,0xbd,0x32,0x38,0x3, 0x74,0x1, 
+0x22,0xe4,0x22,0x70,0x3, 0x43,0x87,0x1, 0xb4,0x1, 0x3, 0x43,0x87,0x2, 0xb4,0x2, 
+0x3, 0x43,0x87,0x2, 0x22,0xca,0xb8,0xc2,0x92,0xe4,0x7a,0xb3,0x2b,0x59,0x7a,0xb3,
+0x2b,0x5b,0xda,0xb8,0x32,0xc2,0x8e,0x43,0x89,0x10,0x75,0x8d,0xf0,0x75,0x8b,0x5f,
+0xd2,0x8e,0xd2,0xab,0x22,0x7d,0x13,0xbd,0x21,0x50,0x5, 0x7d,0x31,0x9d,0x32,0x22,
+0x7d,0x32,0x9d,0x31,0x22,0x7d,0x23,0xbe,0x24,0x0, 0x0, 0x48,0x3, 0x7d,0x32,0x22,
+0x6d,0x33,0x9d,0x32,0x22,0x7d,0x13,0x80,0x7, 0x1b,0x24,0x7a,0x19,0xb0,0xb, 0x14,
+0x4d,0x22,0x78,0xf5,0x22,0x75,0x92,0x70,0xd2,0xad,0xd2,0xe8,0xc2,0xc0,0xa9,0xd5,
+0xb7,0xc2,0xbd,0x22,0xc2,0x1, 0x53,0xdb,0xfd,0xd2,0xeb,0xc2,0xc3,0xa9,0xd3,0xf7,
+0xd2,0xfb,0x22,0xe4,0x7e,0x70,0x3, 0x12,0x57,0xff,0x60,0x3, 0x74,0x1, 0x22,0xe4,
+0x22,0xe4,0x6c,0x77,0x12,0x57,0xff,0x60,0x3, 0x74,0x1, 0x22,0xe4,0x22,0x6d,0x33,
+0x7a,0x37,0x2b,0xbd,0xe4,0x7a,0xb3,0x2b,0x66,0x22,0x53,0xdb,0xfd,0xd2,0xeb,0x43,
+0xdb,0x1, 0x43,0xdb,0x20,0x22,0x6d,0x22,0x7a,0x27,0x1f,0x7c,0x7a,0x37,0x0, 0x80,
+0x22,0xe4,0x7a,0xb3,0x2b,0x61,0x12,0x59,0x71,0x2, 0x4f,0xda,0xc2,0x8e,0x75,0x8d,
+0xf0,0x75,0x8b,0x5f,0xd2,0x8e,0x22,0xd2,0x1, 0xa9,0xc1,0xdb,0xc2,0xc3,0x53,0xdb,
+0xbf,0x32,0xe5,0x9a,0x60,0x5, 0xd2,0x9c,0xa9,0xd6,0xdf,0x22,0x30,0x1, 0x5, 0xc2,
+0x1, 0x74,0x1, 0x22,0xe4,0x22,0x70,0x4, 0x53,0xdb,0xbf,0x22,0x43,0xdb,0x40,0x22,
+0x70,0x3, 0xd2,0x87,0x22,0xc2,0x87,0x22,0x1, 0x2, 0x4, 0x8, 0x10,0x20,0x40,0x80,
+0x2e,0x34,0x78,0x0, 0x2, 0x55,0x49,0x75,0xd9,0x2, 0x75,0xda,0x7d,0x22,0xa9,0xd0,
+0x99,0xa9,0xc6,0xdf,0x22,0x12,0x56,0x4, 0x2, 0x0, 0x18,0xf5,0xd9,0x7a,0x71,0xda,
+0x22,0x2, 0x58,0xa5,0xc2,0xec,0x32,0x2, 0x57,0xe8,0x0, 0x1, 0x2b,0xc3,0x1, 0x0, 
+0x1, 0x1f,0x63,0x0, 0x0, 0x2, 0x28,0x5a,0x0, 0x0, 0x0, 0x1, 0x2b,0x59,0x0, 0x0, 
+0x1, 0x2b,0x5b,0x0, 0x0, 0x1, 0x2b,0x5e,0x0, 0x0, 0x2, 0x2b,0x5f,0x0, 0x0, 0x0, 
+0x1, 0x2b,0x62,0x0, 0x0, 0x1, 0x2b,0x65,0x0, 0x0, 0x1, 0x29,0x10,0x0, 0x0, 0x2, 
+0x2c,0x4c,0x0, 0x0, 0x0, 0x1, 0x2b,0xc4,0x0, 0x0, 0x2, 0x2c,0x7, 0x0, 0x0, 0x0, 
+0x0, 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x6f,0xe8,0x90,0x17,0x75,0x8a,
+0x18,0x5c,
diff --git a/drivers/media/video/sunxi-vfe/config.c b/drivers/media/video/sunxi-vfe/config.c
index f10250f..0ec2cd1 100755
--- a/drivers/media/video/sunxi-vfe/config.c
+++ b/drivers/media/video/sunxi-vfe/config.c
@@ -262,7 +262,7 @@ int fetch_config(struct vfe_dev *dev)
     type = script_get_item(vfe_para, dev_para, &val);
     if (SCIRPT_ITEM_VALUE_TYPE_PIO != type) {
       dev->ccm_cfg[i]->gpio.power_en_io.gpio = GPIO_INDEX_INVALID;
-      vfe_dbg(0,"fetch vip_dev%d_power_en from sys_config failed\n", i);
+     // vfe_dbg(0,"fetch vip_dev%d_power_en from sys_config failed\n", i);    //potter del
     } else {
       dev->ccm_cfg[i]->gpio.power_en_io.gpio=val.gpio.gpio;
       dev->ccm_cfg[i]->gpio.power_en_io.mul_sel=val.gpio.mul_sel;
@@ -272,7 +272,7 @@ int fetch_config(struct vfe_dev *dev)
     if (SCIRPT_ITEM_VALUE_TYPE_PIO != type) {
       dev->ccm_cfg[i]->gpio.flash_en_io.gpio = GPIO_INDEX_INVALID;
       dev->ccm_cfg[i]->flash_used=0;
-      vfe_dbg(0,"fetch vip_dev%d_flash_en from sys_config failed\n", i);
+     // vfe_dbg(0,"fetch vip_dev%d_flash_en from sys_config failed\n", i);   //potter del
     } else {
       dev->ccm_cfg[i]->gpio.flash_en_io.gpio=val.gpio.gpio;
       dev->ccm_cfg[i]->gpio.flash_en_io.mul_sel=val.gpio.mul_sel;
@@ -283,7 +283,7 @@ int fetch_config(struct vfe_dev *dev)
     type = script_get_item(vfe_para, dev_para, &val);
     if (SCIRPT_ITEM_VALUE_TYPE_PIO != type) {
       dev->ccm_cfg[i]->gpio.flash_mode_io.gpio = GPIO_INDEX_INVALID;
-      vfe_dbg(0,"fetch vip_dev%d_flash_mode from sys_config failed\n", i); 
+     // vfe_dbg(0,"fetch vip_dev%d_flash_mode from sys_config failed\n", i);     //potter del
     } else {
       dev->ccm_cfg[i]->gpio.flash_mode_io.gpio=val.gpio.gpio;
       dev->ccm_cfg[i]->gpio.flash_mode_io.mul_sel=val.gpio.mul_sel;
@@ -294,7 +294,7 @@ int fetch_config(struct vfe_dev *dev)
     if (SCIRPT_ITEM_VALUE_TYPE_PIO != type) {
       dev->ccm_cfg[i]->gpio.af_pwdn_io.gpio = GPIO_INDEX_INVALID;
 
-      vfe_dbg(0,"fetch vip_dev%d_af_pwdn from sys_config failed\n", i);
+     // vfe_dbg(0,"fetch vip_dev%d_af_pwdn from sys_config failed\n", i);   //potter del
     } else {
       dev->ccm_cfg[i]->gpio.af_pwdn_io.gpio=val.gpio.gpio;
       dev->ccm_cfg[i]->gpio.af_pwdn_io.mul_sel=val.gpio.mul_sel;
@@ -305,7 +305,7 @@ int fetch_config(struct vfe_dev *dev)
 	  type = script_get_item(vfe_para, dev_para, &val);
 	  if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
 		dev->ccm_cfg[i]->act_used= 0;
-		vfe_dbg(0,"fetch vip_dev%d_act_used from sys_config failed\n", i);
+	//	vfe_dbg(0,"fetch vip_dev%d_act_used from sys_config failed\n", i);   //potter del
 	  } else {
 		dev->ccm_cfg[i]->act_used=val.val;
 	  }
@@ -318,7 +318,7 @@ int fetch_config(struct vfe_dev *dev)
   	    if (SCIRPT_ITEM_VALUE_TYPE_STR != type) {
   	      char null_str[]="";
   	      strcpy(dev->ccm_cfg[i]->act_name,null_str);
-  	      vfe_dbg(0,"fetch vip_dev%d_act_name from sys_config failed\n", i);
+  	 //     vfe_dbg(0,"fetch vip_dev%d_act_name from sys_config failed\n", i);   //potter del
   	    } else {
   	      strcpy(dev->ccm_cfg[i]->act_name,val.str);
   	    }
@@ -328,7 +328,7 @@ int fetch_config(struct vfe_dev *dev)
   		if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
   		  dev->ccm_cfg[i]->act_slave= 0;
   		
-  		  vfe_dbg(0,"fetch vip_dev%d_act_slave from sys_config failed\n", i);
+  	//	  vfe_dbg(0,"fetch vip_dev%d_act_slave from sys_config failed\n", i);   //potter del
   		} else {
   		  dev->ccm_cfg[i]->act_slave=val.val;
   		}
diff --git a/drivers/media/video/sunxi-vfe/device/Makefile b/drivers/media/video/sunxi-vfe/device/Makefile
index 913f352..72d7ea6 100755
--- a/drivers/media/video/sunxi-vfe/device/Makefile
+++ b/drivers/media/video/sunxi-vfe/device/Makefile
@@ -1,22 +1,22 @@
 obj-$(CONFIG_CSI_VFE)           += cci.o
 
-obj-m			+= ov5640.o
-obj-m			+= s5k4ec.o
+#obj-m			+= ov5640.o
+#obj-m			+= s5k4ec.o
 obj-m			+= s5k4ec_mipi.o
-obj-m			+= gc2035.o
-obj-m			+= gt2005.o
-obj-m			+= gc0307.o
-obj-m			+= gc0308.o
-obj-m			+= gc0329.o
+#obj-m			+= gc2035.o
+#obj-m			+= gt2005.o
+#obj-m			+= gc0307.o
+#obj-m			+= gc0308.o
+#obj-m			+= gc0329.o
 obj-m			+= hi253.o
 
-obj-m			+= ov5650.o
-obj-m			+= ov5647.o
-obj-m			+= t8et5.o
-obj-m			+= s5k4e1.o
-obj-m			+= s5k4e1_mipi.o
-obj-m			+= sp2518.o
-obj-m			+= sp0718.o
+#obj-m			+= ov5650.o
+#obj-m			+= ov5647.o
+#obj-m			+= t8et5.o
+#obj-m			+= s5k4e1.o
+#obj-m			+= s5k4e1_mipi.o
+#obj-m			+= sp2518.o
+#obj-m			+= sp0718.o
 
 
 
diff --git a/drivers/media/video/sunxi-vfe/device/hi253.c b/drivers/media/video/sunxi-vfe/device/hi253.c
index a58a527..afaf91d 100755
--- a/drivers/media/video/sunxi-vfe/device/hi253.c
+++ b/drivers/media/video/sunxi-vfe/device/hi253.c
@@ -25,7 +25,7 @@ MODULE_LICENSE("GPL");
 
 
 //for internel driver debug
-#define DEV_DBG_EN   		0 
+#define DEV_DBG_EN   		1
 #if(DEV_DBG_EN == 1)		
 #define vfe_dev_dbg(x,arg...) printk("[CSI_DEBUG][HI253]"x,##arg)
 #else
@@ -44,7 +44,7 @@ MODULE_LICENSE("GPL");
                         }
 
 //define module timing
-#define MCLK (27*1000*1000)
+#define MCLK (24*1000*1000)
 #define VREF_POL          V4L2_MBUS_VSYNC_ACTIVE_LOW
 #define HREF_POL          V4L2_MBUS_HSYNC_ACTIVE_HIGH
 #define CLK_POL           V4L2_MBUS_PCLK_SAMPLE_FALLING
@@ -81,6 +81,11 @@ MODULE_LICENSE("GPL");
 
 /* Registers */
 
+/*
+if hi253_firsttime ==0 ,sensor will init sensor_default_regs;
+otherwise it just standy off.
+*/
+static int hi253_firsttime = 0;          //potter add 
 
 /*
  * Information we maintain about a known sensor.
@@ -154,7 +159,7 @@ static struct regval_list sensor_default_regs[] = {
 	{0x03,0x00},
 	{0x10,0x11}, // Sub1/2_Preview2 Mode_H binning
 	{0x11,0x90},
-	{0x12,0x04},
+	{0x12,0x00},
 	
 	{0x0b,0xaa}, // ESD Check Register
 	{0x0c,0xaa}, // ESD Check Register
@@ -170,10 +175,10 @@ static struct regval_list sensor_default_regs[] = {
 	{0x26,0x06},
 	{0x27,0x40}, // WINROW END
 	
-	{0x40,0x01}, //Hblank 408
-	{0x41,0x98}, 
+	{0x40,0x00}, //Hblank 408
+	{0x41,0xe8}, 
 	{0x42,0x00}, //Vblank 20
-	{0x43,0x47},
+	{0x43,0x14},
 	
 	{0x45,0x04},
 	{0x46,0x18},
@@ -197,16 +202,16 @@ static struct regval_list sensor_default_regs[] = {
 	{0x98,0x38},
 	
 	//OutDoor  BLC
-	{0x99,0x43},
-	{0x9a,0x43},
-	{0x9b,0x43},
-	{0x9c,0x43},
+	{0x99,0x42},
+	{0x9a,0x42},
+	{0x9b,0x42},
+	{0x9c,0x42},
 	
 	//Dark BLC
-	{0xa0,0x48},
-	{0xa2,0x48},
-	{0xa4,0x48},
-	{0xa6,0x48},
+	{0xa0,0x00},
+	{0xa2,0x00},
+	{0xa4,0x00},
+	{0xa6,0x00},
 	
 	//Normal BLC
 	{0xa8,0x43},
@@ -384,856 +389,760 @@ static struct regval_list sensor_default_regs[] = {
 	{0x03,0x03},
 	{0x10,0x10},
 	
-	/////// PAGE 10 START ///////
-	{0x03,0x10},
-	{0x10,0x01}, // CrYCbY // For Demoset {0x03
-	{0x12,0x30},
-	{0x13,0x0a}, // contrast on
-	{0x20,0x00},
-	
-	{0x30,0x00},
-	{0x31,0x00},
-	{0x32,0x00},
-	{0x33,0x00},
-	
-	{0x34,0x30},
-	{0x35,0x00},
-	{0x36,0x00},
-	{0x38,0x00},
-	{0x3e,0x58},
-	{0x3f,0x00},
-	
-	{0x40,0x80}, // YOFS
-	{0x41,0x00}, // DYOFS
-	{0x48,0x80}, // Contrast
-	
-	{0x60,0x67},
-	{0x61,0x7c}, //7e //8e //88 //80
-	{0x62,0x7c}, //7e //8e //88 //80
-	{0x63,0x50}, //Double_AG 50->30
-	{0x64,0x41},
-	
-	{0x66,0x42},
-	{0x67,0x20},
-	
-	{0x6a,0x80}, //8a
-	{0x6b,0x84}, //74
-	{0x6c,0x80}, //7e //7a
-	{0x6d,0x80}, //8e
-	
-	//Don't touch//////////////////////////
-	//{0x72,0x84},
-	//{0x76,0x19},
-	//{0x73,0x70},
-	//{0x74,0x68},
-	//{0x75,0x60}, // white protection ON
-	//{0x77,0x0e}, //08 //0a
-	//{0x78,0x2a}, //20
-	//{0x79,0x08},
-	////////////////////////////////////////
-	
-	/////// PAGE 11 START ///////
-	{0x03,0x11},
-	{0x10,0x7f},
-	{0x11,0x40},
-	{0x12,0x0a}, // Blue Max-Filter Delete
-	{0x13,0xbb},
-	
-	{0x26,0x31}, // Double_AG 31->20
-	{0x27,0x34}, // Double_AG 34->22
-	{0x28,0x0f},
-	{0x29,0x10},
-	{0x2b,0x30},
-	{0x2c,0x32},
-	
+	{0x03, 0x10},
+	{0x10, 0x01}, //lxh
+    {0x11, 0x03}, //lxh,normal	
+	{0x12, 0x30},
+	{0x13, 0x02},
+	{0x20, 0x00}, 
+
+	{0x40, 0x88},
+	{0x41, 0x00},
+	{0x48, 0x88},// 84
+	{0x50, 0x90},
+	{0x30, 0x00},
+	{0x31, 0x00},
+	{0x32, 0x00},
+	{0x33, 0x00},
+
+	{0x34, 0x30},
+	{0x35, 0x00},
+	{0x36, 0x00},
+	{0x38, 0x00},
+	{0x3e, 0x58},
+	{0x3f, 0x00},
+
+	//Saturation
+	{0x60, 0x67},
+	{0x61, 0x80},// 74
+	{0x62, 0x78},// 76
+	{0x63, 0x50},
+	{0x64, 0x41},
+
+	{0x66, 0x33},
+	{0x67, 0x00},
+
+	{0x6a, 0x90}, 
+	{0x6b, 0x80}, 
+	{0x6c, 0x80}, 
+	{0x6d, 0xa0}, 
+
+	{0x76, 0x01}, 
+	{0x74, 0x66},
+	{0x79, 0x06},
+	
+	//Page 11
+	{0x03, 0x11}, 
+	{0x10, 0x7f},//lxh,3f 
+	{0x11, 0x40},
+	{0x12, 0xba},
+	{0x13, 0xcb},
+	{0x26, 0x20}, 
+	{0x27, 0x22}, 
+	{0x28, 0x0f}, 
+	{0x29, 0x10}, 
+	{0x2b, 0x30}, 
+	{0x2c, 0x32}, 
+
 	//Out2 D-LPF th
-	{0x30,0x70},
-	{0x31,0x10},
-	{0x32,0x58},
-	{0x33,0x09},
-	{0x34,0x06},
-	{0x35,0x03},
-	
+	{0x30, 0x70}, 
+	{0x31, 0x10}, 
+	{0x32, 0x65}, 
+	{0x33, 0x09}, 
+	{0x34, 0x06}, 
+	{0x35, 0x04}, 
+
 	//Out1 D-LPF th
-	{0x36,0x70},
-	{0x37,0x18},
-	{0x38,0x58},
-	{0x39,0x09},
-	{0x3a,0x06},
-	{0x3b,0x03},
-	
+	{0x36, 0x70}, 
+	{0x37, 0x18}, 
+	{0x38, 0x65}, 
+	{0x39, 0x09}, 
+	{0x3a, 0x06}, 
+	{0x3b, 0x04}, 
+
 	//Indoor D-LPF th
-	{0x3c,0x80},
-	{0x3d,0x18},
-	{0x3e,0xa0}, //80
-	{0x3f,0x0c},
-	{0x40,0x09},
-	{0x41,0x06},
-	
-	{0x42,0x80},
-	{0x43,0x18},
-	{0x44,0xa0}, //80
-	{0x45,0x12},
-	{0x46,0x10},
-	{0x47,0x10},
-	
-	{0x48,0x90},
-	{0x49,0x40},
-	{0x4a,0x80},
-	{0x4b,0x13},
-	{0x4c,0x10},
-	{0x4d,0x11},
-	
-	{0x4e,0x80},
-	{0x4f,0x30},
-	{0x50,0x80},
-	{0x51,0x13},
-	{0x52,0x10},
-	{0x53,0x13},
-	
-	{0x54,0x11},
-	{0x55,0x17},
-	{0x56,0x20},
-	{0x57,0x01},
-	{0x58,0x00},
-	{0x59,0x00},
-	
-	{0x5a,0x1f}, //18
-	{0x5b,0x00},
-	{0x5c,0x00},
-	
-	{0x60,0x3f},
-	{0x62,0x60},
-	{0x70,0x06},
-	
-	/////// PAGE 12 START ///////
-	{0x03,0x12},
-	{0x20,0x0f},
-	{0x21,0x0f},
-	
-	{0x25,0x00}, //{0x30
-	
-	{0x28,0x00},
-	{0x29,0x00},
-	{0x2a,0x00},
-	
-	{0x30,0x50},
-	{0x31,0x18},
-	{0x32,0x32},
-	{0x33,0x40},
-	{0x34,0x50},
-	{0x35,0x70},
-	{0x36,0xa0},
-	
-	{0x3b,0x06},
-	{0x3c,0x06},
-	
-	
+	{0x3c, 0x80}, 
+	{0x3d, 0x18}, 
+	{0x3e, 0x80}, 
+	{0x3f, 0x0c}, 
+	{0x40, 0x09}, 
+	{0x41, 0x06}, 
+
+	{0x42, 0x80}, 
+	{0x43, 0x18}, 
+	{0x44, 0x80}, 
+	{0x45, 0x12}, 
+	{0x46, 0x10}, 
+	{0x47, 0x10}, 
+	{0x48, 0x90}, 
+	{0x49, 0x40}, 
+	{0x4a, 0x80}, 
+	{0x4b, 0x13}, 
+	{0x4c, 0x10}, 
+	{0x4d, 0x11}, 
+	{0x4e, 0x80}, 
+	{0x4f, 0x30}, 
+	{0x50, 0x80}, 
+	{0x51, 0x13}, 
+	{0x52, 0x10}, 
+	{0x53, 0x13}, 
+	{0x54, 0x11},
+	{0x55, 0x17},
+	{0x56, 0x20},
+	{0x57, 0x20},
+	{0x58, 0x20},
+	{0x59, 0x30},
+	{0x5a, 0x18},
+	{0x5b, 0x00},
+	{0x5c, 0x00},
+	{0x60, 0x3f},
+	{0x62, 0x50},
+	{0x70, 0x06},
+	
+	//Page 12
+	{0x03, 0x12}, 
+	{0x20, 0x0f},
+	{0x21, 0x0f},
+	{0x25, 0x30},
+	{0x28, 0x00}, 
+	{0x29, 0x00}, 
+	{0x2a, 0x00},
+	{0x30, 0x50},
+	{0x31, 0x18}, 
+	{0x32, 0x32}, 
+	{0x33, 0x40}, 
+	{0x34, 0x50}, 
+	{0x35, 0x70}, 
+	{0x36, 0xa0}, 
+
 	//Out2 th
-	{0x40,0xa0},
-	{0x41,0x40},
-	{0x42,0xa0},
-	{0x43,0x90},
-	{0x44,0x90},
-	{0x45,0x80},
-	
+	{0x40, 0xa0}, 
+	{0x41, 0x40}, 
+	{0x42, 0xa0}, 
+	{0x43, 0x90}, 
+	{0x44, 0x90}, 
+	{0x45, 0x80}, 
+
 	//Out1 th
-	{0x46,0xb0},
-	{0x47,0x55},
-	{0x48,0xa0},
-	{0x49,0x90},
-	{0x4a,0x90},
-	{0x4b,0x80},
-	
-	//Indoor th
-	{0x4c,0xb0},
-	{0x4d,0x40},
-	{0x4e,0x90},
-	{0x4f,0x90},
-	{0x50,0xa0},
-	{0x51,0x80},
-	
+	{0x46, 0xb0}, 
+	{0x47, 0x55}, 
+	{0x48, 0xa0}, 
+	{0x49, 0x90}, 
+	{0x4a, 0x90}, 
+	{0x4b, 0x80}, 
+
+	//In door th
+	{0x4c, 0xb0},
+	{0x4d, 0x40},
+	{0x4e, 0x90},
+	{0x4f, 0x90},
+	{0x50, 0xe6},
+	{0x51, 0x80},
+
 	//Dark1 th
-	{0x52,0xb0},
-	{0x53,0x60},
-	{0x54,0xc0},
-	{0x55,0xc0},
-	{0x56,0xc0},
-	{0x57,0x80},
-	
+	{0x52, 0xb0},
+	{0x53, 0x60},
+	{0x54, 0xc0},
+	{0x55, 0xc0},
+	{0x56, 0xc0},
+	{0x57, 0x80},
+
 	//Dark2 th
-	{0x58,0x90},
-	{0x59,0x40},
-	{0x5a,0xd0},
-	{0x5b,0xd0},
-	{0x5c,0xe0},
-	{0x5d,0x80},
-	
+	{0x58, 0x90},
+	{0x59, 0x40},
+	{0x5a, 0xd0},
+	{0x5b, 0xd0},
+	{0x5c, 0xe0},
+	{0x5d, 0x80},
+
 	//Dark3 th
-	{0x5e,0x88},
-	{0x5f,0x40},
-	{0x60,0xe0},
-	{0x61,0xe0},
-	{0x62,0xe0},
-	{0x63,0xe0},
-	
-	{0x70,0x15},
-	{0x71,0x01}, //Don't Touch register
-	
-	{0x72,0x18},
-	{0x73,0x01}, //Don't Touch register
-	
-	{0x74,0x25},
-	{0x75,0x15},
-	
-	
-	{0x90,0x5d}, //DPC
-	{0x91,0x88},		
-	{0x98,0x7d},		
-	{0x99,0x28},		
-	{0x9A,0x14},		
-	{0x9B,0xc8},		
-	{0x9C,0x02},		
-	{0x9D,0x1e},		
-	{0x9E,0x28},		
-	{0x9F,0x07},		
-	{0xA0,0x32},		
-	{0xA4,0x04},		
-	{0xA5,0x0e},		
-	{0xA6,0x0c},		
-	{0xA7,0x04},		
-	{0xA8,0x3c},		
-	
-	{0xAA,0x14},		
-	{0xAB,0x11},		
-	{0xAC,0x0f},		
-	{0xAD,0x16},		
-	{0xAE,0x15},		
-	{0xAF,0x14},		
-	
-	{0xB1,0xaa},		
-	{0xB2,0x96},		
-	{0xB3,0x28},		
-	//{0xB6},read}, only//dpc_flat_thres
-	//{0xB7},read}, only//dpc_grad_cnt
-	{0xB8,0x78},		
-	{0xB9,0xa0},		
-	{0xBA,0xb4},		
-	{0xBB,0x14},		
-	{0xBC,0x14},		
-	{0xBD,0x14},		
-	{0xBE,0x64},		
-	{0xBF,0x64},		
-	{0xC0,0x64},		
-	{0xC1,0x64},		
-	{0xC2,0x04},		
-	{0xC3,0x03},		
-	{0xC4,0x0c},		
-	{0xC5,0x30},		
-	{0xC6,0x2a},		
-	{0xD0,0x0c}, //CI Option/CI DPC
-	{0xD1,0x80},		
-	{0xD2,0x67},		
-	{0xD3,0x00},		
-	{0xD4,0x00},		
-	{0xD5,0x02},		
-	{0xD6,0xff},		
-	{0xD7,0x18},	
-	
-	/////// PAGE 13 START ///////
-	{0x03,0x13},
-	//Edge
-	{0x10,0xcb},
-	{0x11,0x7b},
-	{0x12,0x07},
-	{0x14,0x00},
-	
-	{0x20,0x15},
-	{0x21,0x13},
-	{0x22,0x33},
-	{0x23,0x05},
-	{0x24,0x09},
-	
-	{0x25,0x0a},
-	
-	{0x26,0x18},
-	{0x27,0x30},
-	{0x29,0x12},
-	{0x2a,0x50},
-	
+	{0x5e, 0x88},
+	{0x5f, 0x40},
+	{0x60, 0xe0},
+	{0x61, 0xe6},
+	{0x62, 0xe6},
+	{0x63, 0x80},
+
+	{0x70, 0x15},
+	{0x71, 0x01},
+
+	{0x72, 0x18},
+	{0x73, 0x01},
+
+	{0x74, 0x25},
+	{0x75, 0x15},
+	{0x80, 0x30},
+	{0x81, 0x50},
+	{0x82, 0x80},
+	{0x85, 0x1a},
+	{0x88, 0x00},
+	{0x89, 0x00},
+	{0x90, 0x5d},
+
+	{0xc5, 0x30},
+	{0xc6, 0x2a},
+
+	{0xD0, 0x0c},
+	{0xD1, 0x80},
+	{0xD2, 0x67},
+	{0xD3, 0x00},
+	{0xD4, 0x00},
+	{0xD5, 0x02},
+	{0xD6, 0xff},
+	{0xD7, 0x18},
+	{0x3b, 0x06},
+	{0x3c, 0x06},
+
+	{0xc5, 0x30},
+	{0xc6, 0x2a},
+
+	//Page 13
+	{0x03, 0x13},
+	{0x10, 0xcb},
+	{0x11, 0x7b},
+	{0x12, 0x07},
+	{0x14, 0x00},
+
+	{0x20, 0x15},
+	{0x21, 0x13},
+	{0x22, 0x33},
+	{0x23, 0x04},
+	{0x24, 0x09},
+	{0x25, 0x08},
+	{0x26, 0x18},
+	{0x27, 0x30},
+	{0x29, 0x12},
+	{0x2a, 0x50},
+
 	//Low clip th
-	{0x2b,0x00}, //Out2 02
-	{0x2c,0x00}, //Out1 02 //01
-	{0x25,0x06},
-	{0x2d,0x0c},
-	{0x2e,0x12},
-	{0x2f,0x12},
-	
+	{0x2b, 0x06},
+	{0x2c, 0x06},
+	{0x25, 0x08},
+	{0x2d, 0x0c},
+	{0x2e, 0x12},
+	{0x2f, 0x12},
+
 	//Out2 Edge
-/*	{0x50,0x18}, //{0x10 //{0x16
-	{0x51,0x1c}, //{0x14 //{0x1a
-	{0x52,0x1a}, //{0x12 //{0x18
-	{0x53,0x14}, //{0x0c //{0x12
-	{0x54,0x17}, //{0x0f //{0x15
-	{0x55,0x14}, //{0x0c //{0x12
-*/
-	{0x50,0x18}, //{0x10 //{0x16
-	{0x51,0x3c}, //{0x14 //{0x1a
-	{0x52,0x1a}, //{0x12 //{0x18
-	{0x53,0x14}, //{0x0c //{0x12
-	{0x54,0x37}, //{0x0f //{0x15
-	{0x55,0x14}, //{0x0c //{0x12	
-	//Out1 Edge 		 //Edge
-/*	{0x56,0x18}, //{0x10 //{0x16
-	{0x57,0x1c}, //{0x13 //{0x1a
-	{0x58,0x1a}, //{0x12 //{0x18
-	{0x59,0x14}, //{0x0c //{0x12
-	{0x5a,0x17}, //{0x0f //{0x15
-	{0x5b,0x14}, //{0x0c //{0x12
-*/
-	{0x56,0x18}, //{0x10 //{0x16
-	{0x57,0x3c}, //{0x13 //{0x1a
-	{0x58,0x1a}, //{0x12 //{0x18
-	{0x59,0x14}, //{0x0c //{0x12
-	{0x5a,0x37}, //{0x0f //{0x15
-	{0x5b,0x14}, //{0x0c //{0x12	
+	{0x50, 0x10},
+	{0x51, 0x14},
+	{0x52, 0x10},
+	{0x53, 0x0c},
+	{0x54, 0x0f},
+	{0x55, 0x0c},
+
+	//Out1 Edge
+	{0x56, 0x10},
+	{0x57, 0x13},
+	{0x58, 0x10},
+	{0x59, 0x0c},
+	{0x5a, 0x0f},
+	{0x5b, 0x0c},
+
 	//Indoor Edge
-/*	{0x5c,0x0a},
-	{0x5d,0x0b},
-	{0x5e,0x0a},
-	{0x5f,0x08},
-	{0x60,0x09},
-	{0x61,0x08},
-*/	
-  {0x5c,0x0a},
-	{0x5d,0x2b},
-	{0x5e,0x0a},
-	{0x5f,0x08},
-	{0x60,0x29},
-	{0x61,0x08},
+	{0x5c, 0x0a},
+	{0x5d, 0x0b},
+	{0x5e, 0x0a},
+	{0x5f, 0x08},
+	{0x60, 0x09},
+	{0x61, 0x08},
+
 	//Dark1 Edge
-/*	{0x62,0x08},
-	{0x63,0x08},
-	{0x64,0x08},
-	{0x65,0x06},
-	{0x66,0x06},
-	{0x67,0x06},
-*/
-	{0x62,0x08},
-	{0x63,0x28},
-	{0x64,0x08},
-	{0x65,0x06},
-	{0x66,0x26},
-	{0x67,0x06},	
+	{0x62, 0x08},
+	{0x63, 0x08},
+	{0x64, 0x08},
+	{0x65, 0x06},
+	{0x66, 0x06},
+	{0x67, 0x06},
 
 	//Dark2 Edge
-	{0x68,0x07},
-	{0x69,0x07},
-	{0x6a,0x07},
-	{0x6b,0x05},
-	{0x6c,0x05},
-	{0x6d,0x05},
-	
+	{0x68, 0x07},
+	{0x69, 0x07},
+	{0x6a, 0x07},
+	{0x6b, 0x05},
+	{0x6c, 0x05},
+	{0x6d, 0x05},
+
 	//Dark3 Edge
-	{0x6e,0x07},
-	{0x6f,0x07},
-	{0x70,0x07},
-	{0x71,0x05},
-	{0x72,0x05},
-	{0x73,0x05},
-	
+	{0x6e, 0x07},
+	{0x6f, 0x07},
+	{0x70, 0x07},
+	{0x71, 0x05},
+	{0x72, 0x05},
+	{0x73, 0x05},
+
 	//2DY
-	{0x80,0xfd},
-	{0x81,0x1f},
-	{0x82,0x05},
-	{0x83,0x31},
-	
-	{0x90,0x05},
-	{0x91,0x05},
-	{0x92,0x33},
-	{0x93,0x30},
-	{0x94,0x03},
-	{0x95,0x14},
-	{0x97,0x20},
-	{0x99,0x20},
-	
-	{0xa0,0x01},
-	{0xa1,0x02},
-	{0xa2,0x01},
-	{0xa3,0x02},
-	{0xa4,0x05},
-	{0xa5,0x05},
-	{0xa6,0x07},
-	{0xa7,0x08},
-	{0xa8,0x07},
-	{0xa9,0x08},
-	{0xaa,0x07},
-	{0xab,0x08},
-	
+	{0x80, 0xfd},
+	{0x81, 0x1f},
+	{0x82, 0x05},
+	{0x83, 0x01},
+
+	{0x90, 0x15},
+	{0x91, 0x15},
+	{0x92, 0x33},
+	{0x93, 0x30},
+	{0x94, 0x03},
+	{0x95, 0x14},
+	{0x97, 0x30},
+	{0x99, 0x30},
+
+	{0xa0, 0x04},
+	{0xa1, 0x05},
+	{0xa2, 0x04},
+	{0xa3, 0x05},
+	{0xa4, 0x07},
+	{0xa5, 0x08},
+	{0xa6, 0x07},
+	{0xa7, 0x08},
+	{0xa8, 0x07},
+	{0xa9, 0x08},
+	{0xaa, 0x07},
+	{0xab, 0x08}, 
+
 	//Out2 
-	{0xb0,0x22},
-	{0xb1,0x2a},
-	{0xb2,0x28},
-	{0xb3,0x22},
-	{0xb4,0x2a},
-	{0xb5,0x28},
-	
+	{0xb0, 0x22},
+	{0xb1, 0x2a},
+	{0xb2, 0x28},
+	{0xb3, 0x22},
+	{0xb4, 0x2a},
+	{0xb5, 0x28},
+
 	//Out1 
-	{0xb6,0x22},
-	{0xb7,0x2a},
-	{0xb8,0x28},
-	{0xb9,0x22},
-	{0xba,0x2a},
-	{0xbb,0x28},
-	
-	//Indoor 
-	{0xbc,0x25},
-	{0xbd,0x2a},
-	{0xbe,0x27},
-	{0xbf,0x25},
-	{0xc0,0x2a},
-	{0xc1,0x27},
-	
+	{0xb6, 0x22},
+	{0xb7, 0x2a},
+	{0xb8, 0x28},
+	{0xb9, 0x22},
+	{0xba, 0x2a},
+	{0xbb, 0x28},
+
+	{0xbc, 0x17},
+	{0xbd, 0x17},
+	{0xbe, 0x17},
+	{0xbf, 0x17},
+	{0xc0, 0x17},
+	{0xc1, 0x17},
+
 	//Dark1
-	{0xc2,0x1e},
-	{0xc3,0x24},
-	{0xc4,0x20},
-	{0xc5,0x1e},
-	{0xc6,0x24},
-	{0xc7,0x20},
-	
+	{0xc2, 0x1e},
+	{0xc3, 0x12},
+	{0xc4, 0x10},
+	{0xc5, 0x1e},
+	{0xc6, 0x12},
+	{0xc7, 0x10},
+
 	//Dark2
-	{0xc8,0x18},
-	{0xc9,0x20},
-	{0xca,0x1e},
-	{0xcb,0x18},
-	{0xcc,0x20},
-	{0xcd,0x1e},
-	
+	{0xc8, 0x18},
+	{0xc9, 0x05},
+	{0xca, 0x05},
+	{0xcb, 0x18},
+	{0xcc, 0x05},
+	{0xcd, 0x05},
+
 	//Dark3 
-	{0xce,0x18},
-	{0xcf,0x20},
-	{0xd0,0x1e},
-	{0xd1,0x18},
-	{0xd2,0x20},
-	{0xd3,0x1e},
-	
-	/////// PAGE 14 START ///////
-	{0x03,0x14},
-	{0x10,0x11},
-	
-	{0x14,0x80}, // GX
-	{0x15,0x80}, // GY
-	{0x16,0x80}, // RX
-	{0x17,0x80}, // RY
-	{0x18,0x80}, // BX
-	{0x19,0x80}, // BY
-	
-	{0x20,0x60}, //X 60 //a0
-	{0x21,0x80}, //Y
-	
-	{0x22,0x80},
-	{0x23,0x80},
-	{0x24,0x95},//80
-	
-	{0x30,0xc8},
-	{0x31,0x2b},
-	{0x32,0x00},
-	{0x33,0x00},
-	{0x34,0x90},
-	
-	{0x40,0x48}, //31
-	{0x50,0x34}, //23 //32
-	{0x60,0x29}, //1a //27
-	{0x70,0x34}, //23 //32
-	
-	/////// PAGE 15 START ///////
-	{0x03,0x15},
-	{0x10,0x0f},
-	
-	//Rstep H 16
-	//Rstep L 14
-	{0x14,0x42}, //CMCOFSGH_Day //4c
-	{0x15,0x32}, //CMCOFSGM_CWF //3c
-	{0x16,0x24}, //CMCOFSGL_A //2e
-	{0x17,0x2f}, //CMC SIGN
-	
-	//CMC_Default_CWF
-	{0x30,0x8f},
-	{0x31,0x59},
-	{0x32,0x0a},
-	{0x33,0x15},
-	{0x34,0x5b},
-	{0x35,0x06},
-	{0x36,0x07},
-	{0x37,0x40},
-	{0x38,0x87}, //86
-	
-	//CMC OFS L_A
-	{0x40,0x92},
-	{0x41,0x1b},
-	{0x42,0x89},
-	{0x43,0x81},
-	{0x44,0x00},
-	{0x45,0x01},
-	{0x46,0x89},
-	{0x47,0x9e},
-	{0x48,0x28},
-	
-	//{0x40,0x93},
-	//{0x41,0x1c},
-	//{0x42,0x89},
-	//{0x43,0x82},
-	//{0x44,0x01},
-	//{0x45,0x01},
-	//{0x46,0x8a},
-	//{0x47,0x9d},
-	//{0x48,0x28},
-	
-	//CMC POFS H_DAY
-	{0x50,0x02},
-	{0x51,0x82},
-	{0x52,0x00},
-	{0x53,0x07},
-	{0x54,0x11},
-	{0x55,0x98},
-	{0x56,0x00},
-	{0x57,0x0b},
-	{0x58,0x8b},
-	
-	{0x80,0x03},
-	{0x85,0x40},
-	{0x87,0x02},
-	{0x88,0x00},
-	{0x89,0x00},
-	{0x8a,0x00},
-	
-	/////// PAGE 16 START ///////
-	{0x03,0x16},
-	{0x10,0x31},
-	{0x18,0x5e},// Double_AG 5e->37
-	{0x19,0x5d},// Double_AG 5e->36
-	{0x1a,0x0e},
-	{0x1b,0x01},
-	{0x1c,0xdc},
-	{0x1d,0xfe},
-	
-	//GMA Default
-	{0x30,0x00},
-	{0x31,0x0a},
-	{0x32,0x1f},
-	{0x33,0x33},
-	{0x34,0x53},
-	{0x35,0x6c},
-	{0x36,0x81},
-	{0x37,0x94},
-	{0x38,0xa4},
-	{0x39,0xb3},
-	{0x3a,0xc0},
-	{0x3b,0xcb},
-	{0x3c,0xd5},
-	{0x3d,0xde},
-	{0x3e,0xe6},
-	{0x3f,0xee},
-	{0x40,0xf5},
-	{0x41,0xfc},
-	{0x42,0xff},
-	//RGMA
-	{0x50,0x00},
-	{0x51,0x09},
-	{0x52,0x1f},
-	{0x53,0x37},
-	{0x54,0x5b},
-	{0x55,0x76},
-	{0x56,0x8d},
-	{0x57,0xa1},
-	{0x58,0xb2},
-	{0x59,0xbe},
-	{0x5a,0xc9},
-	{0x5b,0xd2},
-	{0x5c,0xdb},
-	{0x5d,0xe3},
-	{0x5e,0xeb},
-	{0x5f,0xf0},
-	{0x60,0xf5},
-	{0x61,0xf7},
-	{0x62,0xf8},
-	//BGMA
-	{0x70,0x00}, // new gamma for low noise
-	{0x71,0x07},
-	{0x72,0x0c},
-	{0x73,0x18},
-	{0x74,0x31},
-	{0x75,0x4d},
-	{0x76,0x69},
-	{0x77,0x83},
-	{0x78,0x9b},
-	{0x79,0xb1},
-	{0x7a,0xc3},
-	{0x7b,0xd2},
-	{0x7c,0xde},
-	{0x7d,0xe8},
-	{0x7e,0xf0},
-	{0x7f,0xf5},
-	{0x80,0xfa},
-	{0x81,0xfd},
-	{0x82,0xff},
-	
-	/////// PAGE 17 START ///////
-	{0x03,0x17},
-	{0x10,0xf7},
-	
-	/////// PAGE 20 START ///////
-	{0x03,0x20},
-	{0x11,0x1c},
-	{0x18,0x30},
-	{0x1a,0x08},
-	{0x20,0x01}, //05_lowtemp Y Mean off
-	{0x21,0x30},
-	{0x22,0x10},
-	{0x23,0x00},
-	{0x24,0x00}, //Uniform Scene Off
-	
-	{0x28,0xe7},
-	{0x29,0x0d}, //20100305 ad->0d
-	{0x2a,0xff},
-	{0x2b,0x34}, //f4->Adaptive off
-	
-	{0x2c,0xc2},
-	{0x2d,0xcf},  //fe->AE Speed option
-	{0x2e,0x33},
-	{0x30,0x78}, //f8
-	{0x32,0x03},
-	{0x33,0x2e},
-	{0x34,0x30},
-	{0x35,0xd4},
-	{0x36,0xfe},
-	{0x37,0x32},
-	{0x38,0x04},
-	
-	{0x39,0x22}, //AE_escapeC10
-	{0x3a,0xde}, //AE_escapeC11
-	
-	{0x3b,0x22}, //AE_escapeC1
-	{0x3c,0xde}, //AE_escapeC2
-	
-	{0x50,0x45},
-	{0x51,0x88},
-	
-	{0x56,0x03},
-	{0x57,0xf7},
-	{0x58,0x14},
-	{0x59,0x88},
-	{0x5a,0x04},
-	
-	//New Weight For Samsung
-	{0x60,0xff},
-	{0x61,0xff},
-	{0x62,0xea},
-	{0x63,0xab},
-	{0x64,0xea},
-	{0x65,0xab},
-	{0x66,0xeb},
-	{0x67,0xeb},
-	{0x68,0xeb},
-	{0x69,0xeb},
-	{0x6a,0xea},
-	{0x6b,0xab},
-	{0x6c,0xea},
-	{0x6d,0xab},
-	{0x6e,0xff},
-	{0x6f,0xff},
-	
-	//{0x60,0x55}, // AEWGT1
-	//{0x61,0x55}, // AEWGT2
-	//{0x62,0x6a}, // AEWGT3
-	//{0x63,0xa9}, // AEWGT4
-	//{0x64,0x6a}, // AEWGT5
-	//{0x65,0xa9}, // AEWGT6
-	//{0x66,0x6a}, // AEWGT7
-	//{0x67,0xa9}, // AEWGT8
-	//{0x68,0x6b}, // AEWGT9
-	//{0x69,0xe9}, // AEWGT10
-	//{0x6a,0x6a}, // AEWGT11
-	//{0x6b,0xa9}, // AEWGT12
-	//{0x6c,0x6a}, // AEWGT13
-	//{0x6d,0xa9}, // AEWGT14
-	//{0x6e,0x55}, // AEWGT15
-	//{0x6f,0x55}, // AEWGT16
-	
-	{0x70,0x76}, //6e
-	{0x71,0x89}, //00 //-4
-	
+	{0xce, 0x18},
+	{0xcf, 0x05},
+	{0xd0, 0x05},
+	{0xd1, 0x18},
+	{0xd2, 0x05},
+	{0xd3, 0x05},
+	
+	//Page 14
+	{0x03, 0x14},
+	{0x10, 0x11},
+	{0x20, 0x40},
+	{0x21, 0x80},
+	{0x23, 0x80},
+	{0x22, 0x80},
+	{0x23, 0x80},
+	{0x24, 0x80},
+
+	{0x30, 0xc8},
+	{0x31, 0x2b},
+	{0x32, 0x00},
+	{0x33, 0x00},
+	{0x34, 0x90},
+
+	{0x40, 0x42},
+	{0x50, 0x2d},
+	{0x60, 0x28},
+	{0x70, 0x2d},
+
+	//Page 15
+	{0x03, 0x15}, 
+	{0x10, 0x0f}, 
+	{0x14, 0x52}, 
+	{0x15, 0x42}, 
+	{0x16, 0x32}, 
+	{0x17, 0x2f}, 
+
+	//CMC
+	{0x30, 0x8f}, 
+	{0x31, 0x59}, 
+	{0x32, 0x0a}, 
+	{0x33, 0x15}, 
+	{0x34, 0x5b}, 
+	{0x35, 0x06}, 
+	{0x36, 0x07}, 
+	{0x37, 0x40}, 
+	{0x38, 0x86}, 
+
+	//CMC OFS
+	{0x40, 0x95}, 
+	{0x41, 0x1f}, 
+	{0x42, 0x8a}, 
+	{0x43, 0x86}, 
+	{0x44, 0x0a}, 
+	{0x45, 0x84}, 
+	{0x46, 0x87}, 
+	{0x47, 0x9b}, 
+	{0x48, 0x23}, 
+
+	//CMC POFS
+	{0x50, 0x8c}, 
+	{0x51, 0x0c}, 
+	{0x52, 0x00}, 
+	{0x53, 0x07}, 
+	{0x54, 0x17}, 
+	{0x55, 0x9d}, 
+	{0x56, 0x00}, 
+	{0x57, 0x0b}, 
+	{0x58, 0x89}, 
+
+	{0x80, 0x03},
+	{0x85, 0x40},
+	{0x87, 0x02},
+	{0x88, 0x00},
+	{0x89, 0x00},
+	{0x8a, 0x00},
+
+{0x03, 0x16},
+{0x10, 0x31},//GMA_CTL
+{0x18, 0x5e},//AG_ON
+{0x19, 0x5d},//AG_OFF
+{0x1A, 0x0e},//TIME_ON
+{0x1B, 0x01},//TIME_OFF
+{0x1C, 0xdc},//OUT_ON
+{0x1D, 0xfe},//OUT_OFF
+//GMA
+{0x30, 0x00},
+{0x31, 0x09},
+{0x32, 0x15},
+{0x33, 0x29},
+{0x34, 0x53},
+{0x35, 0x6c},
+{0x36, 0x81},
+{0x37, 0x94},
+{0x38, 0xa4},
+{0x39, 0xb3},
+{0x3a, 0xc0},
+{0x3b, 0xcb},
+{0x3c, 0xd5},
+{0x3d, 0xde},
+{0x3e, 0xe6},
+{0x3f, 0xee},
+{0x40, 0xf5},
+{0x41, 0xfc},
+{0x42, 0xff},
+//RGMA
+{0x50, 0x00},
+{0x51, 0x09},
+{0x52, 0x1f},
+{0x53, 0x37},
+{0x54, 0x5b},
+{0x55, 0x76},
+{0x56, 0x8d},
+{0x57, 0xa1},
+{0x58, 0xb2},
+{0x59, 0xbe},
+{0x5a, 0xc9},
+{0x5b, 0xd2},
+{0x5c, 0xdb},
+{0x5d, 0xe3},
+{0x5e, 0xeb},
+{0x5f, 0xf0},
+{0x60, 0xf5},
+{0x61, 0xf7},
+{0x62, 0xf8},
+//BGMA
+{0x70, 0x00},
+{0x71, 0x08},
+{0x72, 0x17},
+{0x73, 0x2f},
+{0x74, 0x53},
+{0x75, 0x6c},
+{0x76, 0x81},
+{0x77, 0x94},
+{0x78, 0xa4},
+{0x79, 0xb3},
+{0x7a, 0xc0},
+{0x7b, 0xcb},
+{0x7c, 0xd5},
+{0x7d, 0xde},
+{0x7e, 0xe6},
+{0x7f, 0xee},
+{0x80, 0xf4},
+{0x81, 0xfa},
+{0x82, 0xff},
+
+
+	
+	{0x03, 0x17}, 
+	{0xc4, 0x6e}, 
+	{0xc5, 0x5c}, 
+
+	{0x03, 0x18}, 
+	{0x10, 0x00},
+
+	{0x03, 0x20}, 
+	{0x10, 0x1c},
+	{0x18, 0x38},
+	{0x20, 0x01}, 
+	{0x21, 0x30},
+	{0x22, 0x10},
+	{0x23, 0x00},
+	{0x24, 0x04},
+
+	{0x28, 0xff},
+	{0x29, 0xad},
+
+	{0x2a, 0xf0},
+	{0x2b, 0x34},
+	{0x30, 0x78},
+	{0x2c, 0xc3},
+	{0x2d, 0x5f},
+	{0x2e, 0x33},
+	//{0x30, 0xf8},
+	{0x32, 0x03},
+	{0x33, 0x2e},
+	{0x34, 0x30},
+	{0x35, 0xd4},
+	{0x36, 0xfe},
+	{0x37, 0x32},
+	{0x38, 0x04},
+	{0x47, 0xf0},
+
+	//Y_Frame TH
+	{0x50, 0x45},
+	{0x51, 0x88},
+
+	{0x56, 0x10},
+	{0x57, 0xb7},
+	{0x58, 0x14},
+	{0x59, 0x88},
+	{0x5a, 0x04},
+
+	{0x60, 0x55}, 
+	{0x61, 0x55}, 
+	{0x62, 0x6a}, 
+	{0x63, 0xa9}, 
+	{0x64, 0x6a}, 
+	{0x65, 0xa9}, 
+	{0x66, 0x6a}, 
+	{0x67, 0xa9}, 
+	{0x68, 0x6b}, 
+	{0x69, 0xe9}, 
+	{0x6a, 0x6a}, 
+	{0x6b, 0xa9}, 
+	{0x6c, 0x6a}, 
+	{0x6d, 0xa9}, 
+	{0x6e, 0x55}, 
+	{0x6f, 0x55}, 
+	//{0x70, 0x42}, 
+	{0x70, 0x45}, 
+	{0x71, 0xBb},
+
 	// haunting control
-	{0x76,0x43},
-	{0x77,0xe2}, //04 //f2
-	
-	{0x78,0x23}, //Yth1
-	{0x79,0x42}, //Yth2 //46
-	{0x7a,0x23}, //23
-	{0x7b,0x22}, //22
-	{0x7d,0x23},
-	
-	
-	//0x83--0x9fǸ27MʱõعֵFlickers
-	
-	{0x83,0x01}, //EXP Normal 33.33 fps 
-	{0x84,0x89}, 
-	{0x85,0x00}, 
-	
-	{0x86,0x02}, //EXPMin 5859.38 fps
-	{0x87,0x00}, 
-	
-	{0x88,0x06}, //EXP Max 8.00 fps 
-	{0x89,0x24}, 
-	{0x8a,0x00}, 
-	
-	{0x8B,0x83}, //EXP100 
-	{0x8C,0x00}, 
-	{0x8D,0x6d}, //EXP120 
-	{0x8E,0x00}, 
-	
-	{0x9c,0x18}, //EXP Limit 488.28 fps //keyiyongde
-	{0x9d,0x00}, 
-	{0x9e,0x02}, //EXP Unit 
-	{0x9f,0x00}, 
-	
-	{0xb0,0x18},
-	{0xb1,0x14}, //ADC 400->560
-	{0xb2,0xa0}, 
-	{0xb3,0x18},
-	{0xb4,0x1a},
-	{0xb5,0x44},
-	{0xb6,0x2f},
-	{0xb7,0x28},
-	{0xb8,0x25},
-	{0xb9,0x22},
-	{0xba,0x21},
-	{0xbb,0x20},
-	{0xbc,0x1f},
-	{0xbd,0x1f},
-	
-	{0xc0,0x14},
-	{0xc1,0x1f},
-	{0xc2,0x1f},
-	{0xc3,0x18}, //2b
-	{0xc4,0x10}, //08
-	
-	{0xc8,0x80},
-	{0xc9,0x40},
-	
-	/////// PAGE 22 START ///////
-	{0x03,0x22},
-	{0x10,0xfd},
-	{0x11,0x2e},
-	{0x19,0x01}, // Low On //
-	{0x20,0x30},
-	{0x21,0x80},
-	{0x24,0x01},
-	//{0x25,0x00}, //7f New Lock Cond & New light stable
-	
-	{0x30,0x80},
-	{0x31,0x80},
-	{0x38,0x11},
-	{0x39,0x34},
-	
-	{0x40,0xf7}, //
-	{0x41,0x55}, //44
-	{0x42,0x33}, //43
-	
-	{0x43,0xf7},
-	{0x44,0x55}, //44
-	{0x45,0x44}, //33
-	
-	{0x46,0x00},
-	{0x50,0xb2},
-	{0x51,0x81},
-	{0x52,0x98},
-	
-	{0x80,0x40}, //3e
-	{0x81,0x20},
-	{0x82,0x3e},
-	
-	{0x83,0x5e}, //5e
-	{0x84,0x1e}, //24
-	{0x85,0x5e}, //54 //56 //5a
-	{0x86,0x22}, //24 //22
-	
-	{0x87,0x40},
-	{0x88,0x30},
-	{0x89,0x3f}, //38
-	{0x8a,0x28}, //2a
-	
-	{0x8b,0x40}, //47
-	{0x8c,0x33}, 
-	{0x8d,0x39}, 
-	{0x8e,0x30}, //2c
-	
-	{0x8f,0x53}, //4e
-	{0x90,0x52}, //4d
-	{0x91,0x51}, //4c
-	{0x92,0x4e}, //4a
-	{0x93,0x4a}, //46
-	{0x94,0x45},
-	{0x95,0x3d},
-	{0x96,0x31},
-	{0x97,0x28},
-	{0x98,0x24},
-	{0x99,0x20},
-	{0x9a,0x20},
-	
-	{0x9b,0x77},
-	{0x9c,0x77},
-	{0x9d,0x48},
-	{0x9e,0x38},
-	{0x9f,0x30},
-	
-	{0xa0,0x60},
-	{0xa1,0x34},
-	{0xa2,0x6f},
-	{0xa3,0xff},
-	
-	{0xa4,0x14}, //1500fps
-	{0xa5,0x2c}, // 700fps
-	{0xa6,0xcf},
-	
-	{0xad,0x40},
-	{0xae,0x4a},
-	
-	{0xaf,0x28},  // low temp Rgain
-	{0xb0,0x26},  // low temp Rgain
-	
-	{0xb1,0x00}, //{0x20 -> {0x00 0405 modify
-	{0xb4,0xea},
-	{0xb8,0xa0}, //a2: b-2}, R+2  //b4 B-3}, R+4 lowtemp
-	{0xb9,0x00},
-	
-	// PAGE 20
-	{0x03,0x20}, //page 20
-	{0x10,0x9c}, //ae off
-	
-	// PAGE 22
-	{0x03,0x22}, //page 22
-	{0x10,0xe9}, //awb off
-	
-	// PAGE 0
-	{0x03,0x00},
-	{0x0e,0x03}, //PLL On
-	{0x0e,0x73}, //PLLx2
-	
-	{0x03,0x00}, // Dummy 750us
-	{0x03,0x00},
-	{0x03,0x00},
-	{0x03,0x00},
-	{0x03,0x00},
-	{0x03,0x00},
-	{0x03,0x00},
-	{0x03,0x00},
-	{0x03,0x00},
-	{0x03,0x00},
+	{0x76, 0x21},
+	{0x77, 0x02},
+	{0x78, 0x22},
+	{0x79, 0x2a},
+
+	{0x78, 0x24},
+	{0x79, 0x23},
+	{0x7a, 0x23},
+	{0x7b, 0x22},
+	{0x7d, 0x23},
+	{0x83, 0x01}, //EXP Normal 33.33 fps 
+	{0x84, 0x5f}, 
+	{0x85, 0x00}, 
+	{0x86, 0x01}, //EXPMin 6410.26 fps
+	{0x87, 0xd4}, 
+	{0x88, 0x05}, //EXP Max 8.33 fps 
+	{0x89, 0x7c}, 
+	{0x8a, 0x00}, 
+	{0x8B, 0x75}, //EXP100 
+	{0x8C, 0x00}, 
+	{0x8D, 0x60}, //EXP120 
+	{0x8E, 0xe4}, 
+
+
+	{0x98, 0xdc},
+	{0x99, 0x45},
+	{0x9a, 0x0d},
+	{0x9b, 0xde},
+	{0x9c, 0x08},
+	{0x9d, 0x0a},
+	{0x9e, 0x01},
+    {0x10, 0x9c},
+    {0x18, 0x30},
+    {0x90, 0x0c},
+    {0x91, 0x0c},
+    {0x92, 0xd8},   
+    {0x93, 0xd0},  
+    
+	{0x9c, 0x0c}, //EXP Limit 915.75 fps 
+	{0x9d, 0xcc}, 
+	{0x9e, 0x01}, //EXP Unit 
+	{0x9f, 0xd4},  
+	{0xa0, 0x03},
+	{0xa1, 0xa9},
+	{0xa2, 0x80},
+	{0xb0, 0x1d},
+	{0xb1, 0x1a},
+	{0xb2, 0xa0},
+	{0xb3, 0x1a},
+	{0xb4, 0x1a},
+	{0xb5, 0x44},
+	{0xb6, 0x2f},
+	{0xb7, 0x28},
+	{0xb8, 0x25},
+	{0xb9, 0x22},
+	{0xba, 0x21},
+	{0xbb, 0x20},
+	{0xbc, 0x1f},
+	{0xbd, 0x1f},
+	{0xc0, 0x30},
+	{0xc1, 0x20},
+	{0xc2, 0x20},
+	{0xc3, 0x20},
+	{0xc4, 0x08},
+	{0xc8, 0x60},
+	{0xc9, 0x40},
+	
+	//Page 22
+	{0x03, 0x22}, // Page 22
+	{0x10, 0xfd}, // AWBCTL1
+	{0x11, 0x2e}, // AWBCTL2
+	{0x19, 0x01}, 
+	{0x20, 0x30},
+	{0x21, 0x80},
+	{0x23, 0x08},
+	{0x24, 0x01},
+	
+	{0x30, 0x80}, // ULVL
+	{0x31, 0x80}, // VLVL
+	{0x38, 0x11}, // UVTH1
+	{0x39, 0x34}, // UVTH2
+	{0x40, 0xf7}, // YRANGE
+	
+	{0x41, 0x77}, // CDIFF
+	{0x42, 0x55}, // CSUM2
+	{0x43, 0xf0},
+	{0x44, 0x66},
+	{0x45, 0x33},
+	{0x46, 0x01}, // WHTPXLTH1		   
+	{0x47, 0x94},
+	
+	{0x50, 0xb2},
+	{0x51, 0x81},
+	{0x52, 0x98},
+	
+	{0x80, 0x38}, // RGAIN
+	{0x81, 0x20}, // GGAIN
+	{0x82, 0x38}, // BGAIN
+	
+	{0x83, 0x5e}, // RMAX
+	{0x84, 0x20}, // RMIN
+	{0x85, 0x53}, // BMAX
+	{0x86, 0x15}, // BMIN
+	
+	{0x87, 0x54}, // RMAXM
+	{0x88, 0x20}, // RMINM
+	{0x89, 0x3f}, // BMAXM 
+	{0x8a, 0x1c}, // BMINM
+	
+	{0x8b, 0x54}, // RMAXB 
+	{0x8c, 0x3f}, // RMINB
+	{0x8d, 0x24}, // BMAXB
+	{0x8e, 0x1c}, // BMINB
+	
+	{0x8f, 0x60}, // BGAINPARA1
+	{0x90, 0x5f}, // BGAINPARA2
+	{0x91, 0x5c}, // BGAINPARA3
+	{0x92, 0x4C}, // BGAINPARA4
+	{0x93, 0x41}, // BGAINPARA5
+	{0x94, 0x3b}, // BGAINPARA6
+	{0x95, 0x36}, // BGAINPARA7
+	{0x96, 0x30}, // BGAINPARA8
+	{0x97, 0x27}, // BGAINPARA9
+	{0x98, 0x20}, // BGAINPARA10
+	{0x99, 0x1C}, // BGAINPARA11
+	{0x9a, 0x19}, // BGAINPARA12
+	
+	{0x9b, 0x88}, // BGAINBND1
+	{0x9c, 0x88}, // BGAINBND2
+	{0x9d, 0x48}, // RGAINTH1
+	{0x9e, 0x38}, // RGAINTH2
+	{0x9f, 0x30}, // RGAINTH3
+	
+	{0xa0, 0x74}, // RDELTA1
+	{0xa1, 0x35}, // BDELTA1
+	{0xa2, 0xaf}, // RDELTA2
+	{0xa3, 0xf7}, // BDELTA2
+	
+	{0xa4, 0x10}, // AWBEXPLMT1
+	{0xa5, 0x50}, // AWBEXPLMT2
+	{0xa6, 0xc4}, // AWBEXPLMT3
+	
+	{0xad, 0x40},
+	{0xae, 0x4a},
+	
+	{0xaf, 0x2a},
+	{0xb0, 0x29},
+	
+	{0xb1, 0x20},
+	{0xb4, 0xff},
+	{0xb8, 0x6b},
+	{0xb9, 0x00},
+
+
+	{0x03, 0x24}, 
+	{0x10, 0x01}, 
+	{0x18, 0x06},
+	{0x30, 0x06},
+	{0x31, 0x90},
+	{0x32, 0x25},
+	{0x33, 0xa2},
+	{0x34, 0x26},
+	{0x35, 0x58},
+	{0x36, 0x60},
+	{0x37, 0x00},
+	{0x38, 0x50},
+	{0x39, 0x00},
+
+	{0x03, 0x20}, 
+	{0x10, 0x9c}, 
+	{0x03, 0x22}, 
+	{0x10, 0xe9}, 
+	
+	//Page 00
+	{0x03, 0x00}, 
+	{0x0e, 0x03}, 
+	{0x0e, 0x73}, 
+
+	{0x03, 0x00}, 
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00},
+	{0x03, 0x00}, 
+
 	
 	{0x03,0x00}, // Page 0
-	{0x01,0x50}, // Sleep Off ޸
+	{0x01,0x50}, // Sleep Off
 	
 	{0xff,0xff},
 	{0xff,0xff},
@@ -1243,10 +1152,11 @@ static struct regval_list sensor_default_regs[] = {
 static struct regval_list sensor_uxga_regs[] = {
 	//Resolution Setting : 1600*1200
 	{0x03,0x00},	//PAGEMODE(0x03)
-
-	{0x10,0x00},//VGA Size
-		{0x12,0x05},
-	
+	{0x01,0x70},
+	{0x10,0x00},//UXGA Size
+		//{0x12,0x05},
+	{0x12,0x04},
+	//{0x01,0x50},	
 	{0x20,0x00},
 	{0x21,0x04},
 	{0x22,0x00},
@@ -1258,15 +1168,17 @@ static struct regval_list sensor_uxga_regs[] = {
 	{0x27,0x40},
 	
 	
-	{0x40,0x01},//HBLANK: 0x70 = 112
-	{0x41,0x98},
+	{0x40,0x03},//HBLANK: 0x70 = 860
+	{0x41,0x5c},
 	{0x42,0x00},//VBLANK: 0x04 = 4
-	{0x43,0x47},
+	{0x43,0x64},
 	
 		 {0x03,0x18},	//PAGEMODE(0x03)
      {0x10,0x00},	 
  
-     
+    {0x03,0x13},
+   {0x80,0xfd},
+  
      
 };
 
@@ -1275,7 +1187,7 @@ static struct regval_list sensor_hd720_regs[] = {
         {0x03,0x00},	//PAGEMODE(0x03)
 
 	{0x10,0x00},//VGA Size
-		{0x12,0x05},
+		//{0x12,0x05},
 	
 	{0x20,0x00},
 	{0x21,0xf0},
@@ -1300,8 +1212,8 @@ static struct regval_list sensor_svga_regs[] = {
 	//Resolution Setting : 800*600
 	 {0x03,0x00},	//PAGEMODE(0x03)
 
-	{0x10,0x11},//VGA Size
-	
+	{0x10,0x10},//SVGA Size
+	//{0x12,0x00},	
 	{0x20,0x00},
 	{0x21,0x04},
 	{0x22,0x00},
@@ -1312,31 +1224,34 @@ static struct regval_list sensor_svga_regs[] = {
 	{0x26,0x06},
 	{0x27,0x40},
 	
-	{0x40,0x01},//HBLANK: 0x70 = 112
-	{0x41,0x98},
+	{0x40,0x00},//HBLANK: 0x70 = 112
+	{0x41,0xe8},
 	{0x42,0x00},//VBLANK: 0x04 = 4
-	{0x43,0x47},
+	{0x43,0x14},
 	
 	 {0x03,0x18},	//PAGEMODE(0x03)
      {0x10,0x00},	
 };
 
 static struct regval_list sensor_vga_regs[] = {
-	//Resolution Setting : 600*480
+	//Resolution Setting : 640*480
 	{0x03,0x00},	//PAGEMODE(0x03)
-
-	{0x10,0x11},//VGA Size
-	
+	{0x01,0x50},
+	{0x10,0x10},//VGA Size
+	{0x12,0x00},	
 	{0x20,0x00},
 	{0x21,0x04},
 	{0x22,0x00},
 	{0x23,0x07},
 	
-	{0x40,0x01},//HBLANK: 0x70 = 112
-	{0x41,0x98},
+	{0x40,0x00},//HBLANK: 0x70 = 112
+	{0x41,0xe8},
 	{0x42,0x00},//VBLANK: 0x04 = 4
-	{0x43,0x47},
-         
+	{0x43,0x14},
+  
+ {0x03,0x13},
+   {0x80,0xfc},
+        
 
   {0x03,0x18},
    {0x12,0x20},
@@ -1368,7 +1283,7 @@ static struct regval_list sensor_qvga_regs[] = {
 	//Resolution Setting : 320*240
 	{0x03,0x00},	//PAGEMODE(0x03)
 
-	{0x10,0x11},//VGA Size
+	{0x10,0x10},//VGA Size
 	
 	{0x20,0x00},
 	{0x21,0x04},
@@ -1419,9 +1334,11 @@ static struct regval_list sensor_wb_auto_regs[] = {
 	{0x11,0x2e},				
 			     
 	{0x83,0x5e},
-	{0x84,0x1e},
-	{0x85,0x5e},
-	{0x86,0x22},		
+	{0x84,0x16},
+	{0x85,0x53},
+	{0x86,0x22},
+
+			
 };
 
 static struct regval_list sensor_wb_incandescence_regs[] = {
@@ -1713,48 +1630,75 @@ static struct cfg_array sensor_colorfx[] = {
  * The brightness setttings
  */
 static struct regval_list sensor_brightness_neg4_regs[] = {
-	{0x03},{0x10},
-	{0x40},{0xe0},
+//	{0x03,0x10}, //orginal
+//	{0x40,0xe0},
+	//{0x03,0x10}, //modify
+	//{0x13,0x0a},
+	//{0x4a,0xe0},
 };
 
 static struct regval_list sensor_brightness_neg3_regs[] = {
-	{0x03},{0x10},
-	{0x40},{0xc0},
+//	{0x03,0x10},
+//	{0x40,0xc0},
+	//{0x03,0x10},
+	//{0x13,0x0a},
+	//{0x4a,0xc0},
 };
 
 static struct regval_list sensor_brightness_neg2_regs[] = {
-	{0x03},{0x10},
-	{0x40},{0xa0},
+//	{0x03,0x10},
+//	{0x40,0xa0},
+	//{0x03,0x10},
+	//{0x13,0x0a},
+	//{0x4a,0xa0},
 };
 
 static struct regval_list sensor_brightness_neg1_regs[] = {
-	{0x03},{0x10},
-	{0x40},{0x90},
+//	{0x03,0x10},
+//	{0x40,0x90},
+	//{0x03,0x10},
+	//{0x13,0x0a},
+	//{0x4a,0x90},
 };
 
 static struct regval_list sensor_brightness_zero_regs[] = {
-	{0x03},{0x10},
-	{0x40},{0x85},
+//	{0x03,0x10},
+//	{0x40,0x85},
+	//{0x03,0x10},
+	//{0x13,0x02},
+	//{0x4a,0x80},
 };
 
 static struct regval_list sensor_brightness_pos1_regs[] = {
-	{0x03},{0x10},
-	{0x40},{0x10},
+//	{0x03,0x10},
+//	{0x40,0x10},
+	//{0x03,0x10},
+	//{0x13,0x0a},
+	//{0x4a,0x10},
 };
 
 static struct regval_list sensor_brightness_pos2_regs[] = {
-	{0x03},{0x10},
-	{0x40},{0x20},
+//	{0x03,0x10},
+//	{0x40,0x20},
+	//{0x03,0x10},
+	//{0x13,0x0a},
+	//{0x4a,0x20},
 };
 
 static struct regval_list sensor_brightness_pos3_regs[] = {
-	{0x03},{0x10},
-	{0x40},{0x30},
+//	{0x03,0x10},
+//	{0x40,0x30},
+	//{0x03,0x10},
+	//{0x13,0x0a},
+	//{0x4a,0x30},
 };
 
 static struct regval_list sensor_brightness_pos4_regs[] = {
-	{0x03},{0x10},
-	{0x40},{0x40},
+//	{0x03,0x10},
+//	{0x40,0x40},
+	//{0x03,0x10},
+	//{0x13,0x0a},
+	//{0x4a,0x40},
 };
 
 static struct cfg_array sensor_brightness[] = {
@@ -1800,48 +1744,48 @@ static struct cfg_array sensor_brightness[] = {
  * The contrast setttings
  */
 static struct regval_list sensor_contrast_neg4_regs[] = {
-	{0x03},{0x10},
-	{0x48},{0x44},
+//	{0x03,0x10},
+//	{0x48,0x44},
 };
 
 static struct regval_list sensor_contrast_neg3_regs[] = {
-	{0x03},{0x10},
-	{0x48},{0x54},
+//	{0x03,0x10},
+//	{0x48,0x54},
 };
 
 static struct regval_list sensor_contrast_neg2_regs[] = {
-	{0x03},{0x10},
-	{0x48},{0x64},
+//	{0x03,0x10},
+//	{0x48,0x64},
 };
 
 static struct regval_list sensor_contrast_neg1_regs[] = {
-	{0x03},{0x10},
-	{0x48},{0x74},
+//	{0x03,0x10},
+//	{0x48,0x74},
 };
 
 static struct regval_list sensor_contrast_zero_regs[] = {
-	{0x03},{0x10},
-	{0x48},{0x88},
+//	{0x03,0x10},
+//	{0x48,0x88},
 };
 
 static struct regval_list sensor_contrast_pos1_regs[] = {
-	{0x03},{0x10},
-	{0x48},{0x94},
+//	{0x03,0x10},
+//	{0x48,0x94},
 };
 
 static struct regval_list sensor_contrast_pos2_regs[] = {
-	{0x03},{0x10},
-	{0x48},{0xa4},
+//	{0x03,0x10},
+//	{0x48,0xa4},
 };
 
 static struct regval_list sensor_contrast_pos3_regs[] = {
-	{0x03},{0x10},
-	{0x48},{0xb4},
+//	{0x03,0x10},
+//	{0x48,0xb4},
 };
 
 static struct regval_list sensor_contrast_pos4_regs[] = {
-	{0x03},{0x10},
-	{0x48},{0xc4},
+//	{0x03,0x10},
+//	{0x48,0xc4},
 };
 static struct cfg_array sensor_contrast[] = {
   {
@@ -1886,57 +1830,57 @@ static struct cfg_array sensor_contrast[] = {
  * The saturation setttings
  */
 static struct regval_list sensor_saturation_neg4_regs[] = {
-	{0x03},{0x10},
-	{0x61},{0x50},
-	{0x62},{0x50},
+//	{0x03,0x10},
+//	{0x61,0x50},
+//	{0x62,0x50},
 };
 
 static struct regval_list sensor_saturation_neg3_regs[] = {
-	{0x03},{0x10},
-	{0x61},{0x60},
-	{0x62},{0x60},
+//	{0x03,0x10},
+//	{0x61,0x60},
+//	{0x62,0x60},
 };
 
 static struct regval_list sensor_saturation_neg2_regs[] = {
-	{0x03},{0x10},
-	{0x61},{0x70},
-	{0x62},{0x70},
+//	{0x03,0x10},
+//	{0x61,0x70},
+//	{0x62,0x70},
 };
 
 static struct regval_list sensor_saturation_neg1_regs[] = {
-	{0x03},{0x10},
-	{0x61},{0x80},
-	{0x62},{0x80},
+//	{0x03,0x10},
+//	{0x61,0x80},
+//	{0x62,0x80},
 };
 
 static struct regval_list sensor_saturation_zero_regs[] = {
-	{0x03},{0x10},
-	{0x61},{0x80},
-	{0x62},{0x80},
+//	{0x03,0x10},
+//	{0x61,0x80},
+//	{0x62,0x80},
 };
 
 static struct regval_list sensor_saturation_pos1_regs[] = {
-	{0x03},{0x10},
-	{0x61},{0xa0},
-	{0x62},{0xa0},
+//	{0x03,0x10},
+//	{0x61,0xa0},
+//	{0x62,0xa0},
 };
 
 static struct regval_list sensor_saturation_pos2_regs[] = {
-	{0x03},{0x10},
-	{0x61},{0xb0},
-	{0x62},{0xb0},
+//	{0x03,0x10},
+//	{0x61,0xb0},
+//	{0x62,0xb0},
 };
 
 static struct regval_list sensor_saturation_pos3_regs[] = {
-	{0x03},{0x10},
-	{0x61},{0xc0},
-	{0x62},{0xc0},
+//	{0x03,0x10},
+//	{0x61,0xc0},
+//	{0x62,0xc0},
 };
 
 static struct regval_list sensor_saturation_pos4_regs[] = {
-	{0x03},{0x10},
-	{0x61},{0xd0},
-	{0x62},{0xd0},
+//	{0x03,0x10},
+//	{0x61,0xd0},
+//	{0x62,0xd0},
 };
 
 static struct cfg_array sensor_saturation[] = {
@@ -1983,48 +1927,48 @@ static struct cfg_array sensor_saturation[] = {
  * The exposure target setttings
  */
 static struct regval_list sensor_ev_neg4_regs[] = {
-	{0x03},{0x20},
-	{0x70},{0x38},//58
+	{0x03,0x20},
+	{0x70,0x18},//70
 };
 
 static struct regval_list sensor_ev_neg3_regs[] = {
-	{0x03},{0x20},
-	{0x70},{0x40},//60
+	{0x03,0x20},
+	{0x70,0x28},//70
 };
 
 static struct regval_list sensor_ev_neg2_regs[] = {
-	{0x03},{0x20},
-	{0x70},{0x58},//68
+	{0x03,0x20},
+	{0x70,0x38},//70
 };
 
 static struct regval_list sensor_ev_neg1_regs[] = {
-	{0x03},{0x20},
-	{0x70},{0x66},//70
+	{0x03,0x20},
+	{0x70,0x40},//70
 };
 
 static struct regval_list sensor_ev_zero_regs[] = {
-	{0x03},{0x20},
-	{0x70},{0x76},//70
+	{0x03,0x20},
+	{0x70,0x45},//70
 };
 
 static struct regval_list sensor_ev_pos1_regs[] = {
-	{0x03},{0x20},
-	{0x70},{0x86},//80
+	{0x03,0x20},
+	{0x70,0x60},//70
 };
 
 static struct regval_list sensor_ev_pos2_regs[] = {
-	{0x03},{0x20},
-	{0x70},{0x96},//88
+	{0x03,0x20},
+	{0x70,0x68},//70
 };
 
 static struct regval_list sensor_ev_pos3_regs[] = {
-	{0x03},{0x20},
-	{0x70},{0xa0},//90
+	{0x03,0x20},
+	{0x70,0x78},//70
 };
 
 static struct regval_list sensor_ev_pos4_regs[] = {
-	{0x03},{0x20},
-	{0x70},{0xb0},//98
+	{0x03,0x20},
+	{0x70,0x90},//70
 };
 
 static struct cfg_array sensor_ev[] = {
@@ -2075,24 +2019,24 @@ static struct cfg_array sensor_ev[] = {
 
 
 static struct regval_list sensor_fmt_yuv422_yuyv[] = {
-	{0x03},{0x10},//PAGEMODE 0x10
-	{0x10},{0x03},	//YCbYCr
+	{0x03,0x10},//PAGEMODE 0x10
+	{0x10,0x03},	//YCbYCr
 };
 
 
 static struct regval_list sensor_fmt_yuv422_yvyu[] = {
-	{0x03},{0x10},//PAGEMODE 0x10
-	{0x10},{0x02},	//YCrYCb
+	{0x03,0x10},//PAGEMODE 0x10
+	{0x10,0x02},	//YCrYCb
 };
 
 static struct regval_list sensor_fmt_yuv422_vyuy[] = {
-	{0x03},{0x10},//PAGEMODE 0x10
-	{0x10},{0x00},	//CrYCbY
+	{0x03,0x10},//PAGEMODE 0x10
+	{0x10,0x00},	//CrYCbY
 };
 
 static struct regval_list sensor_fmt_yuv422_uyvy[] = {
-	{0x03},{0x10},//PAGEMODE 0x10
-	{0x10},{0x01},	//CbYCrY
+	{0x03,0x10},//PAGEMODE 0x10
+	{0x10,0x01},	//CbYCrY
 };
 
 //static struct regval_list sensor_fmt_raw[] = {
@@ -2713,10 +2657,11 @@ static int sensor_power(struct v4l2_subdev *sd, int on)
      // vfe_gpio_write(sd,RESET,CSI_RST_OFF);
 	//		usleep_range(10000,12000);
 			//standby on io
-      vfe_gpio_write(sd,PWDN,CSI_STBY_ON);
-			usleep_range(10000,12000);
+/*      vfe_gpio_write(sd,PWDN,CSI_STBY_ON);
+			mdelay(10);
       vfe_gpio_write(sd,PWDN,CSI_STBY_OFF);
-			usleep_range(10000,12000);
+			mdelay(10);
+*/
       vfe_gpio_write(sd,PWDN,CSI_STBY_ON);
 			usleep_range(10000,12000);
       //inactive mclk after stadby in
@@ -2765,6 +2710,7 @@ static int sensor_power(struct v4l2_subdev *sd, int on)
 			msleep(100);
       vfe_gpio_write(sd,RESET,CSI_RST_OFF);
 			usleep_range(10000,12000);
+			hi253_firsttime = 0;
 			break;
 		case CSI_SUBDEV_PWR_OFF:
 			vfe_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
@@ -2785,6 +2731,7 @@ static int sensor_power(struct v4l2_subdev *sd, int on)
 			//set the io to hi-z
       vfe_gpio_set_status(sd,RESET,0);//set the gpio to input
       vfe_gpio_set_status(sd,PWDN,0);//set the gpio to input
+      hi253_firsttime = 0;
       break;
 		default:
 			return -EINVAL;
@@ -2846,7 +2793,14 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 		vfe_dev_err("chip found is not an target chip.\n");
 		return ret;
 	}
-	return sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+	if(hi253_firsttime == 0)
+	{
+		ret = sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
+		hi253_firsttime = 1;
+		return ret;
+	}
+	else
+		return ret;
 }
 
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
@@ -3090,7 +3044,8 @@ static int sensor_s_fmt(struct v4l2_subdev *sd,
 	info->fmt = sensor_fmt;
 	info->width = wsize->width;
 	info->height = wsize->height;
-	msleep(500);//ӳٽշ
+	mdelay(50);   //potter modify
+	//mdelay(500);//\D4\F6\BC\D3\D10115\E2\BE\F6\C5\C4\D503\D6\C6\C1\CE\CA\CC\E2
 	return 0;
 }
 
diff --git a/drivers/media/video/sunxi-vfe/device/s5k4ec_mipi.c b/drivers/media/video/sunxi-vfe/device/s5k4ec_mipi.c
index c4222200..1093fc0 100755
--- a/drivers/media/video/sunxi-vfe/device/s5k4ec_mipi.c
+++ b/drivers/media/video/sunxi-vfe/device/s5k4ec_mipi.c
@@ -68,6 +68,31 @@ MODULE_LICENSE("GPL");
 
 #define AF_WIN_NEW_COORD
 
+#define QSXGA_WIDTH_S5K		2560
+#define QSXGA_HEIGHT_S5K	1920
+#define QXGA_WIDTH_S5K 		2048
+#define QXGA_HEIGHT_S5K		1536
+#define HD1080_WIDTH_S5K	1920
+#define HD1080_HEIGHT_S5K	1080
+#define UXGA_WIDTH_S5K		1600
+#define UXGA_HEIGHT_S5K		1200
+#define SXGA_WIDTH_S5K		1280
+#define SXGA_HEIGHT_S5K		960
+#define HD720_WIDTH_S5K 	1280
+#define HD720_HEIGHT_S5K	720
+#define XGA_WIDTH_S5K			1024
+#define XGA_HEIGHT_S5K 		768
+#define SVGA_WIDTH_S5K		800
+#define SVGA_HEIGHT_S5K 	600
+#define VGA_WIDTH_S5K			640
+#define VGA_HEIGHT_S5K		480
+#define QVGA_WIDTH_S5K		320
+#define QVGA_HEIGHT_S5K		240
+#define CIF_WIDTH_S5K			352
+#define CIF_HEIGHT_S5K		288
+#define QCIF_WIDTH_S5K		176
+#define	QCIF_HEIGHT_S5K		144
+
 unsigned int coarse_af_pd=0;
 
 /*
@@ -82,6 +107,11 @@ unsigned int coarse_af_pd=0;
 
 /* Registers */
 
+/*
+if s5k4ec_firsttime ==0 ,sensor will init sensor_default_regs;
+otherwise it just standy off.
+*/
+static unsigned int s5k4ec_firsttime =0;      //potter add
 
 static int sensor_s_band_filter(struct v4l2_subdev *sd, 
 		enum v4l2_power_line_frequency value);
@@ -109,3054 +139,3792 @@ static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
  */
 
 static struct regval_list sensor_default_regs[] = {
+                                           
+{0xFCFC, 0xD000},                                             
+{0x0010, 0x0001}, //S/W Reset                                 
+{0x1030, 0x0000}, //contint_host_int                          
+{0x0014, 0x0001}, //sw_load_complete - Release CORE (Arm) from reset state
+               
+               
+               
 //==================================================================================
-// 00.History
-//==================================================================================
-//2010 : EVT1.1
-//20110429 : LSI CSE Standard
-//20110728 : Sequence Changed
-//20110728 : ESD Check Register Address Changed
-//20110829 : TnP Changed by S.Y.Lee
-//20120104 : init Parm Update sequence changed
-//20120201 : Flash ֺ Green Noise  setting 
-//20120228 : Add Brightness Block
-//==================================================================================
-  
-//==================================================================================
-// 01.Start Setting
+//02.ETC Setting                                            
 //==================================================================================
-
-{0xFCFC, 0xD000},
-{0x0010, 0x0001},
-{0x1030, 0x0000},
-{0x0014, 0x0001},
-
-//p10 //Delay 10ms
+{0x002A,0x1082},
+{0x0F12,0x0000},	// cregs_d0_d4_cd10 //D4[9:8], D3[7:6], D2[5:4], D1[3:2], D0[1:0]
+{0x0F12,0x0000},	// cregs_d5_d9_cd10 //D9[9:8], D8[7:6], D7[5:4], D6[3:2], D5[1:0]
+{0x002A,0x1088},
+{0x0F12,0x0000},	// cregs_clks_output_cd10 //SDA[11:10], SCL[9:8], PCLK[7:6], VSYNC[3:2], HSYNC[1:0]
 
 
-
-//==================================================================================
-//02.ETC Setting
-//==================================================================================
-
-{0x002A,	0x1082},
-{0x0F12,	0x0000},	//cregs_d0_d4_cd10 //D4[9:8], D3[7:6], D2[5:4], D1[3:2], D0[1:0]
-{0x0F12,	0x0000},	//cregs_d5_d9_cd10 //D9[9:8], D8[7:6], D7[5:4], D6[3:2], D5[1:0]
-{0x002A,	0x1088},
-{0x0F12,	0x0000},	//cregs_clks_output_cd10 //SDA[11:10], SCL[9:8], PCLK[7:6], VSYNC[3:2], HSYNC[1:0]
-
 //==================================================================================
 // 03.Analog Setting & ASP Control
 //==================================================================================
-
-//This register is for FACTORY ONLY. 
+//This register is for FACTORY ONLY.
 //If you change it without prior notification
 //YOU are RESPONSIBLE for the FAILURE that will happen in the future
-
 {0x0028, 0xD000},
-{0x002A, 0x007A},
-{0x0f12, 0x0000},	
-{0x002A, 0xE406},	 //[7]f_ladlc_en [6:5]f max [4]fadlc_en [3:2]L max [1]ladlc_en [0]adlc_ch_sel
-{0x0F12, 0x0092},	
-{0x002A, 0xE410},	
-{0x0F12, 0x3804},	 //[15:8]fadlc_filter_co_b [7:0]fadlc_filter_co_a	
-{0x002A, 0xE41A},	
-{0x0F12, 0x0010},	 	
-{0x002A, 0xE420},	
-{0x0F12, 0x0003},	 //adlc_fadlc_filter_refresh 	
-{0x0F12, 0x0060},	 //adlc_filter_level_diff_threshold
-{0x002A, 0xE42E},	
-{0x0F12, 0x0004},	 //dithered l-ADLC(4bit)
-{0x002A, 0xF400},	
-{0x0F12, 0x5A3C},	 //[15:8]stx_width [7:0]dstx_width 
-{0x0F12, 0x0023},	 //[14]binning_test [13]gain_mode [11:12]row_id [10]cfpn_test [9]pd_pix [8]teg_en [7]adc_res [6]smp_en [5]ldb_en [4]ld_en [3]clp_en [2]srx_en [1]dshut_en [0]dcds_en 
-{0x0F12, 0x8080},	 //CDS option 
-{0x0F12, 0x03AF},	 //[11:6]rst_mx [5:0]sig_mx
-{0x0F12, 0x000A},	 //Avg mode
-{0x0F12, 0xAA54},	 //x1~x1.49:No MS x1.5~x3.99:MS2 x4~x16:MS4
-{0x0F12, 0x0040},	 //RMP option [6]1: RES gain
-{0x0F12, 0x464E},	 //[14]msoff_en [13:8]off_rst [7:0]adc_sat
-{0x0F12, 0x0240},	 //bist_sig_width_e
-{0x0F12, 0x0240},	 //bist_sig_width_o
-{0x0F12, 0x0040},	 //[9]dbs_bist_en [8:0]bist_rst_width
-{0x0F12, 0x1000},	 //[15]aac_en [14]GCLK_DIV2_EN [13:10]dl_cont [9:8]dbs_mode [7:0]dbs_option
-{0x0F12, 0x55cc},	 //bias [15:12]pix [11:8]pix_bst [7:4]comp2 [3:0]comp1  	
-{0x0F12, 0xD000},	 //[15:8]clp_lvl [7:0]ref_option [5]pix_bst_en
-{0x0F12, 0x0010},	 //[7:0]monit
-{0x0F12, 0x0202},	 //[15:8]dbr_tune_tgsl [7:0]dbr_tune_pix
-{0x0F12, 0x0401},	 //[15:8]dbr_tune_ntg [7:0]dbr_tune_rg                                                                       
-{0x0F12, 0x0022},	 //[15:8]reg_option [7:4]rosc_tune_ncp [3:0]rosc_tune_cp                                                    
-{0x0F12, 0x0088},	 //PD [8]inrush_ctrl [7]fblv [6]reg_ntg [5]reg_tgsl [4]reg_rg [3]reg_pix [2]ncp_rosc [1]cp_rosc [0]cp 
-{0x0F12, 0x009F},	 //[9]capa_ctrl_en [8:7]fb_lv [6:5]dbr_clk_sel [4:0]cp_capa                                                
-{0x0F12, 0x0000},	 //[15:0]blst_en_cintr                                                                                        
-{0x0F12, 0x1800},	 //[11]blst_en [10]rfpn_test [9]sl_off [8]tx_off [7:0]rdv_option                                          
-{0x0F12, 0x0088},	 //[15:0]pmg_reg_tune                                                                                         
-{0x0F12, 0x0000},	 //[15:1]analog_dummy [0]pd_reg_test 
-{0x0F12, 0x2428},	 //[13:11]srx_gap1 [10:8]srx_gap0 [7:0]stx_gap
-{0x0F12, 0x0000},	 //[0]atx_option       
-{0x0F12, 0x03EE},	 //aig_avg_half
-{0x0F12, 0x0000},	 //[0]hvs_test_reg     
-{0x0F12, 0x0000},	 //[0]dbus_bist_auto   
-{0x0F12, 0x0000},	 //[7:0]dbr_option	    
-{0x002A, 0xF552},	
-{0x0F12, 0x0708},	 //[7:0]lat_st [15:8]lat_width  
-{0x0F12, 0x080C},	 //[7:0]hold_st [15:8]hold_width
-
-//For subsampling Size	
-
-{0x0028, 0x7000},	
-{0x002A, 0x18BC},	
-{0x0F12, 0x0004},	
-{0x0F12, 0x05B6},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0001},	
-{0x0F12, 0x05BA},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0007},	
-{0x0F12, 0x05BA},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x01F4},	
-{0x0F12, 0x024E},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x01F4},	
-{0x0F12, 0x05B6},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x01F4},	
-{0x0F12, 0x05BA},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x01F4},	
-{0x0F12, 0x024F},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0075},	
-{0x0F12, 0x00CF},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0075},	
-{0x0F12, 0x00D6},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0004},	
-{0x0F12, 0x01F4},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x00F0},	
-{0x0F12, 0x01F4},	
-{0x0F12, 0x029E},	
-{0x0F12, 0x05B2},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x01F8},	
-{0x0F12, 0x0228},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0208},	
-{0x0F12, 0x0238},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0218},	
-{0x0F12, 0x0238},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0001},	
-{0x0F12, 0x0009},	
-{0x0F12, 0x00DE},	
-{0x0F12, 0x05C0},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x00DF},	
-{0x0F12, 0x00E4},	
-{0x0F12, 0x01F8},	
-{0x0F12, 0x01FD},	
-{0x0F12, 0x05B6},	
-{0x0F12, 0x05BB},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x01F8},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0077},	
-{0x0F12, 0x007E},	
-{0x0F12, 0x024F},	
-{0x0F12, 0x025E},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-
- // For Capture 	
-
-{0x0F12, 0x0004},	
-{0x0F12, 0x09D1},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0001},	
-{0x0F12, 0x09D5},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0008},	
-{0x0F12, 0x09D5},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x02AA},	
-{0x0F12, 0x0326},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x02AA},	
-{0x0F12, 0x09D1},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x02AA},	
-{0x0F12, 0x09D5},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x02AA},	
-{0x0F12, 0x0327},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0008},	
-{0x0F12, 0x0084},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0008},	
-{0x0F12, 0x008D},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0008},	
-{0x0F12, 0x02AA},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x00AA},	
-{0x0F12, 0x02AA},	
-{0x0F12, 0x03AD},	
-{0x0F12, 0x09CD},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x02AE},	
-{0x0F12, 0x02DE},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x02BE},	
-{0x0F12, 0x02EE},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x02CE},	
-{0x0F12, 0x02EE},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0001},	
-{0x0F12, 0x0009},	
-{0x0F12, 0x0095},	
-{0x0F12, 0x09DB},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0096},	
-{0x0F12, 0x009B},	
-{0x0F12, 0x02AE},	
-{0x0F12, 0x02B3},	
-{0x0F12, 0x09D1},	
-{0x0F12, 0x09D6},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x02AE},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0009},	
-{0x0F12, 0x0010},	
-{0x0F12, 0x0327},	
-{0x0F12, 0x0336},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0000},	     
-{0x002A, 0x1AF8},	
-{0x0F12, 0x5A3C},    //senHal_TuneStr_AngTuneData1_2_D000F400 register at subsampling	
-{0x002A, 0x1896},	
-{0x0F12, 0x0002},    //senHal_SamplingType	0002 03EE: PLA setting	
-{0x0F12, 0x0000},    //senHal_SamplingMode 0 : 2 PLA / 1 : 4PLA	
-{0x0F12, 0x0003},	
-{0x002A, 0x189E},	
-{0x0F12, 0x0FB0},	
-{0x002A, 0x18AC},	
-{0x0F12, 0x0060},	
-{0x0F12, 0x0060},	
-{0x0F12, 0x05C0},	
-{0x0F12, 0x05C0},	
-{0x002A, 0x1AEA},	
-{0x0F12, 0x8080},	
-{0x0F12, 0x0080},	
-{0x002A, 0x1AE0},	
-{0x0F12, 0x0000},	
-{0x002A, 0x1A72},	
-{0x0F12, 0x0000},	
-{0x002A, 0x18A2},	
-{0x0F12, 0x0004},	
-{0x002A, 0x1A6A},	
-{0x0F12, 0x009A},	
-{0x002A, 0x385E},	
-{0x0F12, 0x024C},	
-{0x002A, 0x0EE6},	
-{0x0F12, 0x0000},	
-{0x002A, 0x1B2A},	
-{0x0F12, 0x0300},	
-{0x0F12, 0x00D6},	
-{0x0F12, 0x008D},	
-{0x0F12, 0x00CF},	
-{0x0F12, 0x0084},	
-
-//==================================================================================
-	
-
+{0x002A,0x007A},
+{0x0F12,0x0000},
+{0x002A,0xE406},
+{0x0F12,0x0092},
+{0x002A,0xE410},
+{0x0F12,0x3804},	// [15:8]fadlc_filter_co_b, [7:0]fadlc_filter_co_a
+{0x002A,0xE41A},
+{0x0F12,0x0010},
+{0x002A,0xE420},
+{0x0F12,0x0003},	// adlc_fadlc_filter_refresh
+{0x0F12,0x0060},	// adlc_filter_level_diff_threshold
+{0x002A,0xE42E},
+{0x0F12,0x0004},	// dithered l-ADLC(4bit)
+{0x002A,0xF400},
+{0x0F12,0x5A3C},	// [15:8]stx_width, [7:0]dstx_width
+{0x0F12,0x0023},	// [14]binning_test [13]gain_mode [11:12]row_id [10]cfpn_test [9]pd_pix [8]teg_en, [7]adc_res, [6]smp_en, [5]ldb_en, [4]ld_en, [3]clp_en [2]srx_en, [1]dshut_en, [0]dcds_en
+{0x0F12,0x8080},	// CDS option
+{0x0F12,0x03AF},	// [11:6]rst_mx, [5:0]sig_mx
+{0x0F12,0x000A},	// Avg mode
+{0x0F12,0xAA54},	// x1~x1.49:No MS, x1.5~x3.99:MS2, x4~x16:MS4
+{0x0F12,0x0040},	// RMP option [6]1: RES gain
+{0x0F12,0x464E},	// [14]msoff_en, [13:8]off_rst, [7:0]adc_sat
+{0x0F12,0x0240},	// bist_sig_width_e
+{0x0F12,0x0240},	// bist_sig_width_o
+{0x0F12,0x0040},	// [9]dbs_bist_en, [8:0]bist_rst_width
+{0x0F12,0x1000},	// [15]aac_en, [14]GCLK_DIV2_EN, [13:10]dl_cont [9:8]dbs_mode, [7:0]dbs_option
+{0x0F12,0x55FF},	// bias [15:12]pix, [11:8]pix_bst [7:4]comp2, [3:0]comp1
+{0x0F12,0xD000},	// [15:8]clp_lvl, [7:0]ref_option, [5]pix_bst_en
+{0x0F12,0x0010},	// [7:0]monit
+{0x0F12,0x0202},	// [15:8]dbr_tune_tgsl, [7:0]dbr_tune_pix
+{0x0F12,0x0401},	// [15:8]dbr_tune_ntg, [7:0]dbr_tune_rg
+{0x0F12,0x0022},	// [15:8]reg_option, [7:4]rosc_tune_ncp, [3:0]rosc_tune_cp
+{0x0F12,0x0088},	// PD [8]inrush_ctrl, [7]fblv, [6]reg_ntg, [5]reg_tgsl, [4]reg_rg, [3]reg_pix, [2]ncp_rosc, [1]cp_rosc, [0]cp
+{0x0F12,0x009F},	// [9]capa_ctrl_en, [8:7]fb_lv, [6:5]dbr_clk_sel, [4:0]cp_capa
+{0x0F12,0x0000},	// [15:0]blst_en_cintr
+{0x0F12,0x1800},	// [11]blst_en, [10]rfpn_test, [9]sl_off, [8]tx_off, [7:0]rdv_option
+{0x0F12,0x0088},	// [15:0]pmg_reg_tune
+{0x0F12,0x0000},	// [15:1]analog_dummy, [0]pd_reg_test
+{0x0F12,0x2428},	// [13:11]srx_gap1, [10:8]srx_gap0, [7:0]stx_gap
+{0x0F12,0x0000},	// [0]atx_option
+{0x0F12,0x03EE},	// aig_avg_half
+{0x0F12,0x0000},	// [0]hvs_test_reg
+{0x0F12,0x0000},	// [0]dbus_bist_auto
+{0x0F12,0x0000},	// [7:0]dbr_option
+{0x002A,0xF552},
+{0x0F12,0x0708},	// [7:0]lat_st, [15:8]lat_width
+{0x0F12,0x080C},	// [7:0]hold_st, [15:8]hold_width
 //=================================================================================
-// 05.Trap and Patch
+// 04.Trap and Patch
 //=================================================================================
 // Start of Patch data
-{0x0028, 0x7000},
-{0x002A, 0x3AF8},
-{0x0F12, 0xB570},	 // 70003AF8
-{0x0F12, 0x4B39},	 // 70003AFA
-{0x0F12, 0x4939},	 // 70003AFC
-{0x0F12, 0x483A},	 // 70003AFE
-{0x0F12, 0x2200},	 // 70003B00
-{0x0F12, 0xC008},	 // 70003B02
-{0x0F12, 0x6001},	 // 70003B04
-{0x0F12, 0x4939},	 // 70003B06
-{0x0F12, 0x4839},	 // 70003B08
-{0x0F12, 0x2401},	 // 70003B0A
-{0x0F12, 0xF000},	 // 70003B0C
-{0x0F12, 0xFBEC},	 // 70003B0E
-{0x0F12, 0x4938},	 // 70003B10
-{0x0F12, 0x4839},	 // 70003B12
-{0x0F12, 0x2502},	 // 70003B14
-{0x0F12, 0x0022},	 // 70003B16
-{0x0F12, 0xF000},	 // 70003B18
-{0x0F12, 0xFBE6},	 // 70003B1A
-{0x0F12, 0x4837},	 // 70003B1C
-{0x0F12, 0x0261},	 // 70003B1E
-{0x0F12, 0x8001},	 // 70003B20
-{0x0F12, 0x2100},	 // 70003B22
-{0x0F12, 0x8041},	 // 70003B24
-{0x0F12, 0x4936},	 // 70003B26
-{0x0F12, 0x4836},	 // 70003B28
-{0x0F12, 0x6041},	 // 70003B2A
-{0x0F12, 0x4936},	 // 70003B2C
-{0x0F12, 0x4837},	 // 70003B2E
-{0x0F12, 0x2403},	 // 70003B30
-{0x0F12, 0x002A},	 // 70003B32
-{0x0F12, 0xF000},	 // 70003B34
-{0x0F12, 0xFBD8},	 // 70003B36
-{0x0F12, 0x4832},	 // 70003B38
-{0x0F12, 0x4935},	 // 70003B3A
-{0x0F12, 0x30C0},	 // 70003B3C
-{0x0F12, 0x63C1},	 // 70003B3E
-{0x0F12, 0x4930},	 // 70003B40
-{0x0F12, 0x4834},	 // 70003B42
-{0x0F12, 0x3980},	 // 70003B44
-{0x0F12, 0x6408},	 // 70003B46
-{0x0F12, 0x4833},	 // 70003B48
-{0x0F12, 0x4934},	 // 70003B4A
-{0x0F12, 0x6388},	 // 70003B4C
-{0x0F12, 0x4934},	 // 70003B4E
-{0x0F12, 0x4834},	 // 70003B50
-{0x0F12, 0x0022},	 // 70003B52
-{0x0F12, 0x2504},	 // 70003B54
-{0x0F12, 0xF000},	 // 70003B56
-{0x0F12, 0xFBC7},	 // 70003B58
-{0x0F12, 0x4933},	 // 70003B5A
-{0x0F12, 0x4833},	 // 70003B5C
-{0x0F12, 0x2405},	 // 70003B5E
-{0x0F12, 0x002A},	 // 70003B60
-{0x0F12, 0xF000},	 // 70003B62
-{0x0F12, 0xF881},	 // 70003B64
-{0x0F12, 0x491F},	 // 70003B66
-{0x0F12, 0x4830},	 // 70003B68
-{0x0F12, 0x0022},	 // 70003B6A
-{0x0F12, 0x2506},	 // 70003B6C
-{0x0F12, 0x39B6},	 // 70003B6E
-{0x0F12, 0x1D80},	 // 70003B70
-{0x0F12, 0xF000},	 // 70003B72
-{0x0F12, 0xF879},	 // 70003B74
-{0x0F12, 0x482D},	 // 70003B76
-{0x0F12, 0x492D},	 // 70003B78
-{0x0F12, 0x2407},	 // 70003B7A
-{0x0F12, 0x002A},	 // 70003B7C
-{0x0F12, 0x300C},	 // 70003B7E
-{0x0F12, 0xF000},	 // 70003B80
-{0x0F12, 0xF872},	 // 70003B82
-{0x0F12, 0x4829},	 // 70003B84
-{0x0F12, 0x492B},	 // 70003B86
-{0x0F12, 0x0022},	 // 70003B88
-{0x0F12, 0x2508},	 // 70003B8A
-{0x0F12, 0x3010},	 // 70003B8C
-{0x0F12, 0xF000},	 // 70003B8E
-{0x0F12, 0xF86B},	 // 70003B90
-{0x0F12, 0x4929},	 // 70003B92
-{0x0F12, 0x4829},	 // 70003B94
-{0x0F12, 0x2409},	 // 70003B96
-{0x0F12, 0x002A},	 // 70003B98
-{0x0F12, 0xF000},	 // 70003B9A
-{0x0F12, 0xFBA5},	 // 70003B9C
-{0x0F12, 0x4928},	 // 70003B9E
-{0x0F12, 0x4828},	 // 70003BA0
-{0x0F12, 0x0022},	 // 70003BA2
-{0x0F12, 0x250A},	 // 70003BA4
-{0x0F12, 0xF000},	 // 70003BA6
-{0x0F12, 0xFB9F},	 // 70003BA8
-{0x0F12, 0x4927},	 // 70003BAA
-{0x0F12, 0x4827},	 // 70003BAC
-{0x0F12, 0x240B},	 // 70003BAE
-{0x0F12, 0x002A},	 // 70003BB0
-{0x0F12, 0xF000},	 // 70003BB2
-{0x0F12, 0xFB99},	 // 70003BB4
-{0x0F12, 0x4926},	 // 70003BB6
-{0x0F12, 0x4826},	 // 70003BB8
-{0x0F12, 0x0022},	 // 70003BBA
-{0x0F12, 0x250C},	 // 70003BBC
-{0x0F12, 0xF000},	 // 70003BBE
-{0x0F12, 0xFB93},	 // 70003BC0
-{0x0F12, 0x4925},	 // 70003BC2
-{0x0F12, 0x4825},	 // 70003BC4
-{0x0F12, 0x240D},	 // 70003BC6
-{0x0F12, 0x002A},	 // 70003BC8
-{0x0F12, 0xF000},	 // 70003BCA
-{0x0F12, 0xFB8D},	 // 70003BCC
-{0x0F12, 0x4924},	 // 70003BCE
-{0x0F12, 0x4824},	 // 70003BD0
-{0x0F12, 0x0022},	 // 70003BD2
-{0x0F12, 0xF000},	 // 70003BD4
-{0x0F12, 0xFB88},	 // 70003BD6
-{0x0F12, 0xBC70},	 // 70003BD8
-{0x0F12, 0xBC08},	 // 70003BDA
-{0x0F12, 0x4718},	 // 70003BDC
-{0x0F12, 0x0000},	 // 70003BDE
-{0x0F12, 0x017B},	 // 70003BE0
-{0x0F12, 0x4EC2},	 // 70003BE2
-{0x0F12, 0x037F},	 // 70003BE4
-{0x0F12, 0x0000},	 // 70003BE6
-{0x0F12, 0x1F90},	 // 70003BE8
-{0x0F12, 0x7000},	 // 70003BEA
-{0x0F12, 0x3C81},	 // 70003BEC
-{0x0F12, 0x7000},	 // 70003BEE
-{0x0F12, 0xE38B},	 // 70003BF0
-{0x0F12, 0x0000},	 // 70003BF2
-{0x0F12, 0x3CB9},	 // 70003BF4
-{0x0F12, 0x7000},	 // 70003BF6
-{0x0F12, 0xC3B1},	 // 70003BF8
-{0x0F12, 0x0000},	 // 70003BFA
-{0x0F12, 0x4780},	 // 70003BFC
-{0x0F12, 0x7000},	 // 70003BFE
-{0x0F12, 0x3D17},	 // 70003C00
-{0x0F12, 0x7000},	 // 70003C02
-{0x0F12, 0x0080},	 // 70003C04
-{0x0F12, 0x7000},	 // 70003C06
-{0x0F12, 0x3D53},	 // 70003C08
-{0x0F12, 0x7000},	 // 70003C0A
-{0x0F12, 0xB49D},	 // 70003C0C
-{0x0F12, 0x0000},	 // 70003C0E
-{0x0F12, 0x3DFF},	 // 70003C10
-{0x0F12, 0x7000},	 // 70003C12
-{0x0F12, 0x3DB3},	 // 70003C14
-{0x0F12, 0x7000},	 // 70003C16
-{0x0F12, 0xFFFF},	 // 70003C18
-{0x0F12, 0x00FF},	 // 70003C1A
-{0x0F12, 0x17E0},	 // 70003C1C
-{0x0F12, 0x7000},	 // 70003C1E
-{0x0F12, 0x3F7B},	 // 70003C20
-{0x0F12, 0x7000},	 // 70003C22
-{0x0F12, 0x053D},	 // 70003C24
-{0x0F12, 0x0000},	 // 70003C26
-{0x0F12, 0x0000},	 // 70003C28
-{0x0F12, 0x0A89},	 // 70003C2A
-{0x0F12, 0x6CD2},	 // 70003C2C
-{0x0F12, 0x0000},	 // 70003C2E
-{0x0F12, 0x0000},	 // 70003C30
-{0x0F12, 0x0A9A},	 // 70003C32
-{0x0F12, 0x0000},	 // 70003C34
-{0x0F12, 0x02D2},	 // 70003C36
-{0x0F12, 0x3FC9},	 // 70003C38
-{0x0F12, 0x7000},	 // 70003C3A
-{0x0F12, 0x9E65},	 // 70003C3C
-{0x0F12, 0x0000},	 // 70003C3E
-{0x0F12, 0x403D},	 // 70003C40
-{0x0F12, 0x7000},	 // 70003C42
-{0x0F12, 0x7C49},	 // 70003C44
-{0x0F12, 0x0000},	 // 70003C46
-{0x0F12, 0x40B1},	 // 70003C48
-{0x0F12, 0x7000},	 // 70003C4A
-{0x0F12, 0x7C63},	 // 70003C4C
-{0x0F12, 0x0000},	 // 70003C4E
-{0x0F12, 0x40CD},	 // 70003C50
-{0x0F12, 0x7000},	 // 70003C52
-{0x0F12, 0x8F01},	 // 70003C54
-{0x0F12, 0x0000},	 // 70003C56
-{0x0F12, 0x416F},	 // 70003C58
-{0x0F12, 0x7000},	 // 70003C5A
-{0x0F12, 0x7F3F},	 // 70003C5C
-{0x0F12, 0x0000},	 // 70003C5E
-{0x0F12, 0x41FD},	 // 70003C60
-{0x0F12, 0x7000},	 // 70003C62
-{0x0F12, 0x98C5},	 // 70003C64
-{0x0F12, 0x0000},	 // 70003C66
-{0x0F12, 0xB570},	 // 70003C68
-{0x0F12, 0x000C},	 // 70003C6A
-{0x0F12, 0x0015},	 // 70003C6C
-{0x0F12, 0x0029},	 // 70003C6E
-{0x0F12, 0xF000},	 // 70003C70
-{0x0F12, 0xFB42},	 // 70003C72
-{0x0F12, 0x49F8},	 // 70003C74
-{0x0F12, 0x00A8},	 // 70003C76
-{0x0F12, 0x500C},	 // 70003C78
-{0x0F12, 0xBC70},	 // 70003C7A
-{0x0F12, 0xBC08},	 // 70003C7C
-{0x0F12, 0x4718},	 // 70003C7E
-{0x0F12, 0x6808},	 // 70003C80
-{0x0F12, 0x0400},	 // 70003C82
-{0x0F12, 0x0C00},	 // 70003C84
-{0x0F12, 0x6849},	 // 70003C86
-{0x0F12, 0x0409},	 // 70003C88
-{0x0F12, 0x0C09},	 // 70003C8A
-{0x0F12, 0x4AF3},	 // 70003C8C
-{0x0F12, 0x8992},	 // 70003C8E
-{0x0F12, 0x2A00},	 // 70003C90
-{0x0F12, 0xD00D},	 // 70003C92
-{0x0F12, 0x2300},	 // 70003C94
-{0x0F12, 0x1A89},	 // 70003C96
-{0x0F12, 0xD400},	 // 70003C98
-{0x0F12, 0x000B},	 // 70003C9A
-{0x0F12, 0x0419},	 // 70003C9C
-{0x0F12, 0x0C09},	 // 70003C9E
-{0x0F12, 0x23FF},	 // 70003CA0
-{0x0F12, 0x33C1},	 // 70003CA2
-{0x0F12, 0x1810},	 // 70003CA4
-{0x0F12, 0x4298},	 // 70003CA6
-{0x0F12, 0xD800},	 // 70003CA8
-{0x0F12, 0x0003},	 // 70003CAA
-{0x0F12, 0x0418},	 // 70003CAC
-{0x0F12, 0x0C00},	 // 70003CAE
-{0x0F12, 0x4AEB},	 // 70003CB0
-{0x0F12, 0x8150},	 // 70003CB2
-{0x0F12, 0x8191},	 // 70003CB4
-{0x0F12, 0x4770},	 // 70003CB6
-{0x0F12, 0xB5F3},	 // 70003CB8
-{0x0F12, 0x0004},	 // 70003CBA
-{0x0F12, 0xB081},	 // 70003CBC
-{0x0F12, 0x9802},	 // 70003CBE
-{0x0F12, 0x6800},	 // 70003CC0
-{0x0F12, 0x0600},	 // 70003CC2
-{0x0F12, 0x0E00},	 // 70003CC4
-{0x0F12, 0x2201},	 // 70003CC6
-{0x0F12, 0x0015},	 // 70003CC8
-{0x0F12, 0x0021},	 // 70003CCA
-{0x0F12, 0x3910},	 // 70003CCC
-{0x0F12, 0x408A},	 // 70003CCE
-{0x0F12, 0x40A5},	 // 70003CD0
-{0x0F12, 0x4FE4},	 // 70003CD2
-{0x0F12, 0x0016},	 // 70003CD4
-{0x0F12, 0x2C10},	 // 70003CD6
-{0x0F12, 0xDA03},	 // 70003CD8
-{0x0F12, 0x8839},	 // 70003CDA
-{0x0F12, 0x43A9},	 // 70003CDC
-{0x0F12, 0x8039},	 // 70003CDE
-{0x0F12, 0xE002},	 // 70003CE0
-{0x0F12, 0x8879},	 // 70003CE2
-{0x0F12, 0x43B1},	 // 70003CE4
-{0x0F12, 0x8079},	 // 70003CE6
-{0x0F12, 0xF000},	 // 70003CE8
-{0x0F12, 0xFB0E},	 // 70003CEA
-{0x0F12, 0x2C10},	 // 70003CEC
-{0x0F12, 0xDA03},	 // 70003CEE
-{0x0F12, 0x8839},	 // 70003CF0
-{0x0F12, 0x4329},	 // 70003CF2
-{0x0F12, 0x8039},	 // 70003CF4
-{0x0F12, 0xE002},	 // 70003CF6
-{0x0F12, 0x8879},	 // 70003CF8
-{0x0F12, 0x4331},	 // 70003CFA
-{0x0F12, 0x8079},	 // 70003CFC
-{0x0F12, 0x49DA},	 // 70003CFE
-{0x0F12, 0x8809},	 // 70003D00
-{0x0F12, 0x2900},	 // 70003D02
-{0x0F12, 0xD102},	 // 70003D04
-{0x0F12, 0xF000},	 // 70003D06
-{0x0F12, 0xFB07},	 // 70003D08
-{0x0F12, 0x2000},	 // 70003D0A
-{0x0F12, 0x9902},	 // 70003D0C
-{0x0F12, 0x6008},	 // 70003D0E
-{0x0F12, 0xBCFE},	 // 70003D10
-{0x0F12, 0xBC08},	 // 70003D12
-{0x0F12, 0x4718},	 // 70003D14
-{0x0F12, 0xB538},	 // 70003D16
-{0x0F12, 0x9C04},	 // 70003D18
-{0x0F12, 0x0015},	 // 70003D1A
-{0x0F12, 0x002A},	 // 70003D1C
-{0x0F12, 0x9400},	 // 70003D1E
-{0x0F12, 0xF000},	 // 70003D20
-{0x0F12, 0xFB02},	 // 70003D22
-{0x0F12, 0x4AD1},	 // 70003D24
-{0x0F12, 0x8811},	 // 70003D26
-{0x0F12, 0x2900},	 // 70003D28
-{0x0F12, 0xD00F},	 // 70003D2A
-{0x0F12, 0x8820},	 // 70003D2C
-{0x0F12, 0x4281},	 // 70003D2E
-{0x0F12, 0xD20C},	 // 70003D30
-{0x0F12, 0x8861},	 // 70003D32
-{0x0F12, 0x8853},	 // 70003D34
-{0x0F12, 0x4299},	 // 70003D36
-{0x0F12, 0xD200},	 // 70003D38
-{0x0F12, 0x1E40},	 // 70003D3A
-{0x0F12, 0x0400},	 // 70003D3C
-{0x0F12, 0x0C00},	 // 70003D3E
-{0x0F12, 0x8020},	 // 70003D40
-{0x0F12, 0x8851},	 // 70003D42
-{0x0F12, 0x8061},	 // 70003D44
-{0x0F12, 0x4368},	 // 70003D46
-{0x0F12, 0x1840},	 // 70003D48
-{0x0F12, 0x6060},	 // 70003D4A
-{0x0F12, 0xBC38},	 // 70003D4C
-{0x0F12, 0xBC08},	 // 70003D4E
-{0x0F12, 0x4718},	 // 70003D50
-{0x0F12, 0xB5F8},	 // 70003D52
-{0x0F12, 0x0004},	 // 70003D54
-{0x0F12, 0x6808},	 // 70003D56
-{0x0F12, 0x0400},	 // 70003D58
-{0x0F12, 0x0C00},	 // 70003D5A
-{0x0F12, 0x2201},	 // 70003D5C
-{0x0F12, 0x0015},	 // 70003D5E
-{0x0F12, 0x0021},	 // 70003D60
-{0x0F12, 0x3910},	 // 70003D62
-{0x0F12, 0x408A},	 // 70003D64
-{0x0F12, 0x40A5},	 // 70003D66
-{0x0F12, 0x4FBE},	 // 70003D68
-{0x0F12, 0x0016},	 // 70003D6A
-{0x0F12, 0x2C10},	 // 70003D6C
-{0x0F12, 0xDA03},	 // 70003D6E
-{0x0F12, 0x8839},	 // 70003D70
-{0x0F12, 0x43A9},	 // 70003D72
-{0x0F12, 0x8039},	 // 70003D74
-{0x0F12, 0xE002},	 // 70003D76
-{0x0F12, 0x8879},	 // 70003D78
-{0x0F12, 0x43B1},	 // 70003D7A
-{0x0F12, 0x8079},	 // 70003D7C
-{0x0F12, 0xF000},	 // 70003D7E
-{0x0F12, 0xFADB},	 // 70003D80
-{0x0F12, 0x2C10},	 // 70003D82
-{0x0F12, 0xDA03},	 // 70003D84
-{0x0F12, 0x8838},	 // 70003D86
-{0x0F12, 0x4328},	 // 70003D88
-{0x0F12, 0x8038},	 // 70003D8A
-{0x0F12, 0xE002},	 // 70003D8C
-{0x0F12, 0x8878},	 // 70003D8E
-{0x0F12, 0x4330},	 // 70003D90
-{0x0F12, 0x8078},	 // 70003D92
-{0x0F12, 0x48B6},	 // 70003D94
-{0x0F12, 0x8800},	 // 70003D96
-{0x0F12, 0x0400},	 // 70003D98
-{0x0F12, 0xD507},	 // 70003D9A
-{0x0F12, 0x4BB5},	 // 70003D9C
-{0x0F12, 0x7819},	 // 70003D9E
-{0x0F12, 0x4AB5},	 // 70003DA0
-{0x0F12, 0x7810},	 // 70003DA2
-{0x0F12, 0x7018},	 // 70003DA4
-{0x0F12, 0x7011},	 // 70003DA6
-{0x0F12, 0x49B4},	 // 70003DA8
-{0x0F12, 0x8188},	 // 70003DAA
-{0x0F12, 0xBCF8},	 // 70003DAC
-{0x0F12, 0xBC08},	 // 70003DAE
-{0x0F12, 0x4718},	 // 70003DB0
-{0x0F12, 0xB538},	 // 70003DB2
-{0x0F12, 0x48B2},	 // 70003DB4
-{0x0F12, 0x4669},	 // 70003DB6
-{0x0F12, 0xF000},	 // 70003DB8
-{0x0F12, 0xFAC6},	 // 70003DBA
-{0x0F12, 0x48B1},	 // 70003DBC
-{0x0F12, 0x49B0},	 // 70003DBE
-{0x0F12, 0x69C2},	 // 70003DC0
-{0x0F12, 0x2400},	 // 70003DC2
-{0x0F12, 0x31A8},	 // 70003DC4
-{0x0F12, 0x2A00},	 // 70003DC6
-{0x0F12, 0xD008},	 // 70003DC8
-{0x0F12, 0x61C4},	 // 70003DCA
-{0x0F12, 0x684A},	 // 70003DCC
-{0x0F12, 0x6242},	 // 70003DCE
-{0x0F12, 0x6282},	 // 70003DD0
-{0x0F12, 0x466B},	 // 70003DD2
-{0x0F12, 0x881A},	 // 70003DD4
-{0x0F12, 0x6302},	 // 70003DD6
-{0x0F12, 0x885A},	 // 70003DD8
-{0x0F12, 0x6342},	 // 70003DDA
-{0x0F12, 0x6A02},	 // 70003DDC
-{0x0F12, 0x2A00},	 // 70003DDE
-{0x0F12, 0xD00A},	 // 70003DE0
-{0x0F12, 0x6204},	 // 70003DE2
-{0x0F12, 0x6849},	 // 70003DE4
-{0x0F12, 0x6281},	 // 70003DE6
-{0x0F12, 0x466B},	 // 70003DE8
-{0x0F12, 0x8819},	 // 70003DEA
-{0x0F12, 0x6301},	 // 70003DEC
-{0x0F12, 0x8859},	 // 70003DEE
-{0x0F12, 0x6341},	 // 70003DF0
-{0x0F12, 0x49A5},	 // 70003DF2
-{0x0F12, 0x88C9},	 // 70003DF4
-{0x0F12, 0x63C1},	 // 70003DF6
-{0x0F12, 0xF000},	 // 70003DF8
-{0x0F12, 0xFAAE},	 // 70003DFA
-{0x0F12, 0xE7A6},	 // 70003DFC
-{0x0F12, 0xB5F0},	 // 70003DFE
-{0x0F12, 0xB08B},	 // 70003E00
-{0x0F12, 0x20FF},	 // 70003E02
-{0x0F12, 0x1C40},	 // 70003E04
-{0x0F12, 0x49A1},	 // 70003E06
-{0x0F12, 0x89CC},	 // 70003E08
-{0x0F12, 0x4E9E},	 // 70003E0A
-{0x0F12, 0x6AB1},	 // 70003E0C
-{0x0F12, 0x4284},	 // 70003E0E
-{0x0F12, 0xD101},	 // 70003E10
-{0x0F12, 0x489F},	 // 70003E12
-{0x0F12, 0x6081},	 // 70003E14
-{0x0F12, 0x6A70},	 // 70003E16
-{0x0F12, 0x0200},	 // 70003E18
-{0x0F12, 0xF000},	 // 70003E1A
-{0x0F12, 0xFAA5},	 // 70003E1C
-{0x0F12, 0x0400},	 // 70003E1E
-{0x0F12, 0x0C00},	 // 70003E20
-{0x0F12, 0x4A96},	 // 70003E22
-{0x0F12, 0x8A11},	 // 70003E24
-{0x0F12, 0x9109},	 // 70003E26
-{0x0F12, 0x2101},	 // 70003E28
-{0x0F12, 0x0349},	 // 70003E2A
-{0x0F12, 0x4288},	 // 70003E2C
-{0x0F12, 0xD200},	 // 70003E2E
-{0x0F12, 0x0001},	 // 70003E30
-{0x0F12, 0x4A92},	 // 70003E32
-{0x0F12, 0x8211},	 // 70003E34
-{0x0F12, 0x4D97},	 // 70003E36
-{0x0F12, 0x8829},	 // 70003E38
-{0x0F12, 0x9108},	 // 70003E3A
-{0x0F12, 0x4A8B},	 // 70003E3C
-{0x0F12, 0x2303},	 // 70003E3E
-{0x0F12, 0x3222},	 // 70003E40
-{0x0F12, 0x1F91},	 // 70003E42
-{0x0F12, 0xF000},	 // 70003E44
-{0x0F12, 0xFA96},	 // 70003E46
-{0x0F12, 0x8028},	 // 70003E48
-{0x0F12, 0x488E},	 // 70003E4A
-{0x0F12, 0x4987},	 // 70003E4C
-{0x0F12, 0x6BC2},	 // 70003E4E
-{0x0F12, 0x6AC0},	 // 70003E50
-{0x0F12, 0x4282},	 // 70003E52
-{0x0F12, 0xD201},	 // 70003E54
-{0x0F12, 0x8CC8},	 // 70003E56
-{0x0F12, 0x8028},	 // 70003E58
-{0x0F12, 0x88E8},	 // 70003E5A
-{0x0F12, 0x9007},	 // 70003E5C
-{0x0F12, 0x2240},	 // 70003E5E
-{0x0F12, 0x4310},	 // 70003E60
-{0x0F12, 0x80E8},	 // 70003E62
-{0x0F12, 0x2000},	 // 70003E64
-{0x0F12, 0x0041},	 // 70003E66
-{0x0F12, 0x194B},	 // 70003E68
-{0x0F12, 0x001E},	 // 70003E6A
-{0x0F12, 0x3680},	 // 70003E6C
-{0x0F12, 0x8BB2},	 // 70003E6E
-{0x0F12, 0xAF04},	 // 70003E70
-{0x0F12, 0x527A},	 // 70003E72
-{0x0F12, 0x4A7D},	 // 70003E74
-{0x0F12, 0x188A},	 // 70003E76
-{0x0F12, 0x8897},	 // 70003E78
-{0x0F12, 0x83B7},	 // 70003E7A
-{0x0F12, 0x33A0},	 // 70003E7C
-{0x0F12, 0x891F},	 // 70003E7E
-{0x0F12, 0xAE01},	 // 70003E80
-{0x0F12, 0x5277},	 // 70003E82
-{0x0F12, 0x8A11},	 // 70003E84
-{0x0F12, 0x8119},	 // 70003E86
-{0x0F12, 0x1C40},	 // 70003E88
-{0x0F12, 0x0400},	 // 70003E8A
-{0x0F12, 0x0C00},	 // 70003E8C
-{0x0F12, 0x2806},	 // 70003E8E
-{0x0F12, 0xD3E9},	 // 70003E90
-{0x0F12, 0xF000},	 // 70003E92
-{0x0F12, 0xFA77},	 // 70003E94
-{0x0F12, 0xF000},	 // 70003E96
-{0x0F12, 0xFA7D},	 // 70003E98
-{0x0F12, 0x4F79},	 // 70003E9A
-{0x0F12, 0x37A8},	 // 70003E9C
-{0x0F12, 0x2800},	 // 70003E9E
-{0x0F12, 0xD10A},	 // 70003EA0
-{0x0F12, 0x1FE0},	 // 70003EA2
-{0x0F12, 0x38FD},	 // 70003EA4
-{0x0F12, 0xD001},	 // 70003EA6
-{0x0F12, 0x1CC0},	 // 70003EA8
-{0x0F12, 0xD105},	 // 70003EAA
-{0x0F12, 0x4874},	 // 70003EAC
-{0x0F12, 0x8829},	 // 70003EAE
-{0x0F12, 0x3818},	 // 70003EB0
-{0x0F12, 0x6840},	 // 70003EB2
-{0x0F12, 0x4348},	 // 70003EB4
-{0x0F12, 0x6078},	 // 70003EB6
-{0x0F12, 0x4972},	 // 70003EB8
-{0x0F12, 0x6878},	 // 70003EBA
-{0x0F12, 0x6B89},	 // 70003EBC
-{0x0F12, 0x4288},	 // 70003EBE
-{0x0F12, 0xD300},	 // 70003EC0
-{0x0F12, 0x0008},	 // 70003EC2
-{0x0F12, 0x6078},	 // 70003EC4
-{0x0F12, 0x2000},	 // 70003EC6
-{0x0F12, 0x0041},	 // 70003EC8
-{0x0F12, 0xAA04},	 // 70003ECA
-{0x0F12, 0x5A53},	 // 70003ECC
-{0x0F12, 0x194A},	 // 70003ECE
-{0x0F12, 0x269C},	 // 70003ED0
-{0x0F12, 0x52B3},	 // 70003ED2
-{0x0F12, 0xAB01},	 // 70003ED4
-{0x0F12, 0x5A59},	 // 70003ED6
-{0x0F12, 0x32A0},	 // 70003ED8
-{0x0F12, 0x8111},	 // 70003EDA
-{0x0F12, 0x1C40},	 // 70003EDC
-{0x0F12, 0x0400},	 // 70003EDE
-{0x0F12, 0x0C00},	 // 70003EE0
-{0x0F12, 0x2806},	 // 70003EE2
-{0x0F12, 0xD3F0},	 // 70003EE4
-{0x0F12, 0x4965},	 // 70003EE6
-{0x0F12, 0x9809},	 // 70003EE8
-{0x0F12, 0x8208},	 // 70003EEA
-{0x0F12, 0x9808},	 // 70003EEC
-{0x0F12, 0x8028},	 // 70003EEE
-{0x0F12, 0x9807},	 // 70003EF0
-{0x0F12, 0x80E8},	 // 70003EF2
-{0x0F12, 0x1FE0},	 // 70003EF4
-{0x0F12, 0x38FD},	 // 70003EF6
-{0x0F12, 0xD13B},	 // 70003EF8
-{0x0F12, 0x4D64},	 // 70003EFA
-{0x0F12, 0x89E8},	 // 70003EFC
-{0x0F12, 0x1FC1},	 // 70003EFE
-{0x0F12, 0x39FF},	 // 70003F00
-{0x0F12, 0xD136},	 // 70003F02
-{0x0F12, 0x4C5F},	 // 70003F04
-{0x0F12, 0x8AE0},	 // 70003F06
-{0x0F12, 0xF000},	 // 70003F08
-{0x0F12, 0xFA4C},	 // 70003F0A
-{0x0F12, 0x0006},	 // 70003F0C
-{0x0F12, 0x8B20},	 // 70003F0E
-{0x0F12, 0xF000},	 // 70003F10
-{0x0F12, 0xFA50},	 // 70003F12
-{0x0F12, 0x9000},	 // 70003F14
-{0x0F12, 0x6AA1},	 // 70003F16
-{0x0F12, 0x6878},	 // 70003F18
-{0x0F12, 0x1809},	 // 70003F1A
-{0x0F12, 0x0200},	 // 70003F1C
-{0x0F12, 0xF000},	 // 70003F1E
-{0x0F12, 0xFA23},	 // 70003F20
-{0x0F12, 0x0400},	 // 70003F22
-{0x0F12, 0x0C00},	 // 70003F24
-{0x0F12, 0x0022},	 // 70003F26
-{0x0F12, 0x3246},	 // 70003F28
-{0x0F12, 0x0011},	 // 70003F2A
-{0x0F12, 0x310A},	 // 70003F2C
-{0x0F12, 0x2305},	 // 70003F2E
-{0x0F12, 0xF000},	 // 70003F30
-{0x0F12, 0xFA20},	 // 70003F32
-{0x0F12, 0x66E8},	 // 70003F34
-{0x0F12, 0x6B23},	 // 70003F36
-{0x0F12, 0x0002},	 // 70003F38
-{0x0F12, 0x0031},	 // 70003F3A
-{0x0F12, 0x0018},	 // 70003F3C
-{0x0F12, 0xF000},	 // 70003F3E
-{0x0F12, 0xFA41},	 // 70003F40
-{0x0F12, 0x466B},	 // 70003F42
-{0x0F12, 0x8518},	 // 70003F44
-{0x0F12, 0x6EEA},	 // 70003F46
-{0x0F12, 0x6B60},	 // 70003F48
-{0x0F12, 0x9900},	 // 70003F4A
-{0x0F12, 0xF000},	 // 70003F4C
-{0x0F12, 0xFA3A},	 // 70003F4E
-{0x0F12, 0x466B},	 // 70003F50
-{0x0F12, 0x8558},	 // 70003F52
-{0x0F12, 0x0029},	 // 70003F54
-{0x0F12, 0x980A},	 // 70003F56
-{0x0F12, 0x3170},	 // 70003F58
-{0x0F12, 0xF000},	 // 70003F5A
-{0x0F12, 0xFA3B},	 // 70003F5C
-{0x0F12, 0x0028},	 // 70003F5E
-{0x0F12, 0x3060},	 // 70003F60
-{0x0F12, 0x8A02},	 // 70003F62
-{0x0F12, 0x4946},	 // 70003F64
-{0x0F12, 0x3128},	 // 70003F66
-{0x0F12, 0x808A},	 // 70003F68
-{0x0F12, 0x8A42},	 // 70003F6A
-{0x0F12, 0x80CA},	 // 70003F6C
-{0x0F12, 0x8A80},	 // 70003F6E
-{0x0F12, 0x8108},	 // 70003F70
-{0x0F12, 0xB00B},	 // 70003F72
-{0x0F12, 0xBCF0},	 // 70003F74
-{0x0F12, 0xBC08},	 // 70003F76
-{0x0F12, 0x4718},	 // 70003F78
-{0x0F12, 0xB570},	 // 70003F7A
-{0x0F12, 0x2400},	 // 70003F7C
-{0x0F12, 0x4D46},	 // 70003F7E
-{0x0F12, 0x4846},	 // 70003F80
-{0x0F12, 0x8881},	 // 70003F82
-{0x0F12, 0x4846},	 // 70003F84
-{0x0F12, 0x8041},	 // 70003F86
-{0x0F12, 0x2101},	 // 70003F88
-{0x0F12, 0x8001},	 // 70003F8A
-{0x0F12, 0xF000},	 // 70003F8C
-{0x0F12, 0xFA2A},	 // 70003F8E
-{0x0F12, 0x4842},	 // 70003F90
-{0x0F12, 0x3820},	 // 70003F92
-{0x0F12, 0x8BC0},	 // 70003F94
-{0x0F12, 0xF000},	 // 70003F96
-{0x0F12, 0xFA2D},	 // 70003F98
-{0x0F12, 0x4B42},	 // 70003F9A
-{0x0F12, 0x220D},	 // 70003F9C
-{0x0F12, 0x0712},	 // 70003F9E
-{0x0F12, 0x18A8},	 // 70003FA0
-{0x0F12, 0x8806},	 // 70003FA2
-{0x0F12, 0x00E1},	 // 70003FA4
-{0x0F12, 0x18C9},	 // 70003FA6
-{0x0F12, 0x81CE},	 // 70003FA8
-{0x0F12, 0x8846},	 // 70003FAA
-{0x0F12, 0x818E},	 // 70003FAC
-{0x0F12, 0x8886},	 // 70003FAE
-{0x0F12, 0x824E},	 // 70003FB0
-{0x0F12, 0x88C0},	 // 70003FB2
-{0x0F12, 0x8208},	 // 70003FB4
-{0x0F12, 0x3508},	 // 70003FB6
-{0x0F12, 0x042D},	 // 70003FB8
-{0x0F12, 0x0C2D},	 // 70003FBA
-{0x0F12, 0x1C64},	 // 70003FBC
-{0x0F12, 0x0424},	 // 70003FBE
-{0x0F12, 0x0C24},	 // 70003FC0
-{0x0F12, 0x2C07},	 // 70003FC2
-{0x0F12, 0xD3EC},	 // 70003FC4
-{0x0F12, 0xE658},	 // 70003FC6
-{0x0F12, 0xB510},	 // 70003FC8
-{0x0F12, 0x4834},	 // 70003FCA
-{0x0F12, 0x4C34},	 // 70003FCC
-{0x0F12, 0x88C0},	 // 70003FCE
-{0x0F12, 0x8060},	 // 70003FD0
-{0x0F12, 0x2001},	 // 70003FD2
-{0x0F12, 0x8020},	 // 70003FD4
-{0x0F12, 0x4831},	 // 70003FD6
-{0x0F12, 0x3820},	 // 70003FD8
-{0x0F12, 0x8BC0},	 // 70003FDA
-{0x0F12, 0xF000},	 // 70003FDC
-{0x0F12, 0xFA0A},	 // 70003FDE
-{0x0F12, 0x88E0},	 // 70003FE0
-{0x0F12, 0x4A31},	 // 70003FE2
-{0x0F12, 0x2800},	 // 70003FE4
-{0x0F12, 0xD003},	 // 70003FE6
-{0x0F12, 0x4930},	 // 70003FE8
-{0x0F12, 0x8849},	 // 70003FEA
-{0x0F12, 0x2900},	 // 70003FEC
-{0x0F12, 0xD009},	 // 70003FEE
-{0x0F12, 0x2001},	 // 70003FF0
-{0x0F12, 0x03C0},	 // 70003FF2
-{0x0F12, 0x8050},	 // 70003FF4
-{0x0F12, 0x80D0},	 // 70003FF6
-{0x0F12, 0x2000},	 // 70003FF8
-{0x0F12, 0x8090},	 // 70003FFA
-{0x0F12, 0x8110},	 // 70003FFC
-{0x0F12, 0xBC10},	 // 70003FFE
-{0x0F12, 0xBC08},	 // 70004000
-{0x0F12, 0x4718},	 // 70004002
-{0x0F12, 0x8050},	 // 70004004
-{0x0F12, 0x8920},	 // 70004006
-{0x0F12, 0x80D0},	 // 70004008
-{0x0F12, 0x8960},	 // 7000400A
-{0x0F12, 0x0400},	 // 7000400C
-{0x0F12, 0x1400},	 // 7000400E
-{0x0F12, 0x8090},	 // 70004010
-{0x0F12, 0x89A1},	 // 70004012
-{0x0F12, 0x0409},	 // 70004014
-{0x0F12, 0x1409},	 // 70004016
-{0x0F12, 0x8111},	 // 70004018
-{0x0F12, 0x89E3},	 // 7000401A
-{0x0F12, 0x8A24},	 // 7000401C
-{0x0F12, 0x2B00},	 // 7000401E
-{0x0F12, 0xD104},	 // 70004020
-{0x0F12, 0x17C3},	 // 70004022
-{0x0F12, 0x0F5B},	 // 70004024
-{0x0F12, 0x1818},	 // 70004026
-{0x0F12, 0x10C0},	 // 70004028
-{0x0F12, 0x8090},	 // 7000402A
-{0x0F12, 0x2C00},	 // 7000402C
-{0x0F12, 0xD1E6},	 // 7000402E
-{0x0F12, 0x17C8},	 // 70004030
-{0x0F12, 0x0F40},	 // 70004032
-{0x0F12, 0x1840},	 // 70004034
-{0x0F12, 0x10C0},	 // 70004036
-{0x0F12, 0x8110},	 // 70004038
-{0x0F12, 0xE7E0},	 // 7000403A
-{0x0F12, 0xB510},	 // 7000403C
-{0x0F12, 0x000C},	 // 7000403E
-{0x0F12, 0x4919},	 // 70004040
-{0x0F12, 0x2204},	 // 70004042
-{0x0F12, 0x6820},	 // 70004044
-{0x0F12, 0x5E8A},	 // 70004046
-{0x0F12, 0x0140},	 // 70004048
-{0x0F12, 0x1A80},	 // 7000404A
-{0x0F12, 0x0280},	 // 7000404C
-{0x0F12, 0x8849},	 // 7000404E
-{0x0F12, 0xF000},	 // 70004050
-{0x0F12, 0xF9D8},	 // 70004052
-{0x0F12, 0x6020},	 // 70004054
-{0x0F12, 0xE7D2},	 // 70004056
-{0x0F12, 0x38D4},	 // 70004058
-{0x0F12, 0x7000},	 // 7000405A
-{0x0F12, 0x17D0},	 // 7000405C
-{0x0F12, 0x7000},	 // 7000405E
-{0x0F12, 0x5000},	 // 70004060
-{0x0F12, 0xD000},	 // 70004062
-{0x0F12, 0x1100},	 // 70004064
-{0x0F12, 0xD000},	 // 70004066
-{0x0F12, 0x171A},	 // 70004068
-{0x0F12, 0x7000},	 // 7000406A
-{0x0F12, 0x4780},	 // 7000406C
-{0x0F12, 0x7000},	 // 7000406E
-{0x0F12, 0x2FCA},	 // 70004070
-{0x0F12, 0x7000},	 // 70004072
-{0x0F12, 0x2FC5},	 // 70004074
-{0x0F12, 0x7000},	 // 70004076
-{0x0F12, 0x2FC6},	 // 70004078
-{0x0F12, 0x7000},	 // 7000407A
-{0x0F12, 0x2ED8},	 // 7000407C
-{0x0F12, 0x7000},	 // 7000407E
-{0x0F12, 0x2BD0},	 // 70004080
-{0x0F12, 0x7000},	 // 70004082
-{0x0F12, 0x17E0},	 // 70004084
-{0x0F12, 0x7000},	 // 70004086
-{0x0F12, 0x2DE8},	 // 70004088
-{0x0F12, 0x7000},	 // 7000408A
-{0x0F12, 0x37E0},	 // 7000408C
-{0x0F12, 0x7000},	 // 7000408E
-{0x0F12, 0x210C},	 // 70004090
-{0x0F12, 0x7000},	 // 70004092
-{0x0F12, 0x1484},	 // 70004094
-{0x0F12, 0x7000},	 // 70004096
-{0x0F12, 0xA006},	 // 70004098
-{0x0F12, 0x0000},	 // 7000409A
-{0x0F12, 0x0724},	 // 7000409C
-{0x0F12, 0x7000},	 // 7000409E
-{0x0F12, 0xA000},	 // 700040A0
-{0x0F12, 0xD000},	 // 700040A2
-{0x0F12, 0x2270},	 // 700040A4
-{0x0F12, 0x7000},	 // 700040A6
-{0x0F12, 0x2558},	 // 700040A8
-{0x0F12, 0x7000},	 // 700040AA
-{0x0F12, 0x146C},	 // 700040AC
-{0x0F12, 0x7000},	 // 700040AE
-{0x0F12, 0xB510},	 // 700040B0
-{0x0F12, 0x000C},	 // 700040B2
-{0x0F12, 0x4983},	 // 700040B4
-{0x0F12, 0x2208},	 // 700040B6
-{0x0F12, 0x6820},	 // 700040B8
-{0x0F12, 0x5E8A},	 // 700040BA
-{0x0F12, 0x0140},	 // 700040BC
-{0x0F12, 0x1A80},	 // 700040BE
-{0x0F12, 0x0280},	 // 700040C0
-{0x0F12, 0x88C9},	 // 700040C2
-{0x0F12, 0xF000},	 // 700040C4
-{0x0F12, 0xF99E},	 // 700040C6
-{0x0F12, 0x6020},	 // 700040C8
-{0x0F12, 0xE798},	 // 700040CA
-{0x0F12, 0xB5FE},	 // 700040CC
-{0x0F12, 0x000C},	 // 700040CE
-{0x0F12, 0x6825},	 // 700040D0
-{0x0F12, 0x6866},	 // 700040D2
-{0x0F12, 0x68A0},	 // 700040D4
-{0x0F12, 0x9001},	 // 700040D6
-{0x0F12, 0x68E7},	 // 700040D8
-{0x0F12, 0x1BA8},	 // 700040DA
-{0x0F12, 0x42B5},	 // 700040DC
-{0x0F12, 0xDA00},	 // 700040DE
-{0x0F12, 0x1B70},	 // 700040E0
-{0x0F12, 0x9000},	 // 700040E2
-{0x0F12, 0x4977},	 // 700040E4
-{0x0F12, 0x4878},	 // 700040E6
-{0x0F12, 0x884A},	 // 700040E8
-{0x0F12, 0x8843},	 // 700040EA
-{0x0F12, 0x435A},	 // 700040EC
-{0x0F12, 0x2304},	 // 700040EE
-{0x0F12, 0x5ECB},	 // 700040F0
-{0x0F12, 0x0A92},	 // 700040F2
-{0x0F12, 0x18D2},	 // 700040F4
-{0x0F12, 0x02D2},	 // 700040F6
-{0x0F12, 0x0C12},	 // 700040F8
-{0x0F12, 0x88CB},	 // 700040FA
-{0x0F12, 0x8880},	 // 700040FC
-{0x0F12, 0x4343},	 // 700040FE
-{0x0F12, 0x0A98},	 // 70004100
-{0x0F12, 0x2308},	 // 70004102
-{0x0F12, 0x5ECB},	 // 70004104
-{0x0F12, 0x18C0},	 // 70004106
-{0x0F12, 0x02C0},	 // 70004108
-{0x0F12, 0x0C00},	 // 7000410A
-{0x0F12, 0x0411},	 // 7000410C
-{0x0F12, 0x0400},	 // 7000410E
-{0x0F12, 0x1409},	 // 70004110
-{0x0F12, 0x1400},	 // 70004112
-{0x0F12, 0x1A08},	 // 70004114
-{0x0F12, 0x496C},	 // 70004116
-{0x0F12, 0x39E0},	 // 70004118
-{0x0F12, 0x6148},	 // 7000411A
-{0x0F12, 0x9801},	 // 7000411C
-{0x0F12, 0x3040},	 // 7000411E
-{0x0F12, 0x7880},	 // 70004120
-{0x0F12, 0x2800},	 // 70004122
-{0x0F12, 0xD103},	 // 70004124
-{0x0F12, 0x9801},	 // 70004126
-{0x0F12, 0x0029},	 // 70004128
-{0x0F12, 0xF000},	 // 7000412A
-{0x0F12, 0xF971},	 // 7000412C
-{0x0F12, 0x8839},	 // 7000412E
-{0x0F12, 0x9800},	 // 70004130
-{0x0F12, 0x4281},	 // 70004132
-{0x0F12, 0xD814},	 // 70004134
-{0x0F12, 0x8879},	 // 70004136
-{0x0F12, 0x9800},	 // 70004138
-{0x0F12, 0x4281},	 // 7000413A
-{0x0F12, 0xD20C},	 // 7000413C
-{0x0F12, 0x9801},	 // 7000413E
-{0x0F12, 0x0029},	 // 70004140
-{0x0F12, 0xF000},	 // 70004142
-{0x0F12, 0xF96D},	 // 70004144
-{0x0F12, 0x9801},	 // 70004146
-{0x0F12, 0x0029},	 // 70004148
-{0x0F12, 0xF000},	 // 7000414A
-{0x0F12, 0xF969},	 // 7000414C
-{0x0F12, 0x9801},	 // 7000414E
-{0x0F12, 0x0029},	 // 70004150
-{0x0F12, 0xF000},	 // 70004152
-{0x0F12, 0xF965},	 // 70004154
-{0x0F12, 0xE003},	 // 70004156
-{0x0F12, 0x9801},	 // 70004158
-{0x0F12, 0x0029},	 // 7000415A
-{0x0F12, 0xF000},	 // 7000415C
-{0x0F12, 0xF960},	 // 7000415E
-{0x0F12, 0x9801},	 // 70004160
-{0x0F12, 0x0032},	 // 70004162
-{0x0F12, 0x0039},	 // 70004164
-{0x0F12, 0xF000},	 // 70004166
-{0x0F12, 0xF963},	 // 70004168
-{0x0F12, 0x6020},	 // 7000416A
-{0x0F12, 0xE5D0},	 // 7000416C
-{0x0F12, 0xB57C},	 // 7000416E
-{0x0F12, 0x4856},	 // 70004170
-{0x0F12, 0xA901},	 // 70004172
-{0x0F12, 0x0004},	 // 70004174
-{0x0F12, 0xF000},	 // 70004176
-{0x0F12, 0xF8E7},	 // 70004178
-{0x0F12, 0x466B},	 // 7000417A
-{0x0F12, 0x88D9},	 // 7000417C
-{0x0F12, 0x8898},	 // 7000417E
-{0x0F12, 0x4B51},	 // 70004180
-{0x0F12, 0x3346},	 // 70004182
-{0x0F12, 0x1E9A},	 // 70004184
-{0x0F12, 0xF000},	 // 70004186
-{0x0F12, 0xF95B},	 // 70004188
-{0x0F12, 0x4850},	 // 7000418A
-{0x0F12, 0x494E},	 // 7000418C
-{0x0F12, 0x3812},	 // 7000418E
-{0x0F12, 0x3140},	 // 70004190
-{0x0F12, 0x8A42},	 // 70004192
-{0x0F12, 0x888B},	 // 70004194
-{0x0F12, 0x18D2},	 // 70004196
-{0x0F12, 0x8242},	 // 70004198
-{0x0F12, 0x8AC2},	 // 7000419A
-{0x0F12, 0x88C9},	 // 7000419C
-{0x0F12, 0x1851},	 // 7000419E
-{0x0F12, 0x82C1},	 // 700041A0
-{0x0F12, 0x0020},	 // 700041A2
-{0x0F12, 0x4669},	 // 700041A4
-{0x0F12, 0xF000},	 // 700041A6
-{0x0F12, 0xF8CF},	 // 700041A8
-{0x0F12, 0x4849},	 // 700041AA
-{0x0F12, 0x214D},	 // 700041AC
-{0x0F12, 0x8301},	 // 700041AE
-{0x0F12, 0x2196},	 // 700041B0
-{0x0F12, 0x8381},	 // 700041B2
-{0x0F12, 0x211D},	 // 700041B4
-{0x0F12, 0x3020},	 // 700041B6
-{0x0F12, 0x8001},	 // 700041B8
-{0x0F12, 0xF000},	 // 700041BA
-{0x0F12, 0xF949},	 // 700041BC
-{0x0F12, 0xF000},	 // 700041BE
-{0x0F12, 0xF94F},	 // 700041C0
-{0x0F12, 0x4844},	 // 700041C2
-{0x0F12, 0x4C44},	 // 700041C4
-{0x0F12, 0x6E00},	 // 700041C6
-{0x0F12, 0x60E0},	 // 700041C8
-{0x0F12, 0x466B},	 // 700041CA
-{0x0F12, 0x8818},	 // 700041CC
-{0x0F12, 0x8859},	 // 700041CE
-{0x0F12, 0x0025},	 // 700041D0
-{0x0F12, 0x1A40},	 // 700041D2
-{0x0F12, 0x3540},	 // 700041D4
-{0x0F12, 0x61A8},	 // 700041D6
-{0x0F12, 0x483B},	 // 700041D8
-{0x0F12, 0x9900},	 // 700041DA
-{0x0F12, 0x3060},	 // 700041DC
-{0x0F12, 0xF000},	 // 700041DE
-{0x0F12, 0xF947},	 // 700041E0
-{0x0F12, 0x466B},	 // 700041E2
-{0x0F12, 0x8819},	 // 700041E4
-{0x0F12, 0x1DE0},	 // 700041E6
-{0x0F12, 0x30F9},	 // 700041E8
-{0x0F12, 0x8741},	 // 700041EA
-{0x0F12, 0x8859},	 // 700041EC
-{0x0F12, 0x8781},	 // 700041EE
-{0x0F12, 0x2000},	 // 700041F0
-{0x0F12, 0x71A0},	 // 700041F2
-{0x0F12, 0x74A8},	 // 700041F4
-{0x0F12, 0xBC7C},	 // 700041F6
-{0x0F12, 0xBC08},	 // 700041F8
-{0x0F12, 0x4718},	 // 700041FA
-{0x0F12, 0xB5F8},	 // 700041FC
-{0x0F12, 0x0005},	 // 700041FE
-{0x0F12, 0x6808},	 // 70004200
-{0x0F12, 0x0400},	 // 70004202
-{0x0F12, 0x0C00},	 // 70004204
-{0x0F12, 0x684A},	 // 70004206
-{0x0F12, 0x0412},	 // 70004208
-{0x0F12, 0x0C12},	 // 7000420A
-{0x0F12, 0x688E},	 // 7000420C
-{0x0F12, 0x68CC},	 // 7000420E
-{0x0F12, 0x492C},	 // 70004210
-{0x0F12, 0x884B},	 // 70004212
-{0x0F12, 0x4343},	 // 70004214
-{0x0F12, 0x0A98},	 // 70004216
-{0x0F12, 0x2304},	 // 70004218
-{0x0F12, 0x5ECB},	 // 7000421A
-{0x0F12, 0x18C0},	 // 7000421C
-{0x0F12, 0x02C0},	 // 7000421E
-{0x0F12, 0x0C00},	 // 70004220
-{0x0F12, 0x88CB},	 // 70004222
-{0x0F12, 0x4353},	 // 70004224
-{0x0F12, 0x0A9A},	 // 70004226
-{0x0F12, 0x2308},	 // 70004228
-{0x0F12, 0x5ECB},	 // 7000422A
-{0x0F12, 0x18D1},	 // 7000422C
-{0x0F12, 0x02C9},	 // 7000422E
-{0x0F12, 0x0C09},	 // 70004230
-{0x0F12, 0x2701},	 // 70004232
-{0x0F12, 0x003A},	 // 70004234
-{0x0F12, 0x40AA},	 // 70004236
-{0x0F12, 0x9200},	 // 70004238
-{0x0F12, 0x002A},	 // 7000423A
-{0x0F12, 0x3A10},	 // 7000423C
-{0x0F12, 0x4097},	 // 7000423E
-{0x0F12, 0x2D10},	 // 70004240
-{0x0F12, 0xDA06},	 // 70004242
-{0x0F12, 0x4A25},	 // 70004244
-{0x0F12, 0x9B00},	 // 70004246
-{0x0F12, 0x8812},	 // 70004248
-{0x0F12, 0x439A},	 // 7000424A
-{0x0F12, 0x4B23},	 // 7000424C
-{0x0F12, 0x801A},	 // 7000424E
-{0x0F12, 0xE003},	 // 70004250
-{0x0F12, 0x4B22},	 // 70004252
-{0x0F12, 0x885A},	 // 70004254
-{0x0F12, 0x43BA},	 // 70004256
-{0x0F12, 0x805A},	 // 70004258
-{0x0F12, 0x0023},	 // 7000425A
-{0x0F12, 0x0032},	 // 7000425C
-{0x0F12, 0xF000},	 // 7000425E
-{0x0F12, 0xF8EF},	 // 70004260
-{0x0F12, 0x2D10},	 // 70004262
-{0x0F12, 0xDA05},	 // 70004264
-{0x0F12, 0x491D},	 // 70004266
-{0x0F12, 0x9A00},	 // 70004268
-{0x0F12, 0x8808},	 // 7000426A
-{0x0F12, 0x4310},	 // 7000426C
-{0x0F12, 0x8008},	 // 7000426E
-{0x0F12, 0xE003},	 // 70004270
-{0x0F12, 0x481A},	 // 70004272
-{0x0F12, 0x8841},	 // 70004274
-{0x0F12, 0x4339},	 // 70004276
-{0x0F12, 0x8041},	 // 70004278
-{0x0F12, 0x4D17},	 // 7000427A
-{0x0F12, 0x2000},	 // 7000427C
-{0x0F12, 0x3580},	 // 7000427E
-{0x0F12, 0x88AA},	 // 70004280
-{0x0F12, 0x5E30},	 // 70004282
-{0x0F12, 0x2100},	 // 70004284
-{0x0F12, 0xF000},	 // 70004286
-{0x0F12, 0xF8FB},	 // 70004288
-{0x0F12, 0x8030},	 // 7000428A
-{0x0F12, 0x2000},	 // 7000428C
-{0x0F12, 0x88AA},	 // 7000428E
-{0x0F12, 0x5E20},	 // 70004290
-{0x0F12, 0x2100},	 // 70004292
-{0x0F12, 0xF000},	 // 70004294
-{0x0F12, 0xF8F4},	 // 70004296
-{0x0F12, 0x8020},	 // 70004298
-{0x0F12, 0xE587},	 // 7000429A
-{0x0F12, 0xB510},	 // 7000429C
-{0x0F12, 0xF000},	 // 7000429E
-{0x0F12, 0xF8F7},	 // 700042A0
-{0x0F12, 0x4A0F},	 // 700042A2
-{0x0F12, 0x8D50},	 // 700042A4
-{0x0F12, 0x2800},	 // 700042A6
-{0x0F12, 0xD007},	 // 700042A8
-{0x0F12, 0x490A},	 // 700042AA
-{0x0F12, 0x31C0},	 // 700042AC
-{0x0F12, 0x684B},	 // 700042AE
-{0x0F12, 0x490C},	 // 700042B0
-{0x0F12, 0x4283},	 // 700042B2
-{0x0F12, 0xD202},	 // 700042B4
-{0x0F12, 0x8D90},	 // 700042B6
-{0x0F12, 0x81C8},	 // 700042B8
-{0x0F12, 0xE6A0},	 // 700042BA
-{0x0F12, 0x8DD0},	 // 700042BC
-{0x0F12, 0x81C8},	 // 700042BE
-{0x0F12, 0xE69D},	 // 700042C0
-{0x0F12, 0x0000},	 // 700042C2
-{0x0F12, 0x2558},	 // 700042C4
-{0x0F12, 0x7000},	 // 700042C6
-{0x0F12, 0x2AB8},	 // 700042C8
-{0x0F12, 0x7000},	 // 700042CA
-{0x0F12, 0x145E},	 // 700042CC
-{0x0F12, 0x7000},	 // 700042CE
-{0x0F12, 0x2698},	 // 700042D0
-{0x0F12, 0x7000},	 // 700042D2
-{0x0F12, 0x2BB8},	 // 700042D4
-{0x0F12, 0x7000},	 // 700042D6
-{0x0F12, 0x2998},	 // 700042D8
-{0x0F12, 0x7000},	 // 700042DA
-{0x0F12, 0x1100},	 // 700042DC
-{0x0F12, 0xD000},	 // 700042DE
-{0x0F12, 0x4780},	 // 700042E0
-{0x0F12, 0x7000},	 // 700042E2
-{0x0F12, 0xE200},	 // 700042E4
-{0x0F12, 0xD000},	 // 700042E6
-{0x0F12, 0x4778},	 // 700042E8
-{0x0F12, 0x46C0},	 // 700042EA
-{0x0F12, 0xC000},	 // 700042EC
-{0x0F12, 0xE59F},	 // 700042EE
-{0x0F12, 0xFF1C},	 // 700042F0
-{0x0F12, 0xE12F},	 // 700042F2
-{0x0F12, 0x1789},	 // 700042F4
-{0x0F12, 0x0001},	 // 700042F6
-{0x0F12, 0x4778},	 // 700042F8
-{0x0F12, 0x46C0},	 // 700042FA
-{0x0F12, 0xC000},	 // 700042FC
-{0x0F12, 0xE59F},	 // 700042FE
-{0x0F12, 0xFF1C},	 // 70004300
-{0x0F12, 0xE12F},	 // 70004302
-{0x0F12, 0x16F1},	 // 70004304
-{0x0F12, 0x0001},	 // 70004306
-{0x0F12, 0x4778},	 // 70004308
-{0x0F12, 0x46C0},	 // 7000430A
-{0x0F12, 0xC000},	 // 7000430C
-{0x0F12, 0xE59F},	 // 7000430E
-{0x0F12, 0xFF1C},	 // 70004310
-{0x0F12, 0xE12F},	 // 70004312
-{0x0F12, 0xC3B1},	 // 70004314
-{0x0F12, 0x0000},	 // 70004316
-{0x0F12, 0x4778},	 // 70004318
-{0x0F12, 0x46C0},	 // 7000431A
-{0x0F12, 0xC000},	 // 7000431C
-{0x0F12, 0xE59F},	 // 7000431E
-{0x0F12, 0xFF1C},	 // 70004320
-{0x0F12, 0xE12F},	 // 70004322
-{0x0F12, 0xC36D},	 // 70004324
-{0x0F12, 0x0000},	 // 70004326
-{0x0F12, 0x4778},	 // 70004328
-{0x0F12, 0x46C0},	 // 7000432A
-{0x0F12, 0xC000},	 // 7000432C
-{0x0F12, 0xE59F},	 // 7000432E
-{0x0F12, 0xFF1C},	 // 70004330
-{0x0F12, 0xE12F},	 // 70004332
-{0x0F12, 0xF6D7},	 // 70004334
-{0x0F12, 0x0000},	 // 70004336
-{0x0F12, 0x4778},	 // 70004338
-{0x0F12, 0x46C0},	 // 7000433A
-{0x0F12, 0xC000},	 // 7000433C
-{0x0F12, 0xE59F},	 // 7000433E
-{0x0F12, 0xFF1C},	 // 70004340
-{0x0F12, 0xE12F},	 // 70004342
-{0x0F12, 0xB49D},	 // 70004344
-{0x0F12, 0x0000},	 // 70004346
-{0x0F12, 0x4778},	 // 70004348
-{0x0F12, 0x46C0},	 // 7000434A
-{0x0F12, 0xC000},	 // 7000434C
-{0x0F12, 0xE59F},	 // 7000434E
-{0x0F12, 0xFF1C},	 // 70004350
-{0x0F12, 0xE12F},	 // 70004352
-{0x0F12, 0x7EDF},	 // 70004354
-{0x0F12, 0x0000},	 // 70004356
-{0x0F12, 0x4778},	 // 70004358
-{0x0F12, 0x46C0},	 // 7000435A
-{0x0F12, 0xC000},	 // 7000435C
-{0x0F12, 0xE59F},	 // 7000435E
-{0x0F12, 0xFF1C},	 // 70004360
-{0x0F12, 0xE12F},	 // 70004362
-{0x0F12, 0x448D},	 // 70004364
-{0x0F12, 0x0000},	 // 70004366
-{0x0F12, 0x4778},	 // 70004368
-{0x0F12, 0x46C0},	 // 7000436A
-{0x0F12, 0xF004},	 // 7000436C
-{0x0F12, 0xE51F},	 // 7000436E
-{0x0F12, 0x29EC},	 // 70004370
-{0x0F12, 0x0001},	 // 70004372
-{0x0F12, 0x4778},	 // 70004374
-{0x0F12, 0x46C0},	 // 70004376
-{0x0F12, 0xC000},	 // 70004378
-{0x0F12, 0xE59F},	 // 7000437A
-{0x0F12, 0xFF1C},	 // 7000437C
-{0x0F12, 0xE12F},	 // 7000437E
-{0x0F12, 0x2EF1},	 // 70004380
-{0x0F12, 0x0000},	 // 70004382
-{0x0F12, 0x4778},	 // 70004384
-{0x0F12, 0x46C0},	 // 70004386
-{0x0F12, 0xC000},	 // 70004388
-{0x0F12, 0xE59F},	 // 7000438A
-{0x0F12, 0xFF1C},	 // 7000438C
-{0x0F12, 0xE12F},	 // 7000438E
-{0x0F12, 0xEE03},	 // 70004390
-{0x0F12, 0x0000},	 // 70004392
-{0x0F12, 0x4778},	 // 70004394
-{0x0F12, 0x46C0},	 // 70004396
-{0x0F12, 0xC000},	 // 70004398
-{0x0F12, 0xE59F},	 // 7000439A
-{0x0F12, 0xFF1C},	 // 7000439C
-{0x0F12, 0xE12F},	 // 7000439E
-{0x0F12, 0xA58B},	 // 700043A0
-{0x0F12, 0x0000},	 // 700043A2
-{0x0F12, 0x4778},	 // 700043A4
-{0x0F12, 0x46C0},	 // 700043A6
-{0x0F12, 0xC000},	 // 700043A8
-{0x0F12, 0xE59F},	 // 700043AA
-{0x0F12, 0xFF1C},	 // 700043AC
-{0x0F12, 0xE12F},	 // 700043AE
-{0x0F12, 0x7C49},	 // 700043B0
-{0x0F12, 0x0000},	 // 700043B2
-{0x0F12, 0x4778},	 // 700043B4
-{0x0F12, 0x46C0},	 // 700043B6
-{0x0F12, 0xC000},	 // 700043B8
-{0x0F12, 0xE59F},	 // 700043BA
-{0x0F12, 0xFF1C},	 // 700043BC
-{0x0F12, 0xE12F},	 // 700043BE
-{0x0F12, 0x7C63},	 // 700043C0
-{0x0F12, 0x0000},	 // 700043C2
-{0x0F12, 0x4778},	 // 700043C4
-{0x0F12, 0x46C0},	 // 700043C6
-{0x0F12, 0xC000},	 // 700043C8
-{0x0F12, 0xE59F},	 // 700043CA
-{0x0F12, 0xFF1C},	 // 700043CC
-{0x0F12, 0xE12F},	 // 700043CE
-{0x0F12, 0x2DB7},	 // 700043D0
-{0x0F12, 0x0000},	 // 700043D2
-{0x0F12, 0x4778},	 // 700043D4
-{0x0F12, 0x46C0},	 // 700043D6
-{0x0F12, 0xC000},	 // 700043D8
-{0x0F12, 0xE59F},	 // 700043DA
-{0x0F12, 0xFF1C},	 // 700043DC
-{0x0F12, 0xE12F},	 // 700043DE
-{0x0F12, 0xEB3D},	 // 700043E0
-{0x0F12, 0x0000},	 // 700043E2
-{0x0F12, 0x4778},	 // 700043E4
-{0x0F12, 0x46C0},	 // 700043E6
-{0x0F12, 0xC000},	 // 700043E8
-{0x0F12, 0xE59F},	 // 700043EA
-{0x0F12, 0xFF1C},	 // 700043EC
-{0x0F12, 0xE12F},	 // 700043EE
-{0x0F12, 0xF061},	 // 700043F0
-{0x0F12, 0x0000},	 // 700043F2
-{0x0F12, 0x4778},	 // 700043F4
-{0x0F12, 0x46C0},	 // 700043F6
-{0x0F12, 0xC000},	 // 700043F8
-{0x0F12, 0xE59F},	 // 700043FA
-{0x0F12, 0xFF1C},	 // 700043FC
-{0x0F12, 0xE12F},	 // 700043FE
-{0x0F12, 0xF0EF},	 // 70004400
-{0x0F12, 0x0000},	 // 70004402
-{0x0F12, 0x4778},	 // 70004404
-{0x0F12, 0x46C0},	 // 70004406
-{0x0F12, 0xF004},	 // 70004408
-{0x0F12, 0xE51F},	 // 7000440A
-{0x0F12, 0x2824},	 // 7000440C
-{0x0F12, 0x0001},	 // 7000440E
-{0x0F12, 0x4778},	 // 70004410
-{0x0F12, 0x46C0},	 // 70004412
-{0x0F12, 0xC000},	 // 70004414
-{0x0F12, 0xE59F},	 // 70004416
-{0x0F12, 0xFF1C},	 // 70004418
-{0x0F12, 0xE12F},	 // 7000441A
-{0x0F12, 0x8EDD},	 // 7000441C
-{0x0F12, 0x0000},	 // 7000441E
-{0x0F12, 0x4778},	 // 70004420
-{0x0F12, 0x46C0},	 // 70004422
-{0x0F12, 0xC000},	 // 70004424
-{0x0F12, 0xE59F},	 // 70004426
-{0x0F12, 0xFF1C},	 // 70004428
-{0x0F12, 0xE12F},	 // 7000442A
-{0x0F12, 0x8DCB},	 // 7000442C
-{0x0F12, 0x0000},	 // 7000442E
-{0x0F12, 0x4778},	 // 70004430
-{0x0F12, 0x46C0},	 // 70004432
-{0x0F12, 0xC000},	 // 70004434
-{0x0F12, 0xE59F},	 // 70004436
-{0x0F12, 0xFF1C},	 // 70004438
-{0x0F12, 0xE12F},	 // 7000443A
-{0x0F12, 0x8E17},	 // 7000443C
-{0x0F12, 0x0000},	 // 7000443E
-{0x0F12, 0x4778},	 // 70004440
-{0x0F12, 0x46C0},	 // 70004442
-{0x0F12, 0xC000},	 // 70004444
-{0x0F12, 0xE59F},	 // 70004446
-{0x0F12, 0xFF1C},	 // 70004448
-{0x0F12, 0xE12F},	 // 7000444A
-{0x0F12, 0x98C5},	 // 7000444C
-{0x0F12, 0x0000},	 // 7000444E
-{0x0F12, 0x4778},	 // 70004450
-{0x0F12, 0x46C0},	 // 70004452
-{0x0F12, 0xC000},	 // 70004454
-{0x0F12, 0xE59F},	 // 70004456
-{0x0F12, 0xFF1C},	 // 70004458
-{0x0F12, 0xE12F},	 // 7000445A
-{0x0F12, 0x7C7D},	 // 7000445C
-{0x0F12, 0x0000},	 // 7000445E
-{0x0F12, 0x4778},	 // 70004460
-{0x0F12, 0x46C0},	 // 70004462
-{0x0F12, 0xC000},	 // 70004464
-{0x0F12, 0xE59F},	 // 70004466
-{0x0F12, 0xFF1C},	 // 70004468
-{0x0F12, 0xE12F},	 // 7000446A
-{0x0F12, 0x7E31},	 // 7000446C
-{0x0F12, 0x0000},	 // 7000446E
-{0x0F12, 0x4778},	 // 70004470
-{0x0F12, 0x46C0},	 // 70004472
-{0x0F12, 0xC000},	 // 70004474
-{0x0F12, 0xE59F},	 // 70004476
-{0x0F12, 0xFF1C},	 // 70004478
-{0x0F12, 0xE12F},	 // 7000447A
-{0x0F12, 0x7EAB},	 // 7000447C
-{0x0F12, 0x0000},	 // 7000447E
-{0x0F12, 0x4778},	 // 70004480
-{0x0F12, 0x46C0},	 // 70004482
-{0x0F12, 0xC000},	 // 70004484
-{0x0F12, 0xE59F},	 // 70004486
-{0x0F12, 0xFF1C},	 // 70004488
-{0x0F12, 0xE12F},	 // 7000448A
-{0x0F12, 0x7501},	 // 7000448C
-{0x0F12, 0x0000},	 // 7000448E
-{0x0F12, 0x4778},	 // 70004490
-{0x0F12, 0x46C0},	 // 70004492
-{0x0F12, 0xC000},	 // 70004494
-{0x0F12, 0xE59F},	 // 70004496
-{0x0F12, 0xFF1C},	 // 70004498
-{0x0F12, 0xE12F},	 // 7000449A
-{0x0F12, 0xF63F},	 // 7000449C
-{0x0F12, 0x0000},	 // 7000449E
-
-// End of Patch Data(Last : 7000449Eh)
-// Total Size 2472 (09A8)           
-// Addr : 3AF8  Size : 2470(9A6h)    
-
-//TNP_USER_MBCV_CONTROL
-//TNP_4EC_MBR_TUNE
-//TNP_4EC_FORBIDDEN_TUNE
-//TNP_AF_FINESEARCH_DRIVEBACK
-//TNP_FLASH_ALG
-//TNP_GAS_ALPHA_OTP
-//TNP_AWB_MODUL_COMP
-//TNP_AWB_INIT_QUEUE
-//TNP_AWB_GRID_LOWBR
-//TNP_AWB_GRID_MODULECOMP
-
-{0x0028, 0xD000}, 
-{0x002A, 0x1000}, 
-{0x0F12, 0x0001},
+
+{0x0028,0x7000},
+{0x002A,0x3AF8},
+{0x0F12,0xB5F8},	//  70003AF8
+{0x0F12,0x4B4D},	//  70003AFA
+{0x0F12,0x494D},	//  70003AFC
+{0x0F12,0x484E},	//  70003AFE
+{0x0F12,0x2200},	//  70003B00
+{0x0F12,0xC008},	//  70003B02
+{0x0F12,0x6001},	//  70003B04
+{0x0F12,0x494D},	//  70003B06
+{0x0F12,0x484D},	//  70003B08
+{0x0F12,0x2401},	//  70003B0A
+{0x0F12,0xF000},	//  70003B0C
+{0x0F12,0xFCDE},	//  70003B0E
+{0x0F12,0x494C},	//  70003B10
+{0x0F12,0x484D},	//  70003B12
+{0x0F12,0x2702},	//  70003B14
+{0x0F12,0x0022},	//  70003B16
+{0x0F12,0xF000},	//  70003B18
+{0x0F12,0xFCD8},	//  70003B1A
+{0x0F12,0x0260},	//  70003B1C
+{0x0F12,0x4C4B},	//  70003B1E
+{0x0F12,0x8020},	//  70003B20
+{0x0F12,0x2000},	//  70003B22
+{0x0F12,0x8060},	//  70003B24
+{0x0F12,0x484A},	//  70003B26
+{0x0F12,0x4E4A},	//  70003B28
+{0x0F12,0x6070},	//  70003B2A
+{0x0F12,0x494A},	//  70003B2C
+{0x0F12,0x484B},	//  70003B2E
+{0x0F12,0x003A},	//  70003B30
+{0x0F12,0x2503},	//  70003B32
+{0x0F12,0xF000},	//  70003B34
+{0x0F12,0xFCCA},	//  70003B36
+{0x0F12,0x4949},	//  70003B38
+{0x0F12,0x1DF0},	//  70003B3A
+{0x0F12,0x30F9},	//  70003B3C
+{0x0F12,0x6001},	//  70003B3E
+{0x0F12,0x4948},	//  70003B40
+{0x0F12,0x3840},	//  70003B42
+{0x0F12,0x63C1},	//  70003B44
+{0x0F12,0x4848},	//  70003B46
+{0x0F12,0x0037},	//  70003B48
+{0x0F12,0x3F80},	//  70003B4A
+{0x0F12,0x6438},	//  70003B4C
+{0x0F12,0x4847},	//  70003B4E
+{0x0F12,0x4947},	//  70003B50
+{0x0F12,0x6388},	//  70003B52
+{0x0F12,0x002A},	//  70003B54
+{0x0F12,0x4947},	//  70003B56
+{0x0F12,0x4847},	//  70003B58
+{0x0F12,0x2504},	//  70003B5A
+{0x0F12,0xF000},	//  70003B5C
+{0x0F12,0xFCB6},	//  70003B5E
+{0x0F12,0x002A},	//  70003B60
+{0x0F12,0x4946},	//  70003B62
+{0x0F12,0x4846},	//  70003B64
+{0x0F12,0x2505},	//  70003B66
+{0x0F12,0xF000},	//  70003B68
+{0x0F12,0xF8C2},	//  70003B6A
+{0x0F12,0x4844},	//  70003B6C
+{0x0F12,0x002A},	//  70003B6E
+{0x0F12,0x4944},	//  70003B70
+{0x0F12,0x2506},	//  70003B72
+{0x0F12,0x1D80},	//  70003B74
+{0x0F12,0xF000},	//  70003B76
+{0x0F12,0xF8BB},	//  70003B78
+{0x0F12,0x4841},	//  70003B7A
+{0x0F12,0x002A},	//  70003B7C
+{0x0F12,0x4942},	//  70003B7E
+{0x0F12,0x2507},	//  70003B80
+{0x0F12,0x300C},	//  70003B82
+{0x0F12,0xF000},	//  70003B84
+{0x0F12,0xF8B4},	//  70003B86
+{0x0F12,0x483D},	//  70003B88
+{0x0F12,0x002A}, // 70003B8A
+{0x0F12,0x493F},	//  70003B8C
+{0x0F12,0x2508},	//  70003B8E
+{0x0F12,0x3010},	//  70003B90
+{0x0F12,0xF000},	//  70003B92
+{0x0F12,0xF8AD},	//  70003B94
+{0x0F12,0x002A},	//  70003B96
+{0x0F12,0x493D},	//  70003B98
+{0x0F12,0x483E},	//  70003B9A
+{0x0F12,0x2509},	//  70003B9C
+{0x0F12,0xF000},	//  70003B9E
+{0x0F12,0xFC95},	//  70003BA0
+{0x0F12,0x002A},	//  70003BA2
+{0x0F12,0x493C},	//  70003BA4
+{0x0F12,0x483D},	//  70003BA6
+{0x0F12,0x250A},	//  70003BA8
+{0x0F12,0xF000},	//  70003BAA
+{0x0F12,0xFC8F},	//  70003BAC
+{0x0F12,0x002A},	//  70003BAE
+{0x0F12,0x493B},	//  70003BB0
+{0x0F12,0x483C},	//  70003BB2
+{0x0F12,0x250B},	//  70003BB4
+{0x0F12,0xF000},	//  70003BB6
+{0x0F12,0xFC89},	//  70003BB8
+{0x0F12,0x002A},	//  70003BBA
+{0x0F12,0x493A},	//  70003BBC
+{0x0F12,0x483B},	//  70003BBE
+{0x0F12,0x250C},	//  70003BC0
+{0x0F12,0xF000},	//  70003BC2
+{0x0F12,0xFC83},	//  70003BC4
+{0x0F12,0x002A},	//  70003BC6
+{0x0F12,0x4939},	//  70003BC8
+{0x0F12,0x483A},	//  70003BCA
+{0x0F12,0x250D},	//  70003BCC
+{0x0F12,0xF000},	//  70003BCE
+{0x0F12,0xFC7D},	//  70003BD0
+{0x0F12,0x002A},	//  70003BD2
+{0x0F12,0x4938},	//  70003BD4
+{0x0F12,0x4839},	//  70003BD6
+{0x0F12,0x250E},	//  70003BD8
+{0x0F12,0xF000},	//  70003BDA
+{0x0F12,0xFC77},	//  70003BDC
+{0x0F12,0x002A},	//  70003BDE
+{0x0F12,0x4937},	//  70003BE0
+{0x0F12,0x4838},	//  70003BE2
+{0x0F12,0x250F},	//  70003BE4
+{0x0F12,0xF000},	//  70003BE6
+{0x0F12,0xFC71},	//  70003BE8
+{0x0F12,0x002A},	//  70003BEA
+{0x0F12,0x4936},	//  70003BEC
+{0x0F12,0x4837},	//  70003BEE
+{0x0F12,0x2510},	//  70003BF0
+{0x0F12,0xF000},	//  70003BF2
+{0x0F12,0xFC6B},	//  70003BF4
+{0x0F12,0x002A},	//  70003BF6
+{0x0F12,0x4935},	//  70003BF8
+{0x0F12,0x4836},	//  70003BFA
+{0x0F12,0x2511},	//  70003BFC
+{0x0F12,0xF000},	//  70003BFE
+{0x0F12,0xFC65},	//  70003C00
+{0x0F12,0x4835},	//  70003C02
+{0x0F12,0x61B0},	//  70003C04
+{0x0F12,0x2000},	//  70003C06
+{0x0F12,0x8620},	//  70003C08
+{0x0F12,0x20FF},	//  70003C0A
+{0x0F12,0x1C40},	//  70003C0C
+{0x0F12,0x8660},	//  70003C0E
+{0x0F12,0x4832},	//  70003C10
+{0x0F12,0x64F8},	//  70003C12
+{0x0F12,0x4932},	//  70003C14
+{0x0F12,0x4833},	//  70003C16
+{0x0F12,0x2412},	//  70003C18
+{0x0F12,0x002A},	//  70003C1A
+{0x0F12,0xF000},	//  70003C1C
+{0x0F12,0xFC56},	//  70003C1E
+{0x0F12,0x4931},	//  70003C20
+{0x0F12,0x4832},	//  70003C22
+{0x0F12,0x0022},	//  70003C24
+{0x0F12,0xF000},	//  70003C26
+{0x0F12,0xFC51},	//  70003C28
+{0x0F12,0xBCF8},	//  70003C2A
+{0x0F12,0xBC08},	//  70003C2C
+{0x0F12,0x4718},	//  70003C2E
+{0x0F12,0x0184},	//  70003C30
+{0x0F12,0x4EC2},	//  70003C32
+{0x0F12,0x77FF},	//  70003C34
+{0x0F12,0x0000},	//  70003C36
+{0x0F12,0x1F90},	//  70003C38
+{0x0F12,0x7000},	//  70003C3A
+{0x0F12,0x3D09},	//  70003C3C
+{0x0F12,0x7000},	//  70003C3E
+{0x0F12,0xE38B},	//  70003C40
+{0x0F12,0x0000},	//  70003C42
+{0x0F12,0x3D41},	//  70003C44
+{0x0F12,0x7000},	//  70003C46
+{0x0F12,0xC3B1},	//  70003C48
+{0x0F12,0x0000},	//  70003C4A
+{0x0F12,0x4780},	//  70003C4C
+{0x0F12,0x7000},	//  70003C4E
+{0x0F12,0x3D9F},	//  70003C50
+{0x0F12,0x7000},	//  70003C52
+{0x0F12,0x0080},	//  70003C54
+{0x0F12,0x7000},	//  70003C56
+{0x0F12,0x3DDB},	//  70003C58
+{0x0F12,0x7000},//  70003C5A
+{0x0F12,0xB49D},	//  70003C5C
+{0x0F12,0x0000},	//  70003C5E
+{0x0F12,0x4003},	//  70003C60
+{0x0F12,0x7000},	//  70003C62
+{0x0F12,0x3E87},	//  70003C64
+{0x0F12,0x7000},	//  70003C66
+{0x0F12,0x3E3B},	//  70003C68
+{0x0F12,0x7000},	//  70003C6A
+{0x0F12,0xFFFF},	//  70003C6C
+{0x0F12,0x00FF},	//  70003C6E
+{0x0F12,0x17E0},	//  70003C70
+{0x0F12,0x7000},	//  70003C72
+{0x0F12,0x4021},	//  70003C74
+{0x0F12,0x7000},	//  70003C76
+{0x0F12,0x053D},	//  70003C78
+{0x0F12,0x0000},	//  70003C7A
+{0x0F12,0x0000},	//  70003C7C
+{0x0F12,0x0A89},	//  70003C7E
+{0x0F12,0x6CD2},	//  70003C80
+{0x0F12,0x0000},	//  70003C82
+{0x0F12,0x02C9},	//  70003C84
+{0x0F12,0x0000},	//  70003C86
+{0x0F12,0x0000},	//  70003C88
+{0x0F12,0x0A9A},	//  70003C8A
+{0x0F12,0x0000},	//  70003C8C
+{0x0F12,0x02D2},	//  70003C8E
+{0x0F12,0x406F},	//  70003C90
+{0x0F12,0x7000},	//  70003C92
+{0x0F12,0x9E65},	//  70003C94
+{0x0F12,0x0000},	//  70003C96
+{0x0F12,0x4141},	//  70003C98
+{0x0F12,0x7000},	//  70003C9A
+{0x0F12,0x7C49},	//  70003C9C
+{0x0F12,0x0000},	//  70003C9E
+{0x0F12,0x415D},	//  70003CA0
+{0x0F12,0x7000},	//  70003CA2
+{0x0F12,0x7C63},	//  70003CA4
+{0x0F12,0x0000},	//  70003CA6
+{0x0F12,0x4179},	//  70003CA8
+{0x0F12,0x7000},	//  70003CAA
+{0x0F12,0x8F01},	//  70003CAC
+{0x0F12,0x0000},	//  70003CAE
+{0x0F12,0x421B},	//  70003CB0
+{0x0F12,0x7000},	//  70003CB2
+{0x0F12,0x7F3F},	//  70003CB4
+{0x0F12,0x0000},	//  70003CB6
+{0x0F12,0x42A9},	//  70003CB8
+{0x0F12,0x7000},	//  70003CBA
+{0x0F12,0x98C5},	//  70003CBC
+{0x0F12,0x0000},	//  70003CBE
+{0x0F12,0x4349},	//  70003CC0
+{0x0F12,0x7000},	//  70003CC2
+{0x0F12,0xCE75},	//  70003CC4
+{0x0F12,0x0000},	//  70003CC6
+{0x0F12,0x4447},	//  70003CC8
+{0x0F12,0x7000},	//  70003CCA
+{0x0F12,0x6099},	//  70003CCC
+{0x0F12,0x0000},	//  70003CCE
+{0x0F12,0x4445},	//  70003CD0
+{0x0F12,0x7000},	//  70003CD2
+{0x0F12,0xF87F},	//  70003CD4
+{0x0F12,0x0000},	//  70003CD6
+{0x0F12,0x443D},	//  70003CD8
+{0x0F12,0x7000},	//  70003CDA
+{0x0F12,0x4397},	//  70003CDC
+{0x0F12,0x7000},	//  70003CDE
+{0x0F12,0x43ED},	//  70003CE0
+{0x0F12,0x7000},	//  70003CE2
+{0x0F12,0xA70B},	//  70003CE4
+{0x0F12,0x0000},	//  70003CE6
+{0x0F12,0x440F},	//  70003CE8
+{0x0F12,0x7000},	//  70003CEA
+{0x0F12,0x400D},	//  70003CEC
+{0x0F12,0x0000},	//  70003CEE
+{0x0F12,0xB570},	//  70003CF0
+{0x0F12,0x000C},	//  70003CF2
+{0x0F12,0x0015},	//  70003CF4
+{0x0F12,0x0029},	//  70003CF6
+{0x0F12,0xF000},	//  70003CF8
+{0x0F12,0xFBF0},	//  70003CFA
+{0x0F12,0x49F9},	//  70003CFC
+{0x0F12,0x00A8},	//  70003CFE
+{0x0F12,0x500C},	//  70003D00
+{0x0F12,0xBC70},	//  70003D02
+{0x0F12,0xBC08},	//  70003D04
+{0x0F12,0x4718},	//  70003D06
+{0x0F12,0x6808},	//  70003D08
+{0x0F12,0x0400},	//  70003D0A
+{0x0F12,0x0C00},	//  70003D0C
+{0x0F12,0x6849},	//  70003D0E
+{0x0F12,0x0409},	//  70003D10
+{0x0F12,0x0C09},	//  70003D12
+{0x0F12,0x4AF4},	//  70003D14
+{0x0F12,0x8992},	//  70003D16
+{0x0F12,0x2A00},	//  70003D18
+{0x0F12,0xD00D},	//  70003D1A
+{0x0F12,0x2300},	//  70003D1C
+{0x0F12,0x1A89},	//  70003D1E
+{0x0F12,0xD400},	//  70003D20
+{0x0F12,0x000B},	//  70003D22
+{0x0F12,0x0419},	//  70003D24
+{0x0F12,0x0C09},	//  70003D26
+{0x0F12,0x23FF},	//  70003D28
+{0x0F12,0x33C1},	//  70003D2A
+{0x0F12,0x1810},	//  70003D2C
+{0x0F12,0x4298},	//  70003D2E
+{0x0F12,0xD800},	//  70003D30
+{0x0F12,0x0003},	//  70003D32
+{0x0F12,0x0418},	//  70003D34
+{0x0F12,0x0C00},	//  70003D36
+{0x0F12,0x4AEC},	//  70003D38
+{0x0F12,0x8150},	//  70003D3A
+{0x0F12,0x8191},	//  70003D3C
+{0x0F12,0x4770},	//  70003D3E
+{0x0F12,0xB5F3},	//  70003D40
+{0x0F12,0x0004},	//  70003D42
+{0x0F12,0xB081},	//  70003D44
+{0x0F12,0x9802},	//  70003D46
+{0x0F12,0x6800},	//  70003D48
+{0x0F12,0x0600},	//  70003D4A
+{0x0F12,0x0E00},	//  70003D4C
+{0x0F12,0x2201},	//  70003D4E
+{0x0F12,0x0015},	//  70003D50
+{0x0F12,0x0021},	//  70003D52
+{0x0F12,0x3910},	//  70003D54
+{0x0F12,0x408A},	//  70003D56
+{0x0F12,0x40A5},	//  70003D58
+{0x0F12,0x4FE5},	//  70003D5A
+{0x0F12,0x0016},	//  70003D5C
+{0x0F12,0x2C10},	//  70003D5E
+{0x0F12,0xDA03},	//  70003D60
+{0x0F12,0x8839},	//  70003D62
+{0x0F12,0x43A9},	//  70003D64
+{0x0F12,0x8039},	//  70003D66
+{0x0F12,0xE002},	//  70003D68
+{0x0F12,0x8879},	//  70003D6A
+{0x0F12,0x43B1},	//  70003D6C
+{0x0F12,0x8079},	//  70003D6E
+{0x0F12,0xF000},	//  70003D70
+{0x0F12,0xFBBC},	//  70003D72
+{0x0F12,0x2C10},	//  70003D74
+{0x0F12,0xDA03},	//  70003D76
+{0x0F12,0x8839},	//  70003D78
+{0x0F12,0x4329},	//  70003D7A
+{0x0F12,0x8039},	//  70003D7C
+{0x0F12,0xE002},	//  70003D7E
+{0x0F12,0x8879},	//  70003D80
+{0x0F12,0x4331},	//  70003D82
+{0x0F12,0x8079},	//  70003D84
+{0x0F12,0x49DB},	//  70003D86
+{0x0F12,0x8809},	//  70003D88
+{0x0F12,0x2900},	//  70003D8A
+{0x0F12,0xD102},	//  70003D8C
+{0x0F12,0xF000},	//  70003D8E
+{0x0F12,0xFBB5},	//  70003D90
+{0x0F12,0x2000},	//  70003D92
+{0x0F12,0x9902},	//  70003D94
+{0x0F12,0x6008},	//  70003D96
+{0x0F12,0xBCFE},	//  70003D98
+{0x0F12,0xBC08},	//  70003D9A
+{0x0F12,0x4718},	//  70003D9C
+{0x0F12,0xB538},	//  70003D9E
+{0x0F12,0x9C04},	//  70003DA0
+{0x0F12,0x0015},	//  70003DA2
+{0x0F12,0x002A},	//  70003DA4
+{0x0F12,0x9400},	//  70003DA6
+{0x0F12,0xF000},	//  70003DA8
+{0x0F12,0xFBB0},	//  70003DAA
+{0x0F12,0x4AD2},	//  70003DAC
+{0x0F12,0x8811},	//  70003DAE
+{0x0F12,0x2900},	//  70003DB0
+{0x0F12,0xD00F},	//  70003DB2
+{0x0F12,0x8820},	//  70003DB4
+{0x0F12,0x4281},	//  70003DB6
+{0x0F12,0xD20C},	//  70003DB8
+{0x0F12,0x8861},	//  70003DBA
+{0x0F12,0x8853},	//  70003DBC
+{0x0F12,0x4299},	//  70003DBE
+{0x0F12,0xD200},	//  70003DC0
+{0x0F12,0x1E40},	//  70003DC2
+{0x0F12,0x0400},	//  70003DC4
+{0x0F12,0x0C00},	//  70003DC6
+{0x0F12,0x8020},	//  70003DC8
+{0x0F12,0x8851},	//  70003DCA
+{0x0F12,0x8061},	//  70003DCC
+{0x0F12,0x4368},	//  70003DCE
+{0x0F12,0x1840},	//  70003DD0
+{0x0F12,0x6060},	//  70003DD2
+{0x0F12,0xBC38},	//  70003DD4
+{0x0F12,0xBC08},	//  70003DD6
+{0x0F12,0x4718},	//  70003DD8
+{0x0F12,0xB5F8},	//  70003DDA
+{0x0F12,0x0004},	//  70003DDC
+{0x0F12,0x6808},	//  70003DDE
+{0x0F12,0x0400},	//  70003DE0
+{0x0F12,0x0C00},	//  70003DE2
+{0x0F12,0x2201},	//  70003DE4
+{0x0F12,0x0015},	//  70003DE6
+{0x0F12,0x0021},	//  70003DE8
+{0x0F12,0x3910},	//  70003DEA
+{0x0F12,0x408A},	//  70003DEC
+{0x0F12,0x40A5},	//  70003DEE
+{0x0F12,0x4FBF},	//  70003DF0
+{0x0F12,0x0016},	//  70003DF2
+{0x0F12,0x2C10},	//  70003DF4
+{0x0F12,0xDA03},	//  70003DF6
+{0x0F12,0x8839},	//  70003DF8
+{0x0F12,0x43A9},	//  70003DFA
+{0x0F12,0x8039},	//  70003DFC
+{0x0F12,0xE002},	//  70003DFE
+{0x0F12,0x8879},	//  70003E00
+{0x0F12,0x43B1},	//  70003E02
+{0x0F12,0x8079},	//  70003E04
+{0x0F12,0xF000},	//  70003E06
+{0x0F12,0xFB89},	//  70003E08
+{0x0F12,0x2C10},	//  70003E0A
+{0x0F12,0xDA03},	//  70003E0C
+{0x0F12,0x8838},	//  70003E0E
+{0x0F12,0x4328},	//  70003E10
+{0x0F12,0x8038},	//  70003E12
+{0x0F12,0xE002},	//  70003E14
+{0x0F12,0x8878},	//  70003E16
+{0x0F12,0x4330},	//  70003E18
+{0x0F12,0x8078},	//  70003E1A
+{0x0F12,0x48B7},	//  70003E1C
+{0x0F12,0x8800},	//  70003E1E
+{0x0F12,0x0400},	//  70003E20
+{0x0F12,0xD507},	//  70003E22
+{0x0F12,0x4BB6},	//  70003E24
+{0x0F12,0x7819},	//  70003E26
+{0x0F12,0x4AB6},	//  70003E28
+{0x0F12,0x7810},	//  70003E2A
+{0x0F12,0x7018},	//  70003E2C
+{0x0F12,0x7011},	//  70003E2E
+{0x0F12,0x49B5},	//  70003E30
+{0x0F12,0x8188},	//  70003E32
+{0x0F12,0xBCF8},	//  70003E34
+{0x0F12,0xBC08},	//  70003E36
+{0x0F12,0x4718},	//  70003E38
+{0x0F12,0xB538},	//  70003E3A
+{0x0F12,0x48B3},	//  70003E3C
+{0x0F12,0x4669},	//  70003E3E
+{0x0F12,0xF000},	//  70003E40
+{0x0F12,0xFB74},	//  70003E42
+{0x0F12,0x48B2},	//  70003E44
+{0x0F12,0x49B1},	//  70003E46
+{0x0F12,0x69C2},	//  70003E48
+{0x0F12,0x2400},	//  70003E4A
+{0x0F12,0x31A8},	//  70003E4C
+{0x0F12,0x2A00},	//  70003E4E
+{0x0F12,0xD008},	//  70003E50
+{0x0F12,0x61C4},	//  70003E52
+{0x0F12,0x684A},	//  70003E54
+{0x0F12,0x6242},	//  70003E56
+{0x0F12,0x6282},	//  70003E58
+{0x0F12,0x466B},	//  70003E5A
+{0x0F12,0x881A},	//  70003E5C
+{0x0F12,0x6302},	//  70003E5E
+{0x0F12,0x885A},	//  70003E60
+{0x0F12,0x6342},	//  70003E62
+{0x0F12,0x6A02},	//  70003E64
+{0x0F12,0x2A00},	//  70003E66
+{0x0F12,0xD00A},	//  70003E68
+{0x0F12,0x6204},	//  70003E6A
+{0x0F12,0x6849},	//  70003E6C
+{0x0F12,0x6281},	//  70003E6E
+{0x0F12,0x466B},	//  70003E70
+{0x0F12,0x8819},	//  70003E72
+{0x0F12,0x6301},	//  70003E74
+{0x0F12,0x8859},	//  70003E76
+{0x0F12,0x6341},	//  70003E78
+{0x0F12,0x49A6},	//  70003E7A
+{0x0F12,0x88C9},	//  70003E7C
+{0x0F12,0x63C1},	//  70003E7E
+{0x0F12,0xF000},	//  70003E80
+{0x0F12,0xFB5C},	//  70003E82
+{0x0F12,0xE7A6},	//  70003E84
+{0x0F12,0xB5F0},	//  70003E86
+{0x0F12,0xB08B},	//  70003E88
+{0x0F12,0x20FF},	//  70003E8A
+{0x0F12,0x1C40},	//  70003E8C
+{0x0F12,0x49A2},	//  70003E8E
+{0x0F12,0x89CC},	//  70003E90
+{0x0F12,0x4E9F},	//  70003E92
+{0x0F12,0x6AB1},	//  70003E94
+{0x0F12,0x4284},	//  70003E96
+{0x0F12,0xD101},	//  70003E98
+{0x0F12,0x48A0},	//  70003E9A
+{0x0F12,0x6081},	//  70003E9C
+{0x0F12,0x6A70},	//  70003E9E
+{0x0F12,0x0200},	//  70003EA0
+{0x0F12,0xF000},	//  70003EA2
+{0x0F12,0xFB53},	//  70003EA4
+{0x0F12,0x0400},	//  70003EA6
+{0x0F12,0x0C00},	//  70003EA8
+{0x0F12,0x4A97},	//  70003EAA
+{0x0F12,0x8A11},	//  70003EAC
+{0x0F12,0x9109},	//  70003EAE
+{0x0F12,0x2101},	//  70003EB0
+{0x0F12,0x0349},	//  70003EB2
+{0x0F12,0x4288},	//  70003EB4
+{0x0F12,0xD200},	//  70003EB6
+{0x0F12,0x0001},	//  70003EB8
+{0x0F12,0x4A93},	//  70003EBA
+{0x0F12,0x8211},	//  70003EBC
+{0x0F12,0x4D98},	//  70003EBE
+{0x0F12,0x8829},	//  70003EC0
+{0x0F12,0x9108},	//  70003EC2
+{0x0F12,0x4A8C},	//  70003EC4
+{0x0F12,0x2303},	//  70003EC6
+{0x0F12,0x3222},	//  70003EC8
+{0x0F12,0x1F91},	//  70003ECA
+{0x0F12,0xF000},	//  70003ECC
+{0x0F12,0xFB44},	//  70003ECE
+{0x0F12,0x8028},	//  70003ED0
+{0x0F12,0x488F},	//  70003ED2
+{0x0F12,0x4988},	//  70003ED4
+{0x0F12,0x6BC2},	//  70003ED6
+{0x0F12,0x6AC0},	//  70003ED8
+{0x0F12,0x4282},	//  70003EDA
+{0x0F12,0xD201},	//  70003EDC
+{0x0F12,0x8CC8},	//  70003EDE
+{0x0F12,0x8028},	//  70003EE0
+{0x0F12,0x88E8},	//  70003EE2
+{0x0F12,0x9007},	//  70003EE4
+{0x0F12,0x2240},	//  70003EE6
+{0x0F12,0x4310},	//  70003EE8
+{0x0F12,0x80E8},	//  70003EEA
+{0x0F12,0x2000},	//  70003EEC
+{0x0F12,0x0041},	//  70003EEE
+{0x0F12,0x194B},	//  70003EF0
+{0x0F12,0x001E},	//  70003EF2
+{0x0F12,0x3680},	//  70003EF4
+{0x0F12,0x8BB2},	//  70003EF6
+{0x0F12,0xAF04},	//  70003EF8
+{0x0F12,0x527A},	//  70003EFA
+{0x0F12,0x4A7E},	//  70003EFC
+{0x0F12,0x188A},	//  70003EFE
+{0x0F12,0x8897},	//  70003F00
+{0x0F12,0x83B7},	//  70003F02
+{0x0F12,0x33A0},	//  70003F04
+{0x0F12,0x891F},	//  70003F06
+{0x0F12,0xAE01},	//  70003F08
+{0x0F12,0x5277},	//  70003F0A
+{0x0F12,0x8A11},	//  70003F0C
+{0x0F12,0x8119},	//  70003F0E
+{0x0F12,0x1C40},	//  70003F10
+{0x0F12,0x0400},	//  70003F12
+{0x0F12,0x0C00},	//  70003F14
+{0x0F12,0x2806},	//  70003F16
+{0x0F12,0xD3E9},	//  70003F18
+{0x0F12,0xF000},	//  70003F1A
+{0x0F12,0xFB25},	//  70003F1C
+{0x0F12,0xF000},	//  70003F1E
+{0x0F12,0xFB2B},	//  70003F20
+{0x0F12,0x4F7A},	//  70003F22
+{0x0F12,0x37A8},	//  70003F24
+{0x0F12,0x2800},	//  70003F26
+{0x0F12,0xD10A},	//  70003F28
+{0x0F12,0x1FE0},	//  70003F2A
+{0x0F12,0x38FD},	//  70003F2C
+{0x0F12,0xD001},	//  70003F2E
+{0x0F12,0x1CC0},	//  70003F30
+{0x0F12,0xD105},	//  70003F32
+{0x0F12,0x4875},	//  70003F34
+{0x0F12,0x8829},	//  70003F36
+{0x0F12,0x3818},	//  70003F38
+{0x0F12,0x6840},	//  70003F3A
+{0x0F12,0x4348},	//  70003F3C
+{0x0F12,0x6078},	//  70003F3E
+{0x0F12,0x4973},	//  70003F40
+{0x0F12,0x6878},	//  70003F42
+{0x0F12,0x6B89},	//  70003F44
+{0x0F12,0x4288},	//  70003F46
+{0x0F12,0xD300},	//  70003F48
+{0x0F12,0x0008},	//  70003F4A
+{0x0F12,0x6078},	//  70003F4C
+{0x0F12,0x2000},	//  70003F4E
+{0x0F12,0x0041},	//  70003F50
+{0x0F12,0xAA04},	//  70003F52
+{0x0F12,0x5A53},	//  70003F54
+{0x0F12,0x194A},	//  70003F56
+{0x0F12,0x269C},	//  70003F58
+{0x0F12,0x52B3},	//  70003F5A
+{0x0F12,0xAB01},	//  70003F5C
+{0x0F12,0x5A59},	//  70003F5E
+{0x0F12,0x32A0},	//  70003F60
+{0x0F12,0x8111},	//  70003F62
+{0x0F12,0x1C40},	//  70003F64
+{0x0F12,0x0400},	//  70003F66
+{0x0F12,0x0C00},	//  70003F68
+{0x0F12,0x2806},	//  70003F6A
+{0x0F12,0xD3F0},	//  70003F6C
+{0x0F12,0x4966},	//  70003F6E
+{0x0F12,0x9809},	//  70003F70
+{0x0F12,0x8208},	//  70003F72
+{0x0F12,0x9808},	//  70003F74
+{0x0F12,0x8028},	//  70003F76
+{0x0F12,0x9807},	//  70003F78
+{0x0F12,0x80E8},	//  70003F7A
+{0x0F12,0x1FE0},	//  70003F7C
+{0x0F12,0x38FD},	//  70003F7E
+{0x0F12,0xD13B},	//  70003F80
+{0x0F12,0x4D65},	//  70003F82
+{0x0F12,0x89E8},	//  70003F84
+{0x0F12,0x1FC1},	//  70003F86
+{0x0F12,0x39FF},	//  70003F88
+{0x0F12,0xD136},	//  70003F8A
+{0x0F12,0x4C60},	//  70003F8C
+{0x0F12,0x8AE0},	//  70003F8E
+{0x0F12,0xF000},	//  70003F90
+{0x0F12,0xFAFA},	//  70003F92
+{0x0F12,0x0006},	//  70003F94
+{0x0F12,0x8B20},	//  70003F96
+{0x0F12,0xF000},	//  70003F98
+{0x0F12,0xFAFE},	//  70003F9A
+{0x0F12,0x9000},	//  70003F9C
+{0x0F12,0x6AA1},	//  70003F9E
+{0x0F12,0x6878},	//  70003FA0
+{0x0F12,0x1809},	//  70003FA2
+{0x0F12,0x0200},	//  70003FA4
+{0x0F12,0xF000},	//  70003FA6
+{0x0F12,0xFAD1},	//  70003FA8
+{0x0F12,0x0400},	//  70003FAA
+{0x0F12,0x0C00},	//  70003FAC
+{0x0F12,0x0022},	//  70003FAE
+{0x0F12,0x3246},	//  70003FB0
+{0x0F12,0x0011},	//  70003FB2
+{0x0F12,0x310A},	//  70003FB4
+{0x0F12,0x2305},	//  70003FB6
+{0x0F12,0xF000},	//  70003FB8
+{0x0F12,0xFACE},	//  70003FBA
+{0x0F12,0x66E8},	//  70003FBC
+{0x0F12,0x6B23},	//  70003FBE
+{0x0F12,0x0002},	//  70003FC0
+{0x0F12,0x0031},	//  70003FC2
+{0x0F12,0x0018},	//  70003FC4
+{0x0F12,0xF000},	//  70003FC6
+{0x0F12,0xFAEF},	//  70003FC8
+{0x0F12,0x466B},	//  70003FCA
+{0x0F12,0x8518},	//  70003FCC
+{0x0F12,0x6EEA},	//  70003FCE
+{0x0F12,0x6B60},	//  70003FD0
+{0x0F12,0x9900},	//  70003FD2
+{0x0F12,0xF000},	//  70003FD4
+{0x0F12,0xFAE8},	//  70003FD6
+{0x0F12,0x466B},	//  70003FD8
+{0x0F12,0x8558},	//  70003FDA
+{0x0F12,0x0029},	//  70003FDC
+{0x0F12,0x980A},	//  70003FDE
+{0x0F12,0x3170},	//  70003FE0
+{0x0F12,0xF000},	//  70003FE2
+{0x0F12,0xFAE9},	//  70003FE4
+{0x0F12,0x0028},	//  70003FE6
+{0x0F12,0x3060},	//  70003FE8
+{0x0F12,0x8A02},	//  70003FEA
+{0x0F12,0x4947},	//  70003FEC
+{0x0F12,0x3128},	//  70003FEE
+{0x0F12,0x808A},	//  70003FF0
+{0x0F12,0x8A42},	//  70003FF2
+{0x0F12,0x80CA},	//  70003FF4
+{0x0F12,0x8A80},	//  70003FF6
+{0x0F12,0x8108},	//  70003FF8
+{0x0F12,0xB00B},	//  70003FFA
+{0x0F12,0xBCF0},	//  70003FFC
+{0x0F12,0xBC08},	//  70003FFE
+{0x0F12,0x4718},	//  70004000
+{0x0F12,0x4845},	//  70004002
+{0x0F12,0x3060},	//  70004004
+{0x0F12,0x8881},	//  70004006
+{0x0F12,0x2900},	//  70004008
+{0x0F12,0xD007},	//  7000400A
+{0x0F12,0x2100},	//  7000400C
+{0x0F12,0x8081},	//  7000400E
+{0x0F12,0x4944},	//  70004010
+{0x0F12,0x20FF},	//  70004012
+{0x0F12,0x1C40},	//  70004014
+{0x0F12,0x8048},	//  70004016
+{0x0F12,0x2001},	//  70004018
+{0x0F12,0x4770},	//  7000401A
+{0x0F12,0x2000},	//  7000401C
+{0x0F12,0x4770},	//  7000401E
+{0x0F12,0xB570},	//  70004020
+{0x0F12,0x2400},	//  70004022
+{0x0F12,0x4D40},	//  70004024
+{0x0F12,0x4841},	//  70004026
+{0x0F12,0x8881},	//  70004028
+{0x0F12,0x4841},	//  7000402A
+{0x0F12,0x8041},	//  7000402C
+{0x0F12,0x2101},	//  7000402E
+{0x0F12,0x8001},	//  70004030
+{0x0F12,0xF000},	//  70004032
+{0x0F12,0xFAC9},	//  70004034
+{0x0F12,0x483D},	//  70004036
+{0x0F12,0x3820},	//  70004038
+{0x0F12,0x8BC0},	//  7000403A
+{0x0F12,0xF000},	//  7000403C
+{0x0F12,0xFACC},	//  7000403E
+{0x0F12,0x4B3C},	//  70004040
+{0x0F12,0x220D},	//  70004042
+{0x0F12,0x0712},	//  70004044
+{0x0F12,0x18A8},	//  70004046
+{0x0F12,0x8806},	//  70004048
+{0x0F12,0x00E1},	//  7000404A
+{0x0F12,0x18C9},	//  7000404C
+{0x0F12,0x81CE},	//  7000404E
+{0x0F12,0x8846},	//  70004050
+{0x0F12,0x818E},	//  70004052
+{0x0F12,0x8886},	//  70004054
+{0x0F12,0x824E},	//  70004056
+{0x0F12,0x88C0},	//  70004058
+{0x0F12,0x8208},	//  7000405A
+{0x0F12,0x3508},	//  7000405C
+{0x0F12,0x042D},	//  7000405E
+{0x0F12,0x0C2D},	//  70004060
+{0x0F12,0x1C64},	//  70004062
+{0x0F12,0x0424},	//  70004064
+{0x0F12,0x0C24},	//  70004066
+{0x0F12,0x2C07},	//  70004068
+{0x0F12,0xD3EC},	//  7000406A
+{0x0F12,0xE649},	//  7000406C
+{0x0F12,0xB510},	//  7000406E
+{0x0F12,0x482E},	//  70004070
+{0x0F12,0x4C2F},	//  70004072
+{0x0F12,0x88C0},	//  70004074
+{0x0F12,0x8060},	//  70004076
+{0x0F12,0x2001},	//  70004078
+{0x0F12,0x8020},	//  7000407A
+{0x0F12,0x482B},	//  7000407C
+{0x0F12,0x3820},	//  7000407E
+{0x0F12,0x8BC0},	//  70004080
+{0x0F12,0xF000},	//  70004082
+{0x0F12,0xFAA9},	//  70004084
+{0x0F12,0x88E0},	//  70004086
+{0x0F12,0x4A2B},	//  70004088
+{0x0F12,0x2800},	//  7000408A
+{0x0F12,0xD003},	//  7000408C
+{0x0F12,0x492B},	//  7000408E
+{0x0F12,0x8849},	//  70004090
+{0x0F12,0x2900},	//  70004092
+{0x0F12,0xD009},	//  70004094
+{0x0F12,0x2001},	//  70004096
+{0x0F12,0x03C0},	//  70004098
+{0x0F12,0x8050},	//  7000409A
+{0x0F12,0x80D0},	//  7000409C
+{0x0F12,0x2000},	//  7000409E
+{0x0F12,0x8090},	//  700040A0
+{0x0F12,0x8110},	//  700040A2
+{0x0F12,0xBC10},	//  700040A4
+{0x0F12,0xBC08},	//  700040A6
+{0x0F12,0x4718},//  700040A8
+{0x0F12,0x8050},	//  700040AA
+{0x0F12,0x8920},	//  700040AC
+{0x0F12,0x80D0},	//  700040AE
+{0x0F12,0x8960},	//  700040B0
+{0x0F12,0x0400},	//  700040B2
+{0x0F12,0x1400},	//  700040B4
+{0x0F12,0x8090},	//  700040B6
+{0x0F12,0x89A1},	//  700040B8
+{0x0F12,0x0409},	//  700040BA
+{0x0F12,0x1409},	//  700040BC
+{0x0F12,0x8111},	//  700040BE
+{0x0F12,0x89E3},	//  700040C0
+{0x0F12,0x8A24},	//  700040C2
+{0x0F12,0x2B00},	//  700040C4
+{0x0F12,0xD104},	//  700040C6
+{0x0F12,0x17C3},	//  700040C8
+{0x0F12,0x0F5B},	//  700040CA
+{0x0F12,0x1818},	//  700040CC
+{0x0F12,0x10C0},	//  700040CE
+{0x0F12,0x8090},	//  700040D0
+{0x0F12,0x2C00},	//  700040D2
+{0x0F12,0xD1E6},	//  700040D4
+{0x0F12,0x17C8},	//  700040D6
+{0x0F12,0x0F40},	//  700040D8
+{0x0F12,0x1840},	//  700040DA
+{0x0F12,0x10C0},	//  700040DC
+{0x0F12,0x8110},	//  700040DE
+{0x0F12,0xE7E0},	//  700040E0
+{0x0F12,0x0000},	//  700040E2
+{0x0F12,0x38D4},	//  700040E4
+{0x0F12,0x7000},	//  700040E6
+{0x0F12,0x17D0},	//  700040E8
+{0x0F12,0x7000},	//  700040EA
+{0x0F12,0x5000},	//  700040EC
+{0x0F12,0xD000},	//  700040EE
+{0x0F12,0x1100},	//  700040F0
+{0x0F12,0xD000},	//  700040F2
+{0x0F12,0x171A},	//  700040F4
+{0x0F12,0x7000},	//  700040F6
+{0x0F12,0x4780},	//  700040F8
+{0x0F12,0x7000},	//  700040FA
+{0x0F12,0x2FCA},	//  700040FC
+{0x0F12,0x7000},	//  700040FE
+{0x0F12,0x2FC5},	//  70004100
+{0x0F12,0x7000},	//  70004102
+{0x0F12,0x2FC6},	//  70004104
+{0x0F12,0x7000},	//  70004106
+{0x0F12,0x2ED8},	//  70004108
+{0x0F12,0x7000},	//  7000410A
+{0x0F12,0x2BD0},	//  7000410C
+{0x0F12,0x7000},	//  7000410E
+{0x0F12,0x17E0},	//  70004110
+{0x0F12,0x7000},	//  70004112
+{0x0F12,0x2DE8},	//  70004114
+{0x0F12,0x7000},	//  70004116
+{0x0F12,0x37E0},	//  70004118
+{0x0F12,0x7000},	//  7000411A
+{0x0F12,0x210C},	//  7000411C
+{0x0F12,0x7000},	//  7000411E
+{0x0F12,0x1484},	//  70004120
+{0x0F12,0x7000},	//  70004122
+{0x0F12,0xC100},	//  70004124
+{0x0F12,0xD000},	//  70004126
+{0x0F12,0xA006},	//  70004128
+{0x0F12,0x0000},	//  7000412A
+{0x0F12,0x0724},	//  7000412C
+{0x0F12,0x7000},	//  7000412E
+{0x0F12,0xA000},	//  70004130
+{0x0F12,0xD000},	//  70004132
+{0x0F12,0x2270},	//  70004134
+{0x0F12,0x7000},	//  70004136
+{0x0F12,0x2558},	//  70004138
+{0x0F12,0x7000},	//  7000413A
+{0x0F12,0x146C},	//  7000413C
+{0x0F12,0x7000},	//  7000413E
+{0x0F12,0xB510},	//  70004140
+{0x0F12,0x000C},	//  70004142
+{0x0F12,0x49D4},	//  70004144
+{0x0F12,0x2204},	//  70004146
+{0x0F12,0x6820},	//  70004148
+{0x0F12,0x5E8A},	//  7000414A
+{0x0F12,0x0140},	//  7000414C
+{0x0F12,0x1A80},	//  7000414E
+{0x0F12,0x0280},	//  70004150
+{0x0F12,0x8849},	//  70004152
+{0x0F12,0xF000},	//  70004154
+{0x0F12,0xFA48},	//  70004156
+{0x0F12,0x6020},	//  70004158
+{0x0F12,0xE7A3},	//  7000415A
+{0x0F12,0xB510},	//  7000415C
+{0x0F12,0x000C},	//  7000415E
+{0x0F12,0x49CD},	//  70004160
+{0x0F12,0x2208},	//  70004162
+{0x0F12,0x6820},	//  70004164
+{0x0F12,0x5E8A},	//  70004166
+{0x0F12,0x0140},	//  70004168
+{0x0F12,0x1A80},	//  7000416A
+{0x0F12,0x0280},	//  7000416C
+{0x0F12,0x88C9},	//  7000416E
+{0x0F12,0xF000},	//  70004170
+{0x0F12,0xFA3A},	//  70004172
+{0x0F12,0x6020},	//  70004174
+{0x0F12,0xE795},	//  70004176
+{0x0F12,0xB5FE},	//  70004178
+{0x0F12,0x000C},	//  7000417A
+{0x0F12,0x6825},	//  7000417C
+{0x0F12,0x6866},	//  7000417E
+{0x0F12,0x68A0},	//  70004180
+{0x0F12,0x9001},	//  70004182
+{0x0F12,0x68E7},	//  70004184
+{0x0F12,0x1BA8},	//  70004186
+{0x0F12,0x42B5},	//  70004188
+{0x0F12,0xDA00},	//  7000418A
+{0x0F12,0x1B70},	//  7000418C
+{0x0F12,0x9000},	//  7000418E
+{0x0F12,0x49C1},	//  70004190
+{0x0F12,0x48C2},	//  70004192
+{0x0F12,0x884A},	//  70004194
+{0x0F12,0x8843},	//  70004196
+{0x0F12,0x435A},	//  70004198
+{0x0F12,0x2304},	//  7000419A
+{0x0F12,0x5ECB},	//  7000419C
+{0x0F12,0x0A92},	//  7000419E
+{0x0F12,0x18D2},	//  700041A0
+{0x0F12,0x02D2},	//  700041A2
+{0x0F12,0x0C12},	//  700041A4
+{0x0F12,0x88CB},	//  700041A6
+{0x0F12,0x8880},	//  700041A8
+{0x0F12,0x4343},	//  700041AA
+{0x0F12,0x0A98},	//  700041AC
+{0x0F12,0x2308},	//  700041AE
+{0x0F12,0x5ECB},	//  700041B0
+{0x0F12,0x18C0},	//  700041B2
+{0x0F12,0x02C0},	//  700041B4
+{0x0F12,0x0C00},	//  700041B6
+{0x0F12,0x0411},	//  700041B8
+{0x0F12,0x0400},	//  700041BA
+{0x0F12,0x1409},	//  700041BC
+{0x0F12,0x1400},	//  700041BE
+{0x0F12,0x1A08},	//  700041C0
+{0x0F12,0x49B6},	//  700041C2
+{0x0F12,0x39E0},	//  700041C4
+{0x0F12,0x6148},	//  700041C6
+{0x0F12,0x9801},	//  700041C8
+{0x0F12,0x3040},	//  700041CA
+{0x0F12,0x7880},	//  700041CC
+{0x0F12,0x2800},	//  700041CE
+{0x0F12,0xD103},	//  700041D0
+{0x0F12,0x9801},	//  700041D2
+{0x0F12,0x0029},	//  700041D4
+{0x0F12,0xF000},	//  700041D6
+{0x0F12,0xFA0D},	//  700041D8
+{0x0F12,0x8839},	//  700041DA
+{0x0F12,0x9800},	//  700041DC
+{0x0F12,0x4281},	//  700041DE
+{0x0F12,0xD814},	//  700041E0
+{0x0F12,0x8879},	//  700041E2
+{0x0F12,0x9800},	//  700041E4
+{0x0F12,0x4281},	//  700041E6
+{0x0F12,0xD20C},	//  700041E8
+{0x0F12,0x9801},	//  700041EA
+{0x0F12,0x0029},	//  700041EC
+{0x0F12,0xF000},	//  700041EE
+{0x0F12,0xFA09},	//  700041F0
+{0x0F12,0x9801},	//  700041F2
+{0x0F12,0x0029},	//  700041F4
+{0x0F12,0xF000},	//  700041F6
+{0x0F12,0xFA05},	//  700041F8
+{0x0F12,0x9801},	//  700041FA
+{0x0F12,0x0029},	//  700041FC
+{0x0F12,0xF000},	//  700041FE
+{0x0F12,0xFA01},	//  70004200
+{0x0F12,0xE003},	//  70004202
+{0x0F12,0x9801},	//  70004204
+{0x0F12,0x0029},	//  70004206
+{0x0F12,0xF000},	//  70004208
+{0x0F12,0xF9FC},	//  7000420A
+{0x0F12,0x9801},	//  7000420C
+{0x0F12,0x0032},	//  7000420E
+{0x0F12,0x0039},	//  70004210
+{0x0F12,0xF000},	//  70004212
+{0x0F12,0xF9FF},	//  70004214
+{0x0F12,0x6020},	//  70004216
+{0x0F12,0xE5BE},	//  70004218
+{0x0F12,0xB57C},	//  7000421A
+{0x0F12,0x48A0},	//  7000421C
+{0x0F12,0xA901},	//  7000421E
+{0x0F12,0x0004},	//  70004220
+{0x0F12,0xF000},	//  70004222
+{0x0F12,0xF983},	//  70004224
+{0x0F12,0x466B},	//  70004226
+{0x0F12,0x88D9},	//  70004228
+{0x0F12,0x8898},	//  7000422A
+{0x0F12,0x4B9B},	//  7000422C
+{0x0F12,0x3346},	//  7000422E
+{0x0F12,0x1E9A},	//  70004230
+{0x0F12,0xF000},	//  70004232
+{0x0F12,0xF9F7},	//  70004234
+{0x0F12,0x489A},	//  70004236
+{0x0F12,0x4998},	//  70004238
+{0x0F12,0x3812},	//  7000423A
+{0x0F12,0x3140},	//  7000423C
+{0x0F12,0x8A42},	//  7000423E
+{0x0F12,0x888B},	//  70004240
+{0x0F12,0x18D2},	//  70004242
+{0x0F12,0x8242},	//  70004244
+{0x0F12,0x8AC2},	//  70004246
+{0x0F12,0x88C9},	//  70004248
+{0x0F12,0x1851},	//  7000424A
+{0x0F12,0x82C1},	//  7000424C
+{0x0F12,0x0020},	//  7000424E
+{0x0F12,0x4669},	//  70004250
+{0x0F12,0xF000},	//  70004252
+{0x0F12,0xF96B},	//  70004254
+{0x0F12,0x4893},	//  70004256
+{0x0F12,0x214D},	//  70004258
+{0x0F12,0x8301},	//  7000425A
+{0x0F12,0x2196},	//  7000425C
+{0x0F12,0x8381},	//  7000425E
+{0x0F12,0x211D},	//  70004260
+{0x0F12,0x3020},	//  70004262
+{0x0F12,0x8001},	//  70004264
+{0x0F12,0xF000},	//  70004266
+{0x0F12,0xF9E5},	//  70004268
+{0x0F12,0xF000},	//  7000426A
+{0x0F12,0xF9EB},	//  7000426C
+{0x0F12,0x488E},	//  7000426E
+{0x0F12,0x4C8E},	//  70004270
+{0x0F12,0x6E00},	//  70004272
+{0x0F12,0x60E0},	//  70004274
+{0x0F12,0x466B},	//  70004276
+{0x0F12,0x8818},	//  70004278
+{0x0F12,0x8859},	//  7000427A
+{0x0F12,0x0025},	//  7000427C
+{0x0F12,0x1A40},	//  7000427E
+{0x0F12,0x3540},	//  70004280
+{0x0F12,0x61A8},	//  70004282
+{0x0F12,0x4885},	//  70004284
+{0x0F12,0x9900},	//  70004286
+{0x0F12,0x3060},	//  70004288
+{0x0F12,0xF000},	//  7000428A
+{0x0F12,0xF9E3},	//  7000428C
+{0x0F12,0x466B},	//  7000428E
+{0x0F12,0x8819},	//  70004290
+{0x0F12,0x1DE0},	//  70004292
+{0x0F12,0x30F9},	//  70004294
+{0x0F12,0x8741},	//  70004296
+{0x0F12,0x8859},	//  70004298
+{0x0F12,0x8781},	//  7000429A
+{0x0F12,0x2000},	//  7000429C
+{0x0F12,0x71A0},	//  7000429E
+{0x0F12,0x74A8},	//  700042A0
+{0x0F12,0xBC7C},	//  700042A2
+{0x0F12,0xBC08},	//  700042A4
+{0x0F12,0x4718},	//  700042A6
+{0x0F12,0xB5F8},	//  700042A8
+{0x0F12,0x0005},	//  700042AA
+{0x0F12,0x6808},	//  700042AC
+{0x0F12,0x0400},	//  700042AE
+{0x0F12,0x0C00},	//  700042B0
+{0x0F12,0x684A},	//  700042B2
+{0x0F12,0x0412},	//  700042B4
+{0x0F12,0x0C12},	//  700042B6
+{0x0F12,0x688E},	//  700042B8
+{0x0F12,0x68CC},	//  700042BA
+{0x0F12,0x4976},	//  700042BC
+{0x0F12,0x884B},	//  700042BE
+{0x0F12,0x4343},	//  700042C0
+{0x0F12,0x0A98},	//  700042C2
+{0x0F12,0x2304},	//  700042C4
+{0x0F12,0x5ECB},	//  700042C6
+{0x0F12,0x18C0},	//  700042C8
+{0x0F12,0x02C0},	//  700042CA
+{0x0F12,0x0C00},	//  700042CC
+{0x0F12,0x88CB},	//  700042CE
+{0x0F12,0x4353},	//  700042D0
+{0x0F12,0x0A9A},	//  700042D2
+{0x0F12,0x2308},	//  700042D4
+{0x0F12,0x5ECB},	//  700042D6
+{0x0F12,0x18D1},	//  700042D8
+{0x0F12,0x02C9},	//  700042DA
+{0x0F12,0x0C09},	//  700042DC
+{0x0F12,0x2701},	//  700042DE
+{0x0F12,0x003A},	//  700042E0
+{0x0F12,0x40AA},	//  700042E2
+{0x0F12,0x9200},	//  700042E4
+{0x0F12,0x002A},	//  700042E6
+{0x0F12,0x3A10},	//  700042E8
+{0x0F12,0x4097},	//  700042EA
+{0x0F12,0x2D10},	//  700042EC
+{0x0F12,0xDA06},	//  700042EE
+{0x0F12,0x4A6F},	//  700042F0
+{0x0F12,0x9B00},	//  700042F2
+{0x0F12,0x8812},	//  700042F4
+{0x0F12,0x439A},	//  700042F6
+{0x0F12,0x4B6D},	//  700042F8
+{0x0F12,0x801A},	//  700042FA
+{0x0F12,0xE003},	//  700042FC
+{0x0F12,0x4B6C},	//  700042FE
+{0x0F12,0x885A},	//  70004300
+{0x0F12,0x43BA},	//  70004302
+{0x0F12,0x805A},	//  70004304
+{0x0F12,0x0023},	//  70004306
+{0x0F12,0x0032},	//  70004308
+{0x0F12,0xF000},	//  7000430A
+{0x0F12,0xF98B},	//  7000430C
+{0x0F12,0x2D10},	//  7000430E
+{0x0F12,0xDA05},	//  70004310
+{0x0F12,0x4967},	//  70004312
+{0x0F12,0x9A00},	//  70004314
+{0x0F12,0x8808},	//  70004316
+{0x0F12,0x4310},	//  70004318
+{0x0F12,0x8008},	//  7000431A
+{0x0F12,0xE003},	//  7000431C
+{0x0F12,0x4864},	//  7000431E
+{0x0F12,0x8841},	//  70004320
+{0x0F12,0x4339},	//  70004322
+{0x0F12,0x8041},	//  70004324
+{0x0F12,0x4D61},	//  70004326
+{0x0F12,0x2000},	//  70004328
+{0x0F12,0x3580},	//  7000432A
+{0x0F12,0x88AA},	//  7000432C
+{0x0F12,0x5E30},	//  7000432E
+{0x0F12,0x2100},	//  70004330
+{0x0F12,0xF000},	//  70004332
+{0x0F12,0xF997},	//  70004334
+{0x0F12,0x8030},	//  70004336
+{0x0F12,0x2000},	//  70004338
+{0x0F12,0x88AA},	//  7000433A
+{0x0F12,0x5E20},	//  7000433C
+{0x0F12,0x2100},	//  7000433E
+{0x0F12,0xF000},	//  70004340
+{0x0F12,0xF990},	//  70004342
+{0x0F12,0x8020},	//  70004344
+{0x0F12,0xE575},	//  70004346
+{0x0F12,0xB508},	//  70004348
+{0x0F12,0x6808},	//  7000434A
+{0x0F12,0x4959},	//  7000434C
+{0x0F12,0x8088},	//  7000434E
+{0x0F12,0x0600},	//  70004350
+{0x0F12,0x0D80},	//  70004352
+{0x0F12,0x8288},	//  70004354
+{0x0F12,0x2103},	//  70004356
+{0x0F12,0x466B},	//  70004358
+{0x0F12,0x7019},	//  7000435A
+{0x0F12,0x0A01},	//  7000435C
+{0x0F12,0x7059},	//  7000435E
+{0x0F12,0x7098},	//  70004360
+{0x0F12,0x2103},	//  70004362
+{0x0F12,0x4668},	//  70004364
+{0x0F12,0xF000},	//  70004366
+{0x0F12,0xF985},	//  70004368
+{0x0F12,0xB001},	//  7000436A
+{0x0F12,0xBC08},	//  7000436C
+{0x0F12,0x4718},	//  7000436E
+{0x0F12,0xB510},	//  70004370
+{0x0F12,0xF000},	//  70004372
+{0x0F12,0xF987},	//  70004374
+{0x0F12,0x4A50},	//  70004376
+{0x0F12,0x8D50},	//  70004378
+{0x0F12,0x2800},	//  7000437A
+{0x0F12,0xD007},	//  7000437C
+{0x0F12,0x494A},	//  7000437E
+{0x0F12,0x31C0},	//  70004380
+{0x0F12,0x684B},	//  70004382
+{0x0F12,0x494D},	//  70004384
+{0x0F12,0x4283},	//  70004386
+{0x0F12,0xD202},	//  70004388
+{0x0F12,0x8D90},	//  7000438A
+{0x0F12,0x81C8},	//  7000438C
+{0x0F12,0xE689},	//  7000438E
+{0x0F12,0x8DD0},	//  70004390
+{0x0F12,0x81C8},	//  70004392
+{0x0F12,0xE686},	//  70004394
+{0x0F12,0xB5F8},	//  70004396
+{0x0F12,0xF000},	//  70004398
+{0x0F12,0xF97C},	//  7000439A
+{0x0F12,0x4D46},	//  7000439C
+{0x0F12,0x8E28},	//  7000439E
+{0x0F12,0x2800},	//  700043A0
+{0x0F12,0xD01F},	//  700043A2
+{0x0F12,0x4E46},	//  700043A4
+{0x0F12,0x4840},	//  700043A6
+{0x0F12,0x68B4},	//  700043A8
+{0x0F12,0x6800},	//  700043AA
+{0x0F12,0x4284},	//  700043AC
+{0x0F12,0xD903},	//  700043AE
+{0x0F12,0x1A21},	//  700043B0
+{0x0F12,0x0849},	//  700043B2
+{0x0F12,0x1847},	//  700043B4
+{0x0F12,0xE006},	//  700043B6
+{0x0F12,0x4284},	//  700043B8
+{0x0F12,0xD203},	//  700043BA
+{0x0F12,0x1B01},	//  700043BC
+{0x0F12,0x0849},	//  700043BE
+{0x0F12,0x1A47},	//  700043C0
+{0x0F12,0xE000},	//  700043C2
+{0x0F12,0x0027},	//  700043C4
+{0x0F12,0x0020},	//  700043C6
+{0x0F12,0x4937},	//  700043C8
+{0x0F12,0x3120},	//  700043CA
+{0x0F12,0x7A0C},	//  700043CC
+{0x0F12,0x2C00},	//  700043CE
+{0x0F12,0xD004},	//  700043D0
+{0x0F12,0x0200},	//  700043D2
+{0x0F12,0x0039},	//  700043D4
+{0x0F12,0xF000},	//  700043D6
+{0x0F12,0xF8B9},	//  700043D8
+{0x0F12,0x8668},	//  700043DA
+{0x0F12,0x2C00},	//  700043DC
+{0x0F12,0xD000},	//  700043DE
+{0x0F12,0x60B7},	//  700043E0
+{0x0F12,0xE527},	//  700043E2
+{0x0F12,0x20FF},	//  700043E4
+{0x0F12,0x1C40},	//  700043E6
+{0x0F12,0x8668},	//  700043E8
+{0x0F12,0xE523},	//  700043EA
+{0x0F12,0xB510},	//  700043EC
+{0x0F12,0x000C},	//  700043EE
+{0x0F12,0x6820},	//  700043F0
+{0x0F12,0x0400},	//  700043F2
+{0x0F12,0x0C00},	//  700043F4
+{0x0F12,0x4930},	//  700043F6
+{0x0F12,0x8E0A},	//  700043F8
+{0x0F12,0x2A00},	//  700043FA
+{0x0F12,0xD003},	//  700043FC
+{0x0F12,0x8E49},	//  700043FE
+{0x0F12,0x0200},	//  70004400
+{0x0F12,0xF000},	//  70004402
+{0x0F12,0xF8A3},	//  70004404
+{0x0F12,0x6020},	//  70004406
+{0x0F12,0x0400},	//  70004408
+{0x0F12,0x0C00},	//  7000440A
+{0x0F12,0xE64A},	//  7000440C
+{0x0F12,0xB570},	//  7000440E
+{0x0F12,0x680C},	//  70004410
+{0x0F12,0x4D2C},	//  70004412
+{0x0F12,0x0020},	//  70004414
+{0x0F12,0x6F29},	//  70004416
+{0x0F12,0xF000},	//  70004418
+{0x0F12,0xF944},	//  7000441A
+{0x0F12,0x6F69},	//  7000441C
+{0x0F12,0x1D20},	//  7000441E
+{0x0F12,0xF000},	//  70004420
+{0x0F12,0xF940},	//  70004422
+{0x0F12,0x4824},	//  70004424
+{0x0F12,0x8E00},	//  70004426
+{0x0F12,0x2800},	//  70004428
+{0x0F12,0xD006},	//  7000442A
+{0x0F12,0x491E},	//  7000442C
+{0x0F12,0x2214},	//  7000442E
+{0x0F12,0x3168},	//  70004430
+{0x0F12,0x0008},	//  70004432
+{0x0F12,0x383C},	//  70004434
+{0x0F12,0xF000},	//  70004436
+{0x0F12,0xF93D},	//  70004438
+{0x0F12,0xE462},	//  7000443A
+{0x0F12,0x4821},	//  7000443C
+{0x0F12,0x6FC1},	//  7000443E
+{0x0F12,0x2001},	//  70004440
+{0x0F12,0x4708},	//  70004442
+{0x0F12,0x4770},	//  70004444
+{0x0F12,0xB5F8},	//  70004446
+{0x0F12,0x0004},	//  70004448
+{0x0F12,0x481E},	//  7000444A
+{0x0F12,0x6FC1},	//  7000444C
+{0x0F12,0x2000},	//  7000444E
+{0x0F12,0xF000},	//  70004450
+{0x0F12,0xF928},	//  70004452
+{0x0F12,0x491C},	//  70004454
+{0x0F12,0x20FF},	//  70004456
+{0x0F12,0x1C40},	//  70004458
+{0x0F12,0x8048},	//  7000445A
+{0x0F12,0x2101},	//  7000445C
+{0x0F12,0x000D},	//  7000445E
+{0x0F12,0x0020},	//  70004460
+{0x0F12,0x3810},	//  70004462
+{0x0F12,0x4081},	//  70004464
+{0x0F12,0x40A5},	//  70004466
+{0x0F12,0x4F11},	//  70004468
+{0x0F12,0x000E},	//  7000446A
+{0x0F12,0x2C10},	//  7000446C
+{0x0F12,0xDA03},	//  7000446E
+{0x0F12,0x8838},	//  70004470
+{0x0F12,0x43A8},	//  70004472
+{0x0F12,0x8038},	//  70004474
+{0x0F12,0xE002},	//  70004476
+{0x0F12,0x8878},	//  70004478
+{0x0F12,0x43B0},	//  7000447A
+{0x0F12,0x8078},	//  7000447C
+{0x0F12,0xF000},	//  7000447E
+{0x0F12,0xF91F},	//  70004480
+{0x0F12,0x2C10},	//  70004482
+{0x0F12,0xDA03},	//  70004484
+{0x0F12,0x8838},	//  70004486
+{0x0F12,0x4328},	//  70004488
+{0x0F12,0x8038},	//  7000448A
+{0x0F12,0xE4D2},	//  7000448C
+{0x0F12,0x8878},	//  7000448E
+{0x0F12,0x4330},	//  70004490
+{0x0F12,0x8078},	//  70004492
+{0x0F12,0xE4CE},	//  70004494
+{0x0F12,0x0000},	//  70004496
+{0x0F12,0x2558},	//  70004498
+{0x0F12,0x7000},	//  7000449A
+{0x0F12,0x2AB8},	//  7000449C
+{0x0F12,0x7000},	//  7000449E
+{0x0F12,0x145E},	//  700044A0
+{0x0F12,0x7000},	//  700044A2
+{0x0F12,0x2698},	//  700044A4
+{0x0F12,0x7000},	//  700044A6
+{0x0F12,0x2BB8},	//  700044A8
+{0x0F12,0x7000},	//  700044AA
+{0x0F12,0x2998},	//  700044AC
+{0x0F12,0x7000},	//  700044AE
+{0x0F12,0x1100},	//  700044B0
+{0x0F12,0xD000},	//  700044B2
+{0x0F12,0x3044},	//  700044B4
+{0x0F12,0x7000},	//  700044B6
+{0x0F12,0x4780},	//  700044B8
+{0x0F12,0x7000},	//  700044BA
+{0x0F12,0xE200},	//  700044BC
+{0x0F12,0xD000},	//  700044BE
+{0x0F12,0x210C},	//  700044C0
+{0x0F12,0x7000},	//  700044C2
+{0x0F12,0x0000},	//  700044C4
+{0x0F12,0x7000},	//  700044C6
+{0x0F12,0xC100},	//  700044C8
+{0x0F12,0xD000},	//  700044CA
+{0x0F12,0x4778},	//  700044CC
+{0x0F12,0x46C0},	//  700044CE
+{0x0F12,0xC000},	//  700044D0
+{0x0F12,0xE59F},	//  700044D2
+{0x0F12,0xFF1C},	//  700044D4
+{0x0F12,0xE12F},	//  700044D6
+{0x0F12,0x1789},	//  700044D8
+{0x0F12,0x0001},	//  700044DA
+{0x0F12,0x4778},	//  700044DC
+{0x0F12,0x46C0},	//  700044DE
+{0x0F12,0xC000},	//  700044E0
+{0x0F12,0xE59F},	//  700044E2
+{0x0F12,0xFF1C},	//  700044E4
+{0x0F12,0xE12F},	//  700044E6
+{0x0F12,0x16F1},	//  700044E8
+{0x0F12,0x0001},	//  700044EA
+{0x0F12,0x4778},	//  700044EC
+{0x0F12,0x46C0},	//  700044EE
+{0x0F12,0xC000},	//  700044F0
+{0x0F12,0xE59F},	//  700044F2
+{0x0F12,0xFF1C},	//  700044F4
+{0x0F12,0xE12F},	//  700044F6
+{0x0F12,0xC3B1},	//  700044F8
+{0x0F12,0x0000},	//  700044FA
+{0x0F12,0x4778},	//  700044FC
+{0x0F12,0x46C0},	//  700044FE
+{0x0F12,0xC000},	//  70004500
+{0x0F12,0xE59F},	//  70004502
+{0x0F12,0xFF1C},	//  70004504
+{0x0F12,0xE12F},	//  70004506
+{0x0F12,0xC36D},	//  70004508
+{0x0F12,0x0000},	//  7000450A
+{0x0F12,0x4778},	//  7000450C
+{0x0F12,0x46C0},	//  7000450E
+{0x0F12,0xC000},	//  70004510
+{0x0F12,0xE59F},	//  70004512
+{0x0F12,0xFF1C},	//  70004514
+{0x0F12,0xE12F},	//  70004516
+{0x0F12,0xF6D7},	//  70004518
+{0x0F12,0x0000},	//  7000451A
+{0x0F12,0x4778},	//  7000451C
+{0x0F12,0x46C0},	//  7000451E
+{0x0F12,0xC000},	//  70004520
+{0x0F12,0xE59F},	//  70004522
+{0x0F12,0xFF1C},	//  70004524
+{0x0F12,0xE12F},	//  70004526
+{0x0F12,0xB49D},	//  70004528
+{0x0F12,0x0000},	//  7000452A
+{0x0F12,0x4778},	//  7000452C
+{0x0F12,0x46C0},	//  7000452E
+{0x0F12,0xC000},	//  70004530
+{0x0F12,0xE59F},	//  70004532
+{0x0F12,0xFF1C},	//  70004534
+{0x0F12,0xE12F},	//  70004536
+{0x0F12,0x7EDF},	//  70004538
+{0x0F12,0x0000},	//  7000453A
+{0x0F12,0x4778},	//  7000453C
+{0x0F12,0x46C0},	//  7000453E
+{0x0F12,0xC000},	//  70004540
+{0x0F12,0xE59F},	//  70004542
+{0x0F12,0xFF1C},	//  70004544
+{0x0F12,0xE12F},	//  70004546
+{0x0F12,0x448D},	//  70004548
+{0x0F12,0x0000},	//  7000454A
+{0x0F12,0x4778},	//  7000454C
+{0x0F12,0x46C0},	//  7000454E
+{0x0F12,0xF004},	//  70004550
+{0x0F12,0xE51F},	//  70004552
+{0x0F12,0x29EC},	//  70004554
+{0x0F12,0x0001},	//  70004556
+{0x0F12,0x4778},	//  70004558
+{0x0F12,0x46C0},	//  7000455A
+{0x0F12,0xC000},	//  7000455C
+{0x0F12,0xE59F},	//  7000455E
+{0x0F12,0xFF1C},	//  70004560
+{0x0F12,0xE12F},	//  70004562
+{0x0F12,0x2EF1},	//  70004564
+{0x0F12,0x0000},	//  70004566
+{0x0F12,0x4778},	//  70004568
+{0x0F12,0x46C0},	//  7000456A
+{0x0F12,0xC000},	//  7000456C
+{0x0F12,0xE59F},	//  7000456E
+{0x0F12,0xFF1C},	//  70004570
+{0x0F12,0xE12F},	//  70004572
+{0x0F12,0xEE03},	//  70004574
+{0x0F12,0x0000},	//  70004576
+{0x0F12,0x4778},	//  70004578
+{0x0F12,0x46C0},	//  7000457A
+{0x0F12,0xC000},	//  7000457C
+{0x0F12,0xE59F},	//  7000457E
+{0x0F12,0xFF1C},	//  70004580
+{0x0F12,0xE12F},	//  70004582
+{0x0F12,0xA58B},	//  70004584
+{0x0F12,0x0000},	//  70004586
+{0x0F12,0x4778},	//  70004588
+{0x0F12,0x46C0},	//  7000458A
+{0x0F12,0xC000},	//  7000458C
+{0x0F12,0xE59F},	//  7000458E
+{0x0F12,0xFF1C},	//  70004590
+{0x0F12,0xE12F},	//  70004592
+{0x0F12,0x7C49},	//  70004594
+{0x0F12,0x0000},	//  70004596
+{0x0F12,0x4778},	//  70004598
+{0x0F12,0x46C0},	//  7000459A
+{0x0F12,0xC000},	//  7000459C
+{0x0F12,0xE59F},	//  7000459E
+{0x0F12,0xFF1C},	//  700045A0
+{0x0F12,0xE12F},	//  700045A2
+{0x0F12,0x7C63},	//  700045A4
+{0x0F12,0x0000},	//  700045A6
+{0x0F12,0x4778},	//  700045A8
+{0x0F12,0x46C0},	//  700045AA
+{0x0F12,0xC000},	//  700045AC
+{0x0F12,0xE59F},	//  700045AE
+{0x0F12,0xFF1C},	//  700045B0
+{0x0F12,0xE12F},	//  700045B2
+{0x0F12,0x2DB7},	//  700045B4
+{0x0F12,0x0000},	//  700045B6
+{0x0F12,0x4778},	//  700045B8
+{0x0F12,0x46C0},	//  700045BA
+{0x0F12,0xC000},	//  700045BC
+{0x0F12,0xE59F},	//  700045BE
+{0x0F12,0xFF1C},	//  700045C0
+{0x0F12,0xE12F},	//  700045C2
+{0x0F12,0xEB3D},	//  700045C4
+{0x0F12,0x0000},	//  700045C6
+{0x0F12,0x4778},	//  700045C8
+{0x0F12,0x46C0},	//  700045CA
+{0x0F12,0xC000},	//  700045CC
+{0x0F12,0xE59F},	//  700045CE
+{0x0F12,0xFF1C},	//  700045D0
+{0x0F12,0xE12F},	//  700045D2
+{0x0F12,0xF061},	//  700045D4
+{0x0F12,0x0000},//  700045D6
+{0x0F12,0x4778},	//  700045D8
+{0x0F12,0x46C0},	//  700045DA
+{0x0F12,0xC000},	//  700045DC
+{0x0F12,0xE59F},	//  700045DE
+{0x0F12,0xFF1C},	//  700045E0
+{0x0F12,0xE12F},	//  700045E2
+{0x0F12,0xF0EF},	//  700045E4
+{0x0F12,0x0000},	//  700045E6
+{0x0F12,0x4778},	//  700045E8
+{0x0F12,0x46C0},	//  700045EA
+{0x0F12,0xF004},	//  700045EC
+{0x0F12,0xE51F},	//  700045EE
+{0x0F12,0x2824},	//  700045F0
+{0x0F12,0x0001},	//  700045F2
+{0x0F12,0x4778},	//  700045F4
+{0x0F12,0x46C0},	//  700045F6
+{0x0F12,0xC000},	//  700045F8
+{0x0F12,0xE59F},	//  700045FA
+{0x0F12,0xFF1C},	//  700045FC
+{0x0F12,0xE12F},	//  700045FE
+{0x0F12,0x8EDD},	//  70004600
+{0x0F12,0x0000},//  70004602
+{0x0F12,0x4778},	//  70004604
+{0x0F12,0x46C0},	//  70004606
+{0x0F12,0xC000},	//  70004608
+{0x0F12,0xE59F},	//  7000460A
+{0x0F12,0xFF1C},	//  7000460C
+{0x0F12,0xE12F},	//  7000460E
+{0x0F12,0x8DCB},	//  70004610
+{0x0F12,0x0000},//  70004612
+{0x0F12,0x4778},	//  70004614
+{0x0F12,0x46C0},	//  70004616
+{0x0F12,0xC000},	//  70004618
+{0x0F12,0xE59F},	//  7000461A
+{0x0F12,0xFF1C},	//  7000461C
+{0x0F12,0xE12F},	//  7000461E
+{0x0F12,0x8E17},	//  70004620
+{0x0F12,0x0000},	//  70004622
+{0x0F12,0x4778},	//  70004624
+{0x0F12,0x46C0},	//  70004626
+{0x0F12,0xC000},	//  70004628
+{0x0F12,0xE59F},	//  7000462A
+{0x0F12,0xFF1C},	//  7000462C
+{0x0F12,0xE12F},	//  7000462E
+{0x0F12,0x98C5},	//  70004630
+{0x0F12,0x0000},	//  70004632
+{0x0F12,0x4778},	//  70004634
+{0x0F12,0x46C0},	//  70004636
+{0x0F12,0xC000},	//  70004638
+{0x0F12,0xE59F},	//  7000463A
+{0x0F12,0xFF1C},	//  7000463C
+{0x0F12,0xE12F},	//  7000463E
+{0x0F12,0x7C7D},	//  70004640
+{0x0F12,0x0000},	//  70004642
+{0x0F12,0x4778},	//  70004644
+{0x0F12,0x46C0},	//  70004646
+{0x0F12,0xC000},	//  70004648
+{0x0F12,0xE59F},	//  7000464A
+{0x0F12,0xFF1C},	//  7000464C
+{0x0F12,0xE12F},	//  7000464E
+{0x0F12,0x7E31},	//  70004650
+{0x0F12,0x0000},	//  70004652
+{0x0F12,0x4778},	//  70004654
+{0x0F12,0x46C0},	//  70004656
+{0x0F12,0xC000},	//  70004658
+{0x0F12,0xE59F},	//  7000465A
+{0x0F12,0xFF1C},	//  7000465C
+{0x0F12,0xE12F},	//  7000465E
+{0x0F12,0x7EAB},	//  70004660
+{0x0F12,0x0000},	//  70004662
+{0x0F12,0x4778},	//  70004664
+{0x0F12,0x46C0},	//  70004666
+{0x0F12,0xC000},	//  70004668
+{0x0F12,0xE59F},	//  7000466A
+{0x0F12,0xFF1C},	//  7000466C
+{0x0F12,0xE12F},	//  7000466E
+{0x0F12,0x7501},	//  70004670
+{0x0F12,0x0000},	//  70004672
+{0x0F12,0x4778},	//  70004674
+{0x0F12,0x46C0},	//  70004676
+{0x0F12,0xC000},	//  70004678
+{0x0F12,0xE59F},	//  7000467A
+{0x0F12,0xFF1C},	//  7000467C
+{0x0F12,0xE12F},	//  7000467E
+{0x0F12,0xD19D},	//  70004680
+{0x0F12,0x0000},	//  70004682
+{0x0F12,0x4778},	//  70004684
+{0x0F12,0x46C0},	//  70004686
+{0x0F12,0xC000},	//  70004688
+{0x0F12,0xE59F},	//  7000468A
+{0x0F12,0xFF1C},	//  7000468C
+{0x0F12,0xE12F},	//  7000468E
+{0x0F12,0xF63F},	//  70004690
+{0x0F12,0x0000},	//  70004692
+{0x0F12,0x4778},	//  70004694
+{0x0F12,0x46C0},	//  70004696
+{0x0F12,0xC000},	//  70004698
+{0x0F12,0xE59F},	//  7000469A
+{0x0F12,0xFF1C},	//  7000469C
+{0x0F12,0xE12F},	//  7000469E
+{0x0F12,0x3D0B},	//  700046A0
+{0x0F12,0x0000},	//  700046A2
+{0x0F12,0x4778},	//  700046A4
+{0x0F12,0x46C0},	//  700046A6
+{0x0F12,0xC000},	//  700046A8
+{0x0F12,0xE59F},	//  700046AA
+{0x0F12,0xFF1C},	//  700046AC
+{0x0F12,0xE12F},	//  700046AE
+{0x0F12,0x29BF},	//  700046B0
+{0x0F12,0x0001},	//  700046B2
+{0x0F12,0x4778},	//  700046B4
+{0x0F12,0x46C0},	//  700046B6
+{0x0F12,0xF004},	//  700046B8
+{0x0F12,0xE51F},	//  700046BA
+{0x0F12,0x26D8},	//  700046BC
+{0x0F12,0x0001},	//  700046BE
+{0x0F12,0x4778},	//  700046C0
+{0x0F12,0x46C0},	//  700046C2
+{0x0F12,0xC000},	//  700046C4
+{0x0F12,0xE59F},	//  700046C6
+{0x0F12,0xFF1C},	//  700046C8
+{0x0F12,0xE12F},	//  700046CA
+{0x0F12,0x6099},	//  700046CC
+{0x0F12,0x0000},	//  700046CE
+// End of Patch Data(Last : 700046CEh)
+// Total Size 3032 (0x0BD8)
+// Addr : 3AF8 , Size : 3030(BD6h)
+
+// TNP_USER_MBCV_CONTROL
+// TNP_4EC_MBR_TUNE
+// TNP_4EC_FORBIDDEN_TUNE
+// TNP_AF_FINESEARCH_DRIVEBACK
+// TNP_FLASH_ALG
+// TNP_GAS_ALPHA_OTP
+// TNP_AWB_MODUL_COMP
+// TNP_AWB_INIT_QUEUE
+// TNP_AWB_GRID_LOWBR
+// TNP_AWB_GRID_MODULECOMP
+// TNP_AFD_MOTO
+// TNP_ADLC_TUNE
+// TNP_1FRAME_AE
+// TNP_TG_OFF_CFG_CHG_IN_SPOOF_MODE
 
 //==================================================================================
-// 13.Flash Setting
+// 05.OTP Control
 //==================================================================================
 
+{0x002A,0x0722},
+{0x0F12,0x0100},///skl_OTP_usWaitTime This register should be positioned in fornt of D0001000
+{0x002A,0x0726},
+{0x0F12,0x0000},//skl_bUseOTPfunc This is OTP on/off function
+{0x002A,0x08D6},
+{0x0F12,0x0000},//ash_bUseOTPData
+{0x002A,0x146E},
+{0x0F12,0x0000} ,//awbb_otp_disable
+{0x002A,0x08DC},
+{0x0F12,0x0000},//ash_bUseGasAlphaOTP
+
+//OTP on
+//{0x002A,0x   0722
+//{0x0F12,0x   0100 ///skl_OTP_usWaitTime This register should be positioned in fornt of D0001000
+//{0x002A,0x   0726
+//{0x0F12,0x   0001 //skl_bUseOTPfunc This is OTP on/off function
+//{0x002A,0x   08D6
+//{0x0F12,0x   0001 //ash_bUseOTPData
+//{0x002A,0x   146E
+//{0x0F12,0x   0000 //awbb_otp_disable
+//{0x002A,0x   08DC
+//{0x0F12,0x   0000 //ash_bUseGasAlphaOTP
+
+{0x0028,0xD000},
+{0x002A,0x1000},
+{0x0F12,0x0001},
+//==================================================================================
+// 06.Gas_Anti Shading
+//==================================================================================
 
+// Refer Mon_AWB_RotGain
+{0x0028,0x7000},
+{0x002A,0x08B4},
+{0x0F12,0x0001},	// wbt_bUseOutdoorASH
+{0x002A,0x08BC},
+{0x0F12,0x00C0},	// TVAR_ash_AwbAshCord_0_ 2300K
+{0x0F12,0x00DF},	// TVAR_ash_AwbAshCord_1_ 2750K
+{0x0F12,0x0100},	// TVAR_ash_AwbAshCord_2_ 3300K
+{0x0F12,0x0125},	// TVAR_ash_AwbAshCord_3_ 4150K
+{0x0F12,0x015F},	// TVAR_ash_AwbAshCord_4_ 5250K
+{0x0F12,0x017C},	// TVAR_ash_AwbAshCord_5_ 6400K
+{0x0F12,0x0194},	// TVAR_ash_AwbAshCord_6_ 7500K
+{0x002A,0x08F6},
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_0__0_ R}  // 2300K
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_0__1_ GR
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_0__2_ GB
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_0__3_ B
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_1__0_ R}  // 2750K
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_1__1_ GR
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_1__2_ GB
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_1__3_ B
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_2__0_ R}  // 3300K
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_2__1_ GR
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_2__2_ GB
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_2__3_ B
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_3__0_ R}  // 4150K
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_3__1_ GR
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_3__2_ GB
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_3__3_ B
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_4__0_ R}  // 5250K
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_4__1_ GR
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_4__2_ GB
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_4__3_ B
+{0x0F12,0x4300},	// TVAR_ash_GASAlpha_5__0_ R}  // 6400K
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_5__1_ GR
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_5__2_ GB
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_5__3_ B
+{0x0F12,0x4300},	// TVAR_ash_GASAlpha_6__0_ R}  // 7500K
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_6__1_ GR
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_6__2_ GB
+{0x0F12,0x4000},	// TVAR_ash_GASAlpha_6__3_ B
+//Outdoor GAS Alpha
+{0x0F12,0x4500},
+{0x0F12,0x4000},
+{0x0F12,0x4000},
+{0x0F12,0x4000},
+{0x002A,0x08F4},
+{0x0F12,0x0001},	// ash_bUseGasAlpha
+//	GAS High table	 If OTP is used, GAS Setting Should be deleted.}	// 
+//BENI 1.1 module 101018//
+{0x002A,0x0D26},  
+{0x0F12,0x0F00},
+{0x0F12,0x000F},   
+{0x0F12,0x0F0F},    
+{0x0F12,0x0F0F},
+{0x0F12,0x0F00},
+{0x0F12,0x0000},
+{0x0F12,0x0000},   
+{0x0F12,0x000F},
+{0x0F12,0x0F00},
+{0x0F12,0x0000},
+{0x0F12,0x0F00},
+{0x0F12,0x000F},   
+{0x0F12,0x0F0F},
+{0x0F12,0x0000},
+{0x0F12,0x000F},
+{0x0F12,0x0000},
+{0x0F12,0x000F},
+{0x0F12,0x0F00},
+{0x0F12,0x0F00},   
+{0x0F12,0x0000},
+{0x0F12,0x0F0F},
+{0x0F12,0x0F0F},
+{0x0F12,0x0F00},   
+{0x0F12,0x000F},
+{0x0F12,0x0000},
+{0x0F12,0x000F},   
+{0x0F12,0x0F00},
+{0x0F12,0x0000},
+{0x0F12,0x0F00},
+{0x0F12,0x000F},   
+{0x0F12,0x0F0F},
+{0x0F12,0x000F},
+{0x0F12,0x000F},
+{0x0F12,0x0000},
+{0x0F12,0x000F},
+{0x0F12,0x0F0F},
+{0x0F12,0x0F00},   
+{0x0F12,0x000F},
+{0x0F12,0x000F},   
+{0x0F12,0x000F},    
+{0x0F12,0x0F00},   
+{0x0F12,0x000F},    
+{0x0F12,0x0F00},    
+{0x0F12,0x000F},    
+{0x0F12,0x0F00},    
+{0x0F12,0x0000},    
+{0x0F12,0x0F00},    
+{0x0F12,0x000F},    
+{0x0F12,0x0F0F},   
+{0x0F12,0x000F},    
+{0x0F12,0x000F},    
+{0x0F12,0x0000},    
+{0x0F12,0x000F},    
+{0x0F12,0x0F0F},    
+{0x0F12,0x0F00},    
+{0x0F12,0x000F},    
+{0x0F12,0x0F0F},    
+{0x0F12,0x0F0F},    
+{0x0F12,0x0F00},    
+{0x0F12,0x0000},    
+{0x0F12,0x0000},    
+{0x0F12,0x000F},   
+{0x0F12,0x0F00},    
+{0x0F12,0x0000},   
+{0x0F12,0x0F00},    
+{0x0F12,0x000F},    
+{0x0F12,0x0F0F},    
+{0x0F12,0x000F},    
+{0x0F12,0x000F},    
+{0x0F12,0x0000},    
+{0x0F12,0x000F},    
+{0x0F12,0x0F0F},    
+// TVAR_ash_pGAS_low
+{0x002A,0x0DB6},               
+{0x0F12,0x88A2},  
+{0x0F12,0xEF5B},   
+{0x0F12,0xF576},   
+{0x0F12,0x2242},   
+{0x0F12,0xEC90},   
+{0x0F12,0xFCB2},   
+{0x0F12,0xD726},   
+{0x0F12,0xF77C},   
+{0x0F12,0x1CCB},
+{0x0F12,0xDB4D},
+{0x0F12,0x0948},
+{0x0F12,0x13C2},
+{0x0F12,0x0A14},
+{0x0F12,0x017A},
+{0x0F12,0xE9B4},
+{0x0F12,0x190D},
+{0x0F12,0x16E5},
+{0x0F12,0xCAB2},
+{0x0F12,0x18CD},
+{0x0F12,0x0A84},
+{0x0F12,0x097E},
+{0x0F12,0xF076},
+{0x0F12,0xE849},
+{0x0F12,0x2CFC},
+{0x0F12,0xE460},
+{0x0F12,0xEE89},
+{0x0F12,0x0693},
+{0x0F12,0x06B4},
+{0x0F12,0xF16E},
+{0x0F12,0x12B6},
+{0x0F12,0x0F99},
+{0x0F12,0x0F3B},
+{0x0F12,0xE728},
+{0x0F12,0x19BB},
+{0x0F12,0x058E},
+{0x0F12,0xDA99},
+{0x0F12,0x952B},
+{0x0F12,0xE6F0},
+{0x0F12,0x0163},
+{0x0F12,0x1376},
+{0x0F12,0xFC0E},
+{0x0F12,0xF3A2},
+{0x0F12,0xCE5D},
+{0x0F12,0xFA86},
+{0x0F12,0x11D3},
+{0x0F12,0xEB02},
+{0x0F12,0xFE43},
+{0x0F12,0x17ED},
+{0x0F12,0x1320},
+{0x0F12,0x0156},
+{0x0F12,0xF4FF},
+{0x0F12,0x0ACA},
+{0x0F12,0x162B},
+{0x0F12,0xD2D8},
+{0x0F12,0x0F4F},
+{0x0F12,0x0178},
+{0x0F12,0x0AD1},
+{0x0F12,0xEDE5},
+{0x0F12,0xFBA5},
+{0x0F12,0x1A69},
+{0x0F12,0xF30F},
+{0x0F12,0xFC58},
+{0x0F12,0xF92D},
+{0x0F12,0x131C},
+{0x0F12,0xE607},
+{0x0F12,0x1564},
+{0x0F12,0x02A8},
+{0x0F12,0x08B5},
+{0x0F12,0xF04C},
+{0x0F12,0x15D0},
+{0x0F12,0xFAD0},
+{0x0F12,0xEB70},
+{0x0F12,0x8564},
+{0x0F12,0xE967},
+{0x0F12,0xFFFF},
+{0x0F12,0x16A8},
+{0x0F12,0xEFD6},
+{0x0F12,0x01AF},
+{0x0F12,0xD7AD},
+{0x0F12,0x01A2},
+{0x0F12,0x0A4E},
+{0x0F12,0xF1CE},
+{0x0F12,0xFA95},
+{0x0F12,0x143F},
+{0x0F12,0x1046},
+{0x0F12,0xF6A1},
+{0x0F12,0xF7BB},
+{0x0F12,0x0E8D},
+{0x0F12,0x11A3},
+{0x0F12,0xDB43},
+{0x0F12,0x1459},
+{0x0F12,0x0FFA},
+{0x0F12,0x0731},
+{0x0F12,0xEC67},
+{0x0F12,0xF7CA},
+{0x0F12,0x1682},
+{0x0F12,0xDF77},
+{0x0F12,0xEEA5},
+{0x0F12,0xFF71},
+{0x0F12,0x08FF},
+{0x0F12,0xF8FA},
+{0x0F12,0x138E},
+{0x0F12,0x16FE},
+{0x0F12,0x0BA0},
+{0x0F12,0xF297},
+{0x0F12,0x1717},
+{0x0F12,0xF5BB},
+{0x0F12,0xE6B7},
+{0x0F12,0x87A3},
+{0x0F12,0xECB4},
+{0x0F12,0xF8A1},
+{0x0F12,0x1D23},
+{0x0F12,0xF35F},
+{0x0F12,0xF7C7},
+{0x0F12,0xD9ED},
+{0x0F12,0xF792},
+{0x0F12,0x1E98},
+{0x0F12,0xD734},
+{0x0F12,0x0BA1},
+{0x0F12,0x14E3},
+{0x0F12,0x0BB9},
+{0x0F12,0x0279},
+{0x0F12,0xDEC5},
+{0x0F12,0x2EDC},
+{0x0F12,0x010A},
+{0x0F12,0xD36F},
+{0x0F12,0x1A6A},
+{0x0F12,0x03F6},
+{0x0F12,0x1AE5},
+{0x0F12,0xD3FB},
+{0x0F12,0xFFFA},
+{0x0F12,0x26A0},
+{0x0F12,0xDF98},
+{0x0F12,0xF8DC},
+{0x0F12,0xF675},
+{0x0F12,0x168E},
+{0x0F12,0xEFC9},
+{0x0F12,0x0A42},
+{0x0F12,0x11D3},
+{0x0F12,0x08BE},
+{0x0F12,0xEF30},
+{0x0F12,0x1785},
+{0x0F12,0xFBF7},
+{0x0F12,0xE573},
 
 //==================================================================================
-// 12.AF Setting
+// 07. Analog Setting 2
 //==================================================================================
-{0x0028, 0x7000},
-{0x002A, 0x01FC},
-{0x0F12, 0x0001},	 //REG_TC_IPRM_LedGpio
-{0x002A, 0x01FE},
-{0x0F12, 0x0003},	 //REG_TC_IPRM_CM_Init_AfModeType VCM IIC
-{0x0F12, 0x0000},	 //REG_TC_IPRM_CM_Init_PwmConfig1
-{0x002A, 0x0204},
-{0x0F12, 0x0061},	 //REG_TC_IPRM_CM_Init_GpioConfig1 AF Enable GPIO 6	 //
-{0x002A, 0x020C},
-{0x0F12, 0x2F0C},	 //REG_TC_IPRM_CM_Init_Mi2cBits
-{0x0F12, 0x0190},	 //REG_TC_IPRM_CM_Init_Mi2cRateKhz IIC Speed
-{0x002A, 0x0294},
-{0x0F12, 0x01C7},	 //REG_TC_AF_FstWinStartX
-{0x0F12, 0x01C7},	 //REG_TC_AF_FstWinStartY
-{0x0F12, 0x0072},	 //REG_TC_AF_FstWinSizeX
-{0x0F12, 0x0072},	 //REG_TC_AF_FstWinSizeY
-{0x0F12, 0x01D5},	 //REG_TC_AF_ScndWinStartX
-{0x0F12, 0x01D5},	 //REG_TC_AF_ScndWinStartY
-{0x0F12, 0x0055},	 //REG_TC_AF_ScndWinSizeX
-{0x0F12, 0x0055},	 //REG_TC_AF_ScndWinSizeY
-{0x0F12, 0x0001},	 //REG_TC_AF_WinSizesUpdated
-     
-{0x002A, 0x070E},
-{0x0F12, 0x00FF},	 //skl_af_StatOvlpExpFactor
-{0x002A, 0x071E},
-{0x0F12, 0x0000},	 //skl_af_bAfStatOff
-{0x002A, 0x163C},
-{0x0F12, 0x0000},	 //af_search_usAeStable
-{0x002A, 0x1648},
-{0x0F12, 0x9000},	 //af_search_usSingleAfFlags
-{0x002A, 0x1652},
-{0x0F12, 0x0002},	 //af_search_usFinePeakCount
-{0x0F12, 0x0000},	 //af_search_usFineMaxScale
-{0x002A, 0x15E0},
-{0x0F12, 0x0902},	 //af_pos_usFineStepNumSize
-     
-{0x002A, 0x164C},
-{0x0F12, 0x0003},	 //af_search_usMinPeakSamples
-{0x002A, 0x163E},
-{0x0F12, 0x00E5},	 //af_search_usPeakThr Full search (E5 90%)
-{0x0F12, 0x0098},	 //af_search_usPeakThrLow
-{0x002A, 0x15D4},
-{0x0F12, 0x0020},	 //af_pos_usHomePos
-{0x0F12, 0xD020},	 //af_pos_usLowConfPos
-{0x002A, 0x169A},
-{0x0F12, 0xFF95},	 //af_search_usConfCheckOrder_1_
-{0x002A, 0x166A},
-{0x0F12, 0x0280},	 //af_search_usConfThr_4_
-{0x002A, 0x1676},	
-{0x0F12, 0x03FF},	 //af_search_usConfThr_10_
-{0x0F12, 0x0320},	 //af_search_usConfThr_11_
-{0x002A, 0x16BC},	
-{0x0F12, 0x0030},	 //af_stat_usMinStatVal
-{0x002A, 0x16E0},	
-{0x0F12, 0x0060},	 //af_scene_usSceneLowNormBrThr
-{0x002A, 0x16D4},	
-{0x0F12, 0x0010},	 //af_stat_usBpfThresh
-{0x002A, 0x1656},	
-{0x0F12, 0x0000},	 //af_search_usCapturePolicy
-{0x002A, 0x15E6},
-{0x0F12, 0x003C},	 //af_pos_usCaptureFixedPos
-     
-{0x0F12, 0x0018},	 //af_pos_usTableLastInd
-{0x0F12, 0x002A},	 //af_pos_usTable_0_
-{0x0F12, 0x0030},	 //af_pos_usTable_1_
-{0x0F12, 0x0036},	 //af_pos_usTable_2_
-{0x0F12, 0x003C},	 //af_pos_usTable_3_
-{0x0F12, 0x0042},	 //af_pos_usTable_4_
-{0x0F12, 0x0048},	 //af_pos_usTable_5_
-{0x0F12, 0x004E},	 //af_pos_usTable_6_
-{0x0F12, 0x0054},	 //af_pos_usTable_7_
-{0x0F12, 0x005A},	 //af_pos_usTable_8_
-{0x0F12, 0x0060},	 //af_pos_usTable_9_
-{0x0F12, 0x0066},	 //af_pos_usTable_10
-{0x0F12, 0x006C},	 //af_pos_usTable_11_
-{0x0F12, 0x0072},	 //af_pos_usTable_12_
-{0x0F12, 0x0078},	 //af_pos_usTable_13_
-{0x0F12, 0x007E},	 //af_pos_usTable_14_
-{0x0F12, 0x0084},	 //af_pos_usTable_15_
-{0x0F12, 0x008A},	 //af_pos_usTable_16_
-{0x0F12, 0x0090},	 //af_pos_usTable_17_
-{0x0F12, 0x0096},	 //af_pos_usTable_18_
-{0x0F12, 0x009C},	 //af_pos_usTable_19_
-{0x0F12, 0x00A2},	 //af_pos_usTable_20_
-{0x0F12, 0x00A8},	 //af_pos_usTable_21_
-{0x0F12, 0x00AE},	 //af_pos_usTable_22_
-{0x0F12, 0x00B4},	 //af_pos_usTable_23_
-{0x0F12, 0x00BA},	 //af_pos_usTable_24_
-     
-{0x002A, 0x1722},
-{0x0F12, 0x8000},	 //afd_usParam_0_
-{0x0F12, 0x0006},	 //afd_usParam_1_
-{0x0F12, 0x3FF0},	 //afd_usParam_2_
-{0x0F12, 0x03E8},	 //afd_usParam_3_
-{0x0F12, 0x0000},	 //afd_usParam_4_
-{0x0F12, 0x0020},	 //afd_usParam_5_
-{0x0F12, 0x0010},	 //afd_usParam_6_
-{0x0F12, 0x0010},	 //afd_usParam_7_
-{0x0F12, 0x0040},	 //afd_usParam_8_
-{0x0F12, 0x0080},	 //afd_usParam_9_
-{0x0F12, 0x00C0},	 //afd_usParam_10_
-{0x0F12, 0x00E0},	 //afd_usParam_11_
-     
-{0x002A, 0x028C},
-{0x0F12, 0x0003},	 //REG_TC_AF_AfCmd
+//This register is for FACTORY ONLY.
+//If you change it without prior notification
+//YOU are RESPONSIBLE for the FAILURE that will happen in the future
+//For subsampling Size
+{0x002A,0x18BC},
+{0x0F12,0x0004},
+{0x0F12,0x05B6},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0001},
+{0x0F12,0x05BA},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0007},
+{0x0F12,0x05BA},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x01F4},
+{0x0F12,0x024E},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x01F4},
+{0x0F12,0x05B6},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x01F4},
+{0x0F12,0x05BA},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x01F4},
+{0x0F12,0x024F},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0075},
+{0x0F12,0x00CF},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0075},
+{0x0F12,0x00D6},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0004},
+{0x0F12,0x01F4},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x00F0},
+{0x0F12,0x01F4},
+{0x0F12,0x029E},
+{0x0F12,0x05B2},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x01F8},
+{0x0F12,0x0228},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0208},
+{0x0F12,0x0238},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0218},
+{0x0F12,0x0238},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0001},
+{0x0F12,0x0009},
+{0x0F12,0x00DE},
+{0x0F12,0x05C0},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x00DF},
+{0x0F12,0x00E4},
+{0x0F12,0x01F8},
+{0x0F12,0x01FD},
+{0x0F12,0x05B6},
+{0x0F12,0x05BB},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x01F8},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0077},
+{0x0F12,0x007E},
+{0x0F12,0x024F},
+{0x0F12,0x025E},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+// For Capture
+{0x0F12,0x0004},
+{0x0F12,0x09D1},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0001},
+{0x0F12,0x09D5},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0008},
+{0x0F12,0x09D5},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x02AA},
+{0x0F12,0x0326},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x02AA},
+{0x0F12,0x09D1},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x02AA},
+{0x0F12,0x09D5},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x02AA},
+{0x0F12,0x0327},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0008},
+{0x0F12,0x0084},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0008},
+{0x0F12,0x008D},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0008},
+{0x0F12,0x02AA},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x00AA},
+{0x0F12,0x02AA},
+{0x0F12,0x03AD},
+{0x0F12,0x09CD},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x02AE},
+{0x0F12,0x02DE},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x02BE},
+{0x0F12,0x02EE},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x02CE},
+{0x0F12,0x02EE},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0001},
+{0x0F12,0x0009},
+{0x0F12,0x0095},
+{0x0F12,0x09DB},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0096},
+{0x0F12,0x009B},
+{0x0F12,0x02AE},
+{0x0F12,0x02B3},
+{0x0F12,0x09D1},
+{0x0F12,0x09D6},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x02AE},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0009},
+{0x0F12,0x0010},
+{0x0F12,0x0327},
+{0x0F12,0x0336},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x002A,0x1AF8},
+{0x0F12,0x5A3C},	// senHal_TuneStr_AngTuneData1_2_D000F400 register at subsampling
+{0x002A,0x1896},
+{0x0F12,0x0002},	// senHal_SamplingType	0002 03EE: PLA setting
+{0x0F12,0x0000},	// senHal_SamplingMode 0 : 2 PLA / 1 : 4PLA
+{0x0F12,0x0001},	// senHal_PLAOption	[0] VPLA enable  [1] HPLA enable
+{0x002A,0x1B00},
+{0x0F12,0xF428},
+{0x0F12,0xFFFF},
+{0x0F12,0x0000},
+{0x002A,0x189E},
+{0x0F12,0x0FB0},	// senHal_ExpMinPixels
+{0x002A,0x18AC},
+{0x0F12,0x0060},	// senHal_uAddColsBin
+{0x0F12,0x0060},	// senHal_uAddColsNoBin
+{0x0F12,0x07DC},	// senHal_uMinColsBin
+{0x0F12,0x05C0},	// senHal_uMinColsNoBin
+{0x002A,0x1AEA},
+{0x0F12,0x8080},	// senHal_SubF404Tune
+{0x0F12,0x0080},	// senHal_FullF404Tune
+{0x002A,0x1AE0},
+{0x0F12,0x0000},	// senHal_bSenAAC
+{0x002A,0x1A72},
+{0x0F12,0x0000},	// senHal_bSRX	SRX off
+{0x002A,0x18A2},
+{0x0F12,0x0004},	// senHal_NExpLinesCheckFine extend Forbidden area line
+{0x002A,0x1A6A},
+{0x0F12,0x009A},	// senHal_usForbiddenRightOfs extend right Forbidden area line
+{0x002A,0x385E},
+{0x0F12,0x024C},	// Mon_Sen_uExpPixelsOfs
+{0x002A,0x0EE6},
+{0x0F12,0x0000},	// setot_bUseDigitalHbin
+{0x002A,0x1B2A},
+{0x0F12,0x0300},	// 70001B2A //senHal_TuneStr2_usAngTuneGainTh
+{0x0F12,0x00D6},	// 70001B2C //senHal_TuneStr2_AngTuneF4CA_0_
+{0x0F12,0x008D},	// 70001B2E //senHal_TuneStr2_AngTuneF4CA_1_
+{0x0F12,0x00CF},	// 70001B30 //senHal_TuneStr2_AngTuneF4C2_0_
+{0x0F12,0x0084},	// 70001B32 //senHal_TuneStr2_AngTuneF4C2_1_
 
 //==================================================================================
-//04.Gas_Anti Shading_Otp
+// 08.AF Setting
 //==================================================================================
-{0x002A, 0x08B4},
-{0x0F12, 0x0001},	 //wbt_bUseOutdoorASH
 
-// Refer Mon_AWB_RotGain
-{0x002A, 0x08BC},
-{0x0F12, 0x00C0},	 //TVAR_ash_AwbAshCord_0_ 2300K
-{0x0F12, 0x00DF},	 //TVAR_ash_AwbAshCord_1_ 2750K
-{0x0F12, 0x0100},	 //TVAR_ash_AwbAshCord_2_ 3300K
-{0x0F12, 0x0125},	 //TVAR_ash_AwbAshCord_3_ 4150K
-{0x0F12, 0x015F},	 //TVAR_ash_AwbAshCord_4_ 5250K
-{0x0F12, 0x017C},	 //TVAR_ash_AwbAshCord_5_ 6400K
-{0x0F12, 0x0194},	 //TVAR_ash_AwbAshCord_6_ 7500K
-         
-// GAS Alpha Table
-{0x002A, 0x08F6},
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_0__0_ R   // 2300K
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_0__1_ GR
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_0__2_ GB
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_0__3_ B
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_1__0_ R   // 2750K
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_1__1_ GR
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_1__2_ GB
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_1__3_ B
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_2__0_ R   // 3300K
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_2__1_ GR
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_2__2_ GB
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_2__3_ B
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_3__0_ R   // 4150K
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_3__1_ GR
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_3__2_ GB
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_3__3_ B
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_4__0_ R   // 5250K
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_4__1_ GR
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_4__2_ GB
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_4__3_ B
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_5__0_ R   // 6400K
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_5__1_ GR
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_5__2_ GB
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_5__3_ B
-{0x0F12, 0x4500},	 //TVAR_ash_GASAlpha_6__0_ R   // 7500K
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_6__1_ GR
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_6__2_ GB
-{0x0F12, 0x4000},	 //TVAR_ash_GASAlpha_6__3_ B
-
-// Outdoor GAS Alpha
-{0x0F12, 0x4800},	 //TVAR_ash_GASOutdoorAlpha_0_ R
-{0x0F12, 0x4200},	 //TVAR_ash_GASOutdoorAlpha_1_ GR
-{0x0F12, 0x4000},	 //TVAR_ash_GASOutdoorAlpha_2_ GB
-{0x0F12, 0x4000},	 //TVAR_ash_GASOutdoorAlpha_3_ B
-
-{0x002A, 0x08F4},
-{0x0F12, 0x0001},	 //ash_bUseGasAlpha
+//AF interface setting
+{0x002A,0x01FC},
+{0x0F12,0x0001},	// REG_TC_IPRM_LedGpio, for Flash control
+//s002A1720
+//s0F120100	// afd_usFlags, Low voltage AF enable
+{0x0F12,0x0003},	// REG_TC_IPRM_CM_Init_AfModeType, VCM IIC
+{0x0F12,0x0000},	// REG_TC_IPRM_CM_Init_PwmConfig1
+{0x002A,0x0204},
+{0x0F12,0x0061},	// REG_TC_IPRM_CM_Init_GpioConfig1, AF Enable GPIO 6
+{0x002A,0x020C},
+{0x0F12,0x2F0C},	// REG_TC_IPRM_CM_Init_Mi2cBit
+{0x0F12,0x0190},	// REG_TC_IPRM_CM_Init_Mi2cRateKhz, IIC Speed
+
+
+//AF Window Settings
+{0x002A,0x0294},
+{0x0F12,0x0100},	// REG_TC_AF_FstWinStartX
+{0x0F12,0x00E3},	// REG_TC_AF_FstWinStartY
+{0x0F12,0x0200},	// REG_TC_AF_FstWinSizeX
+{0x0F12,0x0238},	// REG_TC_AF_FstWinSizeY
+{0x0F12,0x018C},	// REG_TC_AF_ScndWinStartX
+{0x0F12,0x0166},	// REG_TC_AF_ScndWinStartY
+{0x0F12,0x00E6},	// REG_TC_AF_ScndWinSizeX
+{0x0F12,0x0132},	// REG_TC_AF_ScndWinSizeY
+{0x0F12,0x0001},	// REG_TC_AF_WinSizesUpdated
+
+
+//2nd search setting
+{0x002A,0x070E},
+{0x0F12,0x00C0},	// skl_af_StatOvlpExpFactor
+{0x002A,0x071E},
+{0x0F12,0x0000},	// skl_af_bAfStatOff
+{0x002A,0x163C},
+{0x0F12,0x0000},	// af_search_usAeStable
+{0x002A,0x1648},
+{0x0F12,0x9002},	// af_search_usSingleAfFlags
+{0x002A,0x1652},
+{0x0F12,0x0002},	// af_search_usFinePeakCount
+{0x0F12,0x0000},	// af_search_usFineMaxScale
+{0x002A,0x15E0},
+{0x0F12,0x0403},	// af_pos_usFineStepNumSize
+{0x002A,0x1656},
+{0x0F12,0x0000},	// af_search_usCapturePolicy
+
+
+//Peak Threshold
+{0x002A,0x164C},
+{0x0F12,0x0003},	// af_search_usMinPeakSamples
+{0x002A,0x163E},
+{0x0F12,0x00C0},	// af_search_usPeakThr
+{0x0F12,0x0080},	// af_search_usPeakThrLow
+{0x002A,0x47A8},
+{0x0F12,0x0080},	// TNP, Macro Threshold register
+
+
+//Home Pos
+{0x002A,0x15D4},
+{0x0F12,0x0000},	// af_pos_usHomePos
+{0x0F12,0xD000},	// af_pos_usLowConfPos
+
+
+//AF statistics
+{0x002A,0x169A},
+{0x0F12,0xFF95},	// af_search_usConfCheckOrder_1_
+{0x002A,0x166A},
+{0x0F12,0x0280},	// af_search_usConfThr_4_
+{0x002A,0x1676},
+{0x0F12,0x03A0},	// af_search_usConfThr_10_
+{0x0F12,0x0320},	// af_search_usConfThr_11_
+{0x002A,0x16BC},
+{0x0F12,0x0030},	// af_stat_usMinStatVal
+{0x002A,0x16E0},
+{0x0F12,0x0060},	// af_scene_usSceneLowNormBrThr
+{0x002A,0x16D4},
+{0x0F12,0x0010},	// af_stat_usBpfThresh
+
+
+//AF Lens Position Table Settings
+{0x002A,0x15E8},
+{0x0F12,0x0010},	// af_pos_usTableLastInd
+{0x0F12,0x0018},	// af_pos_usTable
+{0x0F12,0x0020},	// af_pos_usTable
+{0x0F12,0x0028},	// af_pos_usTable
+{0x0F12,0x0030},	// af_pos_usTable
+{0x0F12,0x0038},	// af_pos_usTable
+{0x0F12,0x0040},	// af_pos_usTable
+{0x0F12,0x0048},	// af_pos_usTable
+{0x0F12,0x0050},	// af_pos_usTable
+{0x0F12,0x0058},	// af_pos_usTable
+{0x0F12,0x0060},	// af_pos_usTable
+{0x0F12,0x0068},	// af_pos_usTable
+{0x0F12,0x0070},	// af_pos_usTable
+{0x0F12,0x0080},	// af_pos_usTable
+{0x0F12,0x0090},	// af_pos_usTable
+{0x0F12,0x00A0},	// af_pos_usTable
+{0x0F12,0x00B0},	// af_pos_usTable
+{0x0F12,0x00C0},	// af_pos_usTable
+
+//VCM AF driver with PWM/I2C
+{0x002A,0x1722},
+{0x0F12,0x8000},	// afd_usParam[0] I2C power down command
+{0x0F12,0x0006},	// afd_usParam[1] Position Right Shift
+{0x0F12,0x3FF0},	// afd_usParam[2] I2C Data Mask
+{0x0F12,0x03E8},	// afd_usParam[3] PWM Period
+{0x0F12,0x0000},	// afd_usParam[4] PWM Divider
+{0x0F12,0x0020},	// afd_usParam[5] SlowMotion Delay 4. reduce lens collision noise.
+{0x0F12,0x0010},	// afd_usParam[6] SlowMotion Threshold
+{0x0F12,0x0008},	// afd_usParam[7] Signal Shaping
+{0x0F12,0x0040},	// afd_usParam[8] Signal Shaping level
+{0x0F12,0x0080},	// afd_usParam[9] Signal Shaping level
+{0x0F12,0x00C0},	// afd_usParam[10] Signal Shaping level
+{0x0F12,0x00E0},	// afd_usParam[11] Signal Shaping level
+{0x002A,0x028C},
+{0x0F12,0x0003},	// REG_TC_AF_AfCmd
 
+
+//==================================================================================
+// 09.AWB-BASIC setting
 //==================================================================================
-// 09.Auto Flicker Detection
+
 //==================================================================================
+// 09.AWB-BASIC setting
+//==================================================================================
+
+// AWB Init
+{0x002A,0x145E},
+{0x0F12,0x0523},  //awbb_GainsInit_0_
+{0x0F12,0x0400},  //awbb_GainsInit_1_
+{0x0F12,0x07D0},  //awbb_GainsInit_2_
 
-{0x002A, 0x0F30}, 	
-{0x0F12, 0x0001},   	 //AFC_D_ConvAccelerPower 
-     
-// Auto Flicker (60Mhz start)	
-{0x002A, 0x0F2A},	
-{0x0F12, 0x0000},	 //AFC_Default BIT[0] 1:60Hz 0:50Hz
-{0x002A, 0x04E6},	                                      
-{0x0F12, 0x077F},	 //REG_TC_DBG 7F: 60Hz  5F:50Hz
+// White Locus
+{0x002A,0x11F0},
+{0x0F12,0x0125},  //#awbb_IntcR
+{0x0F12,0x0130},  //#awbb_IntcB
+
+// IndoorZone
+{0x002A,0x101C},
+{0x0F12,0x03A0},  //#awbb_IndoorGrZones_m_BGrid_0__m_left
+{0x0F12,0x03B6},  //#awbb_IndoorGrZones_m_BGrid_0__m_right
+{0x0F12,0x02DC},  //#awbb_IndoorGrZones_m_BGrid_1__m_left
+{0x0F12,0x037C},  //#awbb_IndoorGrZones_m_BGrid_1__m_right
+{0x0F12,0x02A8},  //#awbb_IndoorGrZones_m_BGrid_2__m_left
+{0x0F12,0x034C},  //#awbb_IndoorGrZones_m_BGrid_2__m_right
+{0x0F12,0x0286},  //#awbb_IndoorGrZones_m_BGrid_3__m_left
+{0x0F12,0x031E},  //#awbb_IndoorGrZones_m_BGrid_3__m_right
+{0x0F12,0x0266},  //#awbb_IndoorGrZones_m_BGrid_4__m_left
+{0x0F12,0x02FA},  //#awbb_IndoorGrZones_m_BGrid_4__m_right
+{0x0F12,0x0246},  //#awbb_IndoorGrZones_m_BGrid_5__m_left
+{0x0F12,0x02DA},  //#awbb_IndoorGrZones_m_BGrid_5__m_right
+{0x0F12,0x0230},  //#awbb_IndoorGrZones_m_BGrid_6__m_left
+{0x0F12,0x02B8},  //#awbb_IndoorGrZones_m_BGrid_6__m_right
+{0x0F12,0x021A},  //#awbb_IndoorGrZones_m_BGrid_7__m_left
+{0x0F12,0x0298},  //#awbb_IndoorGrZones_m_BGrid_7__m_right
+{0x0F12,0x0200},  //#awbb_IndoorGrZones_m_BGrid_8__m_left
+{0x0F12,0x0284},  //#awbb_IndoorGrZones_m_BGrid_8__m_right
+{0x0F12,0x01F0},  //#awbb_IndoorGrZones_m_BGrid_9__m_left
+{0x0F12,0x0278},  //#awbb_IndoorGrZones_m_BGrid_9__m_right
+{0x0F12,0x01E0},  //#awbb_IndoorGrZones_m_BGrid_10__m_left
+{0x0F12,0x026C},  //#awbb_IndoorGrZones_m_BGrid_10__m_right
+{0x0F12,0x01D0},  //#awbb_IndoorGrZones_m_BGrid_11__m_left
+{0x0F12,0x025E},  //#awbb_IndoorGrZones_m_BGrid_11__m_right
+{0x0F12,0x01C4},  //#awbb_IndoorGrZones_m_BGrid_12__m_left
+{0x0F12,0x0252},  //#awbb_IndoorGrZones_m_BGrid_12__m_right
+{0x0F12,0x01B6},  //#awbb_IndoorGrZones_m_BGrid_13__m_left
+{0x0F12,0x0244},  //#awbb_IndoorGrZones_m_BGrid_13__m_right
+{0x0F12,0x01D2},  //#awbb_IndoorGrZones_m_BGrid_14__m_left
+{0x0F12,0x0216},  //#awbb_IndoorGrZones_m_BGrid_14__m_right
+{0x0F12,0x0000},  //#awbb_IndoorGrZones_m_BGrid_15__m_left
+{0x0F12,0x0000},  //#awbb_IndoorGrZones_m_BGrid_15__m_right
+{0x0F12,0x0000},  //#awbb_IndoorGrZones_m_BGrid_16__m_left
+{0x0F12,0x0000},  //#awbb_IndoorGrZones_m_BGrid_16__m_right
+{0x0F12,0x0000},  //#awbb_IndoorGrZones_m_BGrid_17__m_left
+{0x0F12,0x0000},  //#awbb_IndoorGrZones_m_BGrid_17__m_right
+{0x0F12,0x0000},  //#awbb_IndoorGrZones_m_BGrid_18__m_left
+{0x0F12,0x0000},  //#awbb_IndoorGrZones_m_BGrid_18__m_right
+{0x0F12,0x0000},  //#awbb_IndoorGrZones_m_BGrid_19__m_left
+{0x0F12,0x0000},  //#awbb_IndoorGrZones_m_BGrid_19__m_right
+
+{0x0F12,0x0005},  //#awbb_IndoorGrZones_m_GridStep
+{0x002A,0x1070},
+{0x0F12,0x000F},  //#awbb_IndoorGrZones_ZInfo_m_GridSz
+{0x002A,0x1074},
+{0x0F12,0x013C},  //#awbb_IndoorGrZones_m_Boffs
 
+// Outdoor Zone
+{0x002A,0x1078},
+{0x0F12,0x0264},  //#awbb_OutdoorGrZones_m_BGrid_0__m_left
+{0x0F12,0x0278},  //#awbb_OutdoorGrZones_m_BGrid_0__m_right
+{0x0F12,0x0242},  //#awbb_OutdoorGrZones_m_BGrid_1__m_left
+{0x0F12,0x028E},  //#awbb_OutdoorGrZones_m_BGrid_1__m_right
+{0x0F12,0x022A},  //#awbb_OutdoorGrZones_m_BGrid_2__m_left
+{0x0F12,0x0290},  //#awbb_OutdoorGrZones_m_BGrid_2__m_right
+{0x0F12,0x021E},  //#awbb_OutdoorGrZones_m_BGrid_3__m_left
+{0x0F12,0x0290},  //#awbb_OutdoorGrZones_m_BGrid_3__m_right
+{0x0F12,0x0214},  //#awbb_OutdoorGrZones_m_BGrid_4__m_left
+{0x0F12,0x0290},  //#awbb_OutdoorGrZones_m_BGrid_4__m_right
+{0x0F12,0x0206},  //#awbb_OutdoorGrZones_m_BGrid_5__m_left
+{0x0F12,0x028E},  //#awbb_OutdoorGrZones_m_BGrid_5__m_right
+{0x0F12,0x01FA},  //#awbb_OutdoorGrZones_m_BGrid_6__m_left
+{0x0F12,0x0286},  //#awbb_OutdoorGrZones_m_BGrid_6__m_right
+{0x0F12,0x01F4},  //#awbb_OutdoorGrZones_m_BGrid_7__m_left
+{0x0F12,0x0280},  //#awbb_OutdoorGrZones_m_BGrid_7__m_right
+{0x0F12,0x01F2},  //#awbb_OutdoorGrZones_m_BGrid_8__m_left
+{0x0F12,0x0278},  //#awbb_OutdoorGrZones_m_BGrid_8__m_right
+{0x0F12,0x01F0},  //#awbb_OutdoorGrZones_m_BGrid_9__m_left
+{0x0F12,0x026E},  //#awbb_OutdoorGrZones_m_BGrid_9__m_right
+{0x0F12,0x01F0},  //#awbb_OutdoorGrZones_m_BGrid_10__m_left
+{0x0F12,0x0262},  //#awbb_OutdoorGrZones_m_BGrid_10__m_right
+{0x0F12,0x01F0},  //#awbb_OutdoorGrZones_m_BGrid_11__m_left
+{0x0F12,0x0218},  //#awbb_OutdoorGrZones_m_BGrid_11__m_right
+
+{0x0F12,0x0004},  //#awbb_OutdoorGrZones_m_GridStep
+{0x002A,0x10AC},  
+{0x0F12,0x000C},  //#awbb_OutdoorGrZones_ZInfo_m_GridSz
+{0x002A,0x10B0},  
+{0x0F12,0x020C},  //#awbb_OutdoorGrZones_m_Boffs
+
+// LowBR Zone
+{0x002A,0x10B4},
+{0x0F12,0x0350},  //#awbb_LowBrGrZones
+{0x0F12,0x0422},  //#awbb_LowBrGrZones_m_BGrid_0__m_right
+{0x0F12,0x02C4},  //#awbb_LowBrGrZones_m_BGrid_1__m_left
+{0x0F12,0x0452},  //#awbb_LowBrGrZones_m_BGrid_1__m_right
+{0x0F12,0x0278},  //#awbb_LowBrGrZones_m_BGrid_2__m_left
+{0x0F12,0x041C},  //#awbb_LowBrGrZones_m_BGrid_2__m_right
+{0x0F12,0x0230},  //#awbb_LowBrGrZones_m_BGrid_3__m_left
+{0x0F12,0x03EE},  //#awbb_LowBrGrZones_m_BGrid_3__m_right
+{0x0F12,0x01F0},  //#awbb_LowBrGrZones_m_BGrid_4__m_left
+{0x0F12,0x0392},  //#awbb_LowBrGrZones_m_BGrid_4__m_right
+{0x0F12,0x01C0},  //#awbb_LowBrGrZones_m_BGrid_5__m_left
+{0x0F12,0x0340},  //#awbb_LowBrGrZones_m_BGrid_5__m_right
+{0x0F12,0x0194},  //#awbb_LowBrGrZones_m_BGrid_6__m_left
+{0x0F12,0x0302},  //#awbb_LowBrGrZones_m_BGrid_6__m_right
+{0x0F12,0x016E},  //#awbb_LowBrGrZones_m_BGrid_7__m_left
+{0x0F12,0x02C2},  //#awbb_LowBrGrZones_m_BGrid_7__m_right
+{0x0F12,0x0148},  //#awbb_LowBrGrZones_m_BGrid_8__m_left
+{0x0F12,0x0286},  //#awbb_LowBrGrZones_m_BGrid_8__m_right
+{0x0F12,0x018A},  //#awbb_LowBrGrZones_m_BGrid_9__m_left
+{0x0F12,0x0242},  //#awbb_LowBrGrZones_m_BGrid_9__m_right
+{0x0F12,0x0000},  //#awbb_LowBrGrZones_m_BGrid_10__m_left
+{0x0F12,0x0000},  //#awbb_LowBrGrZones_m_BGrid_10__m_right
+{0x0F12,0x0000},  //#awbb_LowBrGrZones_m_BGrid_11__m_left
+{0x0F12,0x0000},  //#awbb_LowBrGrZones_m_BGrid_11__m_right
+          
+{0x0F12,0x0006},  //#awbb_LowBrGrZones_m_GridStep
+{0x002A,0x10E8},  
+{0x0F12,0x000A},  //#awbb_LowBrGrZones_ZInfo_m_GridSz
+{0x002A,0x10EC},  
+{0x0F12,0x0106},  //#awbb_LowBrGrZones_m_Boffs
+
+// LowTemp Zone
+{0x002A,0x10F0},
+{0x0F12,0x0380},
+{0x0F12,0x0000},  //#awbb_CrclLowT_R_c
+{0x0F12,0x0168},
+{0x0F12,0x0000},  //#awbb_CrclLowT_B_c
+{0x0F12,0x2D90},
+{0x0F12,0x0000},  //#awbb_CrclLowT_Rad_c
 
+// AWB Convergence Speed
+{0x002A,0x1464},
+{0x0F12,0x0008},  //#awbb_WpFilterMinThr
+{0x0F12,0x0190},  //#awbb_WpFilterMaxThr
+{0x0F12,0x00FF},  //#awbb_WpFilterCoef
+
+{0x002A,0x1228},
+{0x0F12,0x00C0},  //#awbb_YThreshHigh
+{0x002A,0x122C},
+{0x0F12,0x0010},  //#awbb_YThreshLow_Low
+{0x002A,0x122A},
+{0x0F12,0x0010},  //#awbb_YThreshLow_Norm
+
+{0x002A,0x120A},
+{0x0F12,0x05D5},  //#awbb_MvEq_RBthresh
+{0x002A,0x120E},
+{0x0F12,0x0000},  //#awbb_MovingScale10
+
+{0x0F12,0x0771},  //#awbb_GamutWidthThr1
+{0x0F12,0x03A4},  //#awbb_GamutHeightThr1
+{0x0F12,0x0036},  //#awbb_GamutWidthThr2
+{0x0F12,0x002A},  //#awbb_GamutHeightThr2
+
+{0x002A,0x1278},
+{0x0F12,0xFEF7},  //#awbb_SCDetectionMap_SEC_StartR_B
+{0x0F12,0x0021},  //#awbb_SCDetectionMap_SEC_StepR_B
+{0x0F12,0x0BB8},  //#awbb_SCDetectionMap_SEC_SunnyNB
+{0x0F12,0x0BB8},  //#awbb_SCDetectionMap_SEC_StepNB
+{0x0F12,0x018F},  //#awbb_SCDetectionMap_SEC_LowTempR_B
+{0x0F12,0x0096},  //#awbb_SCDetectionMap_SEC_SunnyNBZone
+{0x0F12,0x000E},  //#awbb_SCDetectionMap_SEC_LowTempR_BZone
+{0x002A,0x1224},  
+{0x0F12,0x0032},  //#awbb_LowBr
+{0x0F12,0x001E},  //#awbb_LowBr_NBzone
+{0x002A,0x2BA4},  
+{0x0F12,0x0006},  //#Mon_AWB_ByPassMode
+           
+{0x002A,0x146C},  
+{0x0F12,0x0002},  //#awbb_GridEnable
+
+// Grid     
+{0x002A,0x1434},
+{0x0F12,0x0300},  //#awbb_GridConst_1
+{0x0F12,0x036E},  //#awbb_GridConst_1_1_
+{0x0F12,0x03C2},  //#awbb_GridConst_1_2_
+{0x0F12,0x1015},  //#awbb_GridConst_2
+{0x0F12,0x106C},  //#awbb_GridConst_2_1_
+{0x0F12,0x10CA},  //#awbb_GridConst_2_2_
+{0x0F12,0x1142},  //#awbb_GridConst_2_3_
+{0x0F12,0x11BB},  //#awbb_GridConst_2_4_
+{0x0F12,0x123B},  //#awbb_GridConst_2_5_
+{0x0F12,0x00AB},  //#awbb_GridCoeff_R_1
+{0x0F12,0x00BF},  //#awbb_GridCoeff_B_1
+{0x0F12,0x00D2},  //#awbb_GridCoeff_R_2
+{0x0F12,0x0093},  //#awbb_GridCoeff_B_2
+
+// Indoor Grid Offset
+{0x002A,0x13A4},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+{0x0F12,0x0000},
+
+// Outdoor Grid Offset
+{0x0F12,0xFFEA},
+{0x0F12,0xFFEA},
+{0x0F12,0xFFC8},
+{0x0F12,0xFFC8},
+{0x0F12,0xFFC8},
+{0x0F12,0xFFC8},
+{0x0F12,0xFFEA},
+{0x0F12,0xFFEA},
+{0x0F12,0xFFC8},
+{0x0F12,0xFFC8},
+{0x0F12,0xFFC8},
+{0x0F12,0xFFC8},
+{0x0F12,0xFFEA},
+{0x0F12,0xFFEA},
+{0x0F12,0xFFC8},
+{0x0F12,0xFFC8},
+{0x0F12,0xFFC8},
+{0x0F12,0xFFC8},
+{0x0F12,0x0014},
+{0x0F12,0x0014},
+{0x0F12,0x0014},
+{0x0F12,0xFDA0},
+{0x0F12,0xFCF0},
+{0x0F12,0xFCD0},
+{0x0F12,0x0014},
+{0x0F12,0x0014},
+{0x0F12,0x0014},
+{0x0F12,0xFDA0},
+{0x0F12,0xFCF0},
+{0x0F12,0xFCD0},
+{0x0F12,0x0014},
+{0x0F12,0x0014},
+{0x0F12,0x0014},
+{0x0F12,0xFDA0},
+{0x0F12,0xFCF0},
+{0x0F12,0xFCD0},
+
+{0x002A,0x1208},
+{0x0F12,0x0020},  //#awbb_MinNumOfChromaClassifyPatches
+
+{0x002A,0x144E},
+{0x0F12,0x0000},  //#awbb_RGainOff
+{0x0F12,0x0000},  //#awbb_BGainOff
+{0x0F12,0x0000},  //#awbb_GGainOff
 //==================================================================================
-// 10.AE Setting
+// 10.Clock Setting
+//==================================================================================
+//Input Clock (Mclk)
+{0x002A,0x01F8},                                                                         
+{0x0F12,0x5DC0},//REG_TC_IPRM_InClockLSBs MCLK: 24Mhz                                  
+{0x002A,0x0212},                                                                          
+{0x0F12,0x0000}, //REG_TC_IPRM_UseNPviClocks                                            
+{0x0F12,0x0003},//REG_TC_IPRM_UseNMipiClocks       0x0002                                     
+{0x0F12,0x0002},  //REG_TC_IPRM_NumberOfMipiLanes                                        
+{0x002A,0x021A},                                                                          
+{0x0F12,0x3A98},  //3A98}  //REG_TC_IPRM_OpClk4KHz_0 SCLK: 60Mhz                                   
+{0x0F12,0x277D},  //REG_TC_IPRM_MinOutRate4KHz_0	PCLK Min : 81Mhz                   
+{0x0F12,0x279D},  //REG_TC_IPRM_MaxOutRate4KHz_0	PCLK Max : 81Mhz                   
+{0x0F12,0x4F1A},  //REG_TC_IPRM_OpClk4KHz_1	SCLK 	 : 81Mhz                           
+{0x0F12,0x277D},  //REG_TC_IPRM_MinOutRate4KHz_1	PCLK Min : 81Mhz                   
+{0x0F12,0x279D},  //REG_TC_IPRM_MaxOutRate4KHz_1 PCLK Max : 81Mhz   
+{0x0F12,0x4F1A},
+{0x0F12,0x5988},
+{0x0F12,0x59D8},
+//==================================================================================
+// 11.Auto Flicker Detection
 //==================================================================================
 
-//AE Target	
-{0x002A, 0x1484},	
-{0x0F12, 0x003C},   	 //TVAR_ae_BrAve
-
-//ae_StatMode bit[3] BLC has to be bypassed to prevent AE weight change especially backlight scene 
-{0x002A, 0x148A},	
-{0x0F12, 0x000F},  	  //ae_StatMode
-
-{0x002A, 0x0588},
-{0x0F12, 0x0000},	 //lt_uInitPostToleranceCnt
-     
-//AE_state                	
-{0x002A, 0x0544},	
-{0x0F12, 0x0111},  	  //lt_uLimitHigh
-{0x0F12, 0x00EF},  	  //lt_uLimitLow
-
-//AE Concept	
-{0x002A, 0x0608},                                	
-{0x0F12, 0x0001}, 	 //lt_ExpGain_uSubsamplingmode
-{0x0F12, 0x0001},	 //lt_ExpGain_uNonSubsampling
-{0x0F12, 0x0800},	 //lt_ExpGain_ExpCurveGainMaxStr
-{0x0F12, 0x0100},   	 //lt_ExpGain_ExpCurveGainMaxStr_0__uMaxDigGain
-
-//Exposure	
-{0x002A, 0x0610},	 //lt_ExpGain_ExpCurveGainMaxStr_0__ulExpIn_0
-{0x0F12, 0x0001},
-{0x0F12, 0x0000},	
-{0x0F12, 0x0A3C},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0D04},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x4008},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x7000},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x9C00},	
-{0x0F12, 0x0000},	
-{0x0F12, 0xAD00},	
-{0x0F12, 0x0001},	
-{0x0F12, 0xF1D4},	
-{0x0F12, 0x0002},	
-{0x0F12, 0xDC00},	
-{0x0F12, 0x0005},	
-{0x0F12, 0xDC00},	
-{0x0F12, 0x0005},	
-     
-{0x002A, 0x0638},	 //lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_0_
-{0x0F12, 0x0001},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0A3C},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x0D05},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x3408},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x3408},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x6810},	
-{0x0F12, 0x0000},	
-{0x0F12, 0x8214},	
-{0x0F12, 0x0000},	
-{0x0F12, 0xC350},	
-{0x0F12, 0x0000},	
-{0x0F12, 0xC350},	
-{0x0F12, 0x0000},	
-{0x0F12, 0xC350},	
-{0x0F12, 0x0000},	
-
-//Gain	
-{0x002A, 0x05A2},	
-{0x0F12, 0x1000},	 //lt_uMaxTotGain
-
-// Lei Control	
-{0x002A, 0x06B8},               	
-{0x0F12, 0x452C},               	
-{0x0F12, 0x0005},  	  //lt_uMaxLei
+{0x002A,0x0F30},
+{0x0F12,0x0001},	// AFC_D_ConvAccelerPower
+// Auto Flicker (60Mhz start)
+{0x002A,0x0F2A},
+{0x0F12,0x0000},//AFC_Default60Hz 0001:60Hz 0000h:50Hz
+{0x002A,0x04E6},
+{0x0F12,0x077F},  //REG_TC_DBG
 
 //==================================================================================
-// 11.AE Weight (Normal)
+// 12.AE Setting
 //==================================================================================
 
-{0x002A, 0x1492},
-{0x0F12, 0x0100},	 //ae_WeightTbl_16_0_
-{0x0F12, 0x0101},	 //ae_WeightTbl_16_1_
-{0x0F12, 0x0101},	 //ae_WeightTbl_16_2_
-{0x0F12, 0x0001},	 //ae_WeightTbl_16_3_
-{0x0F12, 0x0101},	 //ae_WeightTbl_16_4_
-{0x0F12, 0x0201},	 //ae_WeightTbl_16_5_
-{0x0F12, 0x0102},	 //ae_WeightTbl_16_6_
-{0x0F12, 0x0101},	 //ae_WeightTbl_16_7_
-{0x0F12, 0x0101},	 //ae_WeightTbl_16_8_
-{0x0F12, 0x0202},	 //ae_WeightTbl_16_9_
-{0x0F12, 0x0202},	 //ae_WeightTbl_16_10_
-{0x0F12, 0x0101},	 //ae_WeightTbl_16_11_
-{0x0F12, 0x0201},	 //ae_WeightTbl_16_12_
-{0x0F12, 0x0302},	 //ae_WeightTbl_16_13_
-{0x0F12, 0x0203},	 //ae_WeightTbl_16_14_
-{0x0F12, 0x0102},	 //ae_WeightTbl_16_15_
-{0x0F12, 0x0201},	 //ae_WeightTbl_16_16_
-{0x0F12, 0x0302},	 //ae_WeightTbl_16_17_
-{0x0F12, 0x0203},	 //ae_WeightTbl_16_18_
-{0x0F12, 0x0102},	 //ae_WeightTbl_16_19_
-{0x0F12, 0x0101},	 //ae_WeightTbl_16_20_
-{0x0F12, 0x0202},	 //ae_WeightTbl_16_21_
-{0x0F12, 0x0202},	 //ae_WeightTbl_16_22_
-{0x0F12, 0x0101},	 //ae_WeightTbl_16_23_
-{0x0F12, 0x0101},	 //ae_WeightTbl_16_24_
-{0x0F12, 0x0201},	 //ae_WeightTbl_16_25_
-{0x0F12, 0x0102},	 //ae_WeightTbl_16_26_
-{0x0F12, 0x0101},	 //ae_WeightTbl_16_27_
-{0x0F12, 0x0101},	 //ae_WeightTbl_16_28_
-{0x0F12, 0x0101},	 //ae_WeightTbl_16_29_
-{0x0F12, 0x0101},	 //ae_WeightTbl_16_30_
-{0x0F12, 0x0101},	 //ae_WeightTbl_16_31_
+//AE Target
+{0x002A,0x1484},
+{0x0F12,0x003C},	// TVAR_ae_BrAve
+//ae_StatMode bit[3] BLC has to be bypassed to prevent AE weight change especially backlight scene
+{0x002A,0x148A},
+{0x0F12,0x000F},  //ae_StatMode
+{0x002A,0x058C},
+{0x0F12,0x3520},
+{0x0F12,0x0000}, //lt_uMaxExp1
+{0x0F12,0xD4C0},
+{0x0F12,0x0001}, //lt_uMaxExp2
+{0x0F12,0x3520},
+{0x0F12,0x0000}, //lt_uCapMaxExp1
+{0x0F12,0xD4C0},
+{0x0F12,0x0001},//lt_uCapMaxExp2
+{0x002A,0x059C},
+{0x0F12,0x0470},//lt_uMaxAnGain1
+{0x0F12,0x0C00},  //lt_uMaxAnGain2
+{0x0F12,0x0100}, //lt_uMaxDigGain
+{0x0F12,0x1000},  //lt_uMaxTotGain
+{0x002A,0x0544},
+{0x0F12,0x0111}, //lt_uLimitHigh
+{0x0F12,0x00EF},  //lt_uLimitLow
+{0x002A,0x0608},
+{0x0F12,0x0001}, //lt_ExpGain_uSubsamplingmode
+{0x0F12,0x0001},  //lt_ExpGain_uNonSubsampling
+{0x0F12,0x0800}, //lt_ExpGain_ExpCurveGainMaxStr
+{0x0F12,0x0100},  //0100}  //lt_ExpGain_ExpCurveGainMaxStr_0__uMaxDigGain
+{0x0F12,0x0001},  //0001 
+{0x0F12,0x0000},  //0000}  //lt_ExpGain_ExpCurveGainMaxStr_0__ulExpIn_0_
+{0x0F12,0x0A3C},  //0A3C  
+{0x0F12,0x0000}, //0000  
+{0x0F12,0x0D05},  //0D05  
+{0x0F12,0x0000},  //0000  
+{0x0F12,0x4008},  //4008  
+{0x0F12,0x0000},  //0000  
+{0x0F12,0x7000},  //7400}  //?? //700Lux
+{0x0F12,0x0000},  //0000  
+{0x0F12,0x9C00},  //C000}  //?? //9C00->9F->A5 //400Lux
+{0x0F12,0x0000},  //0000  
+{0x0F12,0xAD00},  //AD00  
+{0x0F12,0x0001},  //0001  
+{0x0F12,0xF1D4},  //F1D4  
+{0x0F12,0x0002},  //0002  
+{0x0F12,0xDC00},  //DC00  
+{0x0F12,0x0005}, //0005  
+{0x0F12,0xDC00},  //DC00  
+{0x0F12,0x0005},  //0005              }  //      
+{0x002A,0x0638},  //0638
+{0x0F12,0x0001},  //0001
+{0x0F12,0x0000},  //0000}  //lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_0_
+{0x0F12,0x0A3C},  //0A3C
+{0x0F12,0x0000}, //0000
+{0x0F12,0x0D05},  //0D05
+{0x0F12,0x0000},  //0000
+{0x0F12,0x3408},  //3408
+{0x0F12,0x0000},  //0000
+{0x0F12,0x3408},  //3408
+{0x0F12,0x0000},  //0000
+{0x0F12,0x6810},  //6810
+{0x0F12,0x0000},  //0000
+{0x0F12,0x8214},  //8214
+{0x0F12,0x0000},  //0000
+{0x0F12,0xC350},  //C350
+{0x0F12,0x0000},  //0000
+{0x0F12,0xD4C0},  //C350
+{0x0F12,0x0001},  //0000
+{0x0F12,0xD4C0},  //C350
+{0x0F12,0x0001},  //0000
+{0x002A,0x0660},
+{0x0F12,0x0650},  //lt_ExpGain_ExpCurveGainMaxStr_1_
+{0x0F12,0x0100},  //lt_ExpGain_ExpCurveGainMaxStr_1__uMaxDigGain
+{0x002A,0x06B8},
+{0x0F12,0x452C},
+{0x0F12,0x000A},  //0005}  //lt_uMaxLei
+{0x002A,0x05D0},
+{0x0F12,0x0000}, //lt_mbr_Peak_behind 
+
 
 //==================================================================================
-// 14.AWB-BASIC setting
+// 13.AE Weight (Normal)
 //==================================================================================
+{0x002A,0x1492}, 
+{0x0F12,0x0100},	// ae_WeightTbl_16[0]
+{0x0F12,0x0101},	// ae_WeightTbl_16[1]
+{0x0F12,0x0101},	// ae_WeightTbl_16[2]
+{0x0F12,0x0001},	// ae_WeightTbl_16[3]
+{0x0F12,0x0101},	// ae_WeightTbl_16[4]
+{0x0F12,0x0201},	// ae_WeightTbl_16[5]
+{0x0F12,0x0102},	// ae_WeightTbl_16[6]
+{0x0F12,0x0101},	// ae_WeightTbl_16[7]
+{0x0F12,0x0101},	// ae_WeightTbl_16[8]
+{0x0F12,0x0202},	// ae_WeightTbl_16[9]
+{0x0F12,0x0202},	// ae_WeightTbl_16[10]
+{0x0F12,0x0101},	// ae_WeightTbl_16[11]
+{0x0F12,0x0201},	// ae_WeightTbl_16[12]
+{0x0F12,0x0302},	// ae_WeightTbl_16[13]
+{0x0F12,0x0203},	// ae_WeightTbl_16[14]
+{0x0F12,0x0102},	// ae_WeightTbl_16[15]
+{0x0F12,0x0201},	// ae_WeightTbl_16[16]
+{0x0F12,0x0302},	// ae_WeightTbl_16[17]
+{0x0F12,0x0203},	// ae_WeightTbl_16[18]
+{0x0F12,0x0102},	// ae_WeightTbl_16[19]
+{0x0F12,0x0201},	// ae_WeightTbl_16[20]
+{0x0F12,0x0202},	// ae_WeightTbl_16[21]
+{0x0F12,0x0202},	// ae_WeightTbl_16[22]
+{0x0F12,0x0102},	// ae_WeightTbl_16[23]
+{0x0F12,0x0101},	// ae_WeightTbl_16[24]
+{0x0F12,0x0202},	// ae_WeightTbl_16[25]
+{0x0F12,0x0202},	// ae_WeightTbl_16[26]
+{0x0F12,0x0101},	// ae_WeightTbl_16[27]
+{0x0F12,0x0101},	// ae_WeightTbl_16[28]
+{0x0F12,0x0101},	// ae_WeightTbl_16[29]
+{0x0F12,0x0101},	// ae_WeightTbl_16[30]
+{0x0F12,0x0101},	// ae_WeightTbl_16[31]
 
-// AWB init Start point
-{0x002A, 0x145E},
-{0x0F12, 0x0580},	 //awbb_GainsInit_0_
-{0x0F12, 0x0428},	 //awbb_GainsInit_1_
-{0x0F12, 0x0780},	 //awbb_GainsInit_2_
 
-// AWB Convergence Speed
-{0x002A, 0x1464},
-{0x0F12, 0x0008},	 //awbb_WpFilterMinThr
-{0x0F12, 0x0190},	 //awbb_WpFilterMaxThr
-{0x0F12, 0x00A0},	 //awbb_WpFilterCoef
-{0x0F12, 0x0004},	 //awbb_WpFilterSize		
-{0x0F12, 0x0002},	 //awbb_GridEnable	
-
-{0x002A, 0x144E},			
-{0x0F12, 0x0000},	 //awbb_RGainOff 		
-{0x0F12, 0x0000},	 //awbb_BGainOff 		
-{0x0F12, 0x0000},	 //awbb_GGainOff 		
-{0x0f12, 0x00C2},	 //awbb_Alpha_Comp_Mode		
-{0x0F12, 0x0002},	 //awbb_Rpl_InvalidOutDoor		
-{0x0F12, 0x0001},	 //awbb_UseGrThrCorr		
-{0x0F12, 0x0074},	 //awbb_Use_Filters     		
-{0x0F12, 0x0001},	 //awbb_CorrectMinNumPatches		
+//==================================================================================
+// 14.Flash Setting
+//==================================================================================
 
-// White Locus
-{0x002A, 0x11F0},
-{0x0F12, 0x012C},	 //awbb_IntcR
-{0x0F12, 0x0121},	 //awbb_IntcB
-{0x0F12, 0x02DF},	 //awbb_GLocusR		
-{0x0F12, 0x0314},	 //awbb_GLocusB	
-     
-{0x002A, 0x120E},
-{0x0F12, 0x0000},	 //awbb_MovingScale10
-{0x0F12, 0x05FD},	 //awbb_GamutWidthThr1
-{0x0F12, 0x036B},	 //awbb_GamutHeightThr1
-{0x0F12, 0x0020},	 //awbb_GamutWidthThr2
-{0x0F12, 0x001A},	 //awbb_GamutHeightThr2
-     
-{0x002A, 0x1278},
-{0x0F12, 0xFEF7},	 //awbb_SCDetectionMap_SEC_StartR_B
-{0x0F12, 0x0021},	 //awbb_SCDetectionMap_SEC_StepR_B
-{0x0F12, 0x07D0},	 //awbb_SCDetectionMap_SEC_SunnyNB
-{0x0F12, 0x07D0},	 //awbb_SCDetectionMap_SEC_StepNB
-{0x0F12, 0x01C8},	 //awbb_SCDetectionMap_SEC_LowTempR_B
-{0x0F12, 0x0096},	 //awbb_SCDetectionMap_SEC_SunnyNBZone
-{0x0F12, 0x0004},	 //awbb_SCDetectionMap_SEC_LowTempR_BZone
-
-{0x002A, 0x1224},
-{0x0F12, 0x0032},	 //awbb_LowBr
-{0x0F12, 0x001E},	 //awbb_LowBr_NBzone
-{0x0F12, 0x00E2},	 //awbb_YThreshHigh
-{0x0F12, 0x0010},	 //awbb_YThreshLow_Norm
-{0x0F12, 0x0002},	 //awbb_YThreshLow_Low
-{0x002A, 0x2BA4},
-{0x0F12, 0x0002},	         //Mon_AWB_ByPassMode
-	
-{0x002A, 0x11FC},			
-{0x0F12, 0x000C},	 //awbb_MinNumOfFinalPatches  		
-     
-{0x002A, 0x1208},  
-{0x0F12, 0x0020},          //awbb_MinNumOfChromaclassifpatches
-     
-// Indoor Zone
-{0x002A, 0x101C},
-{0x0F12, 0x0360},	 //awbb_IndoorGrZones_m_BGrid_0__m_left
-{0x0F12, 0x036C},	 //awbb_IndoorGrZones_m_BGrid_0__m_right
-{0x0F12, 0x0320},	 //awbb_IndoorGrZones_m_BGrid_1__m_left
-{0x0F12, 0x038A},	 //awbb_IndoorGrZones_m_BGrid_1__m_right
-{0x0F12, 0x02E8},	 //awbb_IndoorGrZones_m_BGrid_2__m_left
-{0x0F12, 0x0380},	 //awbb_IndoorGrZones_m_BGrid_2__m_right
-{0x0F12, 0x02BE},	 //awbb_IndoorGrZones_m_BGrid_3__m_left
-{0x0F12, 0x035A},	 //awbb_IndoorGrZones_m_BGrid_3__m_right
-{0x0F12, 0x0298},	 //awbb_IndoorGrZones_m_BGrid_4__m_left
-{0x0F12, 0x0334},	 //awbb_IndoorGrZones_m_BGrid_4__m_right
-{0x0F12, 0x0272},	 //awbb_IndoorGrZones_m_BGrid_5__m_left
-{0x0F12, 0x030E},	 //awbb_IndoorGrZones_m_BGrid_5__m_right
-{0x0F12, 0x024C},	 //awbb_IndoorGrZones_m_BGrid_6__m_left
-{0x0F12, 0x02EA},	 //awbb_IndoorGrZones_m_BGrid_6__m_right
-{0x0F12, 0x0230},	 //awbb_IndoorGrZones_m_BGrid_7__m_left
-{0x0F12, 0x02CC},	 //awbb_IndoorGrZones_m_BGrid_7__m_right
-{0x0F12, 0x0214},	 //awbb_IndoorGrZones_m_BGrid_8__m_left
-{0x0F12, 0x02B0},	 //awbb_IndoorGrZones_m_BGrid_8__m_right
-{0x0F12, 0x01F8},	 //awbb_IndoorGrZones_m_BGrid_9__m_left
-{0x0F12, 0x0294},	 //awbb_IndoorGrZones_m_BGrid_9__m_right
-{0x0F12, 0x01DC},	 //awbb_IndoorGrZones_m_BGrid_10__m_left
-{0x0F12, 0x0278},	 //awbb_IndoorGrZones_m_BGrid_10__m_right
-{0x0F12, 0x01C0},	 //awbb_IndoorGrZones_m_BGrid_11__m_left
-{0x0F12, 0x0264},	 //awbb_IndoorGrZones_m_BGrid_11__m_right
-{0x0F12, 0x01AA},	 //awbb_IndoorGrZones_m_BGrid_12__m_left
-{0x0F12, 0x0250},	 //awbb_IndoorGrZones_m_BGrid_12__m_right
-{0x0F12, 0x0196},	 //awbb_IndoorGrZones_m_BGrid_13__m_left
-{0x0F12, 0x023C},	 //awbb_IndoorGrZones_m_BGrid_13__m_right
-{0x0F12, 0x0180},	 //awbb_IndoorGrZones_m_BGrid_14__m_left
-{0x0F12, 0x0228},	 //awbb_IndoorGrZones_m_BGrid_14__m_right
-{0x0F12, 0x016C},	 //awbb_IndoorGrZones_m_BGrid_15__m_left
-{0x0F12, 0x0214},	 //awbb_IndoorGrZones_m_BGrid_15__m_right
-{0x0F12, 0x0168},	 //awbb_IndoorGrZones_m_BGrid_16__m_left
-{0x0F12, 0x0200},	 //awbb_IndoorGrZones_m_BGrid_16__m_right
-{0x0F12, 0x0172},	 //awbb_IndoorGrZones_m_BGrid_17__m_left
-{0x0F12, 0x01EC},	 //awbb_IndoorGrZones_m_BGrid_17__m_right
-{0x0F12, 0x019A},	 //awbb_IndoorGrZones_m_BGrid_18__m_left
-{0x0F12, 0x01D8},	 //awbb_IndoorGrZones_m_BGrid_18__m_right
-{0x0F12, 0x0000},	 //awbb_IndoorGrZones_m_BGrid_19__m_left
-{0x0F12, 0x0000},	 //awbb_IndoorGrZones_m_BGrid_19__m_right
-     
-{0x0F12, 0x0005},	 //awbb_IndoorGrZones_m_GridStep
-{0x002A, 0x1070},
-{0x0F12, 0x0013},	 //awbb_IndoorGrZones_ZInfo_m_GridSz
-{0x002A, 0x1074},
-{0x0F12, 0x00EC},	 //awbb_IndoorGrZones_m_Boffs
+{0x002A,0x0484},
+{0x0F12,0x0002},	// capture flash on
+{0x002A,0x183A},
+{0x0F12,0x0001},	// one frame AE
+{0x002A,0x17F6},
+{0x0F12,0x023C},	// AWB R point
+{0x0F12,0x0248},	// AWB B point
+{0x002A,0x1840},
+{0x0F12,0x0001},	//  Fls AE tune start
+{0x0F12,0x0100},	//  fls_afl_FlsAFIn  Rin
+{0x0F12,0x0120},
+{0x0F12,0x0180},
+{0x0F12,0x0200},
+{0x0F12,0x0400},
+{0x0F12,0x0800},
+{0x0F12,0x0A00},
+{0x0F12,0x1000},
+{0x0F12,0x0100},	//  fls_afl_FlsAFOut  Rout
+{0x0F12,0x00A0},
+{0x0F12,0x0090},
+{0x0F12,0x0080},
+{0x0F12,0x0070},
+{0x0F12,0x0045},
+{0x0F12,0x0030},
+{0x0F12,0x0010},
+{0x002A,0x1884},
+{0x0F12,0x0100},	//  fls_afl_FlsNBOut  flash NB default
+{0x0F12,0x0100},
+{0x0F12,0x0100},
+{0x0F12,0x0100},
+{0x0F12,0x0100},
+{0x0F12,0x0100},
+{0x0F12,0x0100},
+{0x0F12,0x0100},
+{0x002A,0x1826},
+{0x0F12,0x0100},	//  fls_afl_FlashWP_Weight  flash NB default
+{0x0F12,0x00C0},
+{0x0F12,0x0080},
+{0x0F12,0x000A},
+{0x0F12,0x0000},
+{0x0F12,0x0030},	//  fls_afl_FlashWP_Weight  flash NB default
+{0x0F12,0x0040},
+{0x0F12,0x0048},
+{0x0F12,0x0050},
+{0x0F12,0x0060},
+{0x002A,0x4784},
+{0x0F12,0x00A0},	//  TNP_Regs_FlsWeightRIn  weight tune start in
+{0x0F12,0x00C0},
+{0x0F12,0x00D0},
+{0x0F12,0x0100},
+{0x0F12,0x0200},
+{0x0F12,0x0300},
+{0x0F12,0x0088},	//  TNP_Regs_FlsWeightROut  weight tune start out
+{0x0F12,0x00B0},
+{0x0F12,0x00C0},
+{0x0F12,0x0100},
+{0x0F12,0x0200},
+{0x0F12,0x0300},
+{0x0F12,0x0120},	// Fls  BRIn
+{0x0F12,0x0150},
+{0x0F12,0x0200},
+{0x0F12,0x003C},	//  Fls  BROut
+{0x0F12,0x003B},
+{0x0F12,0x0026},	// brightness
 
-// Outdoor Zone
-{0x002A, 0x1078},
-{0x0F12, 0x0232},	 //awbb_OutdoorGrZones_m_BGrid_0__m_left
-{0x0F12, 0x025A},	 //awbb_OutdoorGrZones_m_BGrid_0__m_right
-{0x0F12, 0x021E},	 //awbb_OutdoorGrZones_m_BGrid_1__m_left
-{0x0F12, 0x0274},	 //awbb_OutdoorGrZones_m_BGrid_1__m_right
-{0x0F12, 0x020E},	 //awbb_OutdoorGrZones_m_BGrid_2__m_left
-{0x0F12, 0x028E},	 //awbb_OutdoorGrZones_m_BGrid_2__m_right
-{0x0F12, 0x0200},	 //awbb_OutdoorGrZones_m_BGrid_3__m_left
-{0x0F12, 0x0290},	 //awbb_OutdoorGrZones_m_BGrid_3__m_right
-{0x0F12, 0x01F4},	 //awbb_OutdoorGrZones_m_BGrid_4__m_left
-{0x0F12, 0x0286},	 //awbb_OutdoorGrZones_m_BGrid_4__m_right
-{0x0F12, 0x01E8},	 //awbb_OutdoorGrZones_m_BGrid_5__m_left
-{0x0F12, 0x027E},	 //awbb_OutdoorGrZones_m_BGrid_5__m_right
-{0x0F12, 0x01DE},	 //awbb_OutdoorGrZones_m_BGrid_6__m_left
-{0x0F12, 0x0274},	 //awbb_OutdoorGrZones_m_BGrid_6__m_right
-{0x0F12, 0x01D2},	 //awbb_OutdoorGrZones_m_BGrid_7__m_left
-{0x0F12, 0x0268},	 //awbb_OutdoorGrZones_m_BGrid_7__m_right
-{0x0F12, 0x01D0},	 //awbb_OutdoorGrZones_m_BGrid_8__m_left
-{0x0F12, 0x025E},	 //awbb_OutdoorGrZones_m_BGrid_8__m_right
-{0x0F12, 0x01D6},	 //awbb_OutdoorGrZones_m_BGrid_9__m_left
-{0x0F12, 0x0252},	 //awbb_OutdoorGrZones_m_BGrid_9__m_right
-{0x0F12, 0x01E2},	 //awbb_OutdoorGrZones_m_BGrid_10__m_left
-{0x0F12, 0x0248},	 //awbb_OutdoorGrZones_m_BGrid_10__m_right
-{0x0F12, 0x01F4},	 //awbb_OutdoorGrZones_m_BGrid_11__m_left
-{0x0F12, 0x021A},	 //awbb_OutdoorGrZones_m_BGrid_11__m_right
-     
-{0x0F12, 0x0004},	 //awbb_OutdoorGrZones_m_GridStep
-{0x002A, 0x10AC},
-{0x0F12, 0x000C},	 //awbb_OutdoorGrZones_ZInfo_m_GridSz
-{0x002A, 0x10B0},
-{0x0F12, 0x01DA},	 //awbb_OutdoorGrZones_m_Boffs
-
-// Low Brightness Zone
-{0x002A, 0x10B4},
-{0x0F12, 0x0348},	 //awbb_LowBrGrZones_m_BGrid_0__m_left
-{0x0F12, 0x03B6},	 //awbb_LowBrGrZones_m_BGrid_0__m_right
-{0x0F12, 0x02B8},	 //awbb_LowBrGrZones_m_BGrid_1__m_left
-{0x0F12, 0x03B6},	 //awbb_LowBrGrZones_m_BGrid_1__m_right
-{0x0F12, 0x0258},	 //awbb_LowBrGrZones_m_BGrid_2__m_left
-{0x0F12, 0x038E},	 //awbb_LowBrGrZones_m_BGrid_2__m_right
-{0x0F12, 0x0212},	 //awbb_LowBrGrZones_m_BGrid_3__m_left
-{0x0F12, 0x0348},	 //awbb_LowBrGrZones_m_BGrid_3__m_right
-{0x0F12, 0x01CC},	 //awbb_LowBrGrZones_m_BGrid_4__m_left
-{0x0F12, 0x030C},	 //awbb_LowBrGrZones_m_BGrid_4__m_right
-{0x0F12, 0x01A2},	 //awbb_LowBrGrZones_m_BGrid_5__m_left
-{0x0F12, 0x02D2},	 //awbb_LowBrGrZones_m_BGrid_5__m_right
-{0x0F12, 0x0170},	 //awbb_LowBrGrZones_m_BGrid_6__m_left
-{0x0F12, 0x02A6},	 //awbb_LowBrGrZones_m_BGrid_6__m_right
-{0x0F12, 0x014C},	 //awbb_LowBrGrZones_m_BGrid_7__m_left
-{0x0F12, 0x0280},	 //awbb_LowBrGrZones_m_BGrid_7__m_right
-{0x0F12, 0x0128},	 //awbb_LowBrGrZones_m_BGrid_8__m_left
-{0x0F12, 0x025C},	 //awbb_LowBrGrZones_m_BGrid_8__m_right
-{0x0F12, 0x0146},	 //awbb_LowBrGrZones_m_BGrid_9__m_left
-{0x0F12, 0x0236},	 //awbb_LowBrGrZones_m_BGrid_9__m_right
-{0x0F12, 0x0164},	 //awbb_LowBrGrZones_m_BGrid_10__m_left
-{0x0F12, 0x0212},	 //awbb_LowBrGrZones_m_BGrid_10__m_right
-{0x0F12, 0x0000},	 //awbb_LowBrGrZones_m_BGrid_11__m_left
-{0x0F12, 0x0000},	 //awbb_LowBrGrZones_m_BGrid_11__m_right
-     
-{0x0F12, 0x0006},	 //awbb_LowBrGrZones_m_GridStep
-{0x002A, 0x10E8},
-{0x0F12, 0x000B},	 //awbb_LowBrGrZones_ZInfo_m_GridSz
-{0x002A, 0x10EC},
-{0x0F12, 0x00D2},	 //awbb_LowBrGrZones_m_Boffs
-
-// Low Temp. Zone
-{0x002A, 0x10F0},
-{0x0F12, 0x039A},
-{0x0F12, 0x0000},	 //awbb_CrclLowT_R_c
-{0x0F12, 0x00FE},
-{0x0F12, 0x0000},	 //awbb_CrclLowT_B_c
-{0x0F12, 0x2284},
-{0x0F12, 0x0000},	         //awbb_CrclLowT_Rad_c      				
-
-//AWB - GridCorrection			
-{0x002A, 0x1434},
-{0x0F12, 0x02C1},	 //awbb_GridConst_1_0_
-{0x0F12, 0x033A},	 //awbb_GridConst_1_1_
-{0x0F12, 0x038A},	 //awbb_GridConst_1_2_
-{0x0F12, 0x101A},	 //awbb_GridConst_2_0_
-{0x0F12, 0x1075},	 //awbb_GridConst_2_1_
-{0x0F12, 0x113D},	 //awbb_GridConst_2_2_
-{0x0F12, 0x113F},	 //awbb_GridConst_2_3_
-{0x0F12, 0x11AF},	 //awbb_GridConst_2_4_
-{0x0F12, 0x11F0},	 //awbb_GridConst_2_5_
-{0x0F12, 0x00B2},	 //awbb_GridCoeff_R_1
-{0x0F12, 0x00B8},	 //awbb_GridCoeff_B_1
-{0x0F12, 0x00CA},	 //awbb_GridCoeff_R_2
-{0x0F12, 0x009D},	 //awbb_GridCoeff_B_2
-
-// Indoor Grid Offset			
-{0x002A, 0x13A4},
-{0x0F12, 0xFFE0},	 //awbb_GridCorr_R_0__0_
-{0x0F12, 0xFFE0},	 //awbb_GridCorr_R_0__1_
-{0x0F12, 0xFFE0},	 //awbb_GridCorr_R_0__2_
-{0x0F12, 0xFFA0},	 //awbb_GridCorr_R_0__3_
-{0x0F12, 0xFFEE},	 //awbb_GridCorr_R_0__4_
-{0x0F12, 0x0096},	 //awbb_GridCorr_R_0__5_
-{0x0F12, 0xFFE0},	 //awbb_GridCorr_R_1__0_
-{0x0F12, 0xFFE0},	 //awbb_GridCorr_R_1__1_
-{0x0F12, 0xFFE0},	 //awbb_GridCorr_R_1__2_
-{0x0F12, 0xFFA0},	 //awbb_GridCorr_R_1__3_
-{0x0F12, 0xFFEE},	 //awbb_GridCorr_R_1__4_
-{0x0F12, 0x0096},	 //awbb_GridCorr_R_1__5_
-{0x0F12, 0xFFE0},	 //awbb_GridCorr_R_2__0_
-{0x0F12, 0xFFE0},	 //awbb_GridCorr_R_2__1_
-{0x0F12, 0xFFE0},	 //awbb_GridCorr_R_2__2_
-{0x0F12, 0xFFA0},	 //awbb_GridCorr_R_2__3_
-{0x0F12, 0xFFEE},	 //awbb_GridCorr_R_2__4_
-{0x0F12, 0x0096},	 //awbb_GridCorr_R_2__5_
-{0x0F12, 0xFFC0},	 //awbb_GridCorr_B_0__0_
-{0x0F12, 0xFFC0},	 //awbb_GridCorr_B_0__1_
-{0x0F12, 0xFFC0},	 //awbb_GridCorr_B_0__2_
-{0x0F12, 0xFF38},	 //awbb_GridCorr_B_0__3_
-{0x0F12, 0xFEF2},	 //awbb_GridCorr_B_0__4_
-{0x0F12, 0xFE5C},	 //awbb_GridCorr_B_0__5_
-{0x0F12, 0xFFC0},	 //awbb_GridCorr_B_1__0_
-{0x0F12, 0xFFC0},	 //awbb_GridCorr_B_1__1_
-{0x0F12, 0xFFC0},	 //awbb_GridCorr_B_1__2_
-{0x0F12, 0xFF38},	 //awbb_GridCorr_B_1__3_
-{0x0F12, 0xFEF2},	 //awbb_GridCorr_B_1__4_
-{0x0F12, 0xFE5C},	 //awbb_GridCorr_B_1__5_
-{0x0F12, 0xFFC0},	 //awbb_GridCorr_B_2__0_
-{0x0F12, 0xFFC0},	 //awbb_GridCorr_B_2__1_
-{0x0F12, 0xFFC0},	 //awbb_GridCorr_B_2__2_
-{0x0F12, 0xFF38},	 //awbb_GridCorr_B_2__3_
-{0x0F12, 0xFEF2},	 //awbb_GridCorr_B_2__4_
-{0x0F12, 0xFE5C},	 //awbb_GridCorr_B_2__5_
-
-// Outdoor Grid Offset
-{0x0F12, 0xFFC0},	 //awbb_GridCorr_R_Out_0__0_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_R_Out_0__1_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_R_Out_0__2_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_R_Out_0__3_
-{0x0F12, 0x0000},	 //awbb_GridCorr_R_Out_0__4_
-{0x0F12, 0x0000},	 //awbb_GridCorr_R_Out_0__5_
-{0x0F12, 0xFFC0},	 //awbb_GridCorr_R_Out_1__0_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_R_Out_1__1_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_R_Out_1__2_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_R_Out_1__3_
-{0x0F12, 0x0000},	 //awbb_GridCorr_R_Out_1__4_
-{0x0F12, 0x0000},	 //awbb_GridCorr_R_Out_1__5_
-{0x0F12, 0xFFC0},	 //awbb_GridCorr_R_Out_2__0_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_R_Out_2__1_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_R_Out_2__2_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_R_Out_2__3_
-{0x0F12, 0x0000},	 //awbb_GridCorr_R_Out_2__4_
-{0x0F12, 0x0000},	 //awbb_GridCorr_R_Out_2__5_
-{0x0F12, 0x0010},	 //awbb_GridCorr_B_Out_0__0_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_B_Out_0__1_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_B_Out_0__2_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_B_Out_0__3_
-{0x0F12, 0x0000},	 //awbb_GridCorr_B_Out_0__4_
-{0x0F12, 0x0000},	 //awbb_GridCorr_B_Out_0__5_
-{0x0F12, 0x0010},	 //awbb_GridCorr_B_Out_1__0_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_B_Out_1__1_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_B_Out_1__2_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_B_Out_1__3_
-{0x0F12, 0x0000},	 //awbb_GridCorr_B_Out_1__4_
-{0x0F12, 0x0000},	 //awbb_GridCorr_B_Out_1__5_
-{0x0F12, 0x0010},	 //awbb_GridCorr_B_Out_2__0_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_B_Out_2__1_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_B_Out_2__2_
-{0x0F12, 0xFFD0},	 //awbb_GridCorr_B_Out_2__3_
-{0x0F12, 0x0000},	 //awbb_GridCorr_B_Out_2__4_
-{0x0F12, 0x0000},	 //awbb_GridCorr_B_Out_2__5_
 
 //==================================================================================
 // 15.CCM Setting
 //==================================================================================
 
-{0x002A, 0x08A6},
-{0x0F12, 0x0050},	 //SARR_AwbCcmCord_0_
-{0x0F12, 0x00F0},	 //SARR_AwbCcmCord_1_
-{0x0F12, 0x0110},	 //SARR_AwbCcmCord_2_
-{0x0F12, 0x0120},	 //SARR_AwbCcmCord_3_
-{0x0F12, 0x0130},	 //SARR_AwbCcmCord_4_
-{0x0F12, 0x0162},	 //SARR_AwbCcmCord_5_
-     
-{0x0F12, 0x0001},	 //wbt_bUseOutdoorCCM
-     
-{0x002A, 0x0898},	
-{0x0F12, 0x4800},	 //TVAR_wbt_pBaseCcms
-{0x0F12, 0x7000},	
-{0x002A, 0x08A0},	
-{0x0F12, 0x48D8},	 //TVAR_wbt_pOutdoorCcm
-{0x0F12, 0x7000},	
-     
-{0x002A, 0x4800},
-{0x0F12, 0x0119},	 //TVAR_wbt_pBaseCcms[0]  // Horizon
-{0x0F12, 0xFFA9},	 //TVAR_wbt_pBaseCcms[1]
-{0x0F12, 0xFF9D},	 //TVAR_wbt_pBaseCcms[2]
-{0x0F12, 0xFF30},	 //TVAR_wbt_pBaseCcms[3]
-{0x0F12, 0x0130},	 //TVAR_wbt_pBaseCcms[4]
-{0x0F12, 0xFF8E},	 //TVAR_wbt_pBaseCcms[5]
-{0x0F12, 0xFFF8},	 //TVAR_wbt_pBaseCcms[6]
-{0x0F12, 0xFFAC},	 //TVAR_wbt_pBaseCcms[7]
-{0x0F12, 0x0137},	 //TVAR_wbt_pBaseCcms[8]
-{0x0F12, 0x0087},	 //TVAR_wbt_pBaseCcms[9]
-{0x0F12, 0x00D0},	 //TVAR_wbt_pBaseCcms[10]
-{0x0F12, 0xFEE3},	 //TVAR_wbt_pBaseCcms[11]
-{0x0F12, 0x0162},	 //TVAR_wbt_pBaseCcms[12]
-{0x0F12, 0xFF77},	 //TVAR_wbt_pBaseCcms[13]
-{0x0F12, 0x00E8},	 //TVAR_wbt_pBaseCcms[14]
-{0x0F12, 0xFF40},	 //TVAR_wbt_pBaseCcms[15]
-{0x0F12, 0x0114},	 //TVAR_wbt_pBaseCcms[16]
-{0x0F12, 0x00F4},	 //TVAR_wbt_pBaseCcms[17]
-     
-{0x0F12, 0x0119},	 //TVAR_wbt_pBaseCcms[18]  // IncandA
-{0x0F12, 0xFFA9},	 //TVAR_wbt_pBaseCcms[19]
-{0x0F12, 0xFF9D},	 //TVAR_wbt_pBaseCcms[20]
-{0x0F12, 0xFF30},	 //TVAR_wbt_pBaseCcms[21]
-{0x0F12, 0x0130},	 //TVAR_wbt_pBaseCcms[22]
-{0x0F12, 0xFF8E},	 //TVAR_wbt_pBaseCcms[23]
-{0x0F12, 0xFFF8},	 //TVAR_wbt_pBaseCcms[24]
-{0x0F12, 0xFFAC},	 //TVAR_wbt_pBaseCcms[25]
-{0x0F12, 0x0137},	 //TVAR_wbt_pBaseCcms[26]
-{0x0F12, 0x0087},	 //TVAR_wbt_pBaseCcms[27]
-{0x0F12, 0x00D0},	 //TVAR_wbt_pBaseCcms[28]
-{0x0F12, 0xFEE3},	 //TVAR_wbt_pBaseCcms[29]
-{0x0F12, 0x0162},	 //TVAR_wbt_pBaseCcms[30]
-{0x0F12, 0xFF77},	 //TVAR_wbt_pBaseCcms[31]
-{0x0F12, 0x00E8},	 //TVAR_wbt_pBaseCcms[32]
-{0x0F12, 0xFF40},	 //TVAR_wbt_pBaseCcms[33]
-{0x0F12, 0x0114},	 //TVAR_wbt_pBaseCcms[34]
-{0x0F12, 0x00F4},	 //TVAR_wbt_pBaseCcms[35]
-     
-{0x0F12, 0x0204},	 //TVAR_wbt_pBaseCcms[36]  // WW
-{0x0F12, 0xFFB2},	 //TVAR_wbt_pBaseCcms[37]
-{0x0F12, 0xFFF5},	 //TVAR_wbt_pBaseCcms[38]
-{0x0F12, 0xFEE7},	 //TVAR_wbt_pBaseCcms[39]
-{0x0F12, 0x0161},	 //TVAR_wbt_pBaseCcms[40]
-{0x0F12, 0xFF10},	 //TVAR_wbt_pBaseCcms[41]
-{0x0F12, 0xFFDD},	 //TVAR_wbt_pBaseCcms[42]
-{0x0F12, 0xFFE6},	 //TVAR_wbt_pBaseCcms[43]
-{0x0F12, 0x01B2},	 //TVAR_wbt_pBaseCcms[44]
-{0x0F12, 0x00F2},	 //TVAR_wbt_pBaseCcms[45]
-{0x0F12, 0x00CA},	 //TVAR_wbt_pBaseCcms[46]
-{0x0F12, 0xFF48},	 //TVAR_wbt_pBaseCcms[47]
-{0x0F12, 0x0151},	 //TVAR_wbt_pBaseCcms[48]
-{0x0F12, 0xFF50},	 //TVAR_wbt_pBaseCcms[49]
-{0x0F12, 0x0147},	 //TVAR_wbt_pBaseCcms[50]
-{0x0F12, 0xFF75},	 //TVAR_wbt_pBaseCcms[51]
-{0x0F12, 0x01BA},	 //TVAR_wbt_pBaseCcms[52]
-{0x0F12, 0x018C},	 //TVAR_wbt_pBaseCcms[53]
-     
-{0x0F12, 0x0204},	 //TVAR_wbt_pBaseCcms[54]  // CW
-{0x0F12, 0xFFB2},	 //TVAR_wbt_pBaseCcms[55]
-{0x0F12, 0xFFF5},	 //TVAR_wbt_pBaseCcms[56]
-{0x0F12, 0xFEF1},	 //TVAR_wbt_pBaseCcms[57]
-{0x0F12, 0x014E},	 //TVAR_wbt_pBaseCcms[58]
-{0x0F12, 0xFF18},	 //TVAR_wbt_pBaseCcms[59]
-{0x0F12, 0xFFE6},	 //TVAR_wbt_pBaseCcms[60]
-{0x0F12, 0xFFDD},	 //TVAR_wbt_pBaseCcms[61]
-{0x0F12, 0x01B2},	 //TVAR_wbt_pBaseCcms[62]
-{0x0F12, 0x00F2},	 //TVAR_wbt_pBaseCcms[63]
-{0x0F12, 0x00CA},	 //TVAR_wbt_pBaseCcms[64]
-{0x0F12, 0xFF48},	 //TVAR_wbt_pBaseCcms[65]
-{0x0F12, 0x0151},	 //TVAR_wbt_pBaseCcms[66]
-{0x0F12, 0xFF50},	 //TVAR_wbt_pBaseCcms[67]
-{0x0F12, 0x0147},	 //TVAR_wbt_pBaseCcms[68]
-{0x0F12, 0xFF75},	 //TVAR_wbt_pBaseCcms[69]
-{0x0F12, 0x0187},	 //TVAR_wbt_pBaseCcms[70]
-{0x0F12, 0x01BF},	 //TVAR_wbt_pBaseCcms[71]
-     
-{0x0F12, 0x0204},	 //TVAR_wbt_pBaseCcms[72]  // D50
-{0x0F12, 0xFFB2},	 //TVAR_wbt_pBaseCcms[73]
-{0x0F12, 0xFFF5},	 //TVAR_wbt_pBaseCcms[74]
-{0x0F12, 0xFEF1},	 //TVAR_wbt_pBaseCcms[75]
-{0x0F12, 0x014E},	 //TVAR_wbt_pBaseCcms[76]
-{0x0F12, 0xFF18},	 //TVAR_wbt_pBaseCcms[77]
-{0x0F12, 0xFFE6},	 //TVAR_wbt_pBaseCcms[78]
-{0x0F12, 0xFFDD},	 //TVAR_wbt_pBaseCcms[79]
-{0x0F12, 0x01B2},	 //TVAR_wbt_pBaseCcms[80]
-{0x0F12, 0x00F2},	 //TVAR_wbt_pBaseCcms[81]
-{0x0F12, 0x00CA},	 //TVAR_wbt_pBaseCcms[82]
-{0x0F12, 0xFF48},	 //TVAR_wbt_pBaseCcms[83]
-{0x0F12, 0x0151},	 //TVAR_wbt_pBaseCcms[84]
-{0x0F12, 0xFF50},	 //TVAR_wbt_pBaseCcms[85]
-{0x0F12, 0x0147},	 //TVAR_wbt_pBaseCcms[86]
-{0x0F12, 0xFF75},	 //TVAR_wbt_pBaseCcms[87]
-{0x0F12, 0x0187},	 //TVAR_wbt_pBaseCcms[88]
-{0x0F12, 0x01BF},	 //TVAR_wbt_pBaseCcms[89]
-     
-{0x0F12, 0x0204},	 //TVAR_wbt_pBaseCcms[90]  // D65
-{0x0F12, 0xFFB2},	 //TVAR_wbt_pBaseCcms[91]
-{0x0F12, 0xFFF5},	 //TVAR_wbt_pBaseCcms[92]
-{0x0F12, 0xFEF1},	 //TVAR_wbt_pBaseCcms[93]
-{0x0F12, 0x014E},	 //TVAR_wbt_pBaseCcms[94]
-{0x0F12, 0xFF18},	 //TVAR_wbt_pBaseCcms[95]
-{0x0F12, 0xFFE6},	 //TVAR_wbt_pBaseCcms[96]
-{0x0F12, 0xFFDD},	 //TVAR_wbt_pBaseCcms[97]
-{0x0F12, 0x01B2},	 //TVAR_wbt_pBaseCcms[98]
-{0x0F12, 0x00F2},	 //TVAR_wbt_pBaseCcms[99]
-{0x0F12, 0x00CA},	 //TVAR_wbt_pBaseCcms[100]
-{0x0F12, 0xFF48},	 //TVAR_wbt_pBaseCcms[101]
-{0x0F12, 0x0151},	 //TVAR_wbt_pBaseCcms[102]
-{0x0F12, 0xFF50},	 //TVAR_wbt_pBaseCcms[103]
-{0x0F12, 0x0147},	 //TVAR_wbt_pBaseCcms[104]
-{0x0F12, 0xFF75},	 //TVAR_wbt_pBaseCcms[105]
-{0x0F12, 0x0187},	 //TVAR_wbt_pBaseCcms[106]
-{0x0F12, 0x01BF},	 //TVAR_wbt_pBaseCcms[107]
-     
-{0x0F12, 0x01E5},	 //TVAR_wbt_pOutdoorCcm[0]
-{0x0F12, 0xFFA4},	 //TVAR_wbt_pOutdoorCcm[1]
-{0x0F12, 0xFFDC},	 //TVAR_wbt_pOutdoorCcm[2]
-{0x0F12, 0xFE87},	 //TVAR_wbt_pOutdoorCcm[3]
-{0x0F12, 0x013C},	 //TVAR_wbt_pOutdoorCcm[4]
-{0x0F12, 0xFF2A},	 //TVAR_wbt_pOutdoorCcm[5]
-{0x0F12, 0xFFD2},	 //TVAR_wbt_pOutdoorCcm[6]
-{0x0F12, 0xFFDF},	 //TVAR_wbt_pOutdoorCcm[7]
-{0x0F12, 0x0236},	 //TVAR_wbt_pOutdoorCcm[8]
-{0x0F12, 0x00EC},	 //TVAR_wbt_pOutdoorCcm[9]
-{0x0F12, 0x00F8},	 //TVAR_wbt_pOutdoorCcm[10]
-{0x0F12, 0xFF34},	 //TVAR_wbt_pOutdoorCcm[11]
-{0x0F12, 0x01CE},	 //TVAR_wbt_pOutdoorCcm[12]
-{0x0F12, 0xFF83},	 //TVAR_wbt_pOutdoorCcm[13]
-{0x0F12, 0x0195},	 //TVAR_wbt_pOutdoorCcm[14]
-{0x0F12, 0xFEF3},	 //TVAR_wbt_pOutdoorCcm[15]
-{0x0F12, 0x0126},	 //TVAR_wbt_pOutdoorCcm[16]
-{0x0F12, 0x0162},	 //TVAR_wbt_pOutdoorCcm[17]
+{0x002A,0x08A6},
+{0x0F12,0x00C0},	// SARR_AwbCcmCord[0]
+{0x0F12,0x0100},	// SARR_AwbCcmCord[1]
+{0x0F12,0x0125},	// SARR_AwbCcmCord[2]
+{0x0F12,0x015F},	// SARR_AwbCcmCord[3]
+{0x0F12,0x017C},	// SARR_AwbCcmCord[4]
+{0x0F12,0x0194},	// SARR_AwbCcmCord[5]
+{0x002A,0x0898},
+{0x0F12,0x4800},	// TVAR_wbt_pBaseCcms
+{0x0F12,0x7000},
+{0x002A,0x08A0},
+{0x0F12,0x48D8},	// TVAR_wbt_pOutdoorCcm
+{0x0F12,0x7000},
+//Horizon
+{0x002A,0x4800},
+{0x0F12,0x01EF},	// TVAR_wbt_pBaseCcms[18]
+{0x0F12,0xFFCC},	// TVAR_wbt_pBaseCcms[19]
+{0x0F12,0xFFE2},	// TVAR_wbt_pBaseCcms[20]
+{0x0F12,0xFECE},	// TVAR_wbt_pBaseCcms[21]
+{0x0F12,0x0253},	// TVAR_wbt_pBaseCcms[22]
+{0x0F12,0xFF05},	// TVAR_wbt_pBaseCcms[23]
+{0x0F12,0x0007},	// TVAR_wbt_pBaseCcms[24]
+{0x0F12,0xFFB9},	// TVAR_wbt_pBaseCcms[25]
+{0x0F12,0x0204},	// TVAR_wbt_pBaseCcms[26]
+{0x0F12,0x00F7},	// TVAR_wbt_pBaseCcms[27]
+{0x0F12,0x00D3},	// TVAR_wbt_pBaseCcms[28]
+{0x0F12,0xFE86},	// TVAR_wbt_pBaseCcms[29]
+{0x0F12,0x01E8},	// TVAR_wbt_pBaseCcms[30]
+{0x0F12,0xFFB6},	// TVAR_wbt_pBaseCcms[31]
+{0x0F12,0x0176},	// TVAR_wbt_pBaseCcms[32]
+{0x0F12,0xFE6B},	// TVAR_wbt_pBaseCcms[33]
+{0x0F12,0x0219},	// TVAR_wbt_pBaseCcms[34]
+{0x0F12,0x013C},	// TVAR_wbt_pBaseCcms[35]
+
+// INCA A
+{0x0F12,0x01EF},	// TVAR_wbt_pBaseCcms[18]
+{0x0F12,0xFFCC},	// TVAR_wbt_pBaseCcms[19]
+{0x0F12,0xFFE2},	// TVAR_wbt_pBaseCcms[20]
+{0x0F12,0xFECE},	// TVAR_wbt_pBaseCcms[21]
+{0x0F12,0x0253},	// TVAR_wbt_pBaseCcms[22]
+{0x0F12,0xFF05},	// TVAR_wbt_pBaseCcms[23]
+{0x0F12,0x0007},	// TVAR_wbt_pBaseCcms[24]
+{0x0F12,0xFFB9},	// TVAR_wbt_pBaseCcms[25]
+{0x0F12,0x0204},	// TVAR_wbt_pBaseCcms[26]
+{0x0F12,0x00F7},	// TVAR_wbt_pBaseCcms[27]
+{0x0F12,0x00D3},	// TVAR_wbt_pBaseCcms[28]
+{0x0F12,0xFE86},	// TVAR_wbt_pBaseCcms[29]
+{0x0F12,0x01E8},	// TVAR_wbt_pBaseCcms[30]
+{0x0F12,0xFFB6},	// TVAR_wbt_pBaseCcms[31]
+{0x0F12,0x0176},	// TVAR_wbt_pBaseCcms[32]
+{0x0F12,0xFE6B},	// TVAR_wbt_pBaseCcms[33]
+{0x0F12,0x0219},	// TVAR_wbt_pBaseCcms[34]
+{0x0F12,0x013C},	// TVAR_wbt_pBaseCcms[35
+
+//Warm White
+{0x0F12,0x01EF},	// TVAR_wbt_pBaseCcms[18]
+{0x0F12,0xFFCC},	// TVAR_wbt_pBaseCcms[19]
+{0x0F12,0xFFE2},	// TVAR_wbt_pBaseCcms[20]
+{0x0F12,0xFECE},	// TVAR_wbt_pBaseCcms[21]
+{0x0F12,0x0253},	// TVAR_wbt_pBaseCcms[22]
+{0x0F12,0xFF05},	// TVAR_wbt_pBaseCcms[23]
+{0x0F12,0x0007},	// TVAR_wbt_pBaseCcms[24]
+{0x0F12,0xFFB9},	// TVAR_wbt_pBaseCcms[25]
+{0x0F12,0x0204},	// TVAR_wbt_pBaseCcms[26]
+{0x0F12,0x00F7},	// TVAR_wbt_pBaseCcms[27]
+{0x0F12,0x00D3},	// TVAR_wbt_pBaseCcms[28]
+{0x0F12,0xFE86},	// TVAR_wbt_pBaseCcms[29]
+{0x0F12,0x01E8},	// TVAR_wbt_pBaseCcms[30]
+{0x0F12,0xFFB6},	// TVAR_wbt_pBaseCcms[31]
+{0x0F12,0x0176},	// TVAR_wbt_pBaseCcms[32]
+{0x0F12,0xFE6B},	// TVAR_wbt_pBaseCcms[33]
+{0x0F12,0x0219},	// TVAR_wbt_pBaseCcms[34]
+{0x0F12,0x013C},	// TVAR_wbt_pBaseCcms[35
+
+//Cool White
+{0x0F12,0x01CA},	//TVAR_wbt_pBaseCcms[54]
+{0x0F12,0xFFDA},	//TVAR_wbt_pBaseCcms[55]
+{0x0F12,0xFFFA},	//TVAR_wbt_pBaseCcms[56]
+{0x0F12,0xFF27},	//TVAR_wbt_pBaseCcms[57]
+{0x0F12,0x01AC},	//TVAR_wbt_pBaseCcms[58]
+{0x0F12,0xFF4D},	//TVAR_wbt_pBaseCcms[59]
+{0x0F12,0x002D},	//TVAR_wbt_pBaseCcms[60]
+{0x0F12,0xFFF6},	//TVAR_wbt_pBaseCcms[61]
+{0x0F12,0x01A5},	//TVAR_wbt_pBaseCcms[62]
+{0x0F12,0x00BF},	//TVAR_wbt_pBaseCcms[63]
+{0x0F12,0x009B},	//TVAR_wbt_pBaseCcms[64]
+{0x0F12,0xFEFA},	//TVAR_wbt_pBaseCcms[65]
+{0x0F12,0x01EF},	//TVAR_wbt_pBaseCcms[66]
+{0x0F12,0xFF98},	//TVAR_wbt_pBaseCcms[67]
+{0x0F12,0x0180},	//TVAR_wbt_pBaseCcms[68]
+{0x0F12,0xFF20},	//TVAR_wbt_pBaseCcms[69]
+{0x0F12,0x019F},	//TVAR_wbt_pBaseCcms[70]
+{0x0F12,0x010C},	//TVAR_wbt_pBaseCcms[71]
+
+//D50
+{0x0F12,0x01CA},	//TVAR_wbt_pBaseCcms[54]
+{0x0F12,0xFFDA},	//TVAR_wbt_pBaseCcms[55]
+{0x0F12,0xFFFA},	//TVAR_wbt_pBaseCcms[56]
+{0x0F12,0xFF27},	//TVAR_wbt_pBaseCcms[57]
+{0x0F12,0x01AC},	//TVAR_wbt_pBaseCcms[58]
+{0x0F12,0xFF4D},	//TVAR_wbt_pBaseCcms[59]
+{0x0F12,0x002D},	//TVAR_wbt_pBaseCcms[60]
+{0x0F12,0xFFF6},	//TVAR_wbt_pBaseCcms[61]
+{0x0F12,0x01A5},	//TVAR_wbt_pBaseCcms[62]
+{0x0F12,0x00BF},	//TVAR_wbt_pBaseCcms[63]
+{0x0F12,0x009B},	//TVAR_wbt_pBaseCcms[64]
+{0x0F12,0xFEFA},	//TVAR_wbt_pBaseCcms[65]
+{0x0F12,0x01EF},	//TVAR_wbt_pBaseCcms[66]
+{0x0F12,0xFF98},	//TVAR_wbt_pBaseCcms[67]
+{0x0F12,0x0180},	//TVAR_wbt_pBaseCcms[68]
+{0x0F12,0xFF20},	//TVAR_wbt_pBaseCcms[69]
+{0x0F12,0x019F},	//TVAR_wbt_pBaseCcms[70]
+{0x0F12,0x010C},	//TVAR_wbt_pBaseCcms[71]
+
+//D65
+{0x0F12,0x0204},	// TVAR_wbt_pBaseCcms[90]
+{0x0F12,0xFFB2},	// TVAR_wbt_pBaseCcms[91]
+{0x0F12,0xFFF5},	// TVAR_wbt_pBaseCcms[92]
+{0x0F12,0xFEF1},	// TVAR_wbt_pBaseCcms[93]
+{0x0F12,0x014E},	// TVAR_wbt_pBaseCcms[94]
+{0x0F12,0xFF18},	// TVAR_wbt_pBaseCcms[95]
+{0x0F12,0xFFE6},	// TVAR_wbt_pBaseCcms[96]
+{0x0F12,0xFFDD},	// TVAR_wbt_pBaseCcms[97]
+{0x0F12,0x01B2},	// TVAR_wbt_pBaseCcms[98]
+{0x0F12,0x00F2},	// TVAR_wbt_pBaseCcms[99]
+{0x0F12,0x00CA},	// TVAR_wbt_pBaseCcms[100]
+{0x0F12,0xFF48},	// TVAR_wbt_pBaseCcms[101]
+{0x0F12,0x0151},	// TVAR_wbt_pBaseCcms[102]
+{0x0F12,0xFF50},	// TVAR_wbt_pBaseCcms[103]
+{0x0F12,0x0147},	// TVAR_wbt_pBaseCcms[104]
+{0x0F12,0xFF75},	// TVAR_wbt_pBaseCcms[105]
+{0x0F12,0x0187},	// TVAR_wbt_pBaseCcms[106]
+{0x0F12,0x01BF},	// TVAR_wbt_pBaseCcms[107]
+
+//Outdoor
+{0x0F12,0x01E5},	// TVAR_wbt_pOutdoorCcm[0]
+{0x0F12,0xFFA4},	// TVAR_wbt_pOutdoorCcm[1]
+{0x0F12,0xFFDC},	// TVAR_wbt_pOutdoorCcm[2]
+{0x0F12,0xFE90},	// TVAR_wbt_pOutdoorCcm[3]
+{0x0F12,0x013F},	// TVAR_wbt_pOutdoorCcm[4]
+{0x0F12,0xFF1B},	// TVAR_wbt_pOutdoorCcm[5]
+{0x0F12,0xFFD2},	// TVAR_wbt_pOutdoorCcm[6]
+{0x0F12,0xFFDF},	// TVAR_wbt_pOutdoorCcm[7]
+{0x0F12,0x0236},	// TVAR_wbt_pOutdoorCcm[8]
+{0x0F12,0x00EC},	// TVAR_wbt_pOutdoorCcm[9]
+{0x0F12,0x00F8},	// TVAR_wbt_pOutdoorCcm[10]
+{0x0F12,0xFF34},	// TVAR_wbt_pOutdoorCcm[11]
+{0x0F12,0x01CE},	// TVAR_wbt_pOutdoorCcm[12]
+{0x0F12,0xFF83},	// TVAR_wbt_pOutdoorCcm[13]
+{0x0F12,0x0195},	// TVAR_wbt_pOutdoorCcm[14]
+{0x0F12,0xFEF3},	// TVAR_wbt_pOutdoorCcm[15]
+{0x0F12,0x0126},	// TVAR_wbt_pOutdoorCcm[16]
+{0x0F12,0x0162},	// TVAR_wbt_pOutdoorCcm[17]
+
 
 
 //==================================================================================
 // 16.GAMMA
 //==================================================================================
 
-// Indoor Gamma
-{0x002A, 0x0734},
-{0x0F12, 0x0001},	 //SARR_usGammaLutRGBIndoor_0__0_
-{0x0F12, 0x0003},	 //SARR_usGammaLutRGBIndoor_0__1_
-{0x0F12, 0x000F},	 //SARR_usGammaLutRGBIndoor_0__2_
-{0x0F12, 0x002B},	 //SARR_usGammaLutRGBIndoor_0__3_
-{0x0F12, 0x0069},	 //SARR_usGammaLutRGBIndoor_0__4_
-{0x0F12, 0x00D9},	 //SARR_usGammaLutRGBIndoor_0__5_
-{0x0F12, 0x0138},	 //SARR_usGammaLutRGBIndoor_0__6_
-{0x0F12, 0x0163},	 //SARR_usGammaLutRGBIndoor_0__7_
-{0x0F12, 0x0189},	 //SARR_usGammaLutRGBIndoor_0__8_
-{0x0F12, 0x01C6},	 //SARR_usGammaLutRGBIndoor_0__9_
-{0x0F12, 0x01F8},	 //SARR_usGammaLutRGBIndoor_0__10_
-{0x0F12, 0x0222},	 //SARR_usGammaLutRGBIndoor_0__11_
-{0x0F12, 0x0249},	 //SARR_usGammaLutRGBIndoor_0__12_
-{0x0F12, 0x028D},	 //SARR_usGammaLutRGBIndoor_0__13_
-{0x0F12, 0x02C9},	 //SARR_usGammaLutRGBIndoor_0__14_
-{0x0F12, 0x0327},	 //SARR_usGammaLutRGBIndoor_0__15_
-{0x0F12, 0x0371},	 //SARR_usGammaLutRGBIndoor_0__16_
-{0x0F12, 0x03AC},	 //SARR_usGammaLutRGBIndoor_0__17_
-{0x0F12, 0x03DD},	 //SARR_usGammaLutRGBIndoor_0__18_
-{0x0F12, 0x03FF},	 //SARR_usGammaLutRGBIndoor_0__19_
-{0x0F12, 0x0001},	 //SARR_usGammaLutRGBIndoor_1__0_
-{0x0F12, 0x0003},	 //SARR_usGammaLutRGBIndoor_1__1_
-{0x0F12, 0x000F},	 //SARR_usGammaLutRGBIndoor_1__2_
-{0x0F12, 0x002B},	 //SARR_usGammaLutRGBIndoor_1__3_
-{0x0F12, 0x0069},	 //SARR_usGammaLutRGBIndoor_1__4_
-{0x0F12, 0x00D9},	 //SARR_usGammaLutRGBIndoor_1__5_
-{0x0F12, 0x0138},	 //SARR_usGammaLutRGBIndoor_1__6_
-{0x0F12, 0x0163},	 //SARR_usGammaLutRGBIndoor_1__7_
-{0x0F12, 0x0189},	 //SARR_usGammaLutRGBIndoor_1__8_
-{0x0F12, 0x01C6},	 //SARR_usGammaLutRGBIndoor_1__9_
-{0x0F12, 0x01F8},	 //SARR_usGammaLutRGBIndoor_1__10_
-{0x0F12, 0x0222},	 //SARR_usGammaLutRGBIndoor_1__11_
-{0x0F12, 0x0249},	 //SARR_usGammaLutRGBIndoor_1__12_
-{0x0F12, 0x028D},	 //SARR_usGammaLutRGBIndoor_1__13_
-{0x0F12, 0x02C9},	 //SARR_usGammaLutRGBIndoor_1__14_
-{0x0F12, 0x0327},	 //SARR_usGammaLutRGBIndoor_1__15_
-{0x0F12, 0x0371},	 //SARR_usGammaLutRGBIndoor_1__16_
-{0x0F12, 0x03AC},	 //SARR_usGammaLutRGBIndoor_1__17_
-{0x0F12, 0x03DD},	 //SARR_usGammaLutRGBIndoor_1__18_
-{0x0F12, 0x03FF},	 //SARR_usGammaLutRGBIndoor_1__19_
-{0x0F12, 0x0001},	 //SARR_usGammaLutRGBIndoor_2__0_
-{0x0F12, 0x0003},	 //SARR_usGammaLutRGBIndoor_2__1_
-{0x0F12, 0x000F},	 //SARR_usGammaLutRGBIndoor_2__2_
-{0x0F12, 0x002B},	 //SARR_usGammaLutRGBIndoor_2__3_
-{0x0F12, 0x0069},	 //SARR_usGammaLutRGBIndoor_2__4_
-{0x0F12, 0x00D9},	 //SARR_usGammaLutRGBIndoor_2__5_
-{0x0F12, 0x0138},	 //SARR_usGammaLutRGBIndoor_2__6_
-{0x0F12, 0x0163},	 //SARR_usGammaLutRGBIndoor_2__7_
-{0x0F12, 0x0189},	 //SARR_usGammaLutRGBIndoor_2__8_
-{0x0F12, 0x01C6},	 //SARR_usGammaLutRGBIndoor_2__9_
-{0x0F12, 0x01F8},	 //SARR_usGammaLutRGBIndoor_2__10_
-{0x0F12, 0x0222},	 //SARR_usGammaLutRGBIndoor_2__11_
-{0x0F12, 0x0249},	 //SARR_usGammaLutRGBIndoor_2__12_
-{0x0F12, 0x028D},	 //SARR_usGammaLutRGBIndoor_2__13_
-{0x0F12, 0x02C9},	 //SARR_usGammaLutRGBIndoor_2__14_
-{0x0F12, 0x0327},	 //SARR_usGammaLutRGBIndoor_2__15_
-{0x0F12, 0x0371},	 //SARR_usGammaLutRGBIndoor_2__16_
-{0x0F12, 0x03AC},	 //SARR_usGammaLutRGBIndoor_2__17_
-{0x0F12, 0x03DD},	 //SARR_usGammaLutRGBIndoor_2__18_
-{0x0F12, 0x03FF},	 //SARR_usGammaLutRGBIndoor_2__19_
-
-// Outdoor Gamma
-{0x0F12, 0x0001},	 //SARR_usGammaLutRGBOutdoor_0__0_
-{0x0F12, 0x000B},	 //SARR_usGammaLutRGBOutdoor_0__1_
-{0x0F12, 0x0019},	 //SARR_usGammaLutRGBOutdoor_0__2_
-{0x0F12, 0x0036},	 //SARR_usGammaLutRGBOutdoor_0__3_
-{0x0F12, 0x006F},	 //SARR_usGammaLutRGBOutdoor_0__4_
-{0x0F12, 0x00D8},	 //SARR_usGammaLutRGBOutdoor_0__5_
-{0x0F12, 0x0135},	 //SARR_usGammaLutRGBOutdoor_0__6_
-{0x0F12, 0x015F},	 //SARR_usGammaLutRGBOutdoor_0__7_
-{0x0F12, 0x0185},	 //SARR_usGammaLutRGBOutdoor_0__8_
-{0x0F12, 0x01C1},	 //SARR_usGammaLutRGBOutdoor_0__9_
-{0x0F12, 0x01F3},	 //SARR_usGammaLutRGBOutdoor_0__10_
-{0x0F12, 0x0220},	 //SARR_usGammaLutRGBOutdoor_0__11_
-{0x0F12, 0x024A},	 //SARR_usGammaLutRGBOutdoor_0__12_
-{0x0F12, 0x0291},	 //SARR_usGammaLutRGBOutdoor_0__13_
-{0x0F12, 0x02D0},	 //SARR_usGammaLutRGBOutdoor_0__14_
-{0x0F12, 0x032A},	 //SARR_usGammaLutRGBOutdoor_0__15_
-{0x0F12, 0x036A},	 //SARR_usGammaLutRGBOutdoor_0__16_
-{0x0F12, 0x039F},	 //SARR_usGammaLutRGBOutdoor_0__17_
-{0x0F12, 0x03CC},	 //SARR_usGammaLutRGBOutdoor_0__18_
-{0x0F12, 0x03F9},	 //SARR_usGammaLutRGBOutdoor_0__19_
-{0x0F12, 0x0001},	 //SARR_usGammaLutRGBOutdoor_1__0_
-{0x0F12, 0x000B},	 //SARR_usGammaLutRGBOutdoor_1__1_
-{0x0F12, 0x0019},	 //SARR_usGammaLutRGBOutdoor_1__2_
-{0x0F12, 0x0036},	 //SARR_usGammaLutRGBOutdoor_1__3_
-{0x0F12, 0x006F},	 //SARR_usGammaLutRGBOutdoor_1__4_
-{0x0F12, 0x00D8},	 //SARR_usGammaLutRGBOutdoor_1__5_
-{0x0F12, 0x0135},	 //SARR_usGammaLutRGBOutdoor_1__6_
-{0x0F12, 0x015F},	 //SARR_usGammaLutRGBOutdoor_1__7_
-{0x0F12, 0x0185},	 //SARR_usGammaLutRGBOutdoor_1__8_
-{0x0F12, 0x01C1},	 //SARR_usGammaLutRGBOutdoor_1__9_
-{0x0F12, 0x01F3},	 //SARR_usGammaLutRGBOutdoor_1__10_
-{0x0F12, 0x0220},	 //SARR_usGammaLutRGBOutdoor_1__11_
-{0x0F12, 0x024A},	 //SARR_usGammaLutRGBOutdoor_1__12_
-{0x0F12, 0x0291},	 //SARR_usGammaLutRGBOutdoor_1__13_
-{0x0F12, 0x02D0},	 //SARR_usGammaLutRGBOutdoor_1__14_
-{0x0F12, 0x032A},	 //SARR_usGammaLutRGBOutdoor_1__15_
-{0x0F12, 0x036A},	 //SARR_usGammaLutRGBOutdoor_1__16_
-{0x0F12, 0x039F},	 //SARR_usGammaLutRGBOutdoor_1__17_
-{0x0F12, 0x03CC},	 //SARR_usGammaLutRGBOutdoor_1__18_
-{0x0F12, 0x03F9},	 //SARR_usGammaLutRGBOutdoor_1__19_
-{0x0F12, 0x0001},	 //SARR_usGammaLutRGBOutdoor_2__0_
-{0x0F12, 0x000B},	 //SARR_usGammaLutRGBOutdoor_2__1_
-{0x0F12, 0x0019},	 //SARR_usGammaLutRGBOutdoor_2__2_
-{0x0F12, 0x0036},	 //SARR_usGammaLutRGBOutdoor_2__3_
-{0x0F12, 0x006F},	 //SARR_usGammaLutRGBOutdoor_2__4_
-{0x0F12, 0x00D8},	 //SARR_usGammaLutRGBOutdoor_2__5_
-{0x0F12, 0x0135},	 //SARR_usGammaLutRGBOutdoor_2__6_
-{0x0F12, 0x015F},	 //SARR_usGammaLutRGBOutdoor_2__7_
-{0x0F12, 0x0185},	 //SARR_usGammaLutRGBOutdoor_2__8_
-{0x0F12, 0x01C1},	 //SARR_usGammaLutRGBOutdoor_2__9_
-{0x0F12, 0x01F3},	 //SARR_usGammaLutRGBOutdoor_2__10_
-{0x0F12, 0x0220},	 //SARR_usGammaLutRGBOutdoor_2__11_
-{0x0F12, 0x024A},	 //SARR_usGammaLutRGBOutdoor_2__12_
-{0x0F12, 0x0291},	 //SARR_usGammaLutRGBOutdoor_2__13_
-{0x0F12, 0x02D0},	 //SARR_usGammaLutRGBOutdoor_2__14_
-{0x0F12, 0x032A},	 //SARR_usGammaLutRGBOutdoor_2__15_
-{0x0F12, 0x036A},	 //SARR_usGammaLutRGBOutdoor_2__16_
-{0x0F12, 0x039F},	 //SARR_usGammaLutRGBOutdoor_2__17_
-{0x0F12, 0x03CC},	 //SARR_usGammaLutRGBOutdoor_2__18_
-{0x0F12, 0x03F9},	 //SARR_usGammaLutRGBOutdoor_2__19_                             
-      
+{0x002A,0x0734},
+{0x0F12,0x0000},	// saRR_usDualGammaLutRGBIndoor[0][0]
+{0x0F12,0x0004},	// saRR_usDualGammaLutRGBIndoor[0][1]
+{0x0F12,0x000B},	// saRR_usDualGammaLutRGBIndoor[0][2]
+{0x0F12,0x001B},	// saRR_usDualGammaLutRGBIndoor[0][3]
+{0x0F12,0x0046},	// saRR_usDualGammaLutRGBIndoor[0][4]
+{0x0F12,0x00AE},	// saRR_usDualGammaLutRGBIndoor[0][5]
+{0x0F12,0x011E},	// saRR_usDualGammaLutRGBIndoor[0][6]
+{0x0F12,0x0154},	// saRR_usDualGammaLutRGBIndoor[0][7]
+{0x0F12,0x0184},	// saRR_usDualGammaLutRGBIndoor[0][8]
+{0x0F12,0x01C6},	// saRR_usDualGammaLutRGBIndoor[0][9]
+{0x0F12,0x01F8},	// saRR_usDualGammaLutRGBIndoor[0][10]
+{0x0F12,0x0222},	// saRR_usDualGammaLutRGBIndoor[0][11]
+{0x0F12,0x0247},	// saRR_usDualGammaLutRGBIndoor[0][12]
+{0x0F12,0x0282},	// saRR_usDualGammaLutRGBIndoor[0][13]
+{0x0F12,0x02B5},	// saRR_usDualGammaLutRGBIndoor[0][14]
+{0x0F12,0x030F},	// saRR_usDualGammaLutRGBIndoor[0][15]
+{0x0F12,0x035F},	// saRR_usDualGammaLutRGBIndoor[0][16]
+{0x0F12,0x03A2},	// saRR_usDualGammaLutRGBIndoor[0][17]
+{0x0F12,0x03D8},	// saRR_usDualGammaLutRGBIndoor[0][18]
+{0x0F12,0x03FF},	// saRR_usDualGammaLutRGBIndoor[0][19]
+{0x0F12,0x0000},	// saRR_usDualGammaLutRGBIndoor[0][0]
+{0x0F12,0x0004},	// saRR_usDualGammaLutRGBIndoor[0][1]
+{0x0F12,0x000B},	// saRR_usDualGammaLutRGBIndoor[0][2]
+{0x0F12,0x001B},	// saRR_usDualGammaLutRGBIndoor[0][3]
+{0x0F12,0x0046},	// saRR_usDualGammaLutRGBIndoor[0][4]
+{0x0F12,0x00AE},	// saRR_usDualGammaLutRGBIndoor[0][5]
+{0x0F12,0x011E},	// saRR_usDualGammaLutRGBIndoor[0][6]
+{0x0F12,0x0154},	// saRR_usDualGammaLutRGBIndoor[0][7]
+{0x0F12,0x0184},	// saRR_usDualGammaLutRGBIndoor[0][8]
+{0x0F12,0x01C6},	// saRR_usDualGammaLutRGBIndoor[0][9]
+{0x0F12,0x01F8},	// saRR_usDualGammaLutRGBIndoor[0][10]
+{0x0F12,0x0222},	// saRR_usDualGammaLutRGBIndoor[0][11]
+{0x0F12,0x0247},	// saRR_usDualGammaLutRGBIndoor[0][12]
+{0x0F12,0x0282},	// saRR_usDualGammaLutRGBIndoor[0][13]
+{0x0F12,0x02B5},	// saRR_usDualGammaLutRGBIndoor[0][14]
+{0x0F12,0x030F},	// saRR_usDualGammaLutRGBIndoor[0][15]
+{0x0F12,0x035F},	// saRR_usDualGammaLutRGBIndoor[0][16]
+{0x0F12,0x03A2},	// saRR_usDualGammaLutRGBIndoor[0][17]
+{0x0F12,0x03D8},	// saRR_usDualGammaLutRGBIndoor[0][18]
+{0x0F12,0x03FF},	// saRR_usDualGammaLutRGBIndoor[0][19]
+{0x0F12,0x0000},	// saRR_usDualGammaLutRGBIndoor[0][0]
+{0x0F12,0x0004},	// saRR_usDualGammaLutRGBIndoor[0][1]
+{0x0F12,0x000B},	// saRR_usDualGammaLutRGBIndoor[0][2]
+{0x0F12,0x001B},	// saRR_usDualGammaLutRGBIndoor[0][3]
+{0x0F12,0x0046},	// saRR_usDualGammaLutRGBIndoor[0][4]
+{0x0F12,0x00AE},	// saRR_usDualGammaLutRGBIndoor[0][5]
+{0x0F12,0x011E},	// saRR_usDualGammaLutRGBIndoor[0][6]
+{0x0F12,0x0154},	// saRR_usDualGammaLutRGBIndoor[0][7]
+{0x0F12,0x0184},	// saRR_usDualGammaLutRGBIndoor[0][8]
+{0x0F12,0x01C6},	// saRR_usDualGammaLutRGBIndoor[0][9]
+{0x0F12,0x01F8},	// saRR_usDualGammaLutRGBIndoor[0][10]
+{0x0F12,0x0222},	// saRR_usDualGammaLutRGBIndoor[0][11]
+{0x0F12,0x0247},	// saRR_usDualGammaLutRGBIndoor[0][12]
+{0x0F12,0x0282},	// saRR_usDualGammaLutRGBIndoor[0][13]
+{0x0F12,0x02B5},	// saRR_usDualGammaLutRGBIndoor[0][14]
+{0x0F12,0x030F},	// saRR_usDualGammaLutRGBIndoor[0][15]
+{0x0F12,0x035F},	// saRR_usDualGammaLutRGBIndoor[0][16]
+{0x0F12,0x03A2},	// saRR_usDualGammaLutRGBIndoor[0][17]
+{0x0F12,0x03D8},	// saRR_usDualGammaLutRGBIndoor[0][18]
+{0x0F12,0x03FF},	// saRR_usDualGammaLutRGBIndoor[0][19]
+{0x0F12,0x0000},	// saRR_usDualGammaLutRGBIndoor[0][0]
+{0x0F12,0x0004},	// saRR_usDualGammaLutRGBIndoor[0][1]
+{0x0F12,0x000B},	// saRR_usDualGammaLutRGBIndoor[0][2]
+{0x0F12,0x001B},	// saRR_usDualGammaLutRGBIndoor[0][3]
+{0x0F12,0x0046},	// saRR_usDualGammaLutRGBIndoor[0][4]
+{0x0F12,0x00AE},	// saRR_usDualGammaLutRGBIndoor[0][5]
+{0x0F12,0x011E},	// saRR_usDualGammaLutRGBIndoor[0][6]
+{0x0F12,0x0154},	// saRR_usDualGammaLutRGBIndoor[0][7]
+{0x0F12,0x0184},	// saRR_usDualGammaLutRGBIndoor[0][8]
+{0x0F12,0x01C6},	// saRR_usDualGammaLutRGBIndoor[0][9]
+{0x0F12,0x01F8},	// saRR_usDualGammaLutRGBIndoor[0][10]
+{0x0F12,0x0222},	// saRR_usDualGammaLutRGBIndoor[0][11]
+{0x0F12,0x0247},	// saRR_usDualGammaLutRGBIndoor[0][12]
+{0x0F12,0x0282},	// saRR_usDualGammaLutRGBIndoor[0][13]
+{0x0F12,0x02B5},	// saRR_usDualGammaLutRGBIndoor[0][14]
+{0x0F12,0x030F},	// saRR_usDualGammaLutRGBIndoor[0][15]
+{0x0F12,0x035F},	// saRR_usDualGammaLutRGBIndoor[0][16]
+{0x0F12,0x03A2},	// saRR_usDualGammaLutRGBIndoor[0][17]
+{0x0F12,0x03D8},	// saRR_usDualGammaLutRGBIndoor[0][18]
+{0x0F12,0x03FF},	// saRR_usDualGammaLutRGBIndoor[0][19]
+{0x0F12,0x0000},	// saRR_usDualGammaLutRGBIndoor[0][0]
+{0x0F12,0x0004},	// saRR_usDualGammaLutRGBIndoor[0][1]
+{0x0F12,0x000B},	// saRR_usDualGammaLutRGBIndoor[0][2]
+{0x0F12,0x001B},	// saRR_usDualGammaLutRGBIndoor[0][3]
+{0x0F12,0x0046},	// saRR_usDualGammaLutRGBIndoor[0][4]
+{0x0F12,0x00AE},	// saRR_usDualGammaLutRGBIndoor[0][5]
+{0x0F12,0x011E},	// saRR_usDualGammaLutRGBIndoor[0][6]
+{0x0F12,0x0154},	// saRR_usDualGammaLutRGBIndoor[0][7]
+{0x0F12,0x0184},	// saRR_usDualGammaLutRGBIndoor[0][8]
+{0x0F12,0x01C6},	// saRR_usDualGammaLutRGBIndoor[0][9]
+{0x0F12,0x01F8},	// saRR_usDualGammaLutRGBIndoor[0][10]
+{0x0F12,0x0222},	// saRR_usDualGammaLutRGBIndoor[0][11]
+{0x0F12,0x0247},	// saRR_usDualGammaLutRGBIndoor[0][12]
+{0x0F12,0x0282},	// saRR_usDualGammaLutRGBIndoor[0][13]
+{0x0F12,0x02B5},	// saRR_usDualGammaLutRGBIndoor[0][14]
+{0x0F12,0x030F},	// saRR_usDualGammaLutRGBIndoor[0][15]
+{0x0F12,0x035F},	// saRR_usDualGammaLutRGBIndoor[0][16]
+{0x0F12,0x03A2},	// saRR_usDualGammaLutRGBIndoor[0][17]
+{0x0F12,0x03D8},	// saRR_usDualGammaLutRGBIndoor[0][18]
+{0x0F12,0x03FF},	// saRR_usDualGammaLutRGBIndoor[0][19]
+
 //==================================================================================
 // 17.AFIT
 //==================================================================================
-{0x002A, 0x0944},	
-{0x0F12, 0x0050},	 //afit_uNoiseIndInDoor
-{0x0F12, 0x00B0},	 //afit_uNoiseIndInDoor
-{0x0F12, 0x0196},	 //afit_uNoiseIndInDoor
-{0x0F12, 0x0245},	 //afit_uNoiseIndInDoor
-{0x0F12, 0x0300},	 //afit_uNoiseIndInDoor
-     
-{0x002A, 0x0938},	
-{0x0F12, 0x0000},	 // on/off AFIT by NB option
-{0x0F12, 0x0014},	 //SARR_uNormBrInDoor
-{0x0F12, 0x00D2},	 //SARR_uNormBrInDoor
-{0x0F12, 0x0384},	 //SARR_uNormBrInDoor
-{0x0F12, 0x07D0},	 //SARR_uNormBrInDoor
-{0x0F12, 0x1388},	 //SARR_uNormBrInDoor
-     
-{0x002A, 0x0976},	
-{0x0F12, 0x0070},	 //afit_usGamutTh       
-{0x0F12, 0x0005},	 //afit_usNeargrayOffset
-{0x0F12, 0x0000},	 //afit_bUseSenBpr         
-{0x0F12, 0x01CC},	 //afit_usBprThr_0_        
-{0x0F12, 0x01CC},	 //afit_usBprThr_1_        
-{0x0F12, 0x01CC},	 //afit_usBprThr_2_        
-{0x0F12, 0x01CC},	 //afit_usBprThr_3_        
-{0x0F12, 0x01CC},	 //afit_usBprThr_4_        
-{0x0F12, 0x0180},	 //afit_NIContrastAFITValue
-{0x0F12, 0x0196},	 //afit_NIContrastTh       
-     
-{0x002A, 0x098C},
-{0x0F12, 0x0000},	 //7000098C	 //_BRIGHTNESS	AFIT 0                                  
-{0x0F12, 0x0000},	 //7000098E	 //_CONTRAST                                           
-{0x0F12, 0x0000},	 //70000990	 //_SATURATION                                         
-{0x0F12, 0x0000},	 //70000992	 //_SHARP_BLUR                                         
-{0x0F12, 0x0000},	 //70000994	 //_GLAMOUR                                            
-{0x0F12, 0x00C0},	 //70000996	 //_bnr_edge_high                                      
-{0x0F12, 0x0064},	 //70000998	 //_postdmsc_iLowBright                                
-{0x0F12, 0x0384},	 //7000099A	 //_postdmsc_iHighBright                               
-{0x0F12, 0x005F},	 //7000099C	 //_postdmsc_iLowSat                                   
-{0x0F12, 0x01F4},	 //7000099E	 //_postdmsc_iHighSat                                  
-{0x0F12, 0x0070},	 //700009A0	 //_postdmsc_iTune                                     
-{0x0F12, 0x0040},	 //700009A2	 //_yuvemix_mNegRanges_0                               
-{0x0F12, 0x00A0},	 //700009A4	 //_yuvemix_mNegRanges_1                               
-{0x0F12, 0x0100},	 //700009A6	 //_yuvemix_mNegRanges_2                               
-{0x0F12, 0x0010},	 //700009A8	 //_yuvemix_mPosRanges_0                               
-{0x0F12, 0x0040},	 //700009AA	 //_yuvemix_mPosRanges_1                               
-{0x0F12, 0x00A0},	 //700009AC	 //_yuvemix_mPosRanges_2                               
-{0x0F12, 0x1430},	 //700009AE	 //_bnr_edge_low  [7:0] AFIT8_bnr_repl_thresh          
-{0x0F12, 0x0201},	 //700009B0	 //_bnr_repl_force  [7:0] AFIT8_bnr_iHotThreshHigh     
-{0x0F12, 0x0204},	 //700009B2	 //_bnr_iHotThreshLow   [7:0] AFIT8_bnr_iColdThreshHigh
-{0x0F12, 0x3604},	 //700009B4	 //_bnr_iColdThreshLow   [7:0] AFIT8_bnr_DispTH_Low    
-{0x0F12, 0x032A},	 //700009B6	 //_bnr_DispTH_High   [7:0] AFIT8_bnr_DISP_Limit_Low   
-{0x0F12, 0x0403},	 //700009B8	 //_bnr_DISP_Limit_High   [7:0] AFIT8_bnr_iDistSigmaMin
-{0x0F12, 0x1B06},	 //700009BA	 //_bnr_iDistSigmaMax   [7:0] AFIT8_bnr_iDiffSigmaLow  
-{0x0F12, 0x6015},	 //700009BC	 //_bnr_iDiffSigmaHigh   [7:0] AFIT8_bnr_iNormalizedSTD_TH        
-{0x0F12, 0x00C0},	 //700009BE	 //_bnr_iNormalizedSTD_Limit   [7:0] AFIT8_bnr_iDirNRTune         
-{0x0F12, 0x6080},	 //700009C0	 //_bnr_iDirMinThres   [7:0] AFIT8_bnr_iDirFltDiffThresHigh       
-{0x0F12, 0x4080},	 //700009C2	 //_bnr_iDirFltDiffThresLow   [7:0] AFIT8_bnr_iDirSmoothPowerHigh 
-{0x0F12, 0x0640},	 //700009C4	 //_bnr_iDirSmoothPowerLow   [7:0] AFIT8_bnr_iLowMaxSlopeAllowed  
-{0x0F12, 0x0306},	 //700009C6	 //_bnr_iHighMaxSlopeAllowed   [7:0] AFIT8_bnr_iLowSlopeThresh    
-{0x0F12, 0x2003},	 //700009C8	 //_bnr_iHighSlopeThresh   [7:0] AFIT8_bnr_iSlopenessTH
-{0x0F12, 0xFF01},	 //700009CA	 //_bnr_iSlopeBlurStrength   [7:0] AFIT8_bnr_iSlopenessLimit      
-{0x0F12, 0x0000},	 //700009CC	 //_bnr_AddNoisePower1   [7:0] AFIT8_bnr_AddNoisePower2
-{0x0F12, 0x0400},	 //700009CE	 //_bnr_iRadialTune   [7:0] AFIT8_bnr_iRadialPower     
-{0x0F12, 0x365A},	 //700009D0	 //_bnr_iRadialLimit   [7:0] AFIT8_ee_iFSMagThLow      
-{0x0F12, 0x102A},	 //700009D2	 //_ee_iFSMagThHigh   [7:0] AFIT8_ee_iFSVarThLow       
-{0x0F12, 0x000B},	 //700009D4	 //_ee_iFSVarThHigh   [7:0] AFIT8_ee_iFSThLow          
-{0x0F12, 0x0600},	 //700009D6	 //_ee_iFSThHigh   [7:0] AFIT8_ee_iFSmagPower          
-{0x0F12, 0x5A0F},	 //700009D8	 //_ee_iFSVarCountTh   [7:0] AFIT8_ee_iRadialLimit     
-{0x0F12, 0x0505},	 //700009DA	 //_ee_iRadialPower   [7:0] AFIT8_ee_iSmoothEdgeSlope  
-{0x0F12, 0x1802},	 //700009DC	 //_ee_iROADThres   [7:0] AFIT8_ee_iROADMaxNR          
-{0x0F12, 0x0000},	 //700009DE	 //_ee_iROADSubMaxNR   [7:0] AFIT8_ee_iROADSubThres    
-{0x0F12, 0x2006},	 //700009E0	 //_ee_iROADNeiThres   [7:0] AFIT8_ee_iROADNeiMaxNR    
-{0x0F12, 0x3028},	 //700009E2	 //_ee_iSmoothEdgeThres   [7:0] AFIT8_ee_iMSharpen     
-{0x0F12, 0x0418},	 //700009E4	 //_ee_iWSharpen   [7:0] AFIT8_ee_iMShThresh           
-{0x0F12, 0x0101},	 //700009E6	 //_ee_iWShThresh   [7:0] AFIT8_ee_iReduceNegative     
-{0x0F12, 0x0800},	 //700009E8	 //_ee_iEmbossCentAdd   [7:0] AFIT8_ee_iShDespeckle    
-{0x0F12, 0x1804},	 //700009EA	 //_ee_iReduceEdgeThresh   [7:0] AFIT8_dmsc_iEnhThresh 
-{0x0F12, 0x4008},	 //700009EC	 //_dmsc_iDesatThresh   [7:0] AFIT8_dmsc_iDemBlurHigh  
-{0x0F12, 0x0540},	 //700009EE	 //_dmsc_iDemBlurLow   [7:0] AFIT8_dmsc_iDemBlurRange  
-{0x0F12, 0x8006},	 //700009F0	 //_dmsc_iDecisionThresh   [7:0] AFIT8_dmsc_iCentGrad  
-{0x0F12, 0x0020},	 //700009F2	 //_dmsc_iMonochrom   [7:0] AFIT8_dmsc_iGBDenoiseVal   
-{0x0F12, 0x0000},	 //700009F4	 //_dmsc_iGRDenoiseVal   [7:0] AFIT8_dmsc_iEdgeDesatThrHigh       
-{0x0F12, 0x2000},	 //700009F6	 //_dmsc_iEdgeDesatThrLow   [7:0] AFIT8_dmsc_iEdgeDesat
-{0x0F12, 0x0000},	 //700009F8	 //_dmsc_iNearGrayDesat   [7:0] AFIT8_dmsc_iEdgeDesatLimit        
-{0x0F12, 0x1E10},	 //700009FA	 //_postdmsc_iBCoeff   [7:0] AFIT8_postdmsc_iGCoeff    
-{0x0F12, 0x000B},	 //700009FC	 //_postdmsc_iWideMult   [7:0] AFIT8_yuvemix_mNegSlopes_0         
-{0x0F12, 0x0607},	 //700009FE	 //_yuvemix_mNegSlopes_1   [7:0] AFIT8_yuvemix_mNegSlopes_2       
-{0x0F12, 0x0005},	 //70000A00	 //_yuvemix_mNegSlopes_3   [7:0] AFIT8_yuvemix_mPosSlopes_0       
-{0x0F12, 0x0607},	 //70000A02	 //_yuvemix_mPosSlopes_1   [7:0] AFIT8_yuvemix_mPosSlopes_2       
-{0x0F12, 0x0705},	 //70000A04	 //_yuvemix_mPosSlopes_3   [7:0] AFIT8_yuviirnr_iXSupportY        
-{0x0F12, 0x0206},	 //70000A06	 //_yuviirnr_iXSupportUV   [7:0] AFIT8_yuviirnr_iLowYNorm         
-{0x0F12, 0x0304},	 //70000A08	 //_yuviirnr_iHighYNorm   [7:0] AFIT8_yuviirnr_iLowUVNorm         
-{0x0F12, 0x0309},	 //70000A0A	 //_yuviirnr_iHighUVNorm   [7:0] AFIT8_yuviirnr_iYNormShift       
-{0x0F12, 0x0305},	 //70000A0C	 //_yuviirnr_iUVNormShift   [7:0] AFIT8_yuviirnr_iVertLength_Y    
-{0x0F12, 0x2006},	 //70000A0E	 //_yuviirnr_iVertLength_UV   [7:0] AFIT8_yuviirnr_iDiffThreshL_Y 
-{0x0F12, 0x1320},	 //70000A10	 //_yuviirnr_iDiffThreshH_Y   [7:0] AFIT8_yuviirnr_iDiffThreshL_UV
-{0x0F12, 0x1014},	 //70000A12	 //_yuviirnr_iDiffThreshH_UV   [7:0] AFIT8_yuviirnr_iMaxThreshL_Y 
-{0x0F12, 0x1010},	 //70000A14	 //_yuviirnr_iMaxThreshH_Y   [7:0] AFIT8_yuviirnr_iMaxThreshL_UV  
-{0x0F12, 0x0C10},	 //70000A16	 //_yuviirnr_iMaxThreshH_UV   [7:0] AFIT8_yuviirnr_iYNRStrengthL  
-{0x0F12, 0x1A0C},	 //70000A18	 //_yuviirnr_iYNRStrengthH   [7:0] AFIT8_yuviirnr_iUVNRStrengthL  
-{0x0F12, 0x4A18},	 //70000A1A	 //_yuviirnr_iUVNRStrengthH   [7:0] AFIT8_byr_gras_iShadingPower  
-{0x0F12, 0x0080},	 //70000A1C	 //_RGBGamma2_iLinearity   [7:0] AFIT8_RGBGamma2_iDarkReduce      
-{0x0F12, 0x0350},	 //70000A1E	 //_ccm_oscar_iSaturation   [7:0] AFIT8_RGB2YUV_iYOffset
-{0x0F12, 0x0180},	 //70000A20	 //_RGB2YUV_iRGBGain   [7:0] AFIT8_bnr_nClustLevel_H   
-{0x0F12, 0x0A0A},	 //70000A22	 //_bnr_iClustMulT_H   [7:0] AFIT8_bnr_iClustMulT_C    
-{0x0F12, 0x0101},	 //70000A24	 //_bnr_iClustThresh_H   [7:0] AFIT8_bnr_iClustThresh_C
-{0x0F12, 0x2A36},	 //70000A26	 //_bnr_iDenThreshLow   [7:0] AFIT8_bnr_iDenThreshHigh 
-{0x0F12, 0x6024},	 //70000A28	 //_ee_iLowSharpPower   [7:0] AFIT8_ee_iHighSharpPower 
-{0x0F12, 0x2A36},	 //70000A2A	 //_ee_iLowShDenoise   [7:0] AFIT8_ee_iHighShDenoise   
-{0x0F12, 0xFFFF},	 //70000A2C	 //_ee_iLowSharpClamp   [7:0] AFIT8_ee_iHighSharpClamp 
-{0x0F12, 0x0808},	 //70000A2E	 //_ee_iReduceEdgeMinMult   [7:0] AFIT8_ee_iReduceEdgeSlope       
-{0x0F12, 0x0A01},	 //70000A30	 //_bnr_nClustLevel_H_Bin   [7:0] AFIT8_bnr_iClustMulT_H_Bin      
-{0x0F12, 0x010A},	 //70000A32	 //_bnr_iClustMulT_C_Bin   [7:0] AFIT8_bnr_iClustThresh_H_Bin     
-{0x0F12, 0x2701},	 //70000A34	 //_bnr_iClustThresh_C_Bin   [7:0] AFIT8_bnr_iDenThreshLow_Bin    
-{0x0F12, 0x241E},	 //70000A36	 //_bnr_iDenThreshHigh_Bin   [7:0] AFIT8_ee_iLowSharpPower_Bin    
-{0x0F12, 0x2E60},	 //70000A38	 //_ee_iHighSharpPower_Bin   [7:0] AFIT8_ee_iLowShDenoise_Bin     
-{0x0F12, 0xFF22},	 //70000A3A	 //_ee_iHighShDenoise_Bin   [7:0] AFIT8_ee_iLowSharpClamp_Bin     
-{0x0F12, 0x40FF},	 //70000A3C	 //_ee_iHighSharpClamp_Bin   [7:0] AFIT8_ee_iReduceEdgeMinMult_Bin
-{0x0F12, 0x0009},	 //70000A3E	 //_ee_iReduceEdgeSlope_Bin [7:0]                      
-{0x0F12, 0x0001},	 //70000A40	 //_bnr_nClustLevel_C      [0]                         
-{0x0F12, 0x0000},	 //70000A42	 //_BRIGHTNESS	AFIT 1                                  
-{0x0F12, 0x0000},	 //70000A44	 //_CONTRAST                                           
-{0x0F12, 0x0000},	 //70000A46	 //_SATURATION                                         
-{0x0F12, 0x0000},	 //70000A48	 //_SHARP_BLUR                                         
-{0x0F12, 0x0000},	 //70000A4A	 //_GLAMOUR                                            
-{0x0F12, 0x00C0},	 //70000A4C	 //_bnr_edge_high                                      
-{0x0F12, 0x0064},	 //70000A4E	 //_postdmsc_iLowBright                                
-{0x0F12, 0x0384},	 //70000A50	 //_postdmsc_iHighBright                               
-{0x0F12, 0x0051},	 //70000A52	 //_postdmsc_iLowSat                                   
-{0x0F12, 0x01F4},	 //70000A54	 //_postdmsc_iHighSat                                  
-{0x0F12, 0x0070},	 //70000A56	 //_postdmsc_iTune                                     
-{0x0F12, 0x0040},	 //70000A58	 //_yuvemix_mNegRanges_0                               
-{0x0F12, 0x00A0},	 //70000A5A	 //_yuvemix_mNegRanges_1                               
-{0x0F12, 0x0100},	 //70000A5C	 //_yuvemix_mNegRanges_2                               
-{0x0F12, 0x0010},	 //70000A5E	 //_yuvemix_mPosRanges_0                               
-{0x0F12, 0x0060},	 //70000A60	 //_yuvemix_mPosRanges_1                               
-{0x0F12, 0x0100},	 //70000A62	 //_yuvemix_mPosRanges_2                               
-{0x0F12, 0x1430},	 //70000A64	 //_bnr_edge_low  [7:0] AFIT8_bnr_repl_thresh          
-{0x0F12, 0x0201},	 //70000A66	 //_bnr_repl_force  [7:0] AFIT8_bnr_iHotThreshHigh     
-{0x0F12, 0x0204},	 //70000A68	 //_bnr_iHotThreshLow   [7:0] AFIT8_bnr_iColdThreshHigh
-{0x0F12, 0x2404},	 //70000A6A	 //_bnr_iColdThreshLow   [7:0] AFIT8_bnr_DispTH_Low    
-{0x0F12, 0x031B},	 //70000A6C	 //_bnr_DispTH_High   [7:0] AFIT8_bnr_DISP_Limit_Low   
-{0x0F12, 0x0103},	 //70000A6E	 //_bnr_DISP_Limit_High   [7:0] AFIT8_bnr_iDistSigmaMin
-{0x0F12, 0x1205},	 //70000A70	 //_bnr_iDistSigmaMax   [7:0] AFIT8_bnr_iDiffSigmaLow  
-{0x0F12, 0x400D},	 //70000A72	 //_bnr_iDiffSigmaHigh   [7:0] AFIT8_bnr_iNormalizedSTD_TH        
-{0x0F12, 0x0080},	 //70000A74	 //_bnr_iNormalizedSTD_Limit   [7:0] AFIT8_bnr_iDirNRTune         
-{0x0F12, 0x1980},	 //70000A76	 //_bnr_iDirMinThres   [7:0] AFIT8_bnr_iDirFltDiffThresHigh       
-{0x0F12, 0x272E},	 //70000A78	 //_bnr_iDirFltDiffThresLow   [7:0] AFIT8_bnr_iDirSmoothPowerHigh 
-{0x0F12, 0x0629},	 //70000A7A	 //_bnr_iDirSmoothPowerLow   [7:0] AFIT8_bnr_iLowMaxSlopeAllowed  
-{0x0F12, 0x0306},	 //70000A7C	 //_bnr_iHighMaxSlopeAllowed   [7:0] AFIT8_bnr_iLowSlopeThresh    
-{0x0F12, 0x2003},	 //70000A7E	 //_bnr_iHighSlopeThresh   [7:0] AFIT8_bnr_iSlopenessTH
-{0x0F12, 0xFF01},	 //70000A80	 //_bnr_iSlopeBlurStrength   [7:0] AFIT8_bnr_iSlopenessLimit      
-{0x0F12, 0x0404},	 //70000A82	 //_bnr_AddNoisePower1   [7:0] AFIT8_bnr_AddNoisePower2
-{0x0F12, 0x0300},	 //70000A84	 //_bnr_iRadialTune   [7:0] AFIT8_bnr_iRadialPower     
-{0x0F12, 0x245A},	 //70000A86	 //_bnr_iRadialLimit   [7:0] AFIT8_ee_iFSMagThLow      
-{0x0F12, 0x1018},	 //70000A88	 //_ee_iFSMagThHigh   [7:0] AFIT8_ee_iFSVarThLow       
-{0x0F12, 0x000B},	 //70000A8A	 //_ee_iFSVarThHigh   [7:0] AFIT8_ee_iFSThLow          
-{0x0F12, 0x0B00},	 //70000A8C	 //_ee_iFSThHigh   [7:0] AFIT8_ee_iFSmagPower          
-{0x0F12, 0x5A0F},	 //70000A8E	 //_ee_iFSVarCountTh   [7:0] AFIT8_ee_iRadialLimit     
-{0x0F12, 0x0505},	 //70000A90	 //_ee_iRadialPower   [7:0] AFIT8_ee_iSmoothEdgeSlope  
-{0x0F12, 0x1802},	 //70000A92	 //_ee_iROADThres   [7:0] AFIT8_ee_iROADMaxNR          
-{0x0F12, 0x0000},	 //70000A94	 //_ee_iROADSubMaxNR   [7:0] AFIT8_ee_iROADSubThres    
-{0x0F12, 0x2006},	 //70000A96	 //_ee_iROADNeiThres   [7:0] AFIT8_ee_iROADNeiMaxNR    
-{0x0F12, 0x3828},	 //70000A98	 //_ee_iSmoothEdgeThres   [7:0] AFIT8_ee_iMSharpen     
-{0x0F12, 0x0425},	 //70000A9A	 //_ee_iWSharpen   [7:0] AFIT8_ee_iMShThresh           
-{0x0F12, 0x0101},	 //70000A9C	 //_ee_iWShThresh   [7:0] AFIT8_ee_iReduceNegative     
-{0x0F12, 0x0800},	 //70000A9E	 //_ee_iEmbossCentAdd   [7:0] AFIT8_ee_iShDespeckle    
-{0x0F12, 0x1004},	 //70000AA0	 //_ee_iReduceEdgeThresh   [7:0] AFIT8_dmsc_iEnhThresh 
-{0x0F12, 0x4008},	 //70000AA2	 //_dmsc_iDesatThresh   [7:0] AFIT8_dmsc_iDemBlurHigh  
-{0x0F12, 0x0540},	 //70000AA4	 //_dmsc_iDemBlurLow   [7:0] AFIT8_dmsc_iDemBlurRange  
-{0x0F12, 0x8006},	 //70000AA6	 //_dmsc_iDecisionThresh   [7:0] AFIT8_dmsc_iCentGrad  
-{0x0F12, 0x0020},	 //70000AA8	 //_dmsc_iMonochrom   [7:0] AFIT8_dmsc_iGBDenoiseVal   
-{0x0F12, 0x0000},	 //70000AAA	 //_dmsc_iGRDenoiseVal   [7:0] AFIT8_dmsc_iEdgeDesatThrHigh       
-{0x0F12, 0x2000},	 //70000AAC	 //_dmsc_iEdgeDesatThrLow   [7:0] AFIT8_dmsc_iEdgeDesat
-{0x0F12, 0x0000},	 //70000AAE	 //_dmsc_iNearGrayDesat   [7:0] AFIT8_dmsc_iEdgeDesatLimit        
-{0x0F12, 0x1E10},	 //70000AB0	 //_postdmsc_iBCoeff   [7:0] AFIT8_postdmsc_iGCoeff    
-{0x0F12, 0x000B},	 //70000AB2	 //_postdmsc_iWideMult   [7:0] AFIT8_yuvemix_mNegSlopes_0         
-{0x0F12, 0x0607},	 //70000AB4	 //_yuvemix_mNegSlopes_1   [7:0] AFIT8_yuvemix_mNegSlopes_2       
-{0x0F12, 0x0005},	 //70000AB6	 //_yuvemix_mNegSlopes_3   [7:0] AFIT8_yuvemix_mPosSlopes_0       
-{0x0F12, 0x0607},	 //70000AB8	 //_yuvemix_mPosSlopes_1   [7:0] AFIT8_yuvemix_mPosSlopes_2       
-{0x0F12, 0x0405},	 //70000ABA	 //_yuvemix_mPosSlopes_3   [7:0] AFIT8_yuviirnr_iXSupportY        
-{0x0F12, 0x0205},	 //70000ABC	 //_yuviirnr_iXSupportUV   [7:0] AFIT8_yuviirnr_iLowYNorm         
-{0x0F12, 0x0304},	 //70000ABE	 //_yuviirnr_iHighYNorm   [7:0] AFIT8_yuviirnr_iLowUVNorm         
-{0x0F12, 0x0409},	 //70000AC0	 //_yuviirnr_iHighUVNorm   [7:0] AFIT8_yuviirnr_iYNormShift       
-{0x0F12, 0x0306},	 //70000AC2	 //_yuviirnr_iUVNormShift   [7:0] AFIT8_yuviirnr_iVertLength_Y    
-{0x0F12, 0x0407},	 //70000AC4	 //_yuviirnr_iVertLength_UV   [7:0] AFIT8_yuviirnr_iDiffThreshL_Y 
-{0x0F12, 0x2204},	 //70000AC6	 //_yuviirnr_iDiffThreshH_Y   [7:0] AFIT8_yuviirnr_iDiffThreshL_UV
-{0x0F12, 0x021C},	 //70000AC8	 //_yuviirnr_iDiffThreshH_UV   [7:0] AFIT8_yuviirnr_iMaxThreshL_Y 
-{0x0F12, 0x1102},	 //70000ACA	 //_yuviirnr_iMaxThreshH_Y   [7:0] AFIT8_yuviirnr_iMaxThreshL_UV  
-{0x0F12, 0x0611},	 //70000ACC	 //_yuviirnr_iMaxThreshH_UV   [7:0] AFIT8_yuviirnr_iYNRStrengthL  
-{0x0F12, 0x1A02},	 //70000ACE	 //_yuviirnr_iYNRStrengthH   [7:0] AFIT8_yuviirnr_iUVNRStrengthL  
-{0x0F12, 0x8018},	 //70000AD0	 //_yuviirnr_iUVNRStrengthH   [7:0] AFIT8_byr_gras_iShadingPower  
-{0x0F12, 0x0080},	 //70000AD2	 //_RGBGamma2_iLinearity   [7:0] AFIT8_RGBGamma2_iDarkReduce      
-{0x0F12, 0x0374},	 //70000AD4	 //_ccm_oscar_iSaturation   [7:0] AFIT8_RGB2YUV_iYOffset //
-{0x0F12, 0x0180},	 //70000AD6	 //_RGB2YUV_iRGBGain   [7:0] AFIT8_bnr_nClustLevel_H   
-{0x0F12, 0x0A0A},	 //70000AD8	 //_bnr_iClustMulT_H   [7:0] AFIT8_bnr_iClustMulT_C    
-{0x0F12, 0x0101},	 //70000ADA	 //_bnr_iClustThresh_H   [7:0] AFIT8_bnr_iClustThresh_C
-{0x0F12, 0x141D},	 //70000ADC	 //_bnr_iDenThreshLow   [7:0] AFIT8_bnr_iDenThreshHigh 
-{0x0F12, 0x6024},	 //70000ADE	 //_ee_iLowSharpPower   [7:0] AFIT8_ee_iHighSharpPower 
-{0x0F12, 0x1217},	 //70000AE0	 //_ee_iLowShDenoise   [7:0] AFIT8_ee_iHighShDenoise   
-{0x0F12, 0xFFFF},	 //70000AE2	 //_ee_iLowSharpClamp   [7:0] AFIT8_ee_iHighSharpClamp 
-{0x0F12, 0x0808},	 //70000AE4	 //_ee_iReduceEdgeMinMult   [7:0] AFIT8_ee_iReduceEdgeSlope       
-{0x0F12, 0x0A01},	 //70000AE6	 //_bnr_nClustLevel_H_Bin   [7:0] AFIT8_bnr_iClustMulT_H_Bin      
-{0x0F12, 0x010A},	 //70000AE8	 //_bnr_iClustMulT_C_Bin   [7:0] AFIT8_bnr_iClustThresh_H_Bin     
-{0x0F12, 0x0001},	 //70000AEA	 //_bnr_iClustThresh_C_Bin   [7:0] AFIT8_bnr_iDenThreshLow_Bin    
-{0x0F12, 0x2400},	 //70000AEC	 //_bnr_iDenThreshHigh_Bin   [7:0] AFIT8_ee_iLowSharpPower_Bin    
-{0x0F12, 0x1660},	 //70000AEE	 //_ee_iHighSharpPower_Bin   [7:0] AFIT8_ee_iLowShDenoise_Bin     
-{0x0F12, 0xFF10},	 //70000AF0	 //_ee_iHighShDenoise_Bin   [7:0] AFIT8_ee_iLowSharpClamp_Bin     
-{0x0F12, 0x40FF},	 //70000AF2	 //_ee_iHighSharpClamp_Bin   [7:0] AFIT8_ee_iReduceEdgeMinMult_Bin
-{0x0F12, 0x0009},	 //70000AF4	 //_ee_iReduceEdgeSlope_Bin [7:0]                      
-{0x0F12, 0x0001},	 //70000AF6	 //_bnr_nClustLevel_C      [0]                         
-{0x0F12, 0x0000},	 //70000AF8	 //_BRIGHTNESS	AFIT 2                                  
-{0x0F12, 0x0000},	 //70000AFA	 //_CONTRAST                                           
-{0x0F12, 0x0000},	 //70000AFC	 //_SATURATION                                         
-{0x0F12, 0x0000},	 //70000AFE	 //_SHARP_BLUR                                         
-{0x0F12, 0x0000},	 //70000B00	 //_GLAMOUR                                            
-{0x0F12, 0x00C0},	 //70000B02	 //_bnr_edge_high                                      
-{0x0F12, 0x0064},	 //70000B04	 //_postdmsc_iLowBright                                
-{0x0F12, 0x0384},	 //70000B06	 //_postdmsc_iHighBright                               
-{0x0F12, 0x0043},	 //70000B08	 //_postdmsc_iLowSat                                   
-{0x0F12, 0x01F4},	 //70000B0A	 //_postdmsc_iHighSat                                  
-{0x0F12, 0x0070},	 //70000B0C	 //_postdmsc_iTune                                     
-{0x0F12, 0x0040},	 //70000B0E	 //_yuvemix_mNegRanges_0                               
-{0x0F12, 0x00A0},	 //70000B10	 //_yuvemix_mNegRanges_1                               
-{0x0F12, 0x0100},	 //70000B12	 //_yuvemix_mNegRanges_2                               
-{0x0F12, 0x0010},	 //70000B14	 //_yuvemix_mPosRanges_0                               
-{0x0F12, 0x0060},	 //70000B16	 //_yuvemix_mPosRanges_1                               
-{0x0F12, 0x0100},	 //70000B18	 //_yuvemix_mPosRanges_2                               
-{0x0F12, 0x1430},	 //70000B1A	 //_bnr_edge_low  [7:0] AFIT8_bnr_repl_thresh          
-{0x0F12, 0x0201},	 //70000B1C	 //_bnr_repl_force  [7:0] AFIT8_bnr_iHotThreshHigh     
-{0x0F12, 0x0204},	 //70000B1E	 //_bnr_iHotThreshLow   [7:0] AFIT8_bnr_iColdThreshHigh
-{0x0F12, 0x1B04},	 //70000B20	 //_bnr_iColdThreshLow   [7:0] AFIT8_bnr_DispTH_Low    
-{0x0F12, 0x0312},	 //70000B22	 //_bnr_DispTH_High   [7:0] AFIT8_bnr_DISP_Limit_Low   
-{0x0F12, 0x0003},	 //70000B24	 //_bnr_DISP_Limit_High   [7:0] AFIT8_bnr_iDistSigmaMin
-{0x0F12, 0x0C03},	 //70000B26	 //_bnr_iDistSigmaMax   [7:0] AFIT8_bnr_iDiffSigmaLow  
-{0x0F12, 0x2806},	 //70000B28	 //_bnr_iDiffSigmaHigh   [7:0] AFIT8_bnr_iNormalizedSTD_TH        
-{0x0F12, 0x0060},	 //70000B2A	 //_bnr_iNormalizedSTD_Limit   [7:0] AFIT8_bnr_iDirNRTune         
-{0x0F12, 0x1580},	 //70000B2C	 //_bnr_iDirMinThres   [7:0] AFIT8_bnr_iDirFltDiffThresHigh       
-{0x0F12, 0x2020},	 //70000B2E	 //_bnr_iDirFltDiffThresLow   [7:0] AFIT8_bnr_iDirSmoothPowerHigh 
-{0x0F12, 0x0620},	 //70000B30	 //_bnr_iDirSmoothPowerLow   [7:0] AFIT8_bnr_iLowMaxSlopeAllowed  
-{0x0F12, 0x0306},	 //70000B32	 //_bnr_iHighMaxSlopeAllowed   [7:0] AFIT8_bnr_iLowSlopeThresh    
-{0x0F12, 0x2003},	 //70000B34	 //_bnr_iHighSlopeThresh   [7:0] AFIT8_bnr_iSlopenessTH
-{0x0F12, 0xFF01},	 //70000B36	 //_bnr_iSlopeBlurStrength   [7:0] AFIT8_bnr_iSlopenessLimit      
-{0x0F12, 0x0404},	 //70000B38	 //_bnr_AddNoisePower1   [7:0] AFIT8_bnr_AddNoisePower2
-{0x0F12, 0x0300},	 //70000B3A	 //_bnr_iRadialTune   [7:0] AFIT8_bnr_iRadialPower     
-{0x0F12, 0x145A},	 //70000B3C	 //_bnr_iRadialLimit   [7:0] AFIT8_ee_iFSMagThLow      
-{0x0F12, 0x1010},	 //70000B3E	 //_ee_iFSMagThHigh   [7:0] AFIT8_ee_iFSVarThLow       
-{0x0F12, 0x000B},	 //70000B40	 //_ee_iFSVarThHigh   [7:0] AFIT8_ee_iFSThLow          
-{0x0F12, 0x0E00},	 //70000B42	 //_ee_iFSThHigh   [7:0] AFIT8_ee_iFSmagPower          
-{0x0F12, 0x5A0F},	 //70000B44	 //_ee_iFSVarCountTh   [7:0] AFIT8_ee_iRadialLimit     
-{0x0F12, 0x0504},	 //70000B46	 //_ee_iRadialPower   [7:0] AFIT8_ee_iSmoothEdgeSlope  
-{0x0F12, 0x1802},	 //70000B48	 //_ee_iROADThres   [7:0] AFIT8_ee_iROADMaxNR          
-{0x0F12, 0x0000},	 //70000B4A	 //_ee_iROADSubMaxNR   [7:0] AFIT8_ee_iROADSubThres    
-{0x0F12, 0x2006},	 //70000B4C	 //_ee_iROADNeiThres   [7:0] AFIT8_ee_iROADNeiMaxNR    
-{0x0F12, 0x3828},	 //70000B4E	 //_ee_iSmoothEdgeThres   [7:0] AFIT8_ee_iMSharpen     
-{0x0F12, 0x0428},	 //70000B50	 //_ee_iWSharpen   [7:0] AFIT8_ee_iMShThresh           
-{0x0F12, 0x0101},	 //70000B52	 //_ee_iWShThresh   [7:0] AFIT8_ee_iReduceNegative     
-{0x0F12, 0x8000},	 //70000B54	 //_ee_iEmbossCentAdd   [7:0] AFIT8_ee_iShDespeckle    
-{0x0F12, 0x0A04},	 //70000B56	 //_ee_iReduceEdgeThresh   [7:0] AFIT8_dmsc_iEnhThresh 
-{0x0F12, 0x4008},	 //70000B58	 //_dmsc_iDesatThresh   [7:0] AFIT8_dmsc_iDemBlurHigh  
-{0x0F12, 0x0540},	 //70000B5A	 //_dmsc_iDemBlurLow   [7:0] AFIT8_dmsc_iDemBlurRange  
-{0x0F12, 0x8006},	 //70000B5C	 //_dmsc_iDecisionThresh   [7:0] AFIT8_dmsc_iCentGrad  
-{0x0F12, 0x0020},	 //70000B5E	 //_dmsc_iMonochrom   [7:0] AFIT8_dmsc_iGBDenoiseVal   
-{0x0F12, 0x0000},	 //70000B60	 //_dmsc_iGRDenoiseVal   [7:0] AFIT8_dmsc_iEdgeDesatThrHigh       
-{0x0F12, 0x2000},	 //70000B62	 //_dmsc_iEdgeDesatThrLow   [7:0] AFIT8_dmsc_iEdgeDesat
-{0x0F12, 0x0000},	 //70000B64	 //_dmsc_iNearGrayDesat   [7:0] AFIT8_dmsc_iEdgeDesatLimit        
-{0x0F12, 0x1E10},	 //70000B66	 //_postdmsc_iBCoeff   [7:0] AFIT8_postdmsc_iGCoeff    
-{0x0F12, 0x000B},	 //70000B68	 //_postdmsc_iWideMult   [7:0] AFIT8_yuvemix_mNegSlopes_0         
-{0x0F12, 0x0607},	 //70000B6A	 //_yuvemix_mNegSlopes_1   [7:0] AFIT8_yuvemix_mNegSlopes_2       
-{0x0F12, 0x0005},	 //70000B6C	 //_yuvemix_mNegSlopes_3   [7:0] AFIT8_yuvemix_mPosSlopes_0       
-{0x0F12, 0x0607},	 //70000B6E	 //_yuvemix_mPosSlopes_1   [7:0] AFIT8_yuvemix_mPosSlopes_2       
-{0x0F12, 0x0405},	 //70000B70	 //_yuvemix_mPosSlopes_3   [7:0] AFIT8_yuviirnr_iXSupportY        
-{0x0F12, 0x0207},	 //70000B72	 //_yuviirnr_iXSupportUV   [7:0] AFIT8_yuviirnr_iLowYNorm         
-{0x0F12, 0x0304},	 //70000B74	 //_yuviirnr_iHighYNorm   [7:0] AFIT8_yuviirnr_iLowUVNorm         
-{0x0F12, 0x0409},	 //70000B76	 //_yuviirnr_iHighUVNorm   [7:0] AFIT8_yuviirnr_iYNormShift       
-{0x0F12, 0x0306},	 //70000B78	 //_yuviirnr_iUVNormShift   [7:0] AFIT8_yuviirnr_iVertLength_Y    
-{0x0F12, 0x0407},	 //70000B7A	 //_yuviirnr_iVertLength_UV   [7:0] AFIT8_yuviirnr_iDiffThreshL_Y 
-{0x0F12, 0x2404},	 //70000B7C	 //_yuviirnr_iDiffThreshH_Y   [7:0] AFIT8_yuviirnr_iDiffThreshL_UV
-{0x0F12, 0x0221},	 //70000B7E	 //_yuviirnr_iDiffThreshH_UV   [7:0] AFIT8_yuviirnr_iMaxThreshL_Y 
-{0x0F12, 0x1202},	 //70000B80	 //_yuviirnr_iMaxThreshH_Y   [7:0] AFIT8_yuviirnr_iMaxThreshL_UV  
-{0x0F12, 0x0613},	 //70000B82	 //_yuviirnr_iMaxThreshH_UV   [7:0] AFIT8_yuviirnr_iYNRStrengthL  
-{0x0F12, 0x1A02},	 //70000B84	 //_yuviirnr_iYNRStrengthH   [7:0] AFIT8_yuviirnr_iUVNRStrengthL  
-{0x0F12, 0x8018},	 //70000B86	 //_yuviirnr_iUVNRStrengthH   [7:0] AFIT8_byr_gras_iShadingPower  
-{0x0F12, 0x0080},	 //70000B88	 //_RGBGamma2_iLinearity   [7:0] AFIT8_RGBGamma2_iDarkReduce      
-{0x0F12, 0x0080},	 //70000B8A	 //_ccm_oscar_iSaturation   [7:0] AFIT8_RGB2YUV_iYOffset //
-{0x0F12, 0x0180},	 //70000B8C	 //_RGB2YUV_iRGBGain   [7:0] AFIT8_bnr_nClustLevel_H   
-{0x0F12, 0x0A0A},	 //70000B8E	 //_bnr_iClustMulT_H   [7:0] AFIT8_bnr_iClustMulT_C    
-{0x0F12, 0x0101},	 //70000B90	 //_bnr_iClustThresh_H   [7:0] AFIT8_bnr_iClustThresh_C
-{0x0F12, 0x121B},	 //70000B92	 //_bnr_iDenThreshLow   [7:0] AFIT8_bnr_iDenThreshHigh 
-{0x0F12, 0x6024},	 //70000B94	 //_ee_iLowSharpPower   [7:0] AFIT8_ee_iHighSharpPower 
-{0x0F12, 0x0C0C},	 //70000B96	 //_ee_iLowShDenoise   [7:0] AFIT8_ee_iHighShDenoise   
-{0x0F12, 0xFFFF},	 //70000B98	 //_ee_iLowSharpClamp   [7:0] AFIT8_ee_iHighSharpClamp 
-{0x0F12, 0x0808},	 //70000B9A	 //_ee_iReduceEdgeMinMult   [7:0] AFIT8_ee_iReduceEdgeSlope       
-{0x0F12, 0x0A01},	 //70000B9C	 //_bnr_nClustLevel_H_Bin   [7:0] AFIT8_bnr_iClustMulT_H_Bin      
-{0x0F12, 0x010A},	 //70000B9E	 //_bnr_iClustMulT_C_Bin   [7:0] AFIT8_bnr_iClustThresh_H_Bin     
-{0x0F12, 0x0001},	 //70000BA0	 //_bnr_iClustThresh_C_Bin   [7:0] AFIT8_bnr_iDenThreshLow_Bin    
-{0x0F12, 0x2400},	 //70000BA2	 //_bnr_iDenThreshHigh_Bin   [7:0] AFIT8_ee_iLowSharpPower_Bin    
-{0x0F12, 0x0460},	 //70000BA4	 //_ee_iHighSharpPower_Bin   [7:0] AFIT8_ee_iLowShDenoise_Bin     
-{0x0F12, 0xFF04},	 //70000BA6	 //_ee_iHighShDenoise_Bin   [7:0] AFIT8_ee_iLowSharpClamp_Bin     
-{0x0F12, 0x40FF},	 //70000BA8	 //_ee_iHighSharpClamp_Bin   [7:0] AFIT8_ee_iReduceEdgeMinMult_Bin
-{0x0F12, 0x0009},	 //70000BAA	 //_ee_iReduceEdgeSlope_Bin [7:0]                      
-{0x0F12, 0x0001},	 //70000BAC	 //_bnr_nClustLevel_C      [0]                         
-{0x0F12, 0x0000},	 //70000BAE	 //_BRIGHTNESS	AFIT 3                                  
-{0x0F12, 0x0000},	 //70000BB0	 //_CONTRAST                                           
-{0x0F12, 0x0000},	 //70000BB2	 //_SATURATION                                         
-{0x0F12, 0x0000},	 //70000BB4	 //_SHARP_BLUR                                         
-{0x0F12, 0x0000},	 //70000BB6	 //_GLAMOUR                                            
-{0x0F12, 0x00C0},	 //70000BB8	 //_bnr_edge_high                                      
-{0x0F12, 0x0064},	 //70000BBA	 //_postdmsc_iLowBright                                
-{0x0F12, 0x0384},	 //70000BBC	 //_postdmsc_iHighBright                               
-{0x0F12, 0x0032},	 //70000BBE	 //_postdmsc_iLowSat                                   
-{0x0F12, 0x01F4},	 //70000BC0	 //_postdmsc_iHighSat                                  
-{0x0F12, 0x0070},	 //70000BC2	 //_postdmsc_iTune                                     
-{0x0F12, 0x0040},	 //70000BC4	 //_yuvemix_mNegRanges_0                               
-{0x0F12, 0x00A0},	 //70000BC6	 //_yuvemix_mNegRanges_1                               
-{0x0F12, 0x0100},	 //70000BC8	 //_yuvemix_mNegRanges_2                               
-{0x0F12, 0x0010},	 //70000BCA	 //_yuvemix_mPosRanges_0                               
-{0x0F12, 0x0060},	 //70000BCC	 //_yuvemix_mPosRanges_1                               
-{0x0F12, 0x0100},	 //70000BCE	 //_yuvemix_mPosRanges_2                               
-{0x0F12, 0x1430},	 //70000BD0	 //_bnr_edge_low  [7:0] AFIT8_bnr_repl_thresh          
-{0x0F12, 0x0201},	 //70000BD2	 //_bnr_repl_force  [7:0] AFIT8_bnr_iHotThreshHigh     
-{0x0F12, 0x0204},	 //70000BD4	 //_bnr_iHotThreshLow   [7:0] AFIT8_bnr_iColdThreshHigh
-{0x0F12, 0x1504},	 //70000BD6	 //_bnr_iColdThreshLow   [7:0] AFIT8_bnr_DispTH_Low    
-{0x0F12, 0x030F},	 //70000BD8	 //_bnr_DispTH_High   [7:0] AFIT8_bnr_DISP_Limit_Low   
-{0x0F12, 0x0003},	 //70000BDA	 //_bnr_DISP_Limit_High   [7:0] AFIT8_bnr_iDistSigmaMin
-{0x0F12, 0x0902},	 //70000BDC	 //_bnr_iDistSigmaMax   [7:0] AFIT8_bnr_iDiffSigmaLow  
-{0x0F12, 0x2004},	 //70000BDE	 //_bnr_iDiffSigmaHigh   [7:0] AFIT8_bnr_iNormalizedSTD_TH        
-{0x0F12, 0x0050},	 //70000BE0	 //_bnr_iNormalizedSTD_Limit   [7:0] AFIT8_bnr_iDirNRTune         
-{0x0F12, 0x1140},	 //70000BE2	 //_bnr_iDirMinThres   [7:0] AFIT8_bnr_iDirFltDiffThresHigh       
-{0x0F12, 0x201C},	 //70000BE4	 //_bnr_iDirFltDiffThresLow   [7:0] AFIT8_bnr_iDirSmoothPowerHigh 
-{0x0F12, 0x0620},	 //70000BE6	 //_bnr_iDirSmoothPowerLow   [7:0] AFIT8_bnr_iLowMaxSlopeAllowed  
-{0x0F12, 0x0306},	 //70000BE8	 //_bnr_iHighMaxSlopeAllowed   [7:0] AFIT8_bnr_iLowSlopeThresh    
-{0x0F12, 0x2003},	 //70000BEA	 //_bnr_iHighSlopeThresh   [7:0] AFIT8_bnr_iSlopenessTH
-{0x0F12, 0xFF01},	 //70000BEC	 //_bnr_iSlopeBlurStrength   [7:0] AFIT8_bnr_iSlopenessLimit      
-{0x0F12, 0x0404},	 //70000BEE	 //_bnr_AddNoisePower1   [7:0] AFIT8_bnr_AddNoisePower2
-{0x0F12, 0x0300},	 //70000BF0	 //_bnr_iRadialTune   [7:0] AFIT8_bnr_iRadialPower     
-{0x0F12, 0x145A},	 //70000BF2	 //_bnr_iRadialLimit   [7:0] AFIT8_ee_iFSMagThLow      
-{0x0F12, 0x1010},	 //70000BF4	 //_ee_iFSMagThHigh   [7:0] AFIT8_ee_iFSVarThLow       
-{0x0F12, 0x000B},	 //70000BF6	 //_ee_iFSVarThHigh   [7:0] AFIT8_ee_iFSThLow          
-{0x0F12, 0x1000},	 //70000BF8	 //_ee_iFSThHigh   [7:0] AFIT8_ee_iFSmagPower          
-{0x0F12, 0x5A0F},	 //70000BFA	 //_ee_iFSVarCountTh   [7:0] AFIT8_ee_iRadialLimit     
-{0x0F12, 0x0503},	 //70000BFC	 //_ee_iRadialPower   [7:0] AFIT8_ee_iSmoothEdgeSlope  
-{0x0F12, 0x1802},	 //70000BFE	 //_ee_iROADThres   [7:0] AFIT8_ee_iROADMaxNR          
-{0x0F12, 0x0000},	 //70000C00	 //_ee_iROADSubMaxNR   [7:0] AFIT8_ee_iROADSubThres    
-{0x0F12, 0x2006},	 //70000C02	 //_ee_iROADNeiThres   [7:0] AFIT8_ee_iROADNeiMaxNR    
-{0x0F12, 0x3C28},	 //70000C04	 //_ee_iSmoothEdgeThres   [7:0] AFIT8_ee_iMSharpen     
-{0x0F12, 0x042C},	 //70000C06	 //_ee_iWSharpen   [7:0] AFIT8_ee_iMShThresh           
-{0x0F12, 0x0101},	 //70000C08	 //_ee_iWShThresh   [7:0] AFIT8_ee_iReduceNegative     
-{0x0F12, 0xFF00},	 //70000C0A	 //_ee_iEmbossCentAdd   [7:0] AFIT8_ee_iShDespeckle    
-{0x0F12, 0x0904},	 //70000C0C	 //_ee_iReduceEdgeThresh   [7:0] AFIT8_dmsc_iEnhThresh 
-{0x0F12, 0x4008},	 //70000C0E	 //_dmsc_iDesatThresh   [7:0] AFIT8_dmsc_iDemBlurHigh  
-{0x0F12, 0x0540},	 //70000C10	 //_dmsc_iDemBlurLow   [7:0] AFIT8_dmsc_iDemBlurRange  
-{0x0F12, 0x8006},	 //70000C12	 //_dmsc_iDecisionThresh   [7:0] AFIT8_dmsc_iCentGrad  
-{0x0F12, 0x0020},	 //70000C14	 //_dmsc_iMonochrom   [7:0] AFIT8_dmsc_iGBDenoiseVal   
-{0x0F12, 0x0000},	 //70000C16	 //_dmsc_iGRDenoiseVal   [7:0] AFIT8_dmsc_iEdgeDesatThrHigh       
-{0x0F12, 0x2000},	 //70000C18	 //_dmsc_iEdgeDesatThrLow   [7:0] AFIT8_dmsc_iEdgeDesat
-{0x0F12, 0x0000},	 //70000C1A	 //_dmsc_iNearGrayDesat   [7:0] AFIT8_dmsc_iEdgeDesatLimit        
-{0x0F12, 0x1E10},	 //70000C1C	 //_postdmsc_iBCoeff   [7:0] AFIT8_postdmsc_iGCoeff    
-{0x0F12, 0x000B},	 //70000C1E	 //_postdmsc_iWideMult   [7:0] AFIT8_yuvemix_mNegSlopes_0         
-{0x0F12, 0x0607},	 //70000C20	 //_yuvemix_mNegSlopes_1   [7:0] AFIT8_yuvemix_mNegSlopes_2       
-{0x0F12, 0x0005},	 //70000C22	 //_yuvemix_mNegSlopes_3   [7:0] AFIT8_yuvemix_mPosSlopes_0       
-{0x0F12, 0x0607},	 //70000C24	 //_yuvemix_mPosSlopes_1   [7:0] AFIT8_yuvemix_mPosSlopes_2       
-{0x0F12, 0x0405},	 //70000C26	 //_yuvemix_mPosSlopes_3   [7:0] AFIT8_yuviirnr_iXSupportY        
-{0x0F12, 0x0206},	 //70000C28	 //_yuviirnr_iXSupportUV   [7:0] AFIT8_yuviirnr_iLowYNorm         
-{0x0F12, 0x0304},	 //70000C2A	 //_yuviirnr_iHighYNorm   [7:0] AFIT8_yuviirnr_iLowUVNorm         
-{0x0F12, 0x0409},	 //70000C2C	 //_yuviirnr_iHighUVNorm   [7:0] AFIT8_yuviirnr_iYNormShift       
-{0x0F12, 0x0305},	 //70000C2E	 //_yuviirnr_iUVNormShift   [7:0] AFIT8_yuviirnr_iVertLength_Y    
-{0x0F12, 0x0406},	 //70000C30	 //_yuviirnr_iVertLength_UV   [7:0] AFIT8_yuviirnr_iDiffThreshL_Y 
-{0x0F12, 0x2804},	 //70000C32	 //_yuviirnr_iDiffThreshH_Y   [7:0] AFIT8_yuviirnr_iDiffThreshL_UV
-{0x0F12, 0x0228},	 //70000C34	 //_yuviirnr_iDiffThreshH_UV   [7:0] AFIT8_yuviirnr_iMaxThreshL_Y 
-{0x0F12, 0x1402},	 //70000C36	 //_yuviirnr_iMaxThreshH_Y   [7:0] AFIT8_yuviirnr_iMaxThreshL_UV  
-{0x0F12, 0x0618},	 //70000C38	 //_yuviirnr_iMaxThreshH_UV   [7:0] AFIT8_yuviirnr_iYNRStrengthL  
-{0x0F12, 0x1A02},	 //70000C3A	 //_yuviirnr_iYNRStrengthH   [7:0] AFIT8_yuviirnr_iUVNRStrengthL  
-{0x0F12, 0x8018},	 //70000C3C	 //_yuviirnr_iUVNRStrengthH   [7:0] AFIT8_byr_gras_iShadingPower  
-{0x0F12, 0x0080},	 //70000C3E	 //_RGBGamma2_iLinearity   [7:0] AFIT8_RGBGamma2_iDarkReduce      
-{0x0F12, 0x0080},	 //70000C40	 //_ccm_oscar_iSaturation   [7:0] AFIT8_RGB2YUV_iYOffset //
-{0x0F12, 0x0180},	 //70000C42	 //_RGB2YUV_iRGBGain   [7:0] AFIT8_bnr_nClustLevel_H   
-{0x0F12, 0x0A0A},	 //70000C44	 //_bnr_iClustMulT_H   [7:0] AFIT8_bnr_iClustMulT_C    
-{0x0F12, 0x0101},	 //70000C46	 //_bnr_iClustThresh_H   [7:0] AFIT8_bnr_iClustThresh_C
-{0x0F12, 0x0F15},	 //70000C48	 //_bnr_iDenThreshLow   [7:0] AFIT8_bnr_iDenThreshHigh 
-{0x0F12, 0x6024},	 //70000C4A	 //_ee_iLowSharpPower   [7:0] AFIT8_ee_iHighSharpPower 
-{0x0F12, 0x0A0A},	 //70000C4C	 //_ee_iLowShDenoise   [7:0] AFIT8_ee_iHighShDenoise   
-{0x0F12, 0xFFFF},	 //70000C4E	 //_ee_iLowSharpClamp   [7:0] AFIT8_ee_iHighSharpClamp 
-{0x0F12, 0x0808},	 //70000C50	 //_ee_iReduceEdgeMinMult   [7:0] AFIT8_ee_iReduceEdgeSlope       
-{0x0F12, 0x0A01},	 //70000C52	 //_bnr_nClustLevel_H_Bin   [7:0] AFIT8_bnr_iClustMulT_H_Bin      
-{0x0F12, 0x010A},	 //70000C54	 //_bnr_iClustMulT_C_Bin   [7:0] AFIT8_bnr_iClustThresh_H_Bin     
-{0x0F12, 0x0001},	 //70000C56	 //_bnr_iClustThresh_C_Bin   [7:0] AFIT8_bnr_iDenThreshLow_Bin    
-{0x0F12, 0x2400},	 //70000C58	 //_bnr_iDenThreshHigh_Bin   [7:0] AFIT8_ee_iLowSharpPower_Bin    
-{0x0F12, 0x0260},	 //70000C5A	 //_ee_iHighSharpPower_Bin   [7:0] AFIT8_ee_iLowShDenoise_Bin     
-{0x0F12, 0xFF02},	 //70000C5C	 //_ee_iHighShDenoise_Bin   [7:0] AFIT8_ee_iLowSharpClamp_Bin     
-{0x0F12, 0x40FF},	 //70000C5E	 //_ee_iHighSharpClamp_Bin   [7:0] AFIT8_ee_iReduceEdgeMinMult_Bin
-{0x0F12, 0x0009},	 //70000C60	 //_ee_iReduceEdgeSlope_Bin [7:0]                      
-{0x0F12, 0x0001},	 //70000C62	 //_bnr_nClustLevel_C      [0]                         
-{0x0F12, 0x0000},	 //70000C64	 //_BRIGHTNESS	AFIT 4                                  
-{0x0F12, 0x0000},	 //70000C66	 //_CONTRAST                                           
-{0x0F12, 0x0000},	 //70000C68	 //_SATURATION                                         
-{0x0F12, 0x0000},	 //70000C6A	 //_SHARP_BLUR                                         
-{0x0F12, 0x0000},	 //70000C6C	 //_GLAMOUR                                            
-{0x0F12, 0x00C0},	 //70000C6E	 //_bnr_edge_high                                      
-{0x0F12, 0x0064},	 //70000C70	 //_postdmsc_iLowBright                                
-{0x0F12, 0x0384},	 //70000C72	 //_postdmsc_iHighBright                               
-{0x0F12, 0x0032},	 //70000C74	 //_postdmsc_iLowSat                                   
-{0x0F12, 0x01F4},	 //70000C76	 //_postdmsc_iHighSat                                  
-{0x0F12, 0x0070},	 //70000C78	 //_postdmsc_iTune                                     
-{0x0F12, 0x0040},	 //70000C7A	 //_yuvemix_mNegRanges_0                               
-{0x0F12, 0x00A0},	 //70000C7C	 //_yuvemix_mNegRanges_1                               
-{0x0F12, 0x0100},	 //70000C7E	 //_yuvemix_mNegRanges_2                               
-{0x0F12, 0x0010},	 //70000C80	 //_yuvemix_mPosRanges_0                               
-{0x0F12, 0x0060},	 //70000C82	 //_yuvemix_mPosRanges_1                               
-{0x0F12, 0x0100},	 //70000C84	 //_yuvemix_mPosRanges_2                               
-{0x0F12, 0x1430},	 //70000C86	 //_bnr_edge_low  [7:0] AFIT8_bnr_repl_thresh          
-{0x0F12, 0x0201},	 //70000C88	 //_bnr_repl_force  [7:0] AFIT8_bnr_iHotThreshHigh     
-{0x0F12, 0x0204},	 //70000C8A	 //_bnr_iHotThreshLow   [7:0] AFIT8_bnr_iColdThreshHigh
-{0x0F12, 0x0F04},	 //70000C8C	 //_bnr_iColdThreshLow   [7:0] AFIT8_bnr_DispTH_Low    
-{0x0F12, 0x030C},	 //70000C8E	 //_bnr_DispTH_High   [7:0] AFIT8_bnr_DISP_Limit_Low   
-{0x0F12, 0x0003},	 //70000C90	 //_bnr_DISP_Limit_High   [7:0] AFIT8_bnr_iDistSigmaMin
-{0x0F12, 0x0602},	 //70000C92	 //_bnr_iDistSigmaMax   [7:0] AFIT8_bnr_iDiffSigmaLow  
-{0x0F12, 0x1803},	 //70000C94	 //_bnr_iDiffSigmaHigh   [7:0] AFIT8_bnr_iNormalizedSTD_TH        
-{0x0F12, 0x0040},	 //70000C96	 //_bnr_iNormalizedSTD_Limit   [7:0] AFIT8_bnr_iDirNRTune         
-{0x0F12, 0x0E20},	 //70000C98	 //_bnr_iDirMinThres   [7:0] AFIT8_bnr_iDirFltDiffThresHigh       
-{0x0F12, 0x2018},	 //70000C9A	 //_bnr_iDirFltDiffThresLow   [7:0] AFIT8_bnr_iDirSmoothPowerHigh 
-{0x0F12, 0x0620},	 //70000C9C	 //_bnr_iDirSmoothPowerLow   [7:0] AFIT8_bnr_iLowMaxSlopeAllowed  
-{0x0F12, 0x0306},	 //70000C9E	 //_bnr_iHighMaxSlopeAllowed   [7:0] AFIT8_bnr_iLowSlopeThresh    
-{0x0F12, 0x2003},	 //70000CA0	 //_bnr_iHighSlopeThresh   [7:0] AFIT8_bnr_iSlopenessTH
-{0x0F12, 0xFF01},	 //70000CA2	 //_bnr_iSlopeBlurStrength   [7:0] AFIT8_bnr_iSlopenessLimit      
-{0x0F12, 0x0404},	 //70000CA4	 //_bnr_AddNoisePower1   [7:0] AFIT8_bnr_AddNoisePower2
-{0x0F12, 0x0200},	 //70000CA6	 //_bnr_iRadialTune   [7:0] AFIT8_bnr_iRadialPower     
-{0x0F12, 0x145A},	 //70000CA8	 //_bnr_iRadialLimit   [7:0] AFIT8_ee_iFSMagThLow      
-{0x0F12, 0x1010},	 //70000CAA	 //_ee_iFSMagThHigh   [7:0] AFIT8_ee_iFSVarThLow       
-{0x0F12, 0x000B},	 //70000CAC	 //_ee_iFSVarThHigh   [7:0] AFIT8_ee_iFSThLow          
-{0x0F12, 0x1200},	 //70000CAE	 //_ee_iFSThHigh   [7:0] AFIT8_ee_iFSmagPower          
-{0x0F12, 0x5A0F},	 //70000CB0	 //_ee_iFSVarCountTh   [7:0] AFIT8_ee_iRadialLimit     
-{0x0F12, 0x0502},	 //70000CB2	 //_ee_iRadialPower   [7:0] AFIT8_ee_iSmoothEdgeSlope  
-{0x0F12, 0x1802},	 //70000CB4	 //_ee_iROADThres   [7:0] AFIT8_ee_iROADMaxNR          
-{0x0F12, 0x0000},	 //70000CB6	 //_ee_iROADSubMaxNR   [7:0] AFIT8_ee_iROADSubThres    
-{0x0F12, 0x2006},	 //70000CB8	 //_ee_iROADNeiThres   [7:0] AFIT8_ee_iROADNeiMaxNR    
-{0x0F12, 0x4028},	 //70000CBA	 //_ee_iSmoothEdgeThres   [7:0] AFIT8_ee_iMSharpen     
-{0x0F12, 0x0430},	 //70000CBC	 //_ee_iWSharpen   [7:0] AFIT8_ee_iMShThresh           
-{0x0F12, 0x0101},	 //70000CBE	 //_ee_iWShThresh   [7:0] AFIT8_ee_iReduceNegative     
-{0x0F12, 0xFF00},	 //70000CC0	 //_ee_iEmbossCentAdd   [7:0] AFIT8_ee_iShDespeckle    
-{0x0F12, 0x0804},	 //70000CC2	 //_ee_iReduceEdgeThresh   [7:0] AFIT8_dmsc_iEnhThresh 
-{0x0F12, 0x4008},	 //70000CC4	 //_dmsc_iDesatThresh   [7:0] AFIT8_dmsc_iDemBlurHigh  
-{0x0F12, 0x0540},	 //70000CC6	 //_dmsc_iDemBlurLow   [7:0] AFIT8_dmsc_iDemBlurRange  
-{0x0F12, 0x8006},	 //70000CC8	 //_dmsc_iDecisionThresh   [7:0] AFIT8_dmsc_iCentGrad  
-{0x0F12, 0x0020},	 //70000CCA	 //_dmsc_iMonochrom   [7:0] AFIT8_dmsc_iGBDenoiseVal   
-{0x0F12, 0x0000},	 //70000CCC	 //_dmsc_iGRDenoiseVal   [7:0] AFIT8_dmsc_iEdgeDesatThrHigh       
-{0x0F12, 0x2000},	 //70000CCE	 //_dmsc_iEdgeDesatThrLow   [7:0] AFIT8_dmsc_iEdgeDesat
-{0x0F12, 0x0000},	 //70000CD0	 //_dmsc_iNearGrayDesat   [7:0] AFIT8_dmsc_iEdgeDesatLimit        
-{0x0F12, 0x1E10},	 //70000CD2	 //_postdmsc_iBCoeff   [7:0] AFIT8_postdmsc_iGCoeff    
-{0x0F12, 0x000B},	 //70000CD4	 //_postdmsc_iWideMult   [7:0] AFIT8_yuvemix_mNegSlopes_0         
-{0x0F12, 0x0607},	 //70000CD6	 //_yuvemix_mNegSlopes_1   [7:0] AFIT8_yuvemix_mNegSlopes_2       
-{0x0F12, 0x0005},	 //70000CD8	 //_yuvemix_mNegSlopes_3   [7:0] AFIT8_yuvemix_mPosSlopes_0       
-{0x0F12, 0x0607},	 //70000CDA	 //_yuvemix_mPosSlopes_1   [7:0] AFIT8_yuvemix_mPosSlopes_2       
-{0x0F12, 0x0405},	 //70000CDC	 //_yuvemix_mPosSlopes_3   [7:0] AFIT8_yuviirnr_iXSupportY        
-{0x0F12, 0x0205},	 //70000CDE	 //_yuviirnr_iXSupportUV   [7:0] AFIT8_yuviirnr_iLowYNorm         
-{0x0F12, 0x0304},	 //70000CE0	 //_yuviirnr_iHighYNorm   [7:0] AFIT8_yuviirnr_iLowUVNorm         
-{0x0F12, 0x0409},	 //70000CE2	 //_yuviirnr_iHighUVNorm   [7:0] AFIT8_yuviirnr_iYNormShift       
-{0x0F12, 0x0306},	 //70000CE4	 //_yuviirnr_iUVNormShift   [7:0] AFIT8_yuviirnr_iVertLength_Y    
-{0x0F12, 0x0407},	 //70000CE6	 //_yuviirnr_iVertLength_UV   [7:0] AFIT8_yuviirnr_iDiffThreshL_Y 
-{0x0F12, 0x2C04},	 //70000CE8	 //_yuviirnr_iDiffThreshH_Y   [7:0] AFIT8_yuviirnr_iDiffThreshL_UV
-{0x0F12, 0x022C},	 //70000CEA	 //_yuviirnr_iDiffThreshH_UV   [7:0] AFIT8_yuviirnr_iMaxThreshL_Y 
-{0x0F12, 0x1402},	 //70000CEC	 //_yuviirnr_iMaxThreshH_Y   [7:0] AFIT8_yuviirnr_iMaxThreshL_UV  
-{0x0F12, 0x0618},	 //70000CEE	 //_yuviirnr_iMaxThreshH_UV   [7:0] AFIT8_yuviirnr_iYNRStrengthL  
-{0x0F12, 0x1A02},	 //70000CF0	 //_yuviirnr_iYNRStrengthH   [7:0] AFIT8_yuviirnr_iUVNRStrengthL  
-{0x0F12, 0x8018},	 //70000CF2	 //_yuviirnr_iUVNRStrengthH   [7:0] AFIT8_byr_gras_iShadingPower  
-{0x0F12, 0x0080},	 //70000CF4	 //_RGBGamma2_iLinearity   [7:0] AFIT8_RGBGamma2_iDarkReduce      
-{0x0F12, 0x0080},	 //70000CF6	 //_ccm_oscar_iSaturation   [7:0] AFIT8_RGB2YUV_iYOffset //
-{0x0F12, 0x0180},	 //70000CF8	 //_RGB2YUV_iRGBGain   [7:0] AFIT8_bnr_nClustLevel_H   
-{0x0F12, 0x0A0A},	 //70000CFA	 //_bnr_iClustMulT_H   [7:0] AFIT8_bnr_iClustMulT_C    
-{0x0F12, 0x0101},	 //70000CFC	 //_bnr_iClustThresh_H   [7:0] AFIT8_bnr_iClustThresh_C
-{0x0F12, 0x0C0F},	 //70000CFE	 //_bnr_iDenThreshLow   [7:0] AFIT8_bnr_iDenThreshHigh 
-{0x0F12, 0x6024},	 //70000D00	 //_ee_iLowSharpPower   [7:0] AFIT8_ee_iHighSharpPower 
-{0x0F12, 0x0808},	 //70000D02	 //_ee_iLowShDenoise   [7:0] AFIT8_ee_iHighShDenoise   
-{0x0F12, 0xFFFF},	 //70000D04	 //_ee_iLowSharpClamp   [7:0] AFIT8_ee_iHighSharpClamp 
-{0x0F12, 0x0808},	 //70000D06	 //_ee_iReduceEdgeMinMult   [7:0] AFIT8_ee_iReduceEdgeSlope       
-{0x0F12, 0x0A01},	 //70000D08	 //_bnr_nClustLevel_H_Bin   [7:0] AFIT8_bnr_iClustMulT_H_Bin      
-{0x0F12, 0x010A},	 //70000D0A	 //_bnr_iClustMulT_C_Bin   [7:0] AFIT8_bnr_iClustThresh_H_Bin     
-{0x0F12, 0x0001},	 //70000D0C	 //_bnr_iClustThresh_C_Bin   [7:0] AFIT8_bnr_iDenThreshLow_Bin    
-{0x0F12, 0x2400},	 //70000D0E	 //_bnr_iDenThreshHigh_Bin   [7:0] AFIT8_ee_iLowSharpPower_Bin    
-{0x0F12, 0x0060},	 //70000D10	 //_ee_iHighSharpPower_Bin   [7:0] AFIT8_ee_iLowShDenoise_Bin     
-{0x0F12, 0xFF00},	 //70000D12	 //_ee_iHighShDenoise_Bin   [7:0] AFIT8_ee_iLowSharpClamp_Bin     
-{0x0F12, 0x40FF},	 //70000D14	 //_ee_iHighSharpClamp_Bin   [7:0] AFIT8_ee_iReduceEdgeMinMult_Bin
-{0x0F12, 0x0009},	 //70000D16	 //_ee_iReduceEdgeSlope_Bin [7:0]							        
-{0x0F12, 0x0001},	 //70000D18	 //_bnr_nClustLevel_C      [0]   bWideWide[1]  
-     
-{0x0F12, 0x23CE},	 //70000D1A	 //[0]CAFITB_bnr_bypass                                
-{0x0F12, 0xFDC8},	 //70000D1C	 //[0]CAFITB_bnr_bSlopenessTune                        
-{0x0F12, 0x112E},	 //70000D1E	 //[0]CAFITB_ee_bReduceNegMedSh                        
-{0x0F12, 0x93A5},	 //70000D20	 //[0]CAFITB_dmsc_bDoDesat                             
-{0x0F12, 0xFE67},	 //70000D22	 //[0]CAFITB_postdmsc_bSat                             
-{0x0F12, 0x0000},	 //70000D24	 //[0]CAFITB_yuviirnr_bWideY	
+{0x002A,0x0944},
+{0x0F12,0x0050},	// afit_uNoiseIndInDoor
+{0x0F12,0x00B0},	// afit_uNoiseIndInDoor
+{0x0F12,0x0196},	// afit_uNoiseIndInDoor
+{0x0F12,0x0245},	// afit_uNoiseIndInDoor
+{0x0F12,0x0300},	// afit_uNoiseIndInDoor
+{0x002A,0x0938},
+{0x0F12,0x0000},	//  on/off AFIT by NB option
+{0x0F12,0x0014},	// SARR_uNormBrInDoor
+{0x0F12,0x00D2},	// SARR_uNormBrInDoor
+{0x0F12,0x0384},	// SARR_uNormBrInDoor
+{0x0F12,0x07D0},	// SARR_uNormBrInDoor
+{0x0F12,0x1388},	// SARR_uNormBrInDoor
+{0x002A,0x0976},
+{0x0F12,0x0070},	// afit_usGamutTh
+{0x0F12,0x0005},	// afit_usNeargrayOffset
+{0x0F12,0x0000},	// afit_bUseSenBpr
+{0x0F12,0x01CC},	// afit_usBprThr_0_
+{0x0F12,0x01CC},	// afit_usBprThr_1_
+{0x0F12,0x01CC},	// afit_usBprThr_2_
+{0x0F12,0x01CC},	// afit_usBprThr_3_
+{0x0F12,0x01CC},	// afit_usBprThr_4_
+{0x0F12,0x0180},	// afit_NIContrastAFITValue
+{0x0F12,0x0196},	// afit_NIContrastTh
+{0x002A,0x098C},
+{0x0F12,0x0000},	// 7000098C//AFIT16_BRIGHTNESS
+{0x0F12,0xFFE0},	// 7000098E//AFIT16_CONTRAST
+{0x0F12,0x0000},	// 70000990//AFIT16_SATURATION
+{0x0F12,0xFFC6},	// 70000992//AFIT16_SHARP_BLUR
+{0x0F12,0x0000},	// 70000994//AFIT16_GLAMOUR
+{0x0F12,0x00C0},	// 70000996//AFIT16_bnr_edge_high
+{0x0F12,0x0064},	// 70000998//AFIT16_postdmsc_iLowBright
+{0x0F12,0x0384},	// 7000099A//AFIT16_postdmsc_iHighBright
+{0x0F12,0x005F},	// 7000099C//AFIT16_postdmsc_iLowSat
+{0x0F12,0x01F4},	// 7000099E//AFIT16_postdmsc_iHighSat
+{0x0F12,0x0070},	// 700009A0//AFIT16_postdmsc_iTune
+{0x0F12,0x0040},	// 700009A2//AFIT16_yuvemix_mNegRanges_0
+{0x0F12,0x00A0},	// 700009A4//AFIT16_yuvemix_mNegRanges_1
+{0x0F12,0x0100},	// 700009A6//AFIT16_yuvemix_mNegRanges_2
+{0x0F12,0x0010},	// 700009A8//AFIT16_yuvemix_mPosRanges_0
+{0x0F12,0x0040},	// 700009AA//AFIT16_yuvemix_mPosRanges_1
+{0x0F12,0x00A0},	// 700009AC//AFIT16_yuvemix_mPosRanges_2
+{0x0F12,0x1430},	// 700009AE//AFIT8_bnr_edge_low  [7:0] AFIT8_bnr_repl_thresh
+{0x0F12,0x0201},	// 700009B0//AFIT8_bnr_repl_force  [7:0] AFIT8_bnr_iHotThreshHigh
+{0x0F12,0x0204},	// 700009B2//AFIT8_bnr_iHotThreshLow   [7:0] AFIT8_bnr_iColdThreshHigh
+{0x0F12,0x3604},	// 700009B4//AFIT8_bnr_iColdThreshLow   [7:0] AFIT8_bnr_DispTH_Low
+{0x0F12,0x032A},	// 700009B6//AFIT8_bnr_DispTH_High   [7:0] AFIT8_bnr_DISP_Limit_Low
+{0x0F12,0x0403},	// 700009B8//AFIT8_bnr_DISP_Limit_High   [7:0] AFIT8_bnr_iDistSigmaMin
+{0x0F12,0x1B06},	// 700009BA//AFIT8_bnr_iDistSigmaMax   [7:0] AFIT8_bnr_iDiffSigmaLow
+{0x0F12,0x6015},	// 700009BC//AFIT8_bnr_iDiffSigmaHigh   [7:0] AFIT8_bnr_iNormalizedSTD_TH
+{0x0F12,0x00C0},	// 700009BE//AFIT8_bnr_iNormalizedSTD_Limit   [7:0] AFIT8_bnr_iDirNRTune
+{0x0F12,0x6080},	// 700009C0//AFIT8_bnr_iDirMinThres   [7:0] AFIT8_bnr_iDirFltDiffThresHigh
+{0x0F12,0x4080},	// 700009C2//AFIT8_bnr_iDirFltDiffThresLow   [7:0] AFIT8_bnr_iDirSmoothPowerHigh
+{0x0F12,0x0640},	// 700009C4//AFIT8_bnr_iDirSmoothPowerLow   [7:0] AFIT8_bnr_iLowMaxSlopeAllowed
+{0x0F12,0x0306},	// 700009C6//AFIT8_bnr_iHighMaxSlopeAllowed   [7:0] AFIT8_bnr_iLowSlopeThresh
+{0x0F12,0x2003},	// 700009C8//AFIT8_bnr_iHighSlopeThresh   [7:0] AFIT8_bnr_iSlopenessTH
+{0x0F12,0xFF01},	// 700009CA//AFIT8_bnr_iSlopeBlurStrength   [7:0] AFIT8_bnr_iSlopenessLimit
+{0x0F12,0x0000},	// 700009CC//AFIT8_bnr_AddNoisePower1   [7:0] AFIT8_bnr_AddNoisePower2
+{0x0F12,0x0400},	// 700009CE//AFIT8_bnr_iRadialTune   [7:0] AFIT8_bnr_iRadialPower
+{0x0F12,0x365A},	// 700009D0//AFIT8_bnr_iRadialLimit   [7:0] AFIT8_ee_iFSMagThLow
+{0x0F12,0x102A},	// 700009D2//AFIT8_ee_iFSMagThHigh   [7:0] AFIT8_ee_iFSVarThLow
+{0x0F12,0x000B},	// 700009D4//AFIT8_ee_iFSVarThHigh   [7:0] AFIT8_ee_iFSThLow
+{0x0F12,0x0600},	// 700009D6//AFIT8_ee_iFSThHigh   [7:0] AFIT8_ee_iFSmagPower
+{0x0F12,0x5A0F},	// 700009D8//AFIT8_ee_iFSVarCountTh   [7:0] AFIT8_ee_iRadialLimit
+{0x0F12,0x0505},	// 700009DA//AFIT8_ee_iRadialPower   [7:0] AFIT8_ee_iSmoothEdgeSlope
+{0x0F12,0x1802},	// 700009DC//AFIT8_ee_iROADThres   [7:0] AFIT8_ee_iROADMaxNR
+{0x0F12,0x0000},	// 700009DE//AFIT8_ee_iROADSubMaxNR   [7:0] AFIT8_ee_iROADSubThres
+{0x0F12,0x2006},	// 700009E0//AFIT8_ee_iROADNeiThres   [7:0] AFIT8_ee_iROADNeiMaxNR
+{0x0F12,0x3028},	// 700009E2//AFIT8_ee_iSmoothEdgeThres   [7:0] AFIT8_ee_iMSharpen
+{0x0F12,0x0418},	// 700009E4//AFIT8_ee_iWSharpen   [7:0] AFIT8_ee_iMShThresh
+{0x0F12,0x0101},	// 700009E6//AFIT8_ee_iWShThresh   [7:0] AFIT8_ee_iReduceNegative
+{0x0F12,0x0800},	// 700009E8//AFIT8_ee_iEmbossCentAdd   [7:0] AFIT8_ee_iShDespeckle
+{0x0F12,0x1804},	// 700009EA//AFIT8_ee_iReduceEdgeThresh   [7:0] AFIT8_dmsc_iEnhThresh
+{0x0F12,0x4008},	// 700009EC//AFIT8_dmsc_iDesatThresh   [7:0] AFIT8_dmsc_iDemBlurHigh
+{0x0F12,0x0540},	// 700009EE//AFIT8_dmsc_iDemBlurLow   [7:0] AFIT8_dmsc_iDemBlurRange
+{0x0F12,0x8006},	// 700009F0//AFIT8_dmsc_iDecisionThresh   [7:0] AFIT8_dmsc_iCentGrad
+{0x0F12,0x0020},	// 700009F2//AFIT8_dmsc_iMonochrom   [7:0] AFIT8_dmsc_iGBDenoiseVal
+{0x0F12,0x0000},	// 700009F4//AFIT8_dmsc_iGRDenoiseVal   [7:0] AFIT8_dmsc_iEdgeDesatThrHigh
+{0x0F12,0x1800},	// 700009F6//AFIT8_dmsc_iEdgeDesatThrLow   [7:0] AFIT8_dmsc_iEdgeDesat
+{0x0F12,0x0000},	// 700009F8//AFIT8_dmsc_iNearGrayDesat   [7:0] AFIT8_dmsc_iEdgeDesatLimit
+{0x0F12,0x1E10},	// 700009FA//AFIT8_postdmsc_iBCoeff   [7:0] AFIT8_postdmsc_iGCoeff
+{0x0F12,0x000B},	// 700009FC//AFIT8_postdmsc_iWideMult   [7:0] AFIT8_yuvemix_mNegSlopes_0
+{0x0F12,0x0607},	// 700009FE//AFIT8_yuvemix_mNegSlopes_1   [7:0] AFIT8_yuvemix_mNegSlopes_2
+{0x0F12,0x0005},	// 70000A00//AFIT8_yuvemix_mNegSlopes_3   [7:0] AFIT8_yuvemix_mPosSlopes_0
+{0x0F12,0x0607},	// 70000A02//AFIT8_yuvemix_mPosSlopes_1   [7:0] AFIT8_yuvemix_mPosSlopes_2
+{0x0F12,0x0405},	// 70000A04//AFIT8_yuvemix_mPosSlopes_3   [7:0] AFIT8_yuviirnr_iXSupportY
+{0x0F12,0x0205},	// 70000A06//AFIT8_yuviirnr_iXSupportUV   [7:0] AFIT8_yuviirnr_iLowYNorm
+{0x0F12,0x0304},	// 70000A08//AFIT8_yuviirnr_iHighYNorm   [7:0] AFIT8_yuviirnr_iLowUVNorm
+{0x0F12,0x0409},	// 70000A0A//AFIT8_yuviirnr_iHighUVNorm   [7:0] AFIT8_yuviirnr_iYNormShift
+{0x0F12,0x0306},	// 70000A0C//AFIT8_yuviirnr_iUVNormShift   [7:0] AFIT8_yuviirnr_iVertLength_Y
+{0x0F12,0x0407},	// 70000A0E//AFIT8_yuviirnr_iVertLength_UV   [7:0] AFIT8_yuviirnr_iDiffThreshL_Y
+{0x0F12,0x1C04},	// 70000A10//AFIT8_yuviirnr_iDiffThreshH_Y   [7:0] AFIT8_yuviirnr_iDiffThreshL_UV
+{0x0F12,0x0214},	// 70000A12//AFIT8_yuviirnr_iDiffThreshH_UV   [7:0] AFIT8_yuviirnr_iMaxThreshL_Y
+{0x0F12,0x1002},	// 70000A14//AFIT8_yuviirnr_iMaxThreshH_Y   [7:0] AFIT8_yuviirnr_iMaxThreshL_UV
+{0x0F12,0x0610},	// 70000A16//AFIT8_yuviirnr_iMaxThreshH_UV   [7:0] AFIT8_yuviirnr_iYNRStrengthL
+{0x0F12,0x1A02},	// 70000A18//AFIT8_yuviirnr_iYNRStrengthH   [7:0] AFIT8_yuviirnr_iUVNRStrengthL
+{0x0F12,0x4A18},	// 70000A1A//AFIT8_yuviirnr_iUVNRStrengthH   [7:0] AFIT8_byr_gras_iShadingPower
+{0x0F12,0x0080},	// 70000A1C//AFIT8_RGBGamma2_iLinearity   [7:0] AFIT8_RGBGamma2_iDarkReduce
+{0x0F12,0x0348},	// 70000A1E//AFIT8_ccm_oscar_iSaturation   [7:0] AFIT8_RGB2YUV_iYOffset
+{0x0F12,0x0180},	// 70000A20//AFIT8_RGB2YUV_iRGBGain   [7:0] AFIT8_bnr_nClustLevel_H
+{0x0F12,0x0A0A},	// 70000A22//AFIT8_bnr_iClustMulT_H   [7:0] AFIT8_bnr_iClustMulT_C
+{0x0F12,0x0101},	// 70000A24//AFIT8_bnr_iClustThresh_H   [7:0] AFIT8_bnr_iClustThresh_C
+{0x0F12,0x2A78},	// 70000A26//AFIT8_bnr_iDenThreshLow   [7:0] AFIT8_bnr_iDenThreshHigh
+{0x0F12,0x6024},	// 70000A28//AFIT8_ee_iLowSharpPower   [7:0] AFIT8_ee_iHighSharpPower
+{0x0F12,0x2A74},	// 70000A2A//AFIT8_ee_iLowShDenoise   [7:0] AFIT8_ee_iHighShDenoise
+{0x0F12,0xFFFF},	// 70000A2C//AFIT8_ee_iLowSharpClamp   [7:0] AFIT8_ee_iHighSharpClamp
+{0x0F12,0x0808},	// 70000A2E//AFIT8_ee_iReduceEdgeMinMult   [7:0] AFIT8_ee_iReduceEdgeSlope
+{0x0F12,0x0A01},	// 70000A30//AFIT8_bnr_nClustLevel_H_Bin   [7:0] AFIT8_bnr_iClustMulT_H_Bin
+{0x0F12,0x010A},	// 70000A32//AFIT8_bnr_iClustMulT_C_Bin   [7:0] AFIT8_bnr_iClustThresh_H_Bin
+{0x0F12,0x3601},	// 70000A34//AFIT8_bnr_iClustThresh_C_Bin   [7:0] AFIT8_bnr_iDenThreshLow_Bin
+{0x0F12,0x242A},	// 70000A36//AFIT8_bnr_iDenThreshHigh_Bin   [7:0] AFIT8_ee_iLowSharpPower_Bin
+{0x0F12,0x3660},	// 70000A38//AFIT8_ee_iHighSharpPower_Bin   [7:0] AFIT8_ee_iLowShDenoise_Bin
+{0x0F12,0xFF2A},	// 70000A3A//AFIT8_ee_iHighShDenoise_Bin   [7:0] AFIT8_ee_iLowSharpClamp_Bin
+{0x0F12,0x08FF},	// 70000A3C//AFIT8_ee_iHighSharpClamp_Bin   [7:0] AFIT8_ee_iReduceEdgeMinMult_Bin
+{0x0F12,0x0008},	// 70000A3E//AFIT8_ee_iReduceEdgeSlope_Bin [7:0]
+{0x0F12,0x0001},	// 70000A40//AFITB_bnr_nClustLevel_C      [0]
+{0x0F12,0x0000},	// 70000A42//AFIT16_BRIGHTNESS
+{0x0F12,0x000C},	// 70000A44//AFIT16_CONTRAST
+{0x0F12,0x0010},	// 70000A46//AFIT16_SATURATION
+{0x0F12,0x0000},	// 70000A48//AFIT16_SHARP_BLUR
+{0x0F12,0x0000},	// 70000A4A//AFIT16_GLAMOUR
+{0x0F12,0x00C0},	// 70000A4C//AFIT16_bnr_edge_high
+{0x0F12,0x0064},	// 70000A4E//AFIT16_postdmsc_iLowBright
+{0x0F12,0x0384},	// 70000A50//AFIT16_postdmsc_iHighBright
+{0x0F12,0x0051},	// 70000A52//AFIT16_postdmsc_iLowSat
+{0x0F12,0x01F4},	// 70000A54//AFIT16_postdmsc_iHighSat
+{0x0F12,0x0070},	// 70000A56//AFIT16_postdmsc_iTune
+{0x0F12,0x0040},	// 70000A58//AFIT16_yuvemix_mNegRanges_0
+{0x0F12,0x00A0},	// 70000A5A//AFIT16_yuvemix_mNegRanges_1
+{0x0F12,0x0100},	// 70000A5C//AFIT16_yuvemix_mNegRanges_2
+{0x0F12,0x0010},	// 70000A5E//AFIT16_yuvemix_mPosRanges_0
+{0x0F12,0x0060},	// 70000A60//AFIT16_yuvemix_mPosRanges_1
+{0x0F12,0x0100},	// 70000A62//AFIT16_yuvemix_mPosRanges_2
+{0x0F12,0x1430},	// 70000A64//AFIT8_bnr_edge_low  [7:0] AFIT8_bnr_repl_thresh
+{0x0F12,0x0201},	// 70000A66//AFIT8_bnr_repl_force  [7:0] AFIT8_bnr_iHotThreshHigh
+{0x0F12,0x0204},	// 70000A68//AFIT8_bnr_iHotThreshLow   [7:0] AFIT8_bnr_iColdThreshHigh
+{0x0F12,0x2404},	// 70000A6A//AFIT8_bnr_iColdThreshLow   [7:0] AFIT8_bnr_DispTH_Low
+{0x0F12,0x031B},	// 70000A6C//AFIT8_bnr_DispTH_High   [7:0] AFIT8_bnr_DISP_Limit_Low
+{0x0F12,0x0103},	// 70000A6E//AFIT8_bnr_DISP_Limit_High   [7:0] AFIT8_bnr_iDistSigmaMin
+{0x0F12,0x1205},	// 70000A70//AFIT8_bnr_iDistSigmaMax   [7:0] AFIT8_bnr_iDiffSigmaLow
+{0x0F12,0x400D},	// 70000A72//AFIT8_bnr_iDiffSigmaHigh   [7:0] AFIT8_bnr_iNormalizedSTD_TH
+{0x0F12,0x0080},	// 70000A74//AFIT8_bnr_iNormalizedSTD_Limit   [7:0] AFIT8_bnr_iDirNRTune
+{0x0F12,0x2080},	// 70000A76//AFIT8_bnr_iDirMinThres   [7:0] AFIT8_bnr_iDirFltDiffThresHigh
+{0x0F12,0x3040},	// 70000A78//AFIT8_bnr_iDirFltDiffThresLow   [7:0] AFIT8_bnr_iDirSmoothPowerHigh
+{0x0F12,0x0630},	// 70000A7A//AFIT8_bnr_iDirSmoothPowerLow   [7:0] AFIT8_bnr_iLowMaxSlopeAllowed
+{0x0F12,0x0306},	// 70000A7C//AFIT8_bnr_iHighMaxSlopeAllowed   [7:0] AFIT8_bnr_iLowSlopeThresh
+{0x0F12,0x2003},	// 70000A7E//AFIT8_bnr_iHighSlopeThresh   [7:0] AFIT8_bnr_iSlopenessTH
+{0x0F12,0xFF01},	// 70000A80//AFIT8_bnr_iSlopeBlurStrength   [7:0] AFIT8_bnr_iSlopenessLimit
+{0x0F12,0x0404},	// 70000A82//AFIT8_bnr_AddNoisePower1   [7:0] AFIT8_bnr_AddNoisePower2
+{0x0F12,0x0300},	// 70000A84//AFIT8_bnr_iRadialTune   [7:0] AFIT8_bnr_iRadialPower
+{0x0F12,0x245A},	// 70000A86//AFIT8_bnr_iRadialLimit   [7:0] AFIT8_ee_iFSMagThLow
+{0x0F12,0x1018},	// 70000A88//AFIT8_ee_iFSMagThHigh   [7:0] AFIT8_ee_iFSVarThLow
+{0x0F12,0x000B},	// 70000A8A//AFIT8_ee_iFSVarThHigh   [7:0] AFIT8_ee_iFSThLow
+{0x0F12,0x0B00},	// 70000A8C//AFIT8_ee_iFSThHigh   [7:0] AFIT8_ee_iFSmagPower
+{0x0F12,0x5A0F},	// 70000A8E//AFIT8_ee_iFSVarCountTh   [7:0] AFIT8_ee_iRadialLimit
+{0x0F12,0x0505},	// 70000A90//AFIT8_ee_iRadialPower   [7:0] AFIT8_ee_iSmoothEdgeSlope
+{0x0F12,0x1802},	// 70000A92//AFIT8_ee_iROADThres   [7:0] AFIT8_ee_iROADMaxNR
+{0x0F12,0x0000},	// 70000A94//AFIT8_ee_iROADSubMaxNR   [7:0] AFIT8_ee_iROADSubThres
+{0x0F12,0x2006},	// 70000A96//AFIT8_ee_iROADNeiThres   [7:0] AFIT8_ee_iROADNeiMaxNR
+{0x0F12,0x3428},	// 70000A98//AFIT8_ee_iSmoothEdgeThres   [7:0] AFIT8_ee_iMSharpen
+{0x0F12,0x041C},	// 70000A9A//AFIT8_ee_iWSharpen   [7:0] AFIT8_ee_iMShThresh
+{0x0F12,0x0101},	// 70000A9C//AFIT8_ee_iWShThresh   [7:0] AFIT8_ee_iReduceNegative
+{0x0F12,0x0800},	// 70000A9E//AFIT8_ee_iEmbossCentAdd   [7:0] AFIT8_ee_iShDespeckle
+{0x0F12,0x1004},	// 70000AA0//AFIT8_ee_iReduceEdgeThresh   [7:0] AFIT8_dmsc_iEnhThresh
+{0x0F12,0x4008},	// 70000AA2//AFIT8_dmsc_iDesatThresh   [7:0] AFIT8_dmsc_iDemBlurHigh
+{0x0F12,0x0540},	// 70000AA4//AFIT8_dmsc_iDemBlurLow   [7:0] AFIT8_dmsc_iDemBlurRange
+{0x0F12,0x8006},	// 70000AA6//AFIT8_dmsc_iDecisionThresh   [7:0] AFIT8_dmsc_iCentGrad
+{0x0F12,0x0020},	// 70000AA8//AFIT8_dmsc_iMonochrom   [7:0] AFIT8_dmsc_iGBDenoiseVal
+{0x0F12,0x0000},	// 70000AAA//AFIT8_dmsc_iGRDenoiseVal   [7:0] AFIT8_dmsc_iEdgeDesatThrHigh
+{0x0F12,0x1800},	// 70000AAC//AFIT8_dmsc_iEdgeDesatThrLow   [7:0] AFIT8_dmsc_iEdgeDesat
+{0x0F12,0x0000},	// 70000AAE//AFIT8_dmsc_iNearGrayDesat   [7:0] AFIT8_dmsc_iEdgeDesatLimit
+{0x0F12,0x1E10},	// 70000AB0//AFIT8_postdmsc_iBCoeff   [7:0] AFIT8_postdmsc_iGCoeff
+{0x0F12,0x000B},	// 70000AB2//AFIT8_postdmsc_iWideMult   [7:0] AFIT8_yuvemix_mNegSlopes_0
+{0x0F12,0x0607},	// 70000AB4//AFIT8_yuvemix_mNegSlopes_1   [7:0] AFIT8_yuvemix_mNegSlopes_2
+{0x0F12,0x0005},	// 70000AB6//AFIT8_yuvemix_mNegSlopes_3   [7:0] AFIT8_yuvemix_mPosSlopes_0
+{0x0F12,0x0607},	// 70000AB8//AFIT8_yuvemix_mPosSlopes_1   [7:0] AFIT8_yuvemix_mPosSlopes_2
+{0x0F12,0x0405},	// 70000ABA//AFIT8_yuvemix_mPosSlopes_3   [7:0] AFIT8_yuviirnr_iXSupportY
+{0x0F12,0x0205},	// 70000ABC//AFIT8_yuviirnr_iXSupportUV   [7:0] AFIT8_yuviirnr_iLowYNorm
+{0x0F12,0x0304},	// 70000ABE//AFIT8_yuviirnr_iHighYNorm   [7:0] AFIT8_yuviirnr_iLowUVNorm
+{0x0F12,0x0409},	// 70000AC0//AFIT8_yuviirnr_iHighUVNorm   [7:0] AFIT8_yuviirnr_iYNormShift
+{0x0F12,0x0306},	// 70000AC2//AFIT8_yuviirnr_iUVNormShift   [7:0] AFIT8_yuviirnr_iVertLength_Y
+{0x0F12,0x0407},	// 70000AC4//AFIT8_yuviirnr_iVertLength_UV   [7:0] AFIT8_yuviirnr_iDiffThreshL_Y
+{0x0F12,0x1F04},	// 70000AC6//AFIT8_yuviirnr_iDiffThreshH_Y   [7:0] AFIT8_yuviirnr_iDiffThreshL_UV
+{0x0F12,0x0218},	// 70000AC8//AFIT8_yuviirnr_iDiffThreshH_UV   [7:0] AFIT8_yuviirnr_iMaxThreshL_Y
+{0x0F12,0x1102},	// 70000ACA//AFIT8_yuviirnr_iMaxThreshH_Y   [7:0] AFIT8_yuviirnr_iMaxThreshL_UV
+{0x0F12,0x0611},	// 70000ACC//AFIT8_yuviirnr_iMaxThreshH_UV   [7:0] AFIT8_yuviirnr_iYNRStrengthL
+{0x0F12,0x1A02},	// 70000ACE//AFIT8_yuviirnr_iYNRStrengthH   [7:0] AFIT8_yuviirnr_iUVNRStrengthL
+{0x0F12,0x8018},	// 70000AD0//AFIT8_yuviirnr_iUVNRStrengthH   [7:0] AFIT8_byr_gras_iShadingPower
+{0x0F12,0x0080},	// 70000AD2//AFIT8_RGBGamma2_iLinearity   [7:0] AFIT8_RGBGamma2_iDarkReduce
+{0x0F12,0x0380},	// 70000AD4//AFIT8_ccm_oscar_iSaturation   [7:0] AFIT8_RGB2YUV_iYOffset
+{0x0F12,0x0180},	// 70000AD6//AFIT8_RGB2YUV_iRGBGain   [7:0] AFIT8_bnr_nClustLevel_H
+{0x0F12,0x0A0A},	// 70000AD8//AFIT8_bnr_iClustMulT_H   [7:0] AFIT8_bnr_iClustMulT_C
+{0x0F12,0x0101},	// 70000ADA//AFIT8_bnr_iClustThresh_H   [7:0] AFIT8_bnr_iClustThresh_C
+{0x0F12,0x1B51},	// 70000ADC//AFIT8_bnr_iDenThreshLow   [7:0] AFIT8_bnr_iDenThreshHigh
+{0x0F12,0x6024},	// 70000ADE//AFIT8_ee_iLowSharpPower   [7:0] AFIT8_ee_iHighSharpPower
+{0x0F12,0x1D5F},	// 70000AE0//AFIT8_ee_iLowShDenoise   [7:0] AFIT8_ee_iHighShDenoise
+{0x0F12,0xFFFF},	// 70000AE2//AFIT8_ee_iLowSharpClamp   [7:0] AFIT8_ee_iHighSharpClamp
+{0x0F12,0x0808},	// 70000AE4//AFIT8_ee_iReduceEdgeMinMult   [7:0] AFIT8_ee_iReduceEdgeSlope
+{0x0F12,0x0A01},	// 70000AE6//AFIT8_bnr_nClustLevel_H_Bin   [7:0] AFIT8_bnr_iClustMulT_H_Bin
+{0x0F12,0x010A},	// 70000AE8//AFIT8_bnr_iClustMulT_C_Bin   [7:0] AFIT8_bnr_iClustThresh_H_Bin
+{0x0F12,0x2401},	// 70000AEA//AFIT8_bnr_iClustThresh_C_Bin   [7:0] AFIT8_bnr_iDenThreshLow_Bin
+{0x0F12,0x241B},	// 70000AEC//AFIT8_bnr_iDenThreshHigh_Bin   [7:0] AFIT8_ee_iLowSharpPower_Bin
+{0x0F12,0x1E60},	// 70000AEE//AFIT8_ee_iHighSharpPower_Bin   [7:0] AFIT8_ee_iLowShDenoise_Bin
+{0x0F12,0xFF18},	// 70000AF0//AFIT8_ee_iHighShDenoise_Bin   [7:0] AFIT8_ee_iLowSharpClamp_Bin
+{0x0F12,0x08FF},	// 70000AF2//AFIT8_ee_iHighSharpClamp_Bin   [7:0] AFIT8_ee_iReduceEdgeMinMult_Bin
+{0x0F12,0x0008},	// 70000AF4//AFIT8_ee_iReduceEdgeSlope_Bin [7:0]
+{0x0F12,0x0001},	// 70000AF6//AFITB_bnr_nClustLevel_C      [0]
+{0x0F12,0x0000},	// 70000AF8//AFIT16_BRIGHTNESS
+{0x0F12,0x0018},	// 70000AFA//AFIT16_CONTRAST
+{0x0F12,0x0010},	// 70000AFC//AFIT16_SATURATION
+{0x0F12,0x0000},	// 70000AFE//AFIT16_SHARP_BLUR
+{0x0F12,0x0000},	// 70000B00//AFIT16_GLAMOUR
+{0x0F12,0x00C0},	// 70000B02//AFIT16_bnr_edge_high
+{0x0F12,0x0064},	// 70000B04//AFIT16_postdmsc_iLowBright
+{0x0F12,0x0384},	// 70000B06//AFIT16_postdmsc_iHighBright
+{0x0F12,0x0043},	// 70000B08//AFIT16_postdmsc_iLowSat
+{0x0F12,0x01F4},	// 70000B0A//AFIT16_postdmsc_iHighSat
+{0x0F12,0x0070},	// 70000B0C//AFIT16_postdmsc_iTune
+{0x0F12,0x0040},	// 70000B0E//AFIT16_yuvemix_mNegRanges_0
+{0x0F12,0x00A0},	// 70000B10//AFIT16_yuvemix_mNegRanges_1
+{0x0F12,0x0100},	// 70000B12//AFIT16_yuvemix_mNegRanges_2
+{0x0F12,0x0010},	// 70000B14//AFIT16_yuvemix_mPosRanges_0
+{0x0F12,0x0060},	// 70000B16//AFIT16_yuvemix_mPosRanges_1
+{0x0F12,0x0100},	// 70000B18//AFIT16_yuvemix_mPosRanges_2
+{0x0F12,0x1430},	// 70000B1A//AFIT8_bnr_edge_low  [7:0] AFIT8_bnr_repl_thresh
+{0x0F12,0x0201},	// 70000B1C//AFIT8_bnr_repl_force  [7:0] AFIT8_bnr_iHotThreshHigh
+{0x0F12,0x0204},	// 70000B1E//AFIT8_bnr_iHotThreshLow   [7:0] AFIT8_bnr_iColdThreshHigh
+{0x0F12,0x1B04},	// 70000B20//AFIT8_bnr_iColdThreshLow   [7:0] AFIT8_bnr_DispTH_Low
+{0x0F12,0x0312},	// 70000B22//AFIT8_bnr_DispTH_High   [7:0] AFIT8_bnr_DISP_Limit_Low
+{0x0F12,0x0003},	// 70000B24//AFIT8_bnr_DISP_Limit_High   [7:0] AFIT8_bnr_iDistSigmaMin
+{0x0F12,0x0C03},	// 70000B26//AFIT8_bnr_iDistSigmaMax   [7:0] AFIT8_bnr_iDiffSigmaLow
+{0x0F12,0x2806},	// 70000B28//AFIT8_bnr_iDiffSigmaHigh   [7:0] AFIT8_bnr_iNormalizedSTD_TH
+{0x0F12,0x0060},	// 70000B2A//AFIT8_bnr_iNormalizedSTD_Limit   [7:0] AFIT8_bnr_iDirNRTune
+{0x0F12,0x1580},	// 70000B2C//AFIT8_bnr_iDirMinThres   [7:0] AFIT8_bnr_iDirFltDiffThresHigh
+{0x0F12,0x2020},	// 70000B2E//AFIT8_bnr_iDirFltDiffThresLow   [7:0] AFIT8_bnr_iDirSmoothPowerHigh
+{0x0F12,0x0620},	// 70000B30//AFIT8_bnr_iDirSmoothPowerLow   [7:0] AFIT8_bnr_iLowMaxSlopeAllowed
+{0x0F12,0x0306},	// 70000B32//AFIT8_bnr_iHighMaxSlopeAllowed   [7:0] AFIT8_bnr_iLowSlopeThresh
+{0x0F12,0x2003},	// 70000B34//AFIT8_bnr_iHighSlopeThresh   [7:0] AFIT8_bnr_iSlopenessTH
+{0x0F12,0xFF01},	// 70000B36//AFIT8_bnr_iSlopeBlurStrength   [7:0] AFIT8_bnr_iSlopenessLimit
+{0x0F12,0x0404},	// 70000B38//AFIT8_bnr_AddNoisePower1   [7:0] AFIT8_bnr_AddNoisePower2
+{0x0F12,0x0300},	// 70000B3A//AFIT8_bnr_iRadialTune   [7:0] AFIT8_bnr_iRadialPower
+{0x0F12,0x145A},	// 70000B3C//AFIT8_bnr_iRadialLimit   [7:0] AFIT8_ee_iFSMagThLow
+{0x0F12,0x1010},	// 70000B3E//AFIT8_ee_iFSMagThHigh   [7:0] AFIT8_ee_iFSVarThLow
+{0x0F12,0x000B},	// 70000B40//AFIT8_ee_iFSVarThHigh   [7:0] AFIT8_ee_iFSThLow
+{0x0F12,0x0E00},	// 70000B42//AFIT8_ee_iFSThHigh   [7:0] AFIT8_ee_iFSmagPower
+{0x0F12,0x5A0F},	// 70000B44//AFIT8_ee_iFSVarCountTh   [7:0] AFIT8_ee_iRadialLimit
+{0x0F12,0x0504},	// 70000B46//AFIT8_ee_iRadialPower   [7:0] AFIT8_ee_iSmoothEdgeSlope
+{0x0F12,0x1802},	// 70000B48//AFIT8_ee_iROADThres   [7:0] AFIT8_ee_iROADMaxNR
+{0x0F12,0x0000},	// 70000B4A//AFIT8_ee_iROADSubMaxNR   [7:0] AFIT8_ee_iROADSubThres
+{0x0F12,0x2006},	// 70000B4C//AFIT8_ee_iROADNeiThres   [7:0] AFIT8_ee_iROADNeiMaxNR
+{0x0F12,0x3828},	// 70000B4E//AFIT8_ee_iSmoothEdgeThres   [7:0] AFIT8_ee_iMSharpen
+{0x0F12,0x0428},	// 70000B50//AFIT8_ee_iWSharpen   [7:0] AFIT8_ee_iMShThresh
+{0x0F12,0x0101},	// 70000B52//AFIT8_ee_iWShThresh   [7:0] AFIT8_ee_iReduceNegative
+{0x0F12,0x8000},	// 70000B54//AFIT8_ee_iEmbossCentAdd   [7:0] AFIT8_ee_iShDespeckle
+{0x0F12,0x0A04},	// 70000B56//AFIT8_ee_iReduceEdgeThresh   [7:0] AFIT8_dmsc_iEnhThresh
+{0x0F12,0x4008},	// 70000B58//AFIT8_dmsc_iDesatThresh   [7:0] AFIT8_dmsc_iDemBlurHigh
+{0x0F12,0x0540},	// 70000B5A//AFIT8_dmsc_iDemBlurLow   [7:0] AFIT8_dmsc_iDemBlurRange
+{0x0F12,0x8006},	// 70000B5C//AFIT8_dmsc_iDecisionThresh   [7:0] AFIT8_dmsc_iCentGrad
+{0x0F12,0x0020},	// 70000B5E//AFIT8_dmsc_iMonochrom   [7:0] AFIT8_dmsc_iGBDenoiseVal
+{0x0F12,0x0000},	// 70000B60//AFIT8_dmsc_iGRDenoiseVal   [7:0] AFIT8_dmsc_iEdgeDesatThrHigh
+{0x0F12,0x1800},	// 70000B62//AFIT8_dmsc_iEdgeDesatThrLow   [7:0] AFIT8_dmsc_iEdgeDesat
+{0x0F12,0x0000},	// 70000B64//AFIT8_dmsc_iNearGrayDesat   [7:0] AFIT8_dmsc_iEdgeDesatLimit
+{0x0F12,0x1E10},	// 70000B66//AFIT8_postdmsc_iBCoeff   [7:0] AFIT8_postdmsc_iGCoeff
+{0x0F12,0x000B},	// 70000B68//AFIT8_postdmsc_iWideMult   [7:0] AFIT8_yuvemix_mNegSlopes_0
+{0x0F12,0x0607},	// 70000B6A//AFIT8_yuvemix_mNegSlopes_1   [7:0] AFIT8_yuvemix_mNegSlopes_2
+{0x0F12,0x0005},	// 70000B6C//AFIT8_yuvemix_mNegSlopes_3   [7:0] AFIT8_yuvemix_mPosSlopes_0
+{0x0F12,0x0607},	// 70000B6E//AFIT8_yuvemix_mPosSlopes_1   [7:0] AFIT8_yuvemix_mPosSlopes_2
+{0x0F12,0x0405},	// 70000B70//AFIT8_yuvemix_mPosSlopes_3   [7:0] AFIT8_yuviirnr_iXSupportY
+{0x0F12,0x0207},	// 70000B72//AFIT8_yuviirnr_iXSupportUV   [7:0] AFIT8_yuviirnr_iLowYNorm
+{0x0F12,0x0304},	// 70000B74//AFIT8_yuviirnr_iHighYNorm   [7:0] AFIT8_yuviirnr_iLowUVNorm
+{0x0F12,0x0409},	// 70000B76//AFIT8_yuviirnr_iHighUVNorm   [7:0] AFIT8_yuviirnr_iYNormShift
+{0x0F12,0x0306},	// 70000B78//AFIT8_yuviirnr_iUVNormShift   [7:0] AFIT8_yuviirnr_iVertLength_Y
+{0x0F12,0x0407},	// 70000B7A//AFIT8_yuviirnr_iVertLength_UV   [7:0] AFIT8_yuviirnr_iDiffThreshL_Y
+{0x0F12,0x2404},	// 70000B7C//AFIT8_yuviirnr_iDiffThreshH_Y   [7:0] AFIT8_yuviirnr_iDiffThreshL_UV
+{0x0F12,0x0221},	// 70000B7E//AFIT8_yuviirnr_iDiffThreshH_UV   [7:0] AFIT8_yuviirnr_iMaxThreshL_Y
+{0x0F12,0x1202},	// 70000B80//AFIT8_yuviirnr_iMaxThreshH_Y   [7:0] AFIT8_yuviirnr_iMaxThreshL_UV
+{0x0F12,0x0613},	// 70000B82//AFIT8_yuviirnr_iMaxThreshH_UV   [7:0] AFIT8_yuviirnr_iYNRStrengthL
+{0x0F12,0x1A02},	// 70000B84//AFIT8_yuviirnr_iYNRStrengthH   [7:0] AFIT8_yuviirnr_iUVNRStrengthL
+{0x0F12,0x8018},	// 70000B86//AFIT8_yuviirnr_iUVNRStrengthH   [7:0] AFIT8_byr_gras_iShadingPower
+{0x0F12,0x0080},	// 70000B88//AFIT8_RGBGamma2_iLinearity   [7:0] AFIT8_RGBGamma2_iDarkReduce
+{0x0F12,0x0080},	// 70000B8A//AFIT8_ccm_oscar_iSaturation   [7:0] AFIT8_RGB2YUV_iYOffset
+{0x0F12,0x0180},	// 70000B8C//AFIT8_RGB2YUV_iRGBGain   [7:0] AFIT8_bnr_nClustLevel_H
+{0x0F12,0x0A0A},	// 70000B8E//AFIT8_bnr_iClustMulT_H   [7:0] AFIT8_bnr_iClustMulT_C
+{0x0F12,0x0101},	// 70000B90//AFIT8_bnr_iClustThresh_H   [7:0] AFIT8_bnr_iClustThresh_C
+{0x0F12,0x142E},	// 70000B92//AFIT8_bnr_iDenThreshLow   [7:0] AFIT8_bnr_iDenThreshHigh
+{0x0F12,0x6024},	// 70000B94//AFIT8_ee_iLowSharpPower   [7:0] AFIT8_ee_iHighSharpPower
+{0x0F12,0x0C4A},	// 70000B96//AFIT8_ee_iLowShDenoise   [7:0] AFIT8_ee_iHighShDenoise
+{0x0F12,0xFFFF},	// 70000B98//AFIT8_ee_iLowSharpClamp   [7:0] AFIT8_ee_iHighSharpClamp
+{0x0F12,0x0808},	// 70000B9A//AFIT8_ee_iReduceEdgeMinMult   [7:0] AFIT8_ee_iReduceEdgeSlope
+{0x0F12,0x0A01},	// 70000B9C//AFIT8_bnr_nClustLevel_H_Bin   [7:0] AFIT8_bnr_iClustMulT_H_Bin
+{0x0F12,0x010A},	// 70000B9E//AFIT8_bnr_iClustMulT_C_Bin   [7:0] AFIT8_bnr_iClustThresh_H_Bin
+{0x0F12,0x1B01},	// 70000BA0//AFIT8_bnr_iClustThresh_C_Bin   [7:0] AFIT8_bnr_iDenThreshLow_Bin
+{0x0F12,0x2412},	// 70000BA2//AFIT8_bnr_iDenThreshHigh_Bin   [7:0] AFIT8_ee_iLowSharpPower_Bin
+{0x0F12,0x0C60},	// 70000BA4//AFIT8_ee_iHighSharpPower_Bin   [7:0] AFIT8_ee_iLowShDenoise_Bin
+{0x0F12,0xFF0C},	// 70000BA6//AFIT8_ee_iHighShDenoise_Bin   [7:0] AFIT8_ee_iLowSharpClamp_Bin
+{0x0F12,0x08FF},	// 70000BA8//AFIT8_ee_iHighSharpClamp_Bin   [7:0] AFIT8_ee_iReduceEdgeMinMult_Bin
+{0x0F12,0x0008},	// 70000BAA//AFIT8_ee_iReduceEdgeSlope_Bin [7:0]
+{0x0F12,0x0001},	// 70000BAC//AFITB_bnr_nClustLevel_C      [0]
+{0x0F12,0x0000},	// 70000BAE//AFIT16_BRIGHTNESS
+{0x0F12,0x0018},	// 70000BB0//AFIT16_CONTRAST
+{0x0F12,0x0010},	// 70000BB2//AFIT16_SATURATION
+{0x0F12,0x0000},	// 70000BB4//AFIT16_SHARP_BLUR
+{0x0F12,0x0000},	// 70000BB6//AFIT16_GLAMOUR
+{0x0F12,0x00C0},	// 70000BB8//AFIT16_bnr_edge_high
+{0x0F12,0x0064},	// 70000BBA//AFIT16_postdmsc_iLowBright
+{0x0F12,0x0384},	// 70000BBC//AFIT16_postdmsc_iHighBright
+{0x0F12,0x0032},	// 70000BBE//AFIT16_postdmsc_iLowSat
+{0x0F12,0x01F4},	// 70000BC0//AFIT16_postdmsc_iHighSat
+{0x0F12,0x0070},	// 70000BC2//AFIT16_postdmsc_iTune
+{0x0F12,0x0040},	// 70000BC4//AFIT16_yuvemix_mNegRanges_0
+{0x0F12,0x00A0},	// 70000BC6//AFIT16_yuvemix_mNegRanges_1
+{0x0F12,0x0100},	// 70000BC8//AFIT16_yuvemix_mNegRanges_2
+{0x0F12,0x0010},	// 70000BCA//AFIT16_yuvemix_mPosRanges_0
+{0x0F12,0x0060},	// 70000BCC//AFIT16_yuvemix_mPosRanges_1
+{0x0F12,0x0100},	// 70000BCE//AFIT16_yuvemix_mPosRanges_2
+{0x0F12,0x1430},	// 70000BD0//AFIT8_bnr_edge_low  [7:0] AFIT8_bnr_repl_thresh
+{0x0F12,0x0201},	// 70000BD2//AFIT8_bnr_repl_force  [7:0] AFIT8_bnr_iHotThreshHigh
+{0x0F12,0x0204},	// 70000BD4//AFIT8_bnr_iHotThreshLow   [7:0] AFIT8_bnr_iColdThreshHigh
+{0x0F12,0x1504},	// 70000BD6//AFIT8_bnr_iColdThreshLow   [7:0] AFIT8_bnr_DispTH_Low
+{0x0F12,0x030F},	// 70000BD8//AFIT8_bnr_DispTH_High   [7:0] AFIT8_bnr_DISP_Limit_Low
+{0x0F12,0x0003},	// 70000BDA//AFIT8_bnr_DISP_Limit_High   [7:0] AFIT8_bnr_iDistSigmaMin
+{0x0F12,0x0902},	// 70000BDC//AFIT8_bnr_iDistSigmaMax   [7:0] AFIT8_bnr_iDiffSigmaLow
+{0x0F12,0x2004},	// 70000BDE//AFIT8_bnr_iDiffSigmaHigh   [7:0] AFIT8_bnr_iNormalizedSTD_TH
+{0x0F12,0x0050},	// 70000BE0//AFIT8_bnr_iNormalizedSTD_Limit   [7:0] AFIT8_bnr_iDirNRTune
+{0x0F12,0x1140},	// 70000BE2//AFIT8_bnr_iDirMinThres   [7:0] AFIT8_bnr_iDirFltDiffThresHigh
+{0x0F12,0x201C},	// 70000BE4//AFIT8_bnr_iDirFltDiffThresLow   [7:0] AFIT8_bnr_iDirSmoothPowerHigh
+{0x0F12,0x0620},	// 70000BE6//AFIT8_bnr_iDirSmoothPowerLow   [7:0] AFIT8_bnr_iLowMaxSlopeAllowed
+{0x0F12,0x0306},	// 70000BE8//AFIT8_bnr_iHighMaxSlopeAllowed   [7:0] AFIT8_bnr_iLowSlopeThresh
+{0x0F12,0x2003},	// 70000BEA//AFIT8_bnr_iHighSlopeThresh   [7:0] AFIT8_bnr_iSlopenessTH
+{0x0F12,0xFF01},	// 70000BEC//AFIT8_bnr_iSlopeBlurStrength   [7:0] AFIT8_bnr_iSlopenessLimit
+{0x0F12,0x0404},	// 70000BEE//AFIT8_bnr_AddNoisePower1   [7:0] AFIT8_bnr_AddNoisePower2
+{0x0F12,0x0300},	// 70000BF0//AFIT8_bnr_iRadialTune   [7:0] AFIT8_bnr_iRadialPower
+{0x0F12,0x145A},	// 70000BF2//AFIT8_bnr_iRadialLimit   [7:0] AFIT8_ee_iFSMagThLow
+{0x0F12,0x1010},	// 70000BF4//AFIT8_ee_iFSMagThHigh   [7:0] AFIT8_ee_iFSVarThLow
+{0x0F12,0x000B},	// 70000BF6//AFIT8_ee_iFSVarThHigh   [7:0] AFIT8_ee_iFSThLow
+{0x0F12,0x1000},	// 70000BF8//AFIT8_ee_iFSThHigh   [7:0] AFIT8_ee_iFSmagPower
+{0x0F12,0x5A0F},	// 70000BFA//AFIT8_ee_iFSVarCountTh   [7:0] AFIT8_ee_iRadialLimit
+{0x0F12,0x0503},	// 70000BFC//AFIT8_ee_iRadialPower   [7:0] AFIT8_ee_iSmoothEdgeSlope
+{0x0F12,0x1802},	// 70000BFE//AFIT8_ee_iROADThres   [7:0] AFIT8_ee_iROADMaxNR
+{0x0F12,0x0000},	// 70000C00//AFIT8_ee_iROADSubMaxNR   [7:0] AFIT8_ee_iROADSubThres
+{0x0F12,0x2006},	// 70000C02//AFIT8_ee_iROADNeiThres   [7:0] AFIT8_ee_iROADNeiMaxNR
+{0x0F12,0x3C28},	// 70000C04//AFIT8_ee_iSmoothEdgeThres   [7:0] AFIT8_ee_iMSharpen
+{0x0F12,0x042C},	// 70000C06//AFIT8_ee_iWSharpen   [7:0] AFIT8_ee_iMShThresh
+{0x0F12,0x0101},	// 70000C08//AFIT8_ee_iWShThresh   [7:0] AFIT8_ee_iReduceNegative
+{0x0F12,0xFF00},	// 70000C0A//AFIT8_ee_iEmbossCentAdd   [7:0] AFIT8_ee_iShDespeckle
+{0x0F12,0x0904},	// 70000C0C//AFIT8_ee_iReduceEdgeThresh   [7:0] AFIT8_dmsc_iEnhThresh
+{0x0F12,0x4008},	// 70000C0E//AFIT8_dmsc_iDesatThresh   [7:0] AFIT8_dmsc_iDemBlurHigh
+{0x0F12,0x0540},	// 70000C10//AFIT8_dmsc_iDemBlurLow   [7:0] AFIT8_dmsc_iDemBlurRange
+{0x0F12,0x8006},	// 70000C12//AFIT8_dmsc_iDecisionThresh   [7:0] AFIT8_dmsc_iCentGrad
+{0x0F12,0x0020},	// 70000C14//AFIT8_dmsc_iMonochrom   [7:0] AFIT8_dmsc_iGBDenoiseVal
+{0x0F12,0x0000},	// 70000C16//AFIT8_dmsc_iGRDenoiseVal   [7:0] AFIT8_dmsc_iEdgeDesatThrHigh
+{0x0F12,0x1800},	// 70000C18//AFIT8_dmsc_iEdgeDesatThrLow   [7:0] AFIT8_dmsc_iEdgeDesat
+{0x0F12,0x0000},	// 70000C1A//AFIT8_dmsc_iNearGrayDesat   [7:0] AFIT8_dmsc_iEdgeDesatLimit
+{0x0F12,0x1E10},	// 70000C1C//AFIT8_postdmsc_iBCoeff   [7:0] AFIT8_postdmsc_iGCoeff
+{0x0F12,0x000B},	// 70000C1E//AFIT8_postdmsc_iWideMult   [7:0] AFIT8_yuvemix_mNegSlopes_0
+{0x0F12,0x0607},	// 70000C20//AFIT8_yuvemix_mNegSlopes_1   [7:0] AFIT8_yuvemix_mNegSlopes_2
+{0x0F12,0x0005},	// 70000C22//AFIT8_yuvemix_mNegSlopes_3   [7:0] AFIT8_yuvemix_mPosSlopes_0
+{0x0F12,0x0607},	// 70000C24//AFIT8_yuvemix_mPosSlopes_1   [7:0] AFIT8_yuvemix_mPosSlopes_2
+{0x0F12,0x0405},	// 70000C26//AFIT8_yuvemix_mPosSlopes_3   [7:0] AFIT8_yuviirnr_iXSupportY
+{0x0F12,0x0206},	// 70000C28//AFIT8_yuviirnr_iXSupportUV   [7:0] AFIT8_yuviirnr_iLowYNorm
+{0x0F12,0x0304},	// 70000C2A//AFIT8_yuviirnr_iHighYNorm   [7:0] AFIT8_yuviirnr_iLowUVNorm
+{0x0F12,0x0409},	// 70000C2C//AFIT8_yuviirnr_iHighUVNorm   [7:0] AFIT8_yuviirnr_iYNormShift
+{0x0F12,0x0305},	// 70000C2E//AFIT8_yuviirnr_iUVNormShift   [7:0] AFIT8_yuviirnr_iVertLength_Y
+{0x0F12,0x0406},	// 70000C30//AFIT8_yuviirnr_iVertLength_UV   [7:0] AFIT8_yuviirnr_iDiffThreshL_Y
+{0x0F12,0x2804},	// 70000C32//AFIT8_yuviirnr_iDiffThreshH_Y   [7:0] AFIT8_yuviirnr_iDiffThreshL_UV
+{0x0F12,0x0228},	// 70000C34//AFIT8_yuviirnr_iDiffThreshH_UV   [7:0] AFIT8_yuviirnr_iMaxThreshL_Y
+{0x0F12,0x1402},	// 70000C36//AFIT8_yuviirnr_iMaxThreshH_Y   [7:0] AFIT8_yuviirnr_iMaxThreshL_UV
+{0x0F12,0x0618},	// 70000C38//AFIT8_yuviirnr_iMaxThreshH_UV   [7:0] AFIT8_yuviirnr_iYNRStrengthL
+{0x0F12,0x1A02},	// 70000C3A//AFIT8_yuviirnr_iYNRStrengthH   [7:0] AFIT8_yuviirnr_iUVNRStrengthL
+{0x0F12,0x8018},	// 70000C3C//AFIT8_yuviirnr_iUVNRStrengthH   [7:0] AFIT8_byr_gras_iShadingPower
+{0x0F12,0x0080},	// 70000C3E//AFIT8_RGBGamma2_iLinearity   [7:0] AFIT8_RGBGamma2_iDarkReduce
+{0x0F12,0x0080},	// 70000C40//AFIT8_ccm_oscar_iSaturation   [7:0] AFIT8_RGB2YUV_iYOffset
+{0x0F12,0x0180},	// 70000C42//AFIT8_RGB2YUV_iRGBGain   [7:0] AFIT8_bnr_nClustLevel_H
+{0x0F12,0x0A0A},	// 70000C44//AFIT8_bnr_iClustMulT_H   [7:0] AFIT8_bnr_iClustMulT_C
+{0x0F12,0x0101},	// 70000C46//AFIT8_bnr_iClustThresh_H   [7:0] AFIT8_bnr_iClustThresh_C
+{0x0F12,0x1129},	// 70000C48//AFIT8_bnr_iDenThreshLow   [7:0] AFIT8_bnr_iDenThreshHigh
+{0x0F12,0x6024},	// 70000C4A//AFIT8_ee_iLowSharpPower   [7:0] AFIT8_ee_iHighSharpPower
+{0x0F12,0x0A2E},	// 70000C4C//AFIT8_ee_iLowShDenoise   [7:0] AFIT8_ee_iHighShDenoise
+{0x0F12,0xFFFF},	// 70000C4E//AFIT8_ee_iLowSharpClamp   [7:0] AFIT8_ee_iHighSharpClamp
+{0x0F12,0x0808},	// 70000C50//AFIT8_ee_iReduceEdgeMinMult   [7:0] AFIT8_ee_iReduceEdgeSlope
+{0x0F12,0x0A01},	// 70000C52//AFIT8_bnr_nClustLevel_H_Bin   [7:0] AFIT8_bnr_iClustMulT_H_Bin
+{0x0F12,0x010A},	// 70000C54//AFIT8_bnr_iClustMulT_C_Bin   [7:0] AFIT8_bnr_iClustThresh_H_Bin
+{0x0F12,0x1501},	// 70000C56//AFIT8_bnr_iClustThresh_C_Bin   [7:0] AFIT8_bnr_iDenThreshLow_Bin
+{0x0F12,0x240F},	// 70000C58//AFIT8_bnr_iDenThreshHigh_Bin   [7:0] AFIT8_ee_iLowSharpPower_Bin
+{0x0F12,0x0A60},	// 70000C5A//AFIT8_ee_iHighSharpPower_Bin   [7:0] AFIT8_ee_iLowShDenoise_Bin
+{0x0F12,0xFF0A},	// 70000C5C//AFIT8_ee_iHighShDenoise_Bin   [7:0] AFIT8_ee_iLowSharpClamp_Bin
+{0x0F12,0x08FF},	// 70000C5E//AFIT8_ee_iHighSharpClamp_Bin   [7:0] AFIT8_ee_iReduceEdgeMinMult_Bin
+{0x0F12,0x0008},	// 70000C60//AFIT8_ee_iReduceEdgeSlope_Bin [7:0]
+{0x0F12,0x0001},	// 70000C62//AFITB_bnr_nClustLevel_C      [0]
+{0x0F12,0x0000},	// 70000C64//AFIT16_BRIGHTNESS
+{0x0F12,0x0018},	// 70000C66//AFIT16_CONTRAST
+{0x0F12,0x0010},	// 70000C68//AFIT16_SATURATION
+{0x0F12,0x0000},	// 70000C6A//AFIT16_SHARP_BLUR
+{0x0F12,0x0000},	// 70000C6C//AFIT16_GLAMOUR
+{0x0F12,0x00C0},	// 70000C6E//AFIT16_bnr_edge_high
+{0x0F12,0x0064},	// 70000C70//AFIT16_postdmsc_iLowBright
+{0x0F12,0x0384},	// 70000C72//AFIT16_postdmsc_iHighBright
+{0x0F12,0x0032},	// 70000C74//AFIT16_postdmsc_iLowSat
+{0x0F12,0x01F4},	// 70000C76//AFIT16_postdmsc_iHighSat
+{0x0F12,0x0070},	// 70000C78//AFIT16_postdmsc_iTune
+{0x0F12,0x0040},	// 70000C7A//AFIT16_yuvemix_mNegRanges_0
+{0x0F12,0x00A0},	// 70000C7C//AFIT16_yuvemix_mNegRanges_1
+{0x0F12,0x0100},	// 70000C7E//AFIT16_yuvemix_mNegRanges_2
+{0x0F12,0x0010},	// 70000C80//AFIT16_yuvemix_mPosRanges_0
+{0x0F12,0x0060},	// 70000C82//AFIT16_yuvemix_mPosRanges_1
+{0x0F12,0x0100},	// 70000C84//AFIT16_yuvemix_mPosRanges_2
+{0x0F12,0x1430},	// 70000C86//AFIT8_bnr_edge_low  [7:0] AFIT8_bnr_repl_thresh
+{0x0F12,0x0201},	// 70000C88//AFIT8_bnr_repl_force  [7:0] AFIT8_bnr_iHotThreshHigh
+{0x0F12,0x0204},	// 70000C8A//AFIT8_bnr_iHotThreshLow   [7:0] AFIT8_bnr_iColdThreshHigh
+{0x0F12,0x0F04},	// 70000C8C//AFIT8_bnr_iColdThreshLow   [7:0] AFIT8_bnr_DispTH_Low
+{0x0F12,0x030C},	// 70000C8E//AFIT8_bnr_DispTH_High   [7:0] AFIT8_bnr_DISP_Limit_Low
+{0x0F12,0x0003},	// 70000C90//AFIT8_bnr_DISP_Limit_High   [7:0] AFIT8_bnr_iDistSigmaMin
+{0x0F12,0x0602},	// 70000C92//AFIT8_bnr_iDistSigmaMax   [7:0] AFIT8_bnr_iDiffSigmaLow
+{0x0F12,0x1803},	// 70000C94//AFIT8_bnr_iDiffSigmaHigh   [7:0] AFIT8_bnr_iNormalizedSTD_TH
+{0x0F12,0x0040},	// 70000C96//AFIT8_bnr_iNormalizedSTD_Limit   [7:0] AFIT8_bnr_iDirNRTune
+{0x0F12,0x0E20},	// 70000C98//AFIT8_bnr_iDirMinThres   [7:0] AFIT8_bnr_iDirFltDiffThresHigh
+{0x0F12,0x2018},	// 70000C9A//AFIT8_bnr_iDirFltDiffThresLow   [7:0] AFIT8_bnr_iDirSmoothPowerHigh
+{0x0F12,0x0620},	// 70000C9C//AFIT8_bnr_iDirSmoothPowerLow   [7:0] AFIT8_bnr_iLowMaxSlopeAllowed
+{0x0F12,0x0306},	// 70000C9E//AFIT8_bnr_iHighMaxSlopeAllowed   [7:0] AFIT8_bnr_iLowSlopeThresh
+{0x0F12,0x2003},	// 70000CA0//AFIT8_bnr_iHighSlopeThresh   [7:0] AFIT8_bnr_iSlopenessTH
+{0x0F12,0xFF01},	// 70000CA2//AFIT8_bnr_iSlopeBlurStrength   [7:0] AFIT8_bnr_iSlopenessLimit
+{0x0F12,0x0404},	// 70000CA4//AFIT8_bnr_AddNoisePower1   [7:0] AFIT8_bnr_AddNoisePower2
+{0x0F12,0x0200},	// 70000CA6//AFIT8_bnr_iRadialTune   [7:0] AFIT8_bnr_iRadialPower
+{0x0F12,0x145A},	// 70000CA8//AFIT8_bnr_iRadialLimit   [7:0] AFIT8_ee_iFSMagThLow
+{0x0F12,0x1010},	// 70000CAA//AFIT8_ee_iFSMagThHigh   [7:0] AFIT8_ee_iFSVarThLow
+{0x0F12,0x000B},	// 70000CAC//AFIT8_ee_iFSVarThHigh   [7:0] AFIT8_ee_iFSThLow
+{0x0F12,0x1200},	// 70000CAE//AFIT8_ee_iFSThHigh   [7:0] AFIT8_ee_iFSmagPower
+{0x0F12,0x5A0F},	// 70000CB0//AFIT8_ee_iFSVarCountTh   [7:0] AFIT8_ee_iRadialLimit
+{0x0F12,0x0502},	// 70000CB2//AFIT8_ee_iRadialPower   [7:0] AFIT8_ee_iSmoothEdgeSlope
+{0x0F12,0x1802},	// 70000CB4//AFIT8_ee_iROADThres   [7:0] AFIT8_ee_iROADMaxNR
+{0x0F12,0x0000},	// 70000CB6//AFIT8_ee_iROADSubMaxNR   [7:0] AFIT8_ee_iROADSubThres
+{0x0F12,0x2006},	// 70000CB8//AFIT8_ee_iROADNeiThres   [7:0] AFIT8_ee_iROADNeiMaxNR
+{0x0F12,0x4028},	// 70000CBA//AFIT8_ee_iSmoothEdgeThres   [7:0] AFIT8_ee_iMSharpen
+{0x0F12,0x0430},	// 70000CBC//AFIT8_ee_iWSharpen   [7:0] AFIT8_ee_iMShThresh
+{0x0F12,0x0101},	// 70000CBE//AFIT8_ee_iWShThresh   [7:0] AFIT8_ee_iReduceNegative
+{0x0F12,0xFF00},	// 70000CC0//AFIT8_ee_iEmbossCentAdd   [7:0] AFIT8_ee_iShDespeckle
+{0x0F12,0x0804},	// 70000CC2//AFIT8_ee_iReduceEdgeThresh   [7:0] AFIT8_dmsc_iEnhThresh
+{0x0F12,0x4008},	// 70000CC4//AFIT8_dmsc_iDesatThresh   [7:0] AFIT8_dmsc_iDemBlurHigh
+{0x0F12,0x0540},	// 70000CC6//AFIT8_dmsc_iDemBlurLow   [7:0] AFIT8_dmsc_iDemBlurRange
+{0x0F12,0x8006},	// 70000CC8//AFIT8_dmsc_iDecisionThresh   [7:0] AFIT8_dmsc_iCentGrad
+{0x0F12,0x0020},	// 70000CCA//AFIT8_dmsc_iMonochrom   [7:0] AFIT8_dmsc_iGBDenoiseVal
+{0x0F12,0x0000},	// 70000CCC//AFIT8_dmsc_iGRDenoiseVal   [7:0] AFIT8_dmsc_iEdgeDesatThrHigh
+{0x0F12,0x1800},	// 70000CCE//AFIT8_dmsc_iEdgeDesatThrLow   [7:0] AFIT8_dmsc_iEdgeDesat
+{0x0F12,0x0000},	// 70000CD0//AFIT8_dmsc_iNearGrayDesat   [7:0] AFIT8_dmsc_iEdgeDesatLimit
+{0x0F12,0x1E10},	// 70000CD2//AFIT8_postdmsc_iBCoeff   [7:0] AFIT8_postdmsc_iGCoeff
+{0x0F12,0x000B},	// 70000CD4//AFIT8_postdmsc_iWideMult   [7:0] AFIT8_yuvemix_mNegSlopes_0
+{0x0F12,0x0607},	// 70000CD6//AFIT8_yuvemix_mNegSlopes_1   [7:0] AFIT8_yuvemix_mNegSlopes_2
+{0x0F12,0x0005},	// 70000CD8//AFIT8_yuvemix_mNegSlopes_3   [7:0] AFIT8_yuvemix_mPosSlopes_0
+{0x0F12,0x0607},	// 70000CDA//AFIT8_yuvemix_mPosSlopes_1   [7:0] AFIT8_yuvemix_mPosSlopes_2
+{0x0F12,0x0405},	// 70000CDC//AFIT8_yuvemix_mPosSlopes_3   [7:0] AFIT8_yuviirnr_iXSupportY
+{0x0F12,0x0205},	// 70000CDE//AFIT8_yuviirnr_iXSupportUV   [7:0] AFIT8_yuviirnr_iLowYNorm
+{0x0F12,0x0304},	// 70000CE0//AFIT8_yuviirnr_iHighYNorm   [7:0] AFIT8_yuviirnr_iLowUVNorm
+{0x0F12,0x0409},	// 70000CE2//AFIT8_yuviirnr_iHighUVNorm   [7:0] AFIT8_yuviirnr_iYNormShift
+{0x0F12,0x0306},	// 70000CE4//AFIT8_yuviirnr_iUVNormShift   [7:0] AFIT8_yuviirnr_iVertLength_Y
+{0x0F12,0x0407},	// 70000CE6//AFIT8_yuviirnr_iVertLength_UV   [7:0] AFIT8_yuviirnr_iDiffThreshL_Y
+{0x0F12,0x2C04},	// 70000CE8//AFIT8_yuviirnr_iDiffThreshH_Y   [7:0] AFIT8_yuviirnr_iDiffThreshL_UV
+{0x0F12,0x022C},	// 70000CEA//AFIT8_yuviirnr_iDiffThreshH_UV   [7:0] AFIT8_yuviirnr_iMaxThreshL_Y
+{0x0F12,0x1402},	// 70000CEC//AFIT8_yuviirnr_iMaxThreshH_Y   [7:0] AFIT8_yuviirnr_iMaxThreshL_UV
+{0x0F12,0x0618},	// 70000CEE//AFIT8_yuviirnr_iMaxThreshH_UV   [7:0] AFIT8_yuviirnr_iYNRStrengthL
+{0x0F12,0x1A02},	// 70000CF0//AFIT8_yuviirnr_iYNRStrengthH   [7:0] AFIT8_yuviirnr_iUVNRStrengthL
+{0x0F12,0x8018},	// 70000CF2//AFIT8_yuviirnr_iUVNRStrengthH   [7:0] AFIT8_byr_gras_iShadingPower
+{0x0F12,0x0080},	// 70000CF4//AFIT8_RGBGamma2_iLinearity   [7:0] AFIT8_RGBGamma2_iDarkReduce
+{0x0F12,0x0080},	// 70000CF6//AFIT8_ccm_oscar_iSaturation   [7:0] AFIT8_RGB2YUV_iYOffset
+{0x0F12,0x0180},	// 70000CF8//AFIT8_RGB2YUV_iRGBGain   [7:0] AFIT8_bnr_nClustLevel_H
+{0x0F12,0x0A0A},	// 70000CFA//AFIT8_bnr_iClustMulT_H   [7:0] AFIT8_bnr_iClustMulT_C
+{0x0F12,0x0101},	// 70000CFC//AFIT8_bnr_iClustThresh_H   [7:0] AFIT8_bnr_iClustThresh_C
+{0x0F12,0x0C22},	// 70000CFE//AFIT8_bnr_iDenThreshLow   [7:0] AFIT8_bnr_iDenThreshHigh
+{0x0F12,0x6024},	// 70000D00//AFIT8_ee_iLowSharpPower   [7:0] AFIT8_ee_iHighSharpPower
+{0x0F12,0x0808},	// 70000D02//AFIT8_ee_iLowShDenoise   [7:0] AFIT8_ee_iHighShDenoise
+{0x0F12,0xFFFF},	// 70000D04//AFIT8_ee_iLowSharpClamp   [7:0] AFIT8_ee_iHighSharpClamp
+{0x0F12,0x0808},	// 70000D06//AFIT8_ee_iReduceEdgeMinMult   [7:0] AFIT8_ee_iReduceEdgeSlope
+{0x0F12,0x0A01},	// 70000D08//AFIT8_bnr_nClustLevel_H_Bin   [7:0] AFIT8_bnr_iClustMulT_H_Bin
+{0x0F12,0x010A},	// 70000D0A//AFIT8_bnr_iClustMulT_C_Bin   [7:0] AFIT8_bnr_iClustThresh_H_Bin
+{0x0F12,0x0F01},	// 70000D0C//AFIT8_bnr_iClustThresh_C_Bin   [7:0] AFIT8_bnr_iDenThreshLow_Bin
+{0x0F12,0x240C},	// 70000D0E//AFIT8_bnr_iDenThreshHigh_Bin   [7:0] AFIT8_ee_iLowSharpPower_Bin
+{0x0F12,0x0860},	// 70000D10//AFIT8_ee_iHighSharpPower_Bin   [7:0] AFIT8_ee_iLowShDenoise_Bin
+{0x0F12,0xFF08},	// 70000D12//AFIT8_ee_iHighShDenoise_Bin   [7:0] AFIT8_ee_iLowSharpClamp_Bin
+{0x0F12,0x08FF},	// 70000D14//AFIT8_ee_iHighSharpClamp_Bin   [7:0] AFIT8_ee_iReduceEdgeMinMult_Bin
+{0x0F12,0x0008},	// 70000D16//AFIT8_ee_iReduceEdgeSlope_Bin [7:0]
+{0x0F12,0x0001},  //70000D18 AFITB_bnr_nClustLevel_C      [0]   bWideWide[1]  
+{0x0F12,0x23CE},	// 70000D19//ConstAfitBaseVals
+{0x0F12,0xFDC8},	// 70000D1A//ConstAfitBaseVals
+{0x0F12,0x112E},	// 70000D1B//ConstAfitBaseVals
+{0x0F12,0x93A5},	// 70000D1C//ConstAfitBaseVals
+{0x0F12,0xFE67},	// 70000D1D//ConstAfitBaseVals
+{0x0F12,0x0000},	// 70000D1E//ConstAfitBaseVals
+
+
 
 //==================================================================================
-// 06.Clock Setting
+// 19.Input Size Setting
 //==================================================================================
-//Input Clock (Mclk)		
-{0x002A, 0x01F8},	
-{0x0F12, 0x5DC0},	 //REG_TC_IPRM_InClockLSBs
-{0x002A, 0x0212},	                                     
-{0x0F12, 0x0000},	 //REG_TC_IPRM_UseNPviClocks          
-{0x0F12, 0x0002},	 //REG_TC_IPRM_UseNMipiClocks         
-{0x0F12, 0x0002},	 //REG_TC_IPRM_NumberOfMipiLanes
-
-//System Clock & Output clock (Pclk)	
-
-{0x002A, 0x021A},	
-{0x0F12, 0x3A98},	 //REG_TC_IPRM_OpClk4KHz_0 
-{0x0F12, 0x278D},	 //4F1A	 //REG_TC_IPRM_MinOutRate4KHz_0
-{0x0F12, 0x278D},	 //4F1A	 //REG_TC_IPRM_MaxOutRate4KHz_0
-     
-{0x0F12, 0x4F1A},	 //REG_TC_IPRM_OpClk4KHz_11
-{0x0F12, 0x278D},	 //4F1A	 //REG_TC_IPRM_MinOutRate4KHz_1
-{0x0F12, 0x278D},	 //4F1A	 //REG_TC_IPRM_MaxOutRate4KHz_1
-
-{0x002A, 0x022C},	
-{0x0F12, 0x0001},	 //REG_TC_IPRM_InitParamsUpdated	
-
-     
+//Input Size
+{0x002A,0x0250},
+{0x0F12,0x0A00},	// REG_TC_GP_PrevReqInputWidth
+{0x0F12,0x0780},	// REG_TC_GP_PrevReqInputHeight
+{0x0F12,0x0010},	// REG_TC_GP_PrevInputWidthOfs
+{0x0F12,0x000C},	// REG_TC_GP_PrevInputHeightOfs
+{0x0F12,0x0A00},	// REG_TC_GP_CapReqInputWidth
+{0x0F12,0x0780},	// REG_TC_GP_CapReqInputHeight
+{0x0F12,0x0010},	// REG_TC_GP_CapInputWidthOfs
+{0x0F12,0x000C},	// REG_TC_GP_CapInputHeightOfs
+{0x002A,0x0494},
+{0x0F12,0x0A00},	// REG_TC_PZOOM_ZoomInputWidth
+{0x0F12,0x0780},	// REG_TC_PZOOM_ZoomInputHeight
+{0x0F12,0x0000},	// REG_TC_PZOOM_ZoomInputWidthOfs
+{0x0F12,0x0000},	// REG_TC_PZOOM_ZoomInputHeightOfs
+{0x0F12,0x0A00},	// REG_TC_CZOOM_ZoomInputWidth
+{0x0F12,0x0780},	// REG_TC_CZOOM_ZoomInputHeight
+{0x0F12,0x0000},	// REG_TC_CZOOM_ZoomInputWidthOfs
+{0x0F12,0x0000},	// REG_TC_CZOOM_ZoomInputHeightOfs
+{0x002A,0x0262},
+{0x0F12,0x0001},	// REG_TC_GP_bUseReqInputInPre
+{0x0F12,0x0001},	// REG_TC_GP_bUseReqInputInCap
+
 //==================================================================================
-// 08.Preview & Capture Configration Setting
+// 20.Preview & Capture Configration Setting
 //==================================================================================
+//Preview config[0] 640x480
+//Normal mode(VGA preview ) 
+{0x002A,0x02A6},                                                                          
+{0x0F12,0x0280},//REG_0TC_PCFG_usWidth                                                 
+{0x0F12,0x01E0},  //REG_0TC_PCFG_usHeight                                                
+{0x0F12,0x0005}, //REG_0TC_PCFG_Format	5 YUV	7 Raw	9 JPG                      
+{0x0F12,0x279D},  //REG_0TC_PCFG_usMaxOut4KHzRate                                         
+{0x0F12,0x277D}, //REG_0TC_PCFG_usMinOut4KHzRate                                        
+{0x0F12,0x0100},  //REG_0TC_PCFG_OutClkPerPix88                                          
+{0x0F12,0x0300},  //REG_0TC_PCFG_uBpp88                                                  
+{0x0F12,0x0012},  //REG_0TC_PCFG_PVIMask                                                 
+{0x0F12,0x0000},  //REG_0TC_PCFG_OIFMask                                                 
+{0x0F12,0x01E0},  //REG_0TC_PCFG_usJpegPacketSize                                        
+{0x0F12,0x0000},  //REG_0TC_PCFG_usJpegTotalPackets                                      
+{0x0F12,0x0000},  //REG_0TC_PCFG_uClockInd                                               
+{0x0F12,0x0000},  //REG_0TC_PCFG_usFrTimeType                                            
+{0x0F12,0x0001},  //REG_0TC_PCFG_FrRateQualityType                                       
+{0x0F12,0x03E8},  //REG_0TC_PCFG_usMaxFrTimeMsecMult10                                   
+{0x0F12,0x014A},  //REG_0TC_PCFG_usMinFrTimeMsecMult10                                   
+{0x002A,0x02D0},                                                                          
+{0x0F12,0x0000}, //REG_0TC_PCFG_uPrevMirror                                             
+{0x0F12,0x0000},  //REG_0TC_PCFG_uCaptureMirror                                          
+{0x0F12,0x0000}, //REG_0TC_PCFG_uRotation                                               
+ 
+ 
+ //Preview config[1] 1280x720	                                                   
+//Normal mode(SXGA preview )                                                       
+{0x002A,0x02D6},                                                                          
+{0x0F12,0x0500},//REG_1TC_PCFG_usWidth                                                 
+{0x0F12,0x02D0},  //REG_1TC_PCFG_usHeight                                                
+{0x0F12,0x0005},  //REG_1TC_PCFG_Format	5 YUV	7 Raw	9 JPG                      
+{0x0F12,0x279D},  //REG_1TC_PCFG_usMaxOut4KHzRate                                        
+{0x0F12,0x277D},  //REG_1TC_PCFG_usMinOut4KHzRate                                        
+{0x0F12,0x0100}, //REG_1TC_PCFG_OutClkPerPix88                                          
+{0x0F12,0x0300},  //REG_1TC_PCFG_uBpp88                                                  
+{0x0F12,0x0012},  //REG_1TC_PCFG_PVIMask                                                 
+{0x0F12,0x0000},  //REG_1TC_PCFG_OIFMask                                                 
+{0x0F12,0x01E0},  //REG_1TC_PCFG_usJpegPacketSize                                        
+{0x0F12,0x0000},  //REG_1TC_PCFG_usJpegTotalPackets                                      
+{0x0F12,0x0000},  //REG_1TC_PCFG_uClockInd                                               
+{0x0F12,0x0000},  //REG_1TC_PCFG_usFrTimeType
+{0x0F12,0x0001},  //REG_1TC_PCFG_FrRateQualityType                                                                                   	
+{0x0F12,0x0535},  //REG_1TC_PCFG_usMaxFrTimeMsecMult10                                   
+{0x0F12,0x014d},  //REG_1TC_PCFG_usMinFrTimeMsecMult10                                   
+{0x002A,0x0300},                                                                          
+{0x0F12,0x0000},  //REG_1TC_PCFG_uPrevMirror                                             
+{0x0F12,0x0000}, //REG_1TC_PCFG_uCaptureMirror                                          
+{0x0F12,0x0000},//REG_1TC_PCFG_uRotation  
+ 
+ 
+ 
+    	                                                                              
+//Preview config[2] 1280x860 	                                                   
+//Normal mode(SXGA preview )                                                       
+{0x002A,0x0306},                                                                          
+{0x0F12,0x0800},//0500  //REG_2TC_PCFG_usWidth                                                 
+{0x0F12,0x0600},//03C0  //REG_2TC_PCFG_usHeight                                                
+{0x0F12,0x0005}, //REG_2TC_PCFG_Format	5 YUV	7 Raw	9 JPG                      
+{0x0F12,0x279D},  //REG_2TC_PCFG_usMaxOut4KHzRate                                        
+{0x0F12,0x277D}, //REG_2TC_PCFG_usMinOut4KHzRate                                        
+{0x0F12,0x0100}, //REG_2TC_PCFG_OutClkPerPix88                                          
+{0x0F12,0x0300},  //REG_2TC_PCFG_uBpp88                                                  
+{0x0F12,0x0012},  //REG_2TC_PCFG_PVIMask                                                 
+{0x0F12,0x0000},  //REG_2TC_PCFG_OIFMask                                                 
+{0x0F12,0x01E0},  //REG_2TC_PCFG_usJpegPacketSize                                        
+{0x0F12,0x0000},  //REG_2TC_PCFG_usJpegTotalPackets                                      
+{0x0F12,0x0000},  //REG_2TC_PCFG_uClockInd                                               
+{0x0F12,0x0000},  //REG_2TC_PCFG_usFrTimeType
+{0x0F12,0x0002},  //REG_2TC_PCFG_FrRateQualityType                                                                                   	
+{0x0F12,0x07d0},  //REG_2TC_PCFG_usMaxFrTimeMsecMult10                                   
+{0x0F12,0x0000},  //REG_2TC_PCFG_usMinFrTimeMsecMult10                                   
+{0x002A,0x0330},                                                                         
+{0x0F12,0x0000},  //REG_2TC_PCFG_uPrevMirror                                             
+{0x0F12,0x0000},  //REG_2TC_PCFG_uCaptureMirror                                          
+{0x0F12,0x0000},  //REG_2TC_PCFG_uRotation         
+
+//Preview config[3] 2560x1920 	                                                   
+//Normal mode(5M preview )                                                       
+{0x002A,0x0336},                                                                         
+{0x0F12,0x0A00},  //REG_3TC_PCFG_usWidth                                                 
+{0x0F12,0x0780},  //REG_3TC_PCFG_usHeight                                                
+{0x0F12,0x0005},  //REG_3TC_PCFG_Format	5 YUV	7 Raw	9 JPG                      
+{0x0F12,0x279D},  //REG_3TC_PCFG_usMaxOut4KHzRate                                        
+{0x0F12,0x277D},  //REG_3TC_PCFG_usMinOut4KHzRate                                        
+{0x0F12,0x0100}, //REG_3TC_PCFG_OutClkPerPix88                                          
+{0x0F12,0x0300},  //REG_3TC_PCFG_uBpp88                                                  
+{0x0F12,0x0012},  //REG_3TC_PCFG_PVIMask                                                 
+{0x0F12,0x0000},  //REG_3TC_PCFG_OIFMask                                                 
+{0x0F12,0x01E0},  //REG_3TC_PCFG_usJpegPacketSize                                        
+{0x0F12,0x0000},  //REG_3TC_PCFG_usJpegTotalPackets                                      
+{0x0F12,0x0000},  //REG_3TC_PCFG_uClockInd                                               
+{0x0F12,0x0000},  //REG_3TC_PCFG_usFrTimeType                                            
+{0x0F12,0x0002},  //REG_3TC_PCFG_FrRateQualityType                                       
+{0x0F12,0x07D0},  //REG_3TC_PCFG_usMaxFrTimeMsecMult10                                   
+{0x0F12,0x07D0},  //REG_3TC_PCFG_usMinFrTimeMsecMult10                                   
+{0x002A,0x0360},                                                                         
+{0x0F12,0x0000},  //REG_3TC_PCFG_uPrevMirror                                             
+{0x0F12,0x0000},  //REG_3TC_PCFG_uCaptureMirror                                          
+{0x0F12,0x0000},  //REG_3TC_PCFG_uRotation    
+
+
+                                                                  
+{0x002A,0x0396},                                                                          
+{0x0F12,0x0001},  //REG_0TC_CCFG_uCaptureMode                                            
+{0x0F12,0x0A00},  //REG_0TC_CCFG_usWidth                                                 
+{0x0F12,0x0780},  //REG_0TC_CCFG_usHeight                                                
+{0x0F12,0x0005},  //REG_0TC_CCFG_Format                                                  
+{0x0F12,0x279D},  //REG_0TC_CCFG_usMaxOut4KHzRate                                        
+{0x0F12,0x277D},  //REG_0TC_CCFG_usMinOut4KHzRate                                        
+{0x0F12,0x0100}, //REG_0TC_CCFG_OutClkPerPix88                                          
+{0x0F12,0x0300},  //REG_0TC_CCFG_uBpp88                                                  
+{0x0F12,0x0012},  //REG_0TC_CCFG_PVIMask                                                 
+{0x0F12,0x0070},  //REG_0TC_CCFG_OIFMask                                                 
+{0x0F12,0x0810},  //REG_0TC_CCFG_usJpegPacketSize                                        
+{0x0F12,0x0900},  //REG_0TC_CCFG_usJpegTotalPackets                                      
+{0x0F12,0x0001},  //REG_0TC_CCFG_uClockInd                                               
+{0x0F12,0x0000},  //REG_0TC_CCFG_usFrTimeType                                            
+{0x0F12,0x0002},  //REG_0TC_CCFG_FrRateQualityType                                       
+{0x0F12,0x0535},  //REG_0TC_CCFG_usMaxFrTimeMsecMult10                                   
+{0x0F12,0x029A},  //REG_0TC_CCFG_usMinFrTimeMsecMult10                                                                             
+                                                                         
+                                                                         	                                                                       
+{0x002A,0x1CC2},  //DRx_uDRxWeight for AutoCont function                                 
+{0x0F12,0x0100},                                                                          
+{0x0F12,0x0100},                                                                          
+{0x0F12,0x0100},                                                                          
+{0x0F12,0x0100},                                                                          	                                                                              
+{0x002A,0x022C},                                                                          
+{0x0F12,0x0001}, //REG_TC_IPRM_InitParamsUpdated    
+
+//==================================================================================
+// 21.Select Cofigration Display
+//==================================================================================
+//PREVIEW                                                                  
+
+{0x0028,0x7000},//many insert
+{0x002A,0x0266},
+{0x0F12,0x0000},	// REG_TC_GP_ActivePrevConfig
+{0x002A,0x026A},
+{0x0F12,0x0001},	// REG_TC_GP_PrevOpenAfterChange
+{0x002A,0x0268},
+{0x0F12,0x0001},	// REG_TC_GP_PrevConfigChanged
+{0x002A,0x026E},
+{0x0F12,0x0000},	// REG_TC_GP_ActiveCapConfig
+{0x002A,0x026A},
+{0x0F12,0x0001},	// REG_TC_GP_CapOpenAfterChange
+{0x002A,0x0270},
+{0x0F12,0x0001},	// REG_TC_GP_CapConfigChanged
+{0x002A,0x024E},
+{0x0F12,0x0001},	// REG_TC_GP_NewConfigSync
+{0x002A,0x023E},
+{0x0F12,0x0001},	// REG_TC_GP_EnablePreview
+{0x0F12,0x0001},	// REG_TC_GP_EnablePreviewChanged
+//===================================================================================
+// 22. ESD Check
+//===================================================================================
+
+{0x002A,0x01A8},
+{0x0F12,0xAAAA},
+
+//===================================================================================
+// 23. Brightness min/Max
+//===================================================================================
+{0x0028,0x147C},
+{0x002A,0x01AA},
+{0x0F12,0x0180},	// bp_uMaxBrightnessFactor
+{0x0028,0x1482},
+{0x002A,0x01AC},
+{0x0F12,0x0180},	// bp_uMinBrightnessFactor
+
+};
+////////////////////////////////////////////////////////////////
+// Automatically written by Setfile Rule Check function.
+// Date: 2013-04-26 10:37:00 
+//WRITE #REG_TC_GP_InvokeReadOTPData 0001
+////////////////////////////////////////////////////////////////                       	                         
+
+//for capture                                                                    	    
+static struct regval_list sensor_qsxga_regs[] = { //qsxga: 2560*1920  7fps
 //Preview config[0] 64480  7.5~15fps	
-{0x002A, 0x02A6},	
-{0x0F12, 0x0280},	 //REG_0TC_PCFG_usWidth              	
-{0x0F12, 0x01E0},	 //REG_0TC_PCFG_usHeight             	
+{0x002A, 0x0336},	
+{0x0F12, 0x0A00},	 //REG_0TC_PCFG_usWidth              	
+{0x0F12, 0x0780},	 //REG_0TC_PCFG_usHeight             	
 {0x0F12, 0x0005},	 //REG_0TC_PCFG_Format	                
-{0x0F12, 0x278D},	 //4F1A	 //REG_0TC_PCFG_usMaxOut4KHzRate     	
-{0x0F12, 0x278D},	 //4F1A	 //REG_0TC_PCFG_usMinOut4KHzRate     	
+{0x0F12, 0x279D},	 //4F1A	 //REG_0TC_PCFG_usMaxOut4KHzRate     	
+{0x0F12, 0x277D},	 //4F1A	 //REG_0TC_PCFG_usMinOut4KHzRate     	
 {0x0F12, 0x0100},	 //REG_0TC_PCFG_OutClkPerPix88       	
 {0x0F12, 0x0300},	 //REG_0TC_PCFG_uBpp88               	
-{0x0F12, 0x0002},	 //REG_0TC_PCFG_PVIMask              	
+{0x0F12, 0x0012},	 //REG_0TC_PCFG_PVIMask              	
 {0x0F12, 0x0000},	 //REG_0TC_PCFG_OIFMask              	
 {0x0F12, 0x01E0},	 //REG_0TC_PCFG_usJpegPacketSize     	
 {0x0F12, 0x0000},	 //REG_0TC_PCFG_usJpegTotalPackets   	
 {0x0F12, 0x0000},	 //REG_0TC_PCFG_uClockInd            	
 {0x0F12, 0x0000},	 //REG_0TC_PCFG_usFrTimeType         	
-{0x0F12, 0x0001},	 //REG_0TC_PCFG_FrRateQualityType    	
-{0x0F12, 0x03E8},	 //029A  //REG_0TC_PCFG_usMaxFrTimeMsecMult10	
-{0x0F12, 0x014A},	 //REG_0TC_PCFG_usMinFrTimeMsecMult10	
-{0x002A, 0x02D0},	
-{0x0F12, 0x0002},	 //REG_0TC_PCFG_uPrevMirror
-{0x0F12, 0x0002},	 //REG_0TC_PCFG_uCaptureMirror
-
-//Capture Config[0] 2561920   7.5~15fps                           	
-{0x002A, 0x0396},                                     	
-{0x0F12, 0x0001},	 //REG_0TC_CCFG_uCaptureMode         
-{0x0F12, 0x0A00},	 //REG_0TC_CCFG_usWidth              
-{0x0F12, 0x0780},	 //REG_0TC_CCFG_usHeight             
-{0x0F12, 0x0005},	 //REG_0TC_CCFG_Format               
-{0x0F12, 0x278D},	 //4F1A	 //REG_0TC_CCFG_usMaxOut4KHzRate     
-{0x0F12, 0x278D},	 //4F1A	 //REG_0TC_CCFG_usMinOut4KHzRate     
-{0x0F12, 0x0100},	 //REG_0TC_CCFG_OutClkPerPix88       
-{0x0F12, 0x0300},	 //REG_0TC_CCFG_uBpp88               
-{0x0F12, 0x0002},	 //REG_0TC_CCFG_PVIMask              
-{0x0F12, 0x0070},	 //REG_0TC_CCFG_OIFMask              
-{0x0F12, 0x0810},	 //REG_0TC_CCFG_usJpegPacketSize     
-{0x0F12, 0x0900},	 //REG_0TC_CCFG_usJpegTotalPackets   
-{0x0F12, 0x0001},	 //REG_0TC_CCFG_uClockInd            
-{0x0F12, 0x0000},	 //REG_0TC_CCFG_usFrTimeType         
-{0x0F12, 0x0002},	 //REG_0TC_CCFG_FrRateQualityType    
-{0x0F12, 0x07d0},	 //REG_0TC_CCFG_usMaxFrTimeMsecMult10
-{0x0F12, 0x07d0},	 //REG_0TC_CCFG_usMinFrTimeMsecMult10
-
-
+{0x0F12, 0x0002},	 //REG_0TC_PCFG_FrRateQualityType    	
+{0x0F12, 0x07D0},	 //029A  //REG_0TC_PCFG_usMaxFrTimeMsecMult10	
+{0x0F12, 0x07D0},	 //REG_0TC_PCFG_usMinFrTimeMsecMult10	
 
 
 //==================================================================================
@@ -3166,497 +3934,201 @@ static struct regval_list sensor_default_regs[] = {
 
 {0x0028, 0x7000},//many insert
 {0x002A, 0x0266},   
-{0x0F12, 0x0000},	 //REG_TC_GP_ActivePrevConfig        		
+{0x0F12, 0x0003},	 //REG_TC_GP_ActivePrevConfig        		
 {0x002A, 0x026A},                                    
 {0x0F12, 0x0001},	 //REG_TC_GP_PrevOpenAfterChange     		
-{0x002A, 0x024E},                                    
-{0x0F12, 0x0001},	 //REG_TC_GP_NewConfigSync           		
 {0x002A, 0x0268},                                    
+{0x0F12, 0x0001},	 //REG_TC_GP_NewConfigSync           		
+{0x002A, 0x024E},                                    
 {0x0F12, 0x0001},	 //REG_TC_GP_PrevConfigChanged       		
-{0x002A, 0x0270},
-{0x0F12, 0x0001},	 //REG_TC_GP_CapConfigChanged
-{0x002A, 0x023E},                                    
+{0x002A, 0x023E},
+{0x0F12, 0x0001},	 //REG_TC_GP_CapConfigChanged                                    
 {0x0F12, 0x0001},	 //REG_TC_GP_EnablePreview           	
-{0x0F12, 0x0001},	 //REG_TC_GP_EnablePreviewChanged
-//===================================================================================
-// 22. ESD Check
-//===================================================================================
-
-{0x002A,	0x01A8},
-{0x0F12,	0xAAAA},
+//=============================================
 
-//===================================================================================
-// 23. Brightness min/Max
-//===================================================================================
-{0x0028,	0x147C},
-{0x002A,	0x01AA},
-{0x0F12,	0x0180},	//bp_uMaxBrightnessFactor
-{0x0028,	0x1482},
-{0x002A,	0x01AC},
-{0x0F12,	0x0180},	//bp_uMinBrightnessFactor
-
-//===================================================================================
-// 24.ISSUE
-//===================================================================================
-//20110728 : Sequence Changed by image dev.(by J.M.Ahn)
-//20110728 : ESD Check Register Address Change
-//20110829 : TnP Changed by S.Y.Lee
-//20120104 : init Parm Update sequence changed(by J.M.Ahn)
-//20120201 : Flash ֺ Green Noise  setting (by J.M.Ahn)
-//20120228 : Add Brightness Block
-//20120717 : Lowtemp bypass Ŵ
+{0xffff, 0x00c8},  //delay 200ms*/
 };
-////////////////////////////////////////////////////////////////
-// Automatically written by Setfile Rule Check function.
-// Date: 2013-04-26 10:37:00 
-//WRITE #REG_TC_GP_InvokeReadOTPData 0001
-////////////////////////////////////////////////////////////////                       	                         
-
-#if 0
-//for capture                                                                    	    
-static struct regval_list sensor_qsxga_regs[] = { //qsxga: 2560*1920  5fps
-/* capture setting */
-
-//==================================================================================
-// 20.Preview & Capture Configration Setting
-//==================================================================================
-{0x002A, 0x0396},                                     	
-{0x0F12, 0x0001},	//REG_0TC_CCFG_uCaptureMode         
-{0x0F12, 0x0A00},	//REG_0TC_CCFG_usWidth              
-{0x0F12, 0x0780},	//REG_0TC_CCFG_usHeight
-{0x002A, 0x03AE},                                     	
-{0x0F12, 0x0000},	//REG_0TC_CCFG_uClockInd 
-{0x002A, 0x03B4},                                     	
-{0x0F12, 0x07D0},	//REG_0TC_CCFG_usMaxFrTimeMsecMult10
-{0x0F12, 0x07D0},	//REG_0TC_CCFG_usMinFrTimeMsecMult10
 
-//==================================================================================
-// 21.Select Cofigration Display
-//==================================================================================
-//CAPTURE
-{0xFCFC, 0xD000},
-{0x0028, 0x7000},
-{0x002A, 0x026E},
-{0x0F12, 0x0000}, //REG_TC_GP_ActiveCapConfig
-{0x0F12, 0x0001}, // /
-{0x002A, 0x0242}, // 
-{0x0F12, 0x0001}, // /#REG_TC_GP_EnableCapture
-{0x002A, 0x024E}, // 
-{0x0F12, 0x0001}, // /#REG_TC_GP_NewConfigSync
-{0x002A, 0x0244}, // 
-{0x0F12, 0x0001}, // /#REG_TC_GP_EnableCaptureChanged
-
-{0xffff, 0x00c8},  //delay 200ms
-};
 
+static struct regval_list sensor_qxga_regs[] = { //qxga: 2048*1536
 
-#else
-//for capture                                                                    	    
-static struct regval_list sensor_qsxga_regs[] = { //qsxga: 2560*1920  7fps
-/* capture setting */
+//Preview config[0] 64480  7.5~15fps	
+{0x002A, 0x0306},	
+{0x0F12, 0x0800},	 //REG_0TC_PCFG_usWidth              	
+{0x0F12, 0x0600},	 //REG_0TC_PCFG_usHeight             	
+{0x0F12, 0x0005},	 //REG_0TC_PCFG_Format	                
+{0x0F12, 0x279D},	 //4F1A	 //REG_0TC_PCFG_usMaxOut4KHzRate     	
+{0x0F12, 0x277D},	 //4F1A	 //REG_0TC_PCFG_usMinOut4KHzRate     	
+{0x0F12, 0x0100},	 //REG_0TC_PCFG_OutClkPerPix88       	
+{0x0F12, 0x0300},	 //REG_0TC_PCFG_uBpp88               	
+{0x0F12, 0x0012},	 //REG_0TC_PCFG_PVIMask              	
+{0x0F12, 0x0000},	 //REG_0TC_PCFG_OIFMask              	
+{0x0F12, 0x01E0},	 //REG_0TC_PCFG_usJpegPacketSize     	
+{0x0F12, 0x0000},	 //REG_0TC_PCFG_usJpegTotalPackets   	
+{0x0F12, 0x0000},	 //REG_0TC_PCFG_uClockInd            	
+{0x0F12, 0x0000},	 //REG_0TC_PCFG_usFrTimeType         	
+{0x0F12, 0x0002},	 //REG_0TC_PCFG_FrRateQualityType    	
+{0x0F12, 0x07D0},	 //029A  //REG_0TC_PCFG_usMaxFrTimeMsecMult10	
+{0x0F12, 0x0000},	 //REG_0TC_PCFG_usMinFrTimeMsecMult10	
+	
 
-//==================================================================================
-// 20.Preview & Capture Configration Setting
-//==================================================================================
-{0x002A, 0x0396},                                     	
-{0x0F12, 0x0001},	//REG_0TC_CCFG_uCaptureMode         
-{0x0F12, 0x0A00},	//REG_0TC_CCFG_usWidth              
-{0x0F12, 0x0780},	//REG_0TC_CCFG_usHeight
-{0x002A, 0x03AE},                                     	
-{0x0F12, 0x0000},	//REG_0TC_CCFG_uClockInd            
-{0x002A, 0x03B4},      
-{0x0F12, 0x0535},	//REG_0TC_CCFG_usMaxFrTimeMsecMult10
-{0x0F12, 0x0535},	//REG_0TC_CCFG_usMinFrTimeMsecMult10
 
 //==================================================================================
-// 21.Select Cofigration Display
+// 19.Select Cofigration Display
 //==================================================================================
-//CAPTURE
-{0xFCFC, 0xD000},
-{0x0028, 0x7000},
-{0x002A, 0x026E},
-{0x0F12, 0x0000}, //REG_TC_GP_ActiveCapConfig
-{0x0F12, 0x0001}, // /
-{0x002A, 0x0242}, // 
-{0x0F12, 0x0001}, // /#REG_TC_GP_EnableCapture
-{0x002A, 0x024E}, // 
-{0x0F12, 0x0001}, // /#REG_TC_GP_NewConfigSync
-{0x002A, 0x0244}, // 
-{0x0F12, 0x0001}, // /#REG_TC_GP_EnableCaptureChanged
-
-{0xffff, 0x00c8},  //delay 200ms
-};
-#endif
-
-static struct regval_list sensor_qxga_regs[] = { //qxga: 2048*1536
-/* capture setting */
+//PREVIEW                                                                        		
 
-//==================================================================================
-// 20.Preview & Capture Configration Setting
-//==================================================================================
-{0x002A, 0x0396},                                     	
-{0x0F12, 0x0001},	//REG_0TC_CCFG_uCaptureMode         
-{0x0F12, 0x0800},	//REG_0TC_CCFG_usWidth              
-{0x0F12, 0x0600},	//REG_0TC_CCFG_usHeight
-{0x002A, 0x03AE},                                     	
-{0x0F12, 0x0000},	//REG_0TC_CCFG_uClockInd    
-{0x002A, 0x03B4},                                     	
-{0x0F12, 0x0535},	//REG_0TC_CCFG_usMaxFrTimeMsecMult10
-{0x0F12, 0x0535},	//REG_0TC_CCFG_usMinFrTimeMsecMult10
+{0x0028, 0x7000},//many insert
+{0x002A, 0x0266},   
+{0x0F12, 0x0002},	 //REG_TC_GP_ActivePrevConfig        		
+{0x002A, 0x026A},                                    
+{0x0F12, 0x0001},	 //REG_TC_GP_PrevOpenAfterChange     		       		
+{0x002A, 0x0268},                                    
+{0x0F12, 0x0001},	 //REG_TC_GP_PrevConfigChanged  
+{0x002A, 0x024E},									 
+{0x0F12, 0x0001},	 //REG_TC_GP_NewConfigSync	  
+{0x002A, 0x023E},                                    
+{0x0F12, 0x0001},	 //REG_TC_GP_EnablePreview           	
+{0x0F12, 0x0001},	 //REG_TC_GP_EnablePreviewChanged
+//=============================================
 
-//==================================================================================
-// 21.Select Cofigration Display
-//==================================================================================
-//CAPTURE
-{0xFCFC, 0xD000},
-{0x0028, 0x7000},
-{0x002A, 0x026E},
-{0x0F12, 0x0000}, //REG_TC_GP_ActiveCapConfig
-{0x0F12, 0x0001}, // /
-{0x002A, 0x0242}, // 
-{0x0F12, 0x0001}, // /#REG_TC_GP_EnableCapture
-{0x002A, 0x024E}, // 
-{0x0F12, 0x0001}, // /#REG_TC_GP_NewConfigSync
-{0x002A, 0x0244}, // 
-{0x0F12, 0x0001}, // /#REG_TC_GP_EnableCaptureChanged
-
-{0xffff, 0x00c8},  //delay 200ms
+{0xffff, 0x00c8},  //delay 200ms*/
 };                                      
 
 
 //for video
 static struct regval_list sensor_1080p_regs[] = { //1080: 1920*1080 
-/* preview setting */
-
-{0x002A, 0x18AC},
-{0x0F12, 0x0060}, //senHal_uAddColsBin
-{0x0F12, 0x0060}, //senHal_uAddColsNoBin
-{0x0F12, 0x05C0}, //senHal_uMinColsBin
-{0x0F12, 0x0A96}, //05C0 //senHal_uMinColsNoBin
-
-//==================================================================================
-// 19.Input Size Setting
-//==================================================================================
-//Input Size
-{0x002A, 0x0250},
-{0x0F12, 0x0780},	//REG_TC_GP_PrevReqInputWidth
-{0x0F12, 0x0438},	//REG_TC_GP_PrevReqInputHeight
-{0x0F12, 0x014E},	//REG_TC_GP_PrevInputWidthOfs
-{0x0F12, 0x01B0},	//REG_TC_GP_PrevInputHeightOfs
-{0x0F12, 0x0A00},	//REG_TC_GP_CapReqInputWidth
-{0x0F12, 0x0780},	//REG_TC_GP_CapReqInputHeight
-{0x0F12, 0x0010},	//REG_TC_GP_CapInputWidthOfs
-{0x0F12, 0x000C},	//REG_TC_GP_CapInputHeightOfs
-
-{0x002A, 0x0494},
-{0x0F12, 0x0780},	//REG_TC_PZOOM_ZoomInputWidth
-{0x0F12, 0x0438},	//REG_TC_PZOOM_ZoomInputHeight
-{0x0F12, 0x0000},	//REG_TC_PZOOM_ZoomInputWidthOfs
-{0x0F12, 0x0000},	//REG_TC_PZOOM_ZoomInputHeightOfs
-{0x0F12, 0x0A00},	//REG_TC_CZOOM_ZoomInputWidth
-{0x0F12, 0x0780},	//REG_TC_CZOOM_ZoomInputHeight
-{0x0F12, 0x0000},	//REG_TC_CZOOM_ZoomInputWidthOfs
-{0x0F12, 0x0000},	//REG_TC_CZOOM_ZoomInputHeightOfs
-
-{0x002A, 0x0262},
-{0x0F12, 0x0001},	//REG_TC_GP_bUseReqInputInPre
-{0x0F12, 0x0001},	//REG_TC_GP_bUseReqInputInCap
-
-//==================================================================================
-// 20.Preview & Capture Configration Setting
-//==================================================================================
-{0xFCFC, 0xD000},
-{0x0028, 0x7000},
-{0x002A, 0x02A6},
-{0x0F12, 0x0780},	//280 REG_0TC_PCFG_usWidth
-{0x0F12, 0x0438},	//1E0 REG_0TC_PCFG_usHeight
-{0x002A, 0x02BC},
-{0x0F12, 0x0001},	//REG_0TC_PCFG_uClockInd
-{0x0F12, 0x0001},	//REG_0TC_PCFG_usFrTimeType
-{0x0F12, 0x0000},	//REG_0TC_PCFG_FrRateQualityType
-{0x0F12, 0x029A},	//REG_0TC_PCFG_usMaxFrTimeMsecMult10
-{0x0F12, 0x029A},	//REG_0TC_PCFG_usMinFrTimeMsecMult10
-
-{0x002A, 0x022C},	
-{0x0F12, 0x0001},	//REG_TC_IPRM_InitParamsUpdated
+//Preview config[0] 64480  7.5~15fps
+{0x0028,0x7000},		
+{0x002A,0x0306},																		  
+{0x0F12,0x0780},   //REG_2TC_PCFG_usWidth												  
+{0x0F12,0x0438},   //REG_2TC_PCFG_usHeight												  
+{0x0F12,0x0005},   //REG_2TC_PCFG_Format	5 YUV	7 Raw	9 JPG					   
+{0x0F12,0x59D8},   //REG_2TC_PCFG_usMaxOut4KHzRate									  
+{0x0F12,0x5988},   //REG_2TC_PCFG_usMinOut4KHzRate										  
+{0x0F12,0x0100},   //REG_2TC_PCFG_OutClkPerPix88										  
+{0x0F12,0x0300},   //REG_2TC_PCFG_uBpp88												  
+{0x0F12,0x0012},   //REG_2TC_PCFG_PVIMask												  
+{0x0F12,0x0000},   //REG_2TC_PCFG_OIFMask												  
+{0x0F12,0x01E0},   //REG_2TC_PCFG_usJpegPacketSize										  
+{0x0F12,0x0000},   //REG_2TC_PCFG_usJpegTotalPackets									  
+{0x0F12,0x0002},   //REG_2TC_PCFG_uClockInd 											  
+{0x0F12,0x0000},   //REG_2TC_PCFG_usFrTimeType
+{0x0F12,0x0002},   //REG_2TC_PCFG_FrRateQualityType 																					
+{0x0F12,0x02ca},   //REG_2TC_PCFG_usMaxFrTimeMsecMult10 								  
+{0x0F12,0x0000},   //REG_2TC_PCFG_usMinFrTimeMsecMult10 
 
-//==================================================================================
-// 21.Select Cofigration Display
-//==================================================================================
-//PREVIEW
-{0xFCFC, 0xD000},
-{0x0028, 0x7000},
-{0x002A, 0x0266},
-{0x0f12, 0x0000},	//REG_TC_GP_ActivePrevConfig
-{0x002A, 0x026A},
-{0x0F12, 0x0001},	//REG_TC_GP_PrevOpenAfterChange
-{0x002A, 0x0268},
-{0x0F12, 0x0001},	//REG_TC_GP_PrevConfigChanged
-{0x002A, 0x026E},                                          
-{0x0f12, 0x0000},       //REG_TC_GP_ActiveCapConfig          
-{0x002A, 0x026A},	                                         
-{0x0F12, 0x0001},	//REG_TC_GP_CapOpenAfterChange           
-{0x002A, 0x0270},	                                         
-{0x0F12, 0x0001},	//REG_TC_GP_CapConfigChanged   
-    		
-{0x002A, 0x024E},
-{0x0F12, 0x0001},	//REG_TC_GP_NewConfigSync
-{0x002A, 0x023E},
-{0x0F12, 0x0001},	//REG_TC_GP_EnablePreview
-{0x0F12, 0x0001},	//REG_TC_GP_EnablePreviewChanged
+	
+{0x002A,0x0266},
+{0x0F12,0x0002},	//REG_TC_GP_ActivePrevConfig
+{0x002A,0x026A},
+{0x0F12,0x0001},	//REG_TC_GP_PrevOpenAfterChange
+{0x002A,0x0268},
+{0x0F12,0x0001},	//REG_TC_GP_PrevConfigChanged
+{0x002A,0x026E},
+{0x0F12,0x0000},	//REG_TC_GP_ActiveCapConfig
+{0x002A,0x026A},
+{0x0F12,0x0001},	//REG_TC_GP_CapOpenAfterChange
+{0x002A,0x0270},
+{0x0F12,0x0001},	//REG_TC_GP_CapConfigChanged
+{0x002A,0x024E},
+{0x0F12,0x0001},	//REG_TC_GP_NewConfigSync
+{0x002A,0x023E},
+{0x0F12,0x0001},	//REG_TC_GP_EnablePreview
+{0x0F12,0x0001},	//REG_TC_GP_EnablePreviewChanged
+
+//=============================================
+
+{0xffff, 0x00c8},  //delay 200ms*/
 
 
-{0xffff, 0x00c8},  //delay 200ms
 };
 
 static struct regval_list sensor_720p_regs[] = { //1280*720
-/* preview setting */
 
-{0x002A, 0x18AC},
-{0x0F12, 0x0060}, //senHal_uAddColsBin
-{0x0F12, 0x0060}, //senHal_uAddColsNoBin
-{0x0F12, 0x05C0}, //senHal_uMinColsBin
-{0x0F12, 0x0A96}, //05C0 //senHal_uMinColsNoBin
+//Preview config[0] 64480  7.5~15fps	
+{0x0028, 0x7000},
+{0x002A, 0x02D6},	
+{0x0F12, 0x0500},	 //REG_0TC_PCFG_usWidth              	
+{0x0F12, 0x02D0},	 //REG_0TC_PCFG_usHeight             	
+{0x0F12, 0x0005},	 //REG_0TC_PCFG_Format	                
+{0x0F12, 0x279D},	 //4F1A	 //REG_0TC_PCFG_usMaxOut4KHzRate     	
+{0x0F12, 0x277D},	 //4F1A	 //REG_0TC_PCFG_usMinOut4KHzRate     	
+{0x0F12, 0x0100},	 //REG_0TC_PCFG_OutClkPerPix88       	
+{0x0F12, 0x0300},	 //REG_0TC_PCFG_uBpp88               	
+{0x0F12, 0x0012},	 //REG_0TC_PCFG_PVIMask              	
+{0x0F12, 0x0000},	 //REG_0TC_PCFG_OIFMask              	
+{0x0F12, 0x01E0},	 //REG_0TC_PCFG_usJpegPacketSize     	
+{0x0F12, 0x0000},	 //REG_0TC_PCFG_usJpegTotalPackets   	
+{0x0F12, 0x0000},	 //REG_0TC_PCFG_uClockInd            	
+{0x0F12, 0x0000},	 //REG_0TC_PCFG_usFrTimeType         	
+{0x0F12, 0x0001},	 //REG_0TC_PCFG_FrRateQualityType    	
+{0x0F12, 0x0190},	 //029A  //REG_0TC_PCFG_usMaxFrTimeMsecMult10	
+{0x0F12, 0x014D},	 //REG_0TC_PCFG_usMinFrTimeMsecMult10	
 
 //==================================================================================
-// 19.Input Size Setting
+// 19.Select Cofigration Display
 //==================================================================================
-//Input Size
-{0x002A, 0x0250},
-{0x0F12, 0x0A00},	//REG_TC_GP_PrevReqInputWidth 
-{0x0F12, 0x05A0},	//REG_TC_GP_PrevReqInputHeight
-{0x0F12, 0x0010},	//REG_TC_GP_PrevInputWidthOfs 
-{0x0F12, 0x00FC},	//REG_TC_GP_PrevInputHeightOfs
-{0x0F12, 0x0A00},	//REG_TC_GP_CapReqInputWidth  
-{0x0F12, 0x0780},	//REG_TC_GP_CapReqInputHeight 
-{0x0F12, 0x0010},	//REG_TC_GP_CapInputWidthOfs  
-{0x0F12, 0x000C},	//REG_TC_GP_CapInputHeightOfs 
-
-{0x002A, 0x0494},
-{0x0F12, 0x0A00},	//REG_TC_PZOOM_ZoomInputWidth
-{0x0F12, 0x05A0},	//REG_TC_PZOOM_ZoomInputHeight
-{0x0F12, 0x0000},	//REG_TC_PZOOM_ZoomInputWidthOfs    
-{0x0F12, 0x0000},	//REG_TC_PZOOM_ZoomInputHeightOfs   
-{0x0F12, 0x0A00},	//REG_TC_CZOOM_ZoomInputWidth       
-{0x0F12, 0x0780},	//REG_TC_CZOOM_ZoomInputHeight      
-{0x0F12, 0x0000},	//REG_TC_CZOOM_ZoomInputWidthOfs    
-{0x0F12, 0x0000},	//REG_TC_CZOOM_ZoomInputHeightOfs  
-
-{0x002A, 0x0262},
-{0x0F12, 0x0001},	//REG_TC_GP_bUseReqInputInPre
-{0x0F12, 0x0001},	//REG_TC_GP_bUseReqInputInCap
+//PREVIEW                                                                        		
 
-//==================================================================================
-// 20.Preview & Capture Configration Setting
-//==================================================================================
-{0xFCFC, 0xD000},
-{0x0028, 0x7000},
-{0x002A, 0x02A6},
-{0x0F12, 0x0500},	//280 REG_0TC_PCFG_usWidth
-{0x0F12, 0x02D0},	//1E0 REG_0TC_PCFG_usHeight
-{0x002A, 0x02BC},
-{0x0F12, 0x0000},	//REG_0TC_PCFG_uClockInd
-{0x0F12, 0x0001},	//REG_0TC_PCFG_usFrTimeType
-{0x0F12, 0x0001},	//REG_0TC_PCFG_FrRateQualityType
-{0x0F12, 0x014D},	//REG_0TC_PCFG_usMaxFrTimeMsecMult10
-{0x0F12, 0x014D},	//REG_0TC_PCFG_usMinFrTimeMsecMult10
-
-{0x002A, 0x022C},	
-{0x0F12, 0x0001},	//REG_TC_IPRM_InitParamsUpdated
+{0x0028, 0x7000},//many insert
+{0x002A, 0x0266},   
+{0x0F12, 0x0001},	 //REG_TC_GP_ActivePrevConfig        		
+{0x002A, 0x026A},                                    
+{0x0F12, 0x0001},	 //REG_TC_GP_PrevOpenAfterChange     
+{0x002A, 0x0268},									 
+{0x0F12, 0x0001},	 //REG_TC_GP_PrevConfigChanged	  
+{0x002A, 0x024E},                                    
+{0x0F12, 0x0001},	 //REG_TC_GP_NewConfigSync           		   		
+{0x002A, 0x023E},                                    
+{0x0F12, 0x0001},	 //REG_TC_GP_EnablePreview           	
+{0x0F12, 0x0001},	 //REG_TC_GP_EnablePreviewChanged
+//=============================================
 
-//==================================================================================
-// 21.Select Cofigration Display
-//==================================================================================
-//PREVIEW
-{0xFCFC, 0xD000},
-{0x0028, 0x7000},
-{0x002A, 0x0266},
-{0x0f12, 0x0000},	//REG_TC_GP_ActivePrevConfig
-{0x002A, 0x026A},
-{0x0F12, 0x0001},	//REG_TC_GP_PrevOpenAfterChange
-{0x002A, 0x0268},	                                         
-{0x0F12, 0x0001},	//REG_TC_GP_PrevConfigChanged                             
-{0x002A, 0x026E},                                          
-{0x0f12, 0x0000},       //REG_TC_GP_ActiveCapConfig          
-{0x002A, 0x026A},	                                         
-{0x0F12, 0x0001},	//REG_TC_GP_CapOpenAfterChange           
-{0x002A, 0x0270},	                                         
-{0x0F12, 0x0001},	//REG_TC_GP_CapConfigChanged   
-    		
-{0x002A, 0x024E},
-{0x0F12, 0x0001},	//REG_TC_GP_NewConfigSync
-{0x002A, 0x023E},
-{0x0F12, 0x0001},	//REG_TC_GP_EnablePreview
-{0x0F12, 0x0001},	//REG_TC_GP_EnablePreviewChanged
+{0xffff, 0x00c8},  //delay 200ms*/
 
-{0xffff, 0x00c8},  //delay 200ms
 };
 
 static struct regval_list sensor_vga_regs[] = { //VGA:  640*480
-#if 0  //vga 7.5~30fps
-/* preview setting */
 
-{0x002A, 0x18AC},
-{0x0F12, 0x0060}, //senHal_uAddColsBin
-{0x0F12, 0x0060}, //senHal_uAddColsNoBin
-{0x0F12, 0x05C0}, //senHal_uMinColsBin
-{0x0F12, 0x05C0}, //senHal_uMinColsNoBin
-
-//==================================================================================
-// 19.Input Size Setting
-//==================================================================================
-//Input Size
-{0x002A, 0x0250},
-{0x0F12, 0x0A00},	//REG_TC_GP_PrevReqInputWidth
-{0x0F12, 0x0780},	//REG_TC_GP_PrevReqInputHeight
-{0x0F12, 0x0010},	//REG_TC_GP_PrevInputWidthOfs
-{0x0F12, 0x000C},	//REG_TC_GP_PrevInputHeightOfs
-{0x0F12, 0x0A00},	//REG_TC_GP_CapReqInputWidth
-{0x0F12, 0x0780},	//REG_TC_GP_CapReqInputHeight
-{0x0F12, 0x0010},	//REG_TC_GP_CapInputWidthOfs
-{0x0F12, 0x000C},	//REG_TC_GP_CapInputHeightOfs
-
-{0x002A, 0x0494},
-{0x0F12, 0x0A00},	//REG_TC_PZOOM_ZoomInputWidth
-{0x0F12, 0x0780},	//REG_TC_PZOOM_ZoomInputHeight
-{0x0F12, 0x0000},	//REG_TC_PZOOM_ZoomInputWidthOfs
-{0x0F12, 0x0000},	//REG_TC_PZOOM_ZoomInputHeightOfs
-{0x0F12, 0x0A00},	//REG_TC_CZOOM_ZoomInputWidth
-{0x0F12, 0x0780},	//REG_TC_CZOOM_ZoomInputHeight
-{0x0F12, 0x0000},	//REG_TC_CZOOM_ZoomInputWidthOfs
-{0x0F12, 0x0000},	//REG_TC_CZOOM_ZoomInputHeightOfs
-
-{0x002A, 0x0262},
-{0x0F12, 0x0001},	//REG_TC_GP_bUseReqInputInPre
-{0x0F12, 0x0001},	//REG_TC_GP_bUseReqInputInCap
-
-//==================================================================================
-// 20.Preview & Capture Configration Setting
-//==================================================================================
-{0xFCFC, 0xD000},
-{0x0028, 0x7000},
 {0x002A, 0x02A6},	
-{0x0F12, 0x0280},	//REG_0TC_PCFG_usWidth              	
-{0x0F12, 0x01E0},	//REG_0TC_PCFG_usHeight              	
-{0x002A, 0x02BC},	
-{0x0F12, 0x0000},	//REG_0TC_PCFG_uClockInd            	
-{0x0F12, 0x0000},	//REG_0TC_PCFG_usFrTimeType         	
-{0x0F12, 0x0001},	//REG_0TC_PCFG_FrRateQualityType    	
-{0x0F12, 0x0535},	//REG_0TC_PCFG_usMaxFrTimeMsecMult10	
-{0x0F12, 0x014D},	//REG_0TC_PCFG_usMinFrTimeMsecMult10	
-
-{0x002A, 0x022C},	
-{0x0F12, 0x0001},	//REG_TC_IPRM_InitParamsUpdated
-
-//==================================================================================
-// 21.Select Cofigration Display
-//==================================================================================
-//PREVIEW
-{0xFCFC, 0xD000},
-{0x0028, 0x7000},                                		                               		
-{0x002A, 0x0266},   
-{0x0f12, 0x0000},	//REG_TC_GP_ActivePrevConfig        		
-{0x002A, 0x026A},	                                   
-{0x0F12, 0x0001},	//REG_TC_GP_PrevOpenAfterChange     		
-{0x002A, 0x0268},	                                         
-{0x0F12, 0x0001},	//REG_TC_GP_PrevConfigChanged                             
-{0x002A, 0x026E},                                          
-{0x0f12, 0x0000},       //REG_TC_GP_ActiveCapConfig          
-{0x002A, 0x026A},	                                         
-{0x0F12, 0x0001},	//REG_TC_GP_CapOpenAfterChange           
-{0x002A, 0x0270},	                                         
-{0x0F12, 0x0001},	//REG_TC_GP_CapConfigChanged   
-    		
-{0x002A, 0x024E},	                                   
-{0x0F12, 0x0001},	//REG_TC_GP_NewConfigSync           		
-{0x002A, 0x023E},	                                   
-{0x0F12, 0x0001},	//REG_TC_GP_EnablePreview           	
-{0x0F12, 0x0001},	//REG_TC_GP_EnablePreviewChanged   
-
-{0xffff, 0x00c8},  //delay 200ms
-#else			//vga fix 30fps
-/* preview setting */
-
-{0x002A, 0x18AC},
-{0x0F12, 0x0060}, //senHal_uAddColsBin
-{0x0F12, 0x0060}, //senHal_uAddColsNoBin
-{0x0F12, 0x05C0}, //senHal_uMinColsBin
-{0x0F12, 0x05C0}, //05C0 //senHal_uMinColsNoBin
-
-//==================================================================================
-// 19.Input Size Setting
-//==================================================================================
-//Input Size
-{0x002A, 0x0250},
-{0x0F12, 0x0A00},	//REG_TC_GP_PrevReqInputWidth
-{0x0F12, 0x0780},	//REG_TC_GP_PrevReqInputHeight
-{0x0F12, 0x0010},	//REG_TC_GP_PrevInputWidthOfs
-{0x0F12, 0x000C},	//REG_TC_GP_PrevInputHeightOfs
-{0x0F12, 0x0A00},	//REG_TC_GP_CapReqInputWidth
-{0x0F12, 0x0780},	//REG_TC_GP_CapReqInputHeight
-{0x0F12, 0x0010},	//REG_TC_GP_CapInputWidthOfs
-{0x0F12, 0x000C},	//REG_TC_GP_CapInputHeightOfs
-
-{0x002A, 0x0494},
-{0x0F12, 0x0A00},	//REG_TC_PZOOM_ZoomInputWidth
-{0x0F12, 0x0780},	//REG_TC_PZOOM_ZoomInputHeight
-{0x0F12, 0x0000},	//REG_TC_PZOOM_ZoomInputWidthOfs
-{0x0F12, 0x0000},	//REG_TC_PZOOM_ZoomInputHeightOfs
-{0x0F12, 0x0A00},	//REG_TC_CZOOM_ZoomInputWidth
-{0x0F12, 0x0780},	//REG_TC_CZOOM_ZoomInputHeight
-{0x0F12, 0x0000},	//REG_TC_CZOOM_ZoomInputWidthOfs
-{0x0F12, 0x0000},	//REG_TC_CZOOM_ZoomInputHeightOfs
-
-{0x002A, 0x0262},
-{0x0F12, 0x0001},	//REG_TC_GP_bUseReqInputInPre
-{0x0F12, 0x0001},	//REG_TC_GP_bUseReqInputInCap
-
-//==================================================================================
-// 20.Preview & Capture Configration Setting
-//==================================================================================
-{0xFCFC, 0xD000},
-{0x0028, 0x7000},
-{0x002A, 0x02A6},	
-{0x0F12, 0x0280},	//280 REG_0TC_PCFG_usWidth
-{0x0F12, 0x01E0},	//1E0 REG_0TC_PCFG_usHeight
-{0x002A, 0x02BC},	
-{0x0F12, 0x0000},	//REG_0TC_PCFG_uClockInd
-{0x0F12, 0x0002},	//REG_0TC_PCFG_usFrTimeType
-{0x0F12, 0x0001},	//REG_0TC_PCFG_FrRateQualityType
-{0x0F12, 0x014D},	//REG_0TC_PCFG_usMaxFrTimeMsecMult10
-{0x0F12, 0x0000},	//REG_0TC_PCFG_usMinFrTimeMsecMult10
+{0x0F12, 0x0280},	 //REG_0TC_PCFG_usWidth              	
+{0x0F12, 0x01E0},	 //REG_0TC_PCFG_usHeight             	
+{0x0F12, 0x0005},	 //REG_0TC_PCFG_Format	                
+{0x0F12, 0x279D},	 //4F1A	 //REG_0TC_PCFG_usMaxOut4KHzRate     	
+{0x0F12, 0x277D},	 //4F1A	 //REG_0TC_PCFG_usMinOut4KHzRate     	
+{0x0F12, 0x0100},	 //REG_0TC_PCFG_OutClkPerPix88       	
+{0x0F12, 0x0300},	 //REG_0TC_PCFG_uBpp88               	
+{0x0F12, 0x0012},	 //REG_0TC_PCFG_PVIMask              	
+{0x0F12, 0x0000},	 //REG_0TC_PCFG_OIFMask              	
+{0x0F12, 0x01E0},	 //REG_0TC_PCFG_usJpegPacketSize     	
+{0x0F12, 0x0000},	 //REG_0TC_PCFG_usJpegTotalPackets   	
+{0x0F12, 0x0000},	 //REG_0TC_PCFG_uClockInd            	
+{0x0F12, 0x0000},	 //REG_0TC_PCFG_usFrTimeType         	
+{0x0F12, 0x0001},	 //REG_0TC_PCFG_FrRateQualityType    	
+{0x0F12, 0x01A0},	 //029A  //REG_0TC_PCFG_usMaxFrTimeMsecMult10	
+{0x0F12, 0x014A},	 //REG_0TC_PCFG_usMinFrTimeMsecMult10	
+	
 
 //==================================================================================
-// 21.Select Cofigration Display
+// 19.Select Cofigration Display
 //==================================================================================
-//PREVIEW
-{0x0028, 0x7000},
-{0x002A, 0x0266},
-{0x0f12, 0x0000}, //REG_TC_GP_ActivePrevConfig
-{0x002A, 0x026A},
-{0x0F12, 0x0001},	//REG_TC_GP_PrevOpenAfterChange
-{0x002A, 0x0268},
-{0x0F12, 0x0001},	//REG_TC_GP_PrevConfigChanged
-{0x002A, 0x026E},
-{0x0f12, 0x0000}, //REG_TC_GP_ActiveCapConfig
-{0x002A, 0x026A},
-{0x0F12, 0x0001},	//REG_TC_GP_CapOpenAfterChange
-{0x002A, 0x0270},
-{0x0F12, 0x0001},	//REG_TC_GP_CapConfigChanged
-
-{0x002A, 0x024E},
-{0x0F12, 0x0001},	//REG_TC_GP_NewConfigSync
-{0x002A, 0x023E},
-{0x0F12, 0x0001},	//REG_TC_GP_EnablePreview
-{0x0F12, 0x0001},	//REG_TC_GP_EnablePreviewChanged
+//PREVIEW                                                                        		
 
-//{0xffff, 0x00,150},
-#endif
+{0x0028, 0x7000},//many insert
+{0x002A, 0x0266},   
+{0x0F12, 0x0000},	 //REG_TC_GP_ActivePrevConfig        		
+{0x002A, 0x026A},                                    
+{0x0F12, 0x0001},	 //REG_TC_GP_PrevOpenAfterChange 
+{0x002A, 0x0268},									 
+{0x0F12, 0x0001},	 //REG_TC_GP_PrevConfigChanged	
+{0x002A, 0x024E},                                    
+{0x0F12, 0x0001},	 //REG_TC_GP_NewConfigSync           		     		
+{0x002A, 0x023E},                                    
+{0x0F12, 0x0001},	 //REG_TC_GP_EnablePreview           	
+{0x0F12, 0x0001},	 //REG_TC_GP_EnablePreviewChanged
+      
 
-//{0xFCFC, 0xD000},
-//{0x0028, 0x7000},
-//{0x002A, 0x0236},
-//{0x0F12, 0x0040},   //Control value
 };
 
 #if 0
@@ -4101,13 +4573,13 @@ static struct regval_list sensor_brightness_neg1_regs[] = {
 static struct regval_list sensor_brightness_zero_regs[] = {
 {0x0028, 0x7000},
 {0x002A, 0x1484},
-{0x0F12, 0x003C},
+{0x0F12, 0x0040},
 };
 
 static struct regval_list sensor_brightness_pos1_regs[] = {
 {0x0028, 0x7000},
 {0x002A, 0x1484},
-{0x0F12, 0x0047},
+{0x0F12, 0x004A},
 };
 
 static struct regval_list sensor_brightness_pos2_regs[] = {
@@ -4366,63 +4838,63 @@ static struct regval_list sensor_ev_neg4_regs[] = {
 {0xFCFC, 0xD000},
 {0x0028, 0x7000},
 {0x002A, 0x023A},
-{0x0F12, 0x0080},   //Control value
+{0x0F12, 0x0040},   //Control value   0080
 };
 
 static struct regval_list sensor_ev_neg3_regs[] = {
 {0xFCFC, 0xD000},
 {0x0028, 0x7000},
 {0x002A, 0x023A},
-{0x0F12, 0x00A0},   //Control value
+{0x0F12, 0x0070},   //Control value    00A0
 };
 
 static struct regval_list sensor_ev_neg2_regs[] = {
 {0xFCFC, 0xD000},
 {0x0028, 0x7000},
 {0x002A, 0x023A},
-{0x0F12, 0x00C0},   //Control value
+{0x0F12, 0x00A0},   //Control value   00C0
 };
 
 static struct regval_list sensor_ev_neg1_regs[] = {
 {0xFCFC, 0xD000},
 {0x0028, 0x7000},
 {0x002A, 0x023A},
-{0x0F12, 0x00E0},   //Control value
+{0x0F12, 0x00D0},   //Control value   00E0
 };                     
 
 static struct regval_list sensor_ev_zero_regs[] = {
 {0xFCFC, 0xD000},
 {0x0028, 0x7000},
 {0x002A, 0x023A},
-{0x0F12, 0x0100},   //Control value
+{0x0F12, 0x0100},   //Control value   0100
 };
 
 static struct regval_list sensor_ev_pos1_regs[] = {
 {0xFCFC, 0xD000},
 {0x0028, 0x7000},
 {0x002A, 0x023A},
-{0x0F12, 0x0120},   //Control value
+{0x0F12, 0x0130},   //Control value   0120
 };
 
 static struct regval_list sensor_ev_pos2_regs[] = {
 {0xFCFC, 0xD000},
 {0x0028, 0x7000},
 {0x002A, 0x023A},
-{0x0F12, 0x0140},   //Control value
+{0x0F12, 0x0160},   //Control value   0140
 };
 
 static struct regval_list sensor_ev_pos3_regs[] = {
 {0xFCFC, 0xD000},
 {0x0028, 0x7000},
 {0x002A, 0x023A},
-{0x0F12, 0x0160},   //Control value
+{0x0F12, 0x0190},   //Control value   0160
 };
 
 static struct regval_list sensor_ev_pos4_regs[] = {
 {0xFCFC, 0xD000},
 {0x0028, 0x7000},
 {0x002A, 0x023A},
-{0x0F12, 0x0180},   //Control value
+{0x0F12, 0x01C0},   //Control value   0180
 };
 
 static struct cfg_array sensor_ev[] = {
@@ -4471,16 +4943,13 @@ static struct cfg_array sensor_ev[] = {
  * 
  */
 static struct regval_list sensor_fmt_mipi_yuv422[] = {
-
-
+//uyvy
 {0xFCFC, 0xD000},
 {0x0028, 0x7000},
 {0x002A, 0x02B4},	
-{0x0F12, 0x0040},	//REG_0TC_PCFG_PVIMask    [5:4] YUYV 00 / UYVY 01 / YVYU 10 / VYUV 11        	
+{0x0F12, 0x0050},	//REG_0TC_PCFG_PVIMask    [5:4] YUYV 00 / UYVY 01 / YVYU 10 / VYUV 11        	
 {0x002A, 0x03A6},	
-{0x0F12, 0x0040},	//REG_0TC_CCFG_PVIMask    [5:4] YUYV 00 / UYVY 01 / YVYU 10 / VYUV 11  
-
-
+{0x0F12, 0x0050},	//REG_0TC_CCFG_PVIMask    [5:4] YUYV 00 / UYVY 01 / YVYU 10 / VYUV 11
 
 
 
@@ -4833,18 +5302,17 @@ static int sensor_s_vflip(struct v4l2_subdev *sd, int value)
 	
 	switch (value) {
 		case 0:
-		  pre_val &= 0xf5;
-		  cap_val &= 0xf5;
+		  pre_val = 0x0;
+		  cap_val = 0x0;
 			break;
 		case 1:
-		  pre_val |= 0x0A;
-		  cap_val |= 0x0A;
+		  pre_val = 0x01;
+		  cap_val = 0x01;
 			break;
 		default:
 			return -EINVAL;
 	}
-
-	sensor_write(sd, 0x0f12, pre_val);
+  sensor_write(sd, 0x0f12, pre_val);
   sensor_write(sd, 0x0f12, cap_val);
 
 	ret = sensor_write_array(sd, regs, ARRAY_SIZE(regs));
@@ -5623,7 +6091,7 @@ static int sensor_s_flash_mode(struct v4l2_subdev *sd,
 static int sensor_power(struct v4l2_subdev *sd, int on)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	//int ret;
+	int ret;
   
   //insure that clk_disable() and clk_enable() are called in pair 
   //when calling CSI_SUBDEV_STBY_ON/OFF and CSI_SUBDEV_PWR_ON/OFF
@@ -5645,7 +6113,7 @@ static int sensor_power(struct v4l2_subdev *sd, int on)
 			//when using i2c_lock_adpater function, the following codes must not access i2c bus before calling i2c_unlock_adapter
 			i2c_lock_adapter(client->adapter);
 			//reset on io
-      vfe_gpio_write(sd,RESET,CSI_RST_ON);
+     // vfe_gpio_write(sd,RESET,CSI_RST_ON);
 			usleep_range(1000,1200);
 			//standby on io
       vfe_gpio_write(sd,PWDN,CSI_STBY_ON);
@@ -5661,14 +6129,19 @@ static int sensor_power(struct v4l2_subdev *sd, int on)
 			//when using i2c_lock_adpater function, the following codes must not access i2c bus before calling i2c_unlock_adapter
 			i2c_lock_adapter(client->adapter);
 			//active mclk before stadby out
-			vfe_set_mclk(sd,ON);
-			usleep_range(1000,1200);
+			ret = vfe_set_mclk_freq(sd,MCLK);
+			if(ret !=0)
+				vfe_dev_dbg("CSI_SUBDEV_STBY_OFF vfe_set_mclk_freq ERROR \n");
+			ret = vfe_set_mclk(sd,ON);
+			if(ret !=0)
+				vfe_dev_dbg("CSI_SUBDEV_STBY_OFF vfe_set_mclk ERROR \n");
+			usleep_range(10000,12000);
 			//standby off io
       vfe_gpio_write(sd,PWDN,CSI_STBY_OFF);
-			usleep_range(1000,1200);
+			usleep_range(10000,12000);
 			//reset on io
-      vfe_gpio_write(sd,RESET,CSI_RST_OFF);
-			usleep_range(1000,1200);
+      //vfe_gpio_write(sd,RESET,CSI_RST_OFF);
+		//	usleep_range(1000,1200);
 			//remember to unlock i2c adapter, so the device can access the i2c bus again
 			i2c_unlock_adapter(client->adapter);
 //      //software standby
@@ -5697,14 +6170,17 @@ static int sensor_power(struct v4l2_subdev *sd, int on)
       vfe_set_pmu_channel(sd,AFVDD,ON);
 			usleep_range(10000,12000);
 			//active mclk power on reset
+	 vfe_set_mclk_freq(sd,MCLK);		
       vfe_set_mclk(sd,ON);
+        usleep_range(10000,12000);
 			//power on reset
       vfe_gpio_write(sd,PWDN,CSI_STBY_OFF);
 			usleep_range(10000,12000);
       vfe_gpio_write(sd,RESET,CSI_RST_OFF);
 			usleep_range(10000,12000);
 			//remember to unlock i2c adapter, so the device can access the i2c bus again
-			i2c_unlock_adapter(client->adapter);	
+			i2c_unlock_adapter(client->adapter);
+			s5k4ec_firsttime=0;
 			break;
 		case CSI_SUBDEV_PWR_OFF:
 			vfe_dev_dbg("CSI_SUBDEV_PWR_OFF\n");
@@ -5730,6 +6206,7 @@ static int sensor_power(struct v4l2_subdev *sd, int on)
 			vfe_gpio_set_status(sd,RESET,0);//set the gpio to input
 			//remember to unlock i2c adapter, so the device can access the i2c bus again
 			i2c_unlock_adapter(client->adapter);	
+			s5k4ec_firsttime=0;
 			break;
 		default:
 			return -EINVAL;
@@ -5777,7 +6254,7 @@ static int sensor_detect(struct v4l2_subdev *sd)
 		vfe_dev_err("id read from sensor is 0x%4x,not 0x4ec0\n",rdval);
 		return -ENODEV;
 	}
-	
+	vfe_dev_dbg("sensor_detect OK\n");
 	return 0;
 }
 
@@ -5793,8 +6270,8 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 	if (ret) {
 		vfe_dev_err("chip found is not an target chip.\n");
 		//test
-		printk("test while () \n");
-		while(1);
+	//	printk("test while () \n");
+	//	while(1);
 		
 		//test end
 		return ret;
@@ -5830,12 +6307,21 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 	info->width = 0;
 	info->height = 0;
 	
-	ret = sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));	
-	if(ret < 0) {
-		vfe_dev_err("write sensor_default_regs error\n");
-		return ret;
+	if(s5k4ec_firsttime==0)
+	{
+		vfe_dev_dbg("sensor_init sensor_write_array START\n");
+		ret = sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));	
+		if(ret < 0) {
+			vfe_dev_err("write sensor_default_regs error\n");
+			return ret;
+		}
+		s5k4ec_firsttime=1;
+		vfe_dev_dbg("sensor_init sensor_write_array OK\n");	
+	}
+	else
+	{
+		vfe_dev_dbg("no need to init sensor_write_array\r\n");
 	}
-			
 	sensor_s_band_filter(sd, V4L2_CID_POWER_LINE_FREQUENCY_50HZ);
 	
   if(info->stby_mode == 0)
@@ -5847,8 +6333,29 @@ static int sensor_init(struct v4l2_subdev *sd, u32 val)
 
 static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	int ret=0;
-	return ret;
+	 int ret=0;
+  struct sensor_info *info = to_state(sd);
+//  vfe_dev_dbg("[]cmd=%d\n",cmd);
+//  vfe_dev_dbg("[]arg=%0x\n",arg);
+  switch(cmd) {
+    case GET_CURRENT_WIN_CFG:
+      if(info->current_wins != NULL)
+      {
+        memcpy( arg,
+                info->current_wins,
+                sizeof(struct sensor_win_size) );
+        ret=0;
+      }
+      else
+      {
+        vfe_dev_err("empty wins!\n");
+        ret=-1;
+      }
+      break;
+    default:
+      return -EINVAL;
+  }
+  return ret;
 }
 
 
@@ -5920,30 +6427,33 @@ static struct sensor_format_struct {
 static struct sensor_win_size sensor_win_sizes[] = {
 	/* qsxga: 2592*1936 */
 	{
-		.width			= QSXGA_WIDTH,
-		.height 		= QSXGA_HEIGHT,
+		.width			= QSXGA_WIDTH_S5K,
+		.height 		= QSXGA_HEIGHT_S5K,
 		.regs			  = sensor_qsxga_regs,
     .hoffset    = 0,
     .voffset    = 0,
+    .mipi_bps		= 200*1000*1000,
 		.regs_size	= ARRAY_SIZE(sensor_qsxga_regs),
 		.set_size		= NULL,
 	},
 	/* qxga: 2048*1536 */
 	{
-		.width			= QXGA_WIDTH,
-		.height 		= QXGA_HEIGHT,
+		.width			= QXGA_WIDTH_S5K,
+		.height 		= QXGA_HEIGHT_S5K,
     .hoffset    = 0,
     .voffset    = 0,
+    .mipi_bps		= 200*1000*1000,
 		.regs			  = sensor_qxga_regs,
 		.regs_size	= ARRAY_SIZE(sensor_qxga_regs),
 		.set_size		= NULL,
 	},
 	/* 1080P */
 	{
-		.width			= HD1080_WIDTH,
-		.height			= HD1080_HEIGHT,
+		.width			= HD1080_WIDTH_S5K,
+		.height			= HD1080_HEIGHT_S5K,
     .hoffset    = 0,
     .voffset    = 0,
+    .mipi_bps		= 200*1000*1000,
 		.regs 			= sensor_1080p_regs,
 		.regs_size	= ARRAY_SIZE(sensor_1080p_regs),
 		.set_size		= NULL,
@@ -5951,20 +6461,22 @@ static struct sensor_win_size sensor_win_sizes[] = {
 
 	/* 720p */
 	{
-		.width			= HD720_WIDTH,
-		.height			= HD720_HEIGHT,
+		.width			= HD720_WIDTH_S5K,
+		.height			= HD720_HEIGHT_S5K,
     .hoffset    = 0,
     .voffset    = 0,
+    .mipi_bps		= 200*1000*1000,
 		.regs 			= sensor_720p_regs,
 		.regs_size	= ARRAY_SIZE(sensor_720p_regs),
 		.set_size		= NULL,
 	},
 	/* VGA */
 	{
-		.width			= VGA_WIDTH,
-		.height			= VGA_HEIGHT,
+		.width			= VGA_WIDTH_S5K,
+		.height			= VGA_HEIGHT_S5K,
     .hoffset    = 0,
     .voffset    = 0,
+    	.mipi_bps		= 200*1000*1000,
 		.regs				= sensor_vga_regs,
 		.regs_size	= ARRAY_SIZE(sensor_vga_regs),
 		.set_size		= NULL,
@@ -6007,6 +6519,7 @@ static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
 {
   int index;
   struct sensor_win_size *wsize;
+  struct sensor_info *info = to_state(sd);
 
   for (index = 0; index < N_FMTS; index++)
     if (sensor_formats[index].mbus_code == fmt->code)
@@ -6044,6 +6557,8 @@ static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
   fmt->height = wsize->height;
   fmt->reserved[0] = wsize->hoffset;
   fmt->reserved[1] = wsize->voffset;
+  info->current_wins = wsize;
+  vfe_dev_dbg("sensor_try_fmt_internal wsize->width = %d,wsize->height = %d,wsize->hoffset = %d,wsize->voffset = %d\n",wsize->width,wsize->height,wsize->hoffset,wsize->voffset);
   //pix->bytesperline = pix->width*sensor_formats[index].bpp;
   //pix->sizeimage = pix->height*pix->bytesperline;
 
@@ -6059,9 +6574,11 @@ static int sensor_try_fmt(struct v4l2_subdev *sd,
 static int sensor_g_mbus_config(struct v4l2_subdev *sd,
            struct v4l2_mbus_config *cfg)
 {
-  cfg->type = V4L2_MBUS_PARALLEL;
-  cfg->flags = V4L2_MBUS_MASTER | VREF_POL | HREF_POL | CLK_POL ;
-  
+  //cfg->type = V4L2_MBUS_PARALLEL;
+  //cfg->flags = V4L2_MBUS_MASTER | VREF_POL | HREF_POL | CLK_POL ;
+  cfg->type = V4L2_MBUS_CSI2;
+  cfg->flags = 0|V4L2_MBUS_CSI2_2_LANE|V4L2_MBUS_CSI2_CHANNEL_0;
+ 
   return 0;
 }
 
diff --git a/drivers/media/video/sunxi-vfe/vfe.c b/drivers/media/video/sunxi-vfe/vfe.c
index 62e8a3f..6502236 100755
--- a/drivers/media/video/sunxi-vfe/vfe.c
+++ b/drivers/media/video/sunxi-vfe/vfe.c
@@ -1057,6 +1057,7 @@ static irqreturn_t vfe_isr(int irq, void *priv)
   struct csi_int_status status;
   struct vfe_isp_stat_buf_queue *isp_stat_bq = &dev->isp_stat_bq;  
   struct vfe_isp_stat_buf *stat_buf_pt;
+  struct timespec ts;
   
   FUNCTION_LOG;
   
@@ -1158,8 +1159,11 @@ isp_exp_handle:
 		vfe_warn(" Nobody is waiting on this video buffer,buf = 0x%p\n",buf);		   
 	}
 	list_del(&buf->vb.queue);
-	do_gettimeofday(&buf->vb.ts);
-	buf->vb.field_count++;
+	//do_gettimeofday(&buf->vb.ts);
+	ktime_get_ts(&ts);
+	buf->vb.ts.tv_sec = ts.tv_sec;
+    buf->vb.ts.tv_usec = ts.tv_nsec/1000;
+    buf->vb.field_count++;
 
 	vfe_dbg(2,"video buffer frame interval = %ld\n",buf->vb.ts.tv_sec*1000000+buf->vb.ts.tv_usec - (dev->sec*1000000+dev->usec));
 	dev->sec = buf->vb.ts.tv_sec;
@@ -1338,7 +1342,7 @@ static int buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,
   struct vfe_buffer *buf = container_of(vb, struct vfe_buffer, vb);
   int rc;
 
-  vfe_dbg(1,"buffer_prepare\n");
+  //vfe_dbg(1,"buffer_prepare\n");   //potter del
 
   BUG_ON(NULL == dev->fmt);
 
@@ -1382,7 +1386,7 @@ static void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
   struct vfe_buffer *buf = container_of(vb, struct vfe_buffer, vb);
   struct vfe_dmaqueue *vidq = &dev->vidq;
 
-  vfe_dbg(1,"buffer_queue\n");
+  //vfe_dbg(1,"buffer_queue\n");   //potter del
   buf->vb.state = VIDEOBUF_QUEUED;
   list_add_tail(&buf->vb.queue, &vidq->active);
 }
@@ -3915,13 +3919,6 @@ reg_sd:
     goto probe_hdl_unreg_dev;
   } 
 
-  /*video device register */
-  ret = -ENOMEM;
-  vfd = video_device_alloc();
-  if (!vfd) {
-    goto probe_hdl_unreg_dev;
-  } 
-
   *vfd = vfe_template;
   vfd->v4l2_dev = &dev->v4l2_dev;
   sprintf(vfe_name,"vfe-%d",dev->id);
@@ -4038,11 +4035,11 @@ static int vfe_probe(struct platform_device *pdev)
   }
   
 //  printk("read_ini_info 0\n");
-  if(dev->ccm_cfg[0]->is_isp_used || dev->ccm_cfg[1]->is_isp_used)
-  {
-  	if(read_ini_info(dev))
-    	vfe_warn("read ini info fail\n");
-  }
+if(0)                  //deleted by potter for no use isp of soc
+{
+  if(read_ini_info(dev))
+    vfe_err("read ini info error\n");
+ }
 //  printk("read_ini_info 1\n");
   
 //  printk("vfe_resource_request 0\n");
@@ -4054,12 +4051,14 @@ static int vfe_probe(struct platform_device *pdev)
   ret = bsp_csi_set_base_addr(dev->vip_sel, (unsigned int)dev->regs.csi_regs);
   if(ret < 0)
     goto free_resource;
+	if(dev->id == 0) {
   ret = bsp_mipi_csi_set_base_addr(dev->mipi_sel, (unsigned int)dev->regs.protocol_regs);
   if(ret < 0)
     goto free_resource;
   ret = bsp_mipi_dphy_set_base_addr(dev->mipi_sel, (unsigned int)dev->regs.dphy_regs);
   if(ret < 0)
     goto free_resource;
+    }
 
   bsp_isp_set_base_addr((unsigned int)dev->regs.isp_regs);
   bsp_isp_set_map_load_addr((unsigned int)dev->regs.isp_load_regs);
@@ -4094,7 +4093,9 @@ static int vfe_probe(struct platform_device *pdev)
   INIT_DELAYED_WORK(&dev->probe_work, probe_work_handle);
   mutex_init(&dev->standby_lock);
   sema_init(&dev->standby_seq_sema,1);
-  
+  int retry = 5;
+  while((dev->id == 1) && list_empty(&devlist) && retry-- )
+  	msleep(5);
   schedule_delayed_work(&dev->probe_work,msecs_to_jiffies(1));
 
   /* initial state */
@@ -4216,6 +4217,29 @@ static void resume_work_handle(struct work_struct *work)
   
   //open all the device power
   for (input_num=0; input_num<dev->dev_qty; input_num++) {
+       /*  potter */
+   if(strcmp(dev->ccm_cfg[input_num]->iovdd_str,"")) {
+      dev->ccm_cfg[input_num]->power.iovdd = regulator_get(NULL, dev->ccm_cfg[input_num]->iovdd_str);
+      if (dev->ccm_cfg[input_num]->power.iovdd == NULL) {
+        vfe_err("get regulator csi_iovdd error!input_num = %d\n",input_num);
+ 
+      }
+    }
+    if(strcmp(dev->ccm_cfg[input_num]->avdd_str,"")) {
+      dev->ccm_cfg[input_num]->power.avdd = regulator_get(NULL, dev->ccm_cfg[input_num]->avdd_str);
+      if (dev->ccm_cfg[input_num]->power.avdd == NULL) {
+        vfe_err("get regulator csi_avdd error!input_num = %d\n",input_num);
+  
+      }
+    }
+    if(strcmp(dev->ccm_cfg[input_num]->dvdd_str,"")) {
+      dev->ccm_cfg[input_num]->power.dvdd = regulator_get(NULL, dev->ccm_cfg[input_num]->dvdd_str);
+      if (dev->ccm_cfg[input_num]->power.dvdd == NULL) {
+        vfe_err("get regulator csi_dvdd error!input_num = %d\n",input_num);
+      
+      }
+    }
+
     /* update target device info and select it */
     update_ccm_info(dev, dev->ccm_cfg[input_num]);
     
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index cf7885d..69b0afa 100755
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -540,4 +540,5 @@ source "drivers/misc/lis3lv02d/Kconfig"
 source "drivers/misc/carma/Kconfig"
 source "drivers/misc/altera-stapl/Kconfig"
 source "drivers/misc/sw_3g_module/Kconfig"
+source "drivers/misc/inv_mpu/Kconfig"
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 416beaf..a22ef2c 100755
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -35,6 +35,7 @@ obj-$(CONFIG_DS1682)		+= ds1682.o
 obj-$(CONFIG_TI_DAC7512)	+= ti_dac7512.o
 obj-$(CONFIG_UID_STAT)		+= uid_stat.o
 obj-$(CONFIG_C2PORT)		+= c2port/
+obj-$(CONFIG_MPU_SENSORS_MPU6050B1)		+= inv_mpu/
 obj-$(CONFIG_SW_3G_MODULE)	+= sw_3g_module/
 obj-$(CONFIG_IWMC3200TOP)      += iwmc3200top/
 obj-$(CONFIG_HMC6352)		+= hmc6352.o
diff --git a/drivers/misc/inv_mpu/Kconfig b/drivers/misc/inv_mpu/Kconfig
new file mode 100644
index 0000000..53c7c20
--- /dev/null
+++ b/drivers/misc/inv_mpu/Kconfig
@@ -0,0 +1,77 @@
+config MPU_SENSORS_TIMERIRQ
+	tristate "MPU Timer IRQ"
+	help
+	  If you say yes here you get access to the timerirq device handle which
+	  can be used to select on.  This can be used instead of IRQ's, sleeping,
+	  or timer threads.  Reading from this device returns the same type of
+	  information as reading from the MPU and slave IRQ's.
+
+menuconfig: INV_SENSORS
+	tristate "Motion Processing Unit"
+	depends on I2C
+	default y
+
+if INV_SENSORS
+
+choice
+	prompt "MPU Master"
+	depends on I2C && INV_SENSORS
+	default MPU_SENSORS_MPU3050
+
+config MPU_SENSORS_MPU3050
+	bool "MPU3050"
+	depends on I2C
+	select MPU_SENSORS_MPU3050_GYRO
+	help
+	  If you say yes here you get support for the MPU3050 Gyroscope driver
+	  This driver can also be built as a module.  If so, the module
+	  will be called mpu3050.
+
+config MPU_SENSORS_MPU6050A2
+	bool "MPU6050A2"
+	depends on I2C
+	select MPU_SENSORS_MPU6050_GYRO
+	help
+	  If you say yes here you get support for the MPU6050A2 Gyroscope driver
+	  This driver can also be built as a module.  If so, the module
+	  will be called mpu6050a2.
+
+config MPU_SENSORS_MPU6050B1
+	bool "MPU6050B1"
+	select MPU_SENSORS_MPU6050_GYRO
+	depends on I2C
+	help
+	  If you say yes here you get support for the MPU6050 Gyroscope driver
+	  This driver can also be built as a module.  If so, the module
+	  will be called mpu6050b1.
+
+endchoice
+
+choice
+	prompt "Gyroscope Type"
+	depends on I2C && INV_SENSORS
+	default MPU_SENSORS_MPU3050_GYRO
+
+config MPU_SENSORS_MPU3050_GYRO
+	bool "MPU3050 built in gyroscope"
+	depends on MPU_SENSORS_MPU3050
+
+config MPU_SENSORS_MPU6050_GYRO
+	bool "MPU6050 built in gyroscope"
+	depends on MPU_SENSORS_MPU6050B1 || MPU_SENSORS_MPU6050A2
+
+endchoice
+
+source "drivers/misc/inv_mpu/accel/Kconfig"
+source "drivers/misc/inv_mpu/compass/Kconfig"
+source "drivers/misc/inv_mpu/pressure/Kconfig"
+
+config MPU_USERSPACE_DEBUG
+	bool "MPU Userspace debugging ioctls"
+	help
+	  Allows the ioctls MPU_SET_MPU_PLATFORM_DATA and
+	  MPU_SET_EXT_SLAVE_PLATFORM_DATA, which allows userspace applications
+	  to override the slave address and orientation.  This is dangerous
+	  and could cause the devices not to work.
+
+endif #INV_SENSORS
diff --git a/drivers/misc/inv_mpu/Makefile b/drivers/misc/inv_mpu/Makefile
new file mode 100644
index 0000000..248648f
--- /dev/null
+++ b/drivers/misc/inv_mpu/Makefile
@@ -0,0 +1,45 @@
+
+# Kernel makefile for motions sensors
+#
+#
+
+# MPU
+ifdef CONFIG_MPU_SENSORS_MPU3050
+INV_MODULE_NAME := mpu3050
+endif
+
+ifdef CONFIG_MPU_SENSORS_MPU6050A2
+INV_MODULE_NAME := mpu6050
+endif
+
+ifdef CONFIG_MPU_SENSORS_MPU6050B1
+INV_MODULE_NAME := mpu6050
+endif
+
+obj-$(CONFIG_INV_SENSORS)	+= $(INV_MODULE_NAME).o
+
+$(INV_MODULE_NAME)-objs += mpuirq.o
+$(INV_MODULE_NAME)-objs += slaveirq.o
+$(INV_MODULE_NAME)-objs += mpu-dev.o
+$(INV_MODULE_NAME)-objs += mlsl-kernel.o
+$(INV_MODULE_NAME)-objs += mldl_cfg.o
+$(INV_MODULE_NAME)-objs += mldl_print_cfg.o
+
+ifdef CONFIG_MPU_SENSORS_MPU6050A2
+$(INV_MODULE_NAME)-objs += accel/mpu6050.o
+endif
+
+ifdef CONFIG_MPU_SENSORS_MPU6050B1
+$(INV_MODULE_NAME)-objs += accel/mpu6050.o
+endif
+
+EXTRA_CFLAGS += -Idrivers/misc/inv_mpu
+EXTRA_CFLAGS += -D__C99_DESIGNATED_INITIALIZER
+EXTRA_CFLAGS += -DINV_CACHE_DMP=1
+
+obj-$(CONFIG_MPU_SENSORS_TIMERIRQ)+= timerirq.o
+
+obj-y			+= accel/
+obj-y			+= compass/
+obj-y			+= pressure/
+
diff --git a/drivers/misc/inv_mpu/README b/drivers/misc/inv_mpu/README
new file mode 100644
index 0000000..ce592c8
--- /dev/null
+++ b/drivers/misc/inv_mpu/README
@@ -0,0 +1,104 @@
+Kernel driver mpu
+=====================
+
+Supported chips:
+  * InvenSense IMU3050
+    Prefix: 'mpu3050'
+    Datasheet:
+        PS-MPU-3000A-00.2.4b.pdf
+
+Author: InvenSense <http://invensense.com>
+
+Description
+-----------
+The mpu is a motion processor unit that controls the mpu3050 gyroscope, a slave
+accelerometer, a compass and a pressure sensor.  This document describes how to
+install the driver into a Linux kernel.
+
+Sysfs entries
+-------------
+/dev/mpu
+/dev/mpuirq
+/dev/accelirq
+/dev/compassirq
+/dev/pressureirq
+
+General Remarks MPU3050
+-----------------------
+* Valid addresses for the MPU3050 is 0x68.
+* Accelerometer must be on the secondary I2C bus for MPU3050, the
+  magnetometer must be on the primary bus and pressure sensor must
+  be on the primary bus.
+
+Programming the chip using /dev/mpu
+----------------------------------
+Programming of MPU3050 is done by first opening the /dev/mpu file and
+then performing a series of IOCTLS on the handle returned.  The IOCTL codes can
+be found in mpu.h.  Typically this is done by the mllite library in user
+space.
+
+Board and Platform Data
+-----------------------
+
+In order for the driver to work, board and platform data specific to the device
+needs to be added to the board file.  A mpu_platform_data structure must
+be created and populated and set in the i2c_board_info_structure.  For details
+of each structure member see mpu.h.  All values below are simply an example and
+should be modified for your platform.
+
+#include <linux/mpu.h>
+
+static struct mpu_platform_data mpu3050_data = {
+	.int_config  = 0x10,
+	.orientation = {  -1,  0,  0,
+			   0,  1,  0,
+			   0,  0, -1 },
+};
+
+/* accel */
+static struct ext_slave_platform_data inv_mpu_kxtf9_data = {
+	.bus         = EXT_SLAVE_BUS_SECONDARY,
+	.orientation = {  -1,  0,  0,
+			  0,  1,  0,
+			  0,  0, -1 },
+};
+/* compass */
+static struct ext_slave_platform_data inv_mpu_ak8975_data = {
+	.bus         = EXT_SLAVE_BUS_PRIMARY,
+	.orientation = { 1, 0, 0,
+			 0, 1, 0,
+			 0, 0, 1 },
+};
+
+static struct i2c_board_info __initdata panda_inv_mpu_i2c4_boardinfo[] = {
+	{
+		I2C_BOARD_INFO("mpu3050", 0x68),
+		.irq = (IH_GPIO_BASE + MPUIRQ_GPIO),
+		.platform_data = &mpu3050_data,
+	},
+	{
+		I2C_BOARD_INFO("kxtf9", 0x0F),
+		.irq = (IH_GPIO_BASE + ACCEL_IRQ_GPIO),
+		.platform_data = &inv_mpu_kxtf9_data
+	},
+	{
+		I2C_BOARD_INFO("ak8975", 0x0E),
+		.irq = (IH_GPIO_BASE + COMPASS_IRQ_GPIO),
+		.platform_data = &inv_mpu_ak8975_data,
+	},
+};
+
+Typically the IRQ is a GPIO input pin and needs to be configured properly.  If
+in the above example GPIO 168 corresponds to IRQ 299, the following should be
+done as well:
+
+#define MPU_GPIO_IRQ 168
+
+    gpio_request(MPU_GPIO_IRQ,"MPUIRQ");
+    gpio_direction_input(MPU_GPIO_IRQ)
+
+Dynamic Debug
+=============
+
+The mpu3050 makes use of dynamic debug.  For details on how to use this
+refer to Documentation/dynamic-debug-howto.txt
diff --git a/drivers/misc/inv_mpu/accel/Kconfig b/drivers/misc/inv_mpu/accel/Kconfig
new file mode 100644
index 0000000..4e280bd
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/Kconfig
@@ -0,0 +1,133 @@
+menuconfig INV_SENSORS_ACCELEROMETERS
+	bool "Accelerometer Slave Sensors"
+	default y
+	---help---
+	  Say Y here to get to see options for device drivers for various
+	  accelerometrs for integration with the MPU3050 or MPU6050 driver.
+	  This option alone does not add any kernel code.
+
+	  If you say N, all options in this submenu will be skipped and disabled.
+
+if INV_SENSORS_ACCELEROMETERS
+
+config MPU_SENSORS_ADXL34X
+	tristate "ADI adxl34x"
+	depends on MPU_SENSORS_MPU3050 || MPU_SENSORS_MPU6050B1 || MPU_SENSORS_MPU6050A2
+	help
+	  This enables support for the ADI adxl345 or adxl346 accelerometers.
+	  This support is for integration with the MPU3050 gyroscope device
+	  driver.  Only one accelerometer can be registered at a time.
+	  Specifying more that one accelerometer in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_BMA222
+	tristate "Bosch BMA222"
+	depends on MPU_SENSORS_MPU3050 || MPU_SENSORS_MPU6050B1 || MPU_SENSORS_MPU6050A2
+	help
+	  This enables support for the Bosch BMA222 accelerometer
+	  This support is for integration with the MPU3050 gyroscope device
+	  driver.  Only one accelerometer can be registered at a time.
+	  Specifying more that one accelerometer in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_BMA150
+	tristate "Bosch BMA150"
+	depends on MPU_SENSORS_MPU3050 || MPU_SENSORS_MPU6050B1 || MPU_SENSORS_MPU6050A2
+	help
+	  This enables support for the Bosch BMA150 accelerometer
+	  This support is for integration with the MPU3050 gyroscope device
+	  driver.  Only one accelerometer can be registered at a time.
+	  Specifying more that one accelerometer in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_BMA250
+	tristate "Bosch BMA250"
+	depends on MPU_SENSORS_MPU3050 || MPU_SENSORS_MPU6050B1 || MPU_SENSORS_MPU6050A2
+	help
+	  This enables support for the Bosch BMA250 accelerometer
+	  This support is for integration with the MPU3050 gyroscope device
+	  driver.  Only one accelerometer can be registered at a time.
+	  Specifying more that one accelerometer in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_KXSD9
+	tristate "Kionix KXSD9"
+	depends on MPU_SENSORS_MPU3050 || MPU_SENSORS_MPU6050B1 || MPU_SENSORS_MPU6050A2
+	help
+	  This enables support for the Kionix KXSD9 accelerometer
+	  This support is for integration with the MPU3050 gyroscope device
+	  driver.  Only one accelerometer can be registered at a time.
+	  Specifying more that one accelerometer in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_KXTF9
+	tristate "Kionix KXTF9"
+	depends on MPU_SENSORS_MPU3050 || MPU_SENSORS_MPU6050B1 || MPU_SENSORS_MPU6050A2
+	help
+	  This enables support for the Kionix KXFT9 accelerometer
+	  This support is for integration with the MPU3050 gyroscope device
+	  driver.  Only one accelerometer can be registered at a time.
+	  Specifying more that one accelerometer in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_LIS331DLH
+	tristate "ST lis331dlh"
+	depends on MPU_SENSORS_MPU3050 || MPU_SENSORS_MPU6050B1 || MPU_SENSORS_MPU6050A2
+	help
+	  This enables support for the ST lis331dlh accelerometer
+	  This support is for integration with the MPU3050 gyroscope device
+	  driver.  Only one accelerometer can be registered at a time.
+	  Specifying more that one accelerometer in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_LIS3DH
+	tristate "ST lis3dh"
+	depends on MPU_SENSORS_MPU3050 || MPU_SENSORS_MPU6050B1 || MPU_SENSORS_MPU6050A2
+	help
+	  This enables support for the ST lis3dh accelerometer
+	  This support is for integration with the MPU3050 gyroscope device
+	  driver.  Only one accelerometer can be registered at a time.
+	  Specifying more that one accelerometer in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_LSM303DLX_A
+	tristate "ST lsm303dlx"
+	depends on MPU_SENSORS_MPU3050 || MPU_SENSORS_MPU6050B1 || MPU_SENSORS_MPU6050A2
+	help
+	  This enables support for the ST lsm303dlh and lsm303dlm accelerometers
+	  This support is for integration with the MPU3050 gyroscope device
+	  driver.  Only one accelerometer can be registered at a time.
+	  Specifying more that one accelerometer in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_MMA8450
+	tristate "Freescale mma8450"
+	depends on MPU_SENSORS_MPU3050 || MPU_SENSORS_MPU6050B1 || MPU_SENSORS_MPU6050A2
+	help
+	  This enables support for the Freescale mma8450 accelerometer
+	  This support is for integration with the MPU3050 gyroscope device
+	  driver.  Only one accelerometer can be registered at a time.
+	  Specifying more that one accelerometer in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_MMA845X
+	tristate "Freescale mma8451/8452/8453"
+	depends on MPU_SENSORS_MPU3050 || MPU_SENSORS_MPU6050B1 || MPU_SENSORS_MPU6050A2
+	help
+	  This enables support for the Freescale mma8451/8452/8453 accelerometer
+	  This support is for integration with the MPU3050 gyroscope device
+	  driver.  Only one accelerometer can be registered at a time.
+	  Specifying more that one accelerometer in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_MPU6050_ACCEL
+	tristate "MPU6050 built in accelerometer"
+	depends on MPU_SENSORS_MPU6050B1 || MPU_SENSORS_MPU6050A2
+	help
+	  This enables support for the MPU6050 built in accelerometer.
+	  This the built in support for integration with the MPU6050 gyroscope
+	  device driver.  This is the only accelerometer supported with the
+	  MPU6050.  Specifying another accelerometer in the board file will
+	  result in runtime errors.
+
+endif
diff --git a/drivers/misc/inv_mpu/accel/Makefile b/drivers/misc/inv_mpu/accel/Makefile
new file mode 100644
index 0000000..1f0f5be
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/Makefile
@@ -0,0 +1,38 @@
+#
+# Accel Slaves to MPUxxxx
+#
+obj-$(CONFIG_MPU_SENSORS_ADXL34X) += inv_mpu_adxl34x.o
+inv_mpu_adxl34x-objs += adxl34x.o
+
+obj-$(CONFIG_MPU_SENSORS_BMA150) += inv_mpu_bma150.o
+inv_mpu_bma150-objs += bma150.o
+
+obj-$(CONFIG_MPU_SENSORS_KXTF9) += inv_mpu_kxtf9.o
+inv_mpu_kxtf9-objs += kxtf9.o
+
+obj-$(CONFIG_MPU_SENSORS_BMA222) += inv_mpu_bma222.o
+inv_mpu_bma222-objs += bma222.o
+
+obj-$(CONFIG_MPU_SENSORS_BMA250) += inv_mpu_bma250.o
+inv_mpu_bma250-objs += bma250.o
+
+obj-$(CONFIG_MPU_SENSORS_KXSD9) += inv_mpu_kxsd9.o
+inv_mpu_kxsd9-objs += kxsd9.o
+
+obj-$(CONFIG_MPU_SENSORS_LIS331DLH) += inv_mpu_lis331.o
+inv_mpu_lis331-objs += lis331.o
+
+obj-$(CONFIG_MPU_SENSORS_LIS3DH) += inv_mpu_lis3dh.o
+inv_mpu_lis3dh-objs += lis3dh.o
+
+obj-$(CONFIG_MPU_SENSORS_LSM303DLX_A) += inv_mpu_lsm303dlx_a.o
+inv_mpu_lsm303dlx_a-objs += lsm303dlx_a.o
+
+obj-$(CONFIG_MPU_SENSORS_MMA8450) += inv_mpu_mma8450.o
+inv_mpu_mma8450-objs += mma8450.o
+
+obj-$(CONFIG_MPU_SENSORS_MMA845X) += inv_mpu_mma845x.o
+inv_mpu_mma845x-objs += mma845x.o
+
+EXTRA_CFLAGS += -Idrivers/misc/inv_mpu
+EXTRA_CFLAGS += -D__C99_DESIGNATED_INITIALIZER
diff --git a/drivers/misc/inv_mpu/accel/adxl34x.c b/drivers/misc/inv_mpu/accel/adxl34x.c
new file mode 100644
index 0000000..f2bff8a
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/adxl34x.c
@@ -0,0 +1,728 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup ACCELDL
+ *  @brief      Provides the interface to setup and handle an accelerometer.
+ *
+ *  @{
+ *      @file   adxl34x.c
+ *      @brief  Accelerometer setup and handling methods for AD adxl345 and
+ *              adxl346.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-acc"
+
+/* -------------------------------------------------------------------------- */
+
+/* registers */
+#define ADXL34X_ODR_REG			(0x2C)
+#define ADXL34X_PWR_REG			(0x2D)
+#define ADXL34X_DATAFORMAT_REG		(0x31)
+
+/* masks */
+#define ADXL34X_ODR_MASK		(0x0F)
+#define ADXL34X_PWR_SLEEP_MASK		(0x04)
+#define ADXL34X_PWR_MEAS_MASK		(0x08)
+#define ADXL34X_DATAFORMAT_JUSTIFY_MASK	(0x04)
+#define ADXL34X_DATAFORMAT_FSR_MASK	(0x03)
+
+/* -------------------------------------------------------------------------- */
+
+struct adxl34x_config {
+	unsigned int odr;		/** < output data rate in mHz */
+	unsigned int fsr;		/** < full scale range mg */
+	unsigned int fsr_reg_mask;	/** < register setting for fsr */
+};
+
+struct adxl34x_private_data {
+	struct adxl34x_config suspend;	/** < suspend configuration */
+	struct adxl34x_config resume;	/** < resume configuration */
+};
+
+/**
+ *  @brief Set the output data rate for the particular configuration.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *             Config to modify with new ODR.
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param odr
+ *             Output data rate in units of 1/1000Hz (mHz).
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int adxl34x_set_odr(void *mlsl_handle,
+			   struct ext_slave_platform_data *pdata,
+			   struct adxl34x_config *config,
+			   int apply,
+			   long odr)
+{
+	int result = INV_SUCCESS;
+	unsigned char new_odr_mask;
+
+	/* ADXL346 (Rev. A) pages 13, 24 */
+	if (odr >= 3200000) {
+		new_odr_mask = 0x0F;
+		config->odr = 3200000;
+	} else if (odr >= 1600000) {
+		new_odr_mask = 0x0E;
+		config->odr = 1600000;
+	} else if (odr >= 800000) {
+		new_odr_mask = 0x0D;
+		config->odr = 800000;
+	} else if (odr >= 400000) {
+		new_odr_mask = 0x0C;
+		config->odr = 400000;
+	} else if (odr >= 200000) {
+		new_odr_mask = 0x0B;
+		config->odr = 200000;
+	} else if (odr >= 100000) {
+		new_odr_mask = 0x0A;
+		config->odr = 100000;
+	} else if (odr >= 50000) {
+		new_odr_mask = 0x09;
+		config->odr = 50000;
+	} else if (odr >= 25000) {
+		new_odr_mask = 0x08;
+		config->odr = 25000;
+	} else if (odr >= 12500) {
+		new_odr_mask = 0x07;
+		config->odr = 12500;
+	} else if (odr >= 6250) {
+		new_odr_mask = 0x06;
+		config->odr = 6250;
+	} else if (odr >= 3130) {
+		new_odr_mask = 0x05;
+		config->odr = 3130;
+	} else if (odr >= 1560) {
+		new_odr_mask = 0x04;
+		config->odr = 1560;
+	} else if (odr >= 780) {
+		new_odr_mask = 0x03;
+		config->odr = 780;
+	} else if (odr >= 390) {
+		new_odr_mask = 0x02;
+		config->odr = 390;
+	} else if (odr >= 200) {
+		new_odr_mask = 0x01;
+		config->odr = 200;
+	} else {
+		new_odr_mask = 0x00;
+		config->odr = 100;
+	}
+
+	if (apply) {
+		unsigned char reg_odr;
+		result = inv_serial_read(mlsl_handle, pdata->address,
+				ADXL34X_ODR_REG, 1, &reg_odr);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		reg_odr &= ~ADXL34X_ODR_MASK;
+		reg_odr |= new_odr_mask;
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				ADXL34X_ODR_REG, reg_odr);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		MPL_LOGV("ODR: %d mHz\n", config->odr);
+	}
+	return result;
+}
+
+/**
+ *  @brief Set the full scale range of the accels
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *             pointer to configuration.
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param fsr
+ *             requested full scale range in milli gees (mg).
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int adxl34x_set_fsr(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct adxl34x_config *config,
+			  int apply,
+			  long fsr)
+{
+	int result = INV_SUCCESS;
+
+	if (fsr <= 2000) {
+		config->fsr_reg_mask = 0x00;
+		config->fsr = 2000;
+	} else if (fsr <= 4000) {
+		config->fsr_reg_mask = 0x01;
+		config->fsr = 4000;
+	} else if (fsr <= 8000) {
+		config->fsr_reg_mask = 0x02;
+		config->fsr = 8000;
+	} else { /* 8001 -> oo */
+		config->fsr_reg_mask = 0x03;
+		config->fsr = 16000;
+	}
+
+	if (apply) {
+		unsigned char reg_df;
+		result = inv_serial_read(mlsl_handle, pdata->address,
+				ADXL34X_DATAFORMAT_REG, 1, &reg_df);
+		reg_df &= ~ADXL34X_DATAFORMAT_FSR_MASK;
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				ADXL34X_DATAFORMAT_REG,
+				reg_df | config->fsr_reg_mask);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		MPL_LOGV("FSR: %d mg\n", config->fsr);
+	}
+	return result;
+}
+
+/**
+ *  @brief facility to retrieve the device configuration.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a pointer to store the returned configuration data structure.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int adxl34x_get_config(void *mlsl_handle,
+		    struct ext_slave_descr *slave,
+				struct ext_slave_platform_data *pdata,
+				struct ext_slave_config *data)
+{
+	struct adxl34x_private_data *private_data =
+			(struct adxl34x_private_data *)(pdata->private_data);
+
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.odr;
+		break;
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.odr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief device configuration facility.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a pointer to the configuration data structure.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int adxl34x_config(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata,
+			 struct ext_slave_config *data)
+{
+	struct adxl34x_private_data *private_data =
+			(struct adxl34x_private_data *)(pdata->private_data);
+
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		return adxl34x_set_odr(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		return adxl34x_set_odr(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		return adxl34x_set_fsr(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		return adxl34x_set_fsr(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief suspends the device to put it in its lowest power mode.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int adxl34x_suspend(void *mlsl_handle,
+			   struct ext_slave_descr *slave,
+			   struct ext_slave_platform_data *pdata)
+{
+	int result;
+
+	/*
+	struct adxl34x_config *suspend_config =
+		&((struct adxl34x_private_data *)pdata->private_data)->suspend;
+
+	result = adxl34x_set_odr(mlsl_handle, pdata, suspend_config,
+				true, suspend_config->odr);
+	if (result) {
+	LOG_RESULT_LOCATION(result);
+	return result;
+}
+	result = adxl34x_set_fsr(mlsl_handle, pdata, suspend_config,
+				true, suspend_config->fsr);
+	if (result) {
+	LOG_RESULT_LOCATION(result);
+	return result;
+}
+	*/
+
+	/*
+	  Page 25
+	  When clearing the sleep bit, it is recommended that the part
+	  be placed into standby mode and then set back to measurement mode
+	  with a subsequent write.
+	  This is done to ensure that the device is properly biased if sleep
+	  mode is manually disabled; otherwise, the first few samples of data
+	  after the sleep bit is cleared may have additional noise,
+	  especially if the device was asleep when the bit was cleared. */
+
+	/* go in standy-by mode (suspends measurements) */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			ADXL34X_PWR_REG, ADXL34X_PWR_MEAS_MASK);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* and then in sleep */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			ADXL34X_PWR_REG,
+			ADXL34X_PWR_MEAS_MASK | ADXL34X_PWR_SLEEP_MASK);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return result;
+}
+
+/**
+ *  @brief resume the device in the proper power state given the configuration
+ *         chosen.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int adxl34x_resume(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	struct adxl34x_config *resume_config =
+		&((struct adxl34x_private_data *)pdata->private_data)->resume;
+	unsigned char reg;
+
+	/*
+	  Page 25
+	  When clearing the sleep bit, it is recommended that the part
+	  be placed into standby mode and then set back to measurement mode
+	  with a subsequent write.
+	  This is done to ensure that the device is properly biased if sleep
+	  mode is manually disabled; otherwise, the first few samples of data
+	  after the sleep bit is cleared may have additional noise,
+	  especially if the device was asleep when the bit was cleared. */
+
+	/* remove sleep, but leave in stand-by */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			ADXL34X_PWR_REG, ADXL34X_PWR_MEAS_MASK);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = adxl34x_set_odr(mlsl_handle, pdata, resume_config,
+				true, resume_config->odr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/*
+	  -> FSR
+	  -> Justiy bit for Big endianess
+	  -> resulution to 10 bits
+	*/
+	reg = ADXL34X_DATAFORMAT_JUSTIFY_MASK;
+	reg |= resume_config->fsr_reg_mask;
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			ADXL34X_DATAFORMAT_REG, reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* go in measurement mode */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			ADXL34X_PWR_REG, 0x00);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* DATA_FORMAT: full resolution of +/-2g; data is left justified */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 0x31, reg);
+
+	return result;
+}
+
+/**
+ *  @brief one-time device driver initialization function.
+ *         If the driver is built as a kernel module, this function will be
+ *         called when the module is loaded in the kernel.
+ *         If the driver is built-in in the kernel, this function will be
+ *         called at boot time.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int adxl34x_init(void *mlsl_handle,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata)
+{
+	int result;
+	long range;
+
+	struct adxl34x_private_data *private_data;
+	private_data = (struct adxl34x_private_data *)
+	    kzalloc(sizeof(struct adxl34x_private_data), GFP_KERNEL);
+
+	if (!private_data)
+		return INV_ERROR_MEMORY_EXAUSTED;
+
+	pdata->private_data = private_data;
+
+	result = adxl34x_set_odr(mlsl_handle, pdata, &private_data->suspend,
+				false, 0);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = adxl34x_set_odr(mlsl_handle, pdata, &private_data->resume,
+				false, 200000);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	range = range_fixedpoint_to_long_mg(slave->range);
+	result = adxl34x_set_fsr(mlsl_handle, pdata, &private_data->suspend,
+				false, range);
+	result = adxl34x_set_fsr(mlsl_handle, pdata, &private_data->resume,
+				false, range);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = adxl34x_suspend(mlsl_handle, slave, pdata);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+/**
+ *  @brief one-time device driver exit function.
+ *         If the driver is built as a kernel module, this function will be
+ *         called when the module is removed from the kernel.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int adxl34x_exit(void *mlsl_handle,
+		 struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata)
+{
+	kfree(pdata->private_data);
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief read the sensor data from the device.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a buffer to store the data read.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int adxl34x_read(void *mlsl_handle,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata,
+			unsigned char *data)
+{
+	int result;
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 slave->read_reg, slave->read_len, data);
+	return result;
+}
+
+static struct ext_slave_descr adxl34x_descr = {
+	.init             = adxl34x_init,
+	.exit             = adxl34x_exit,
+	.suspend          = adxl34x_suspend,
+	.resume           = adxl34x_resume,
+	.read             = adxl34x_read,
+	.config           = adxl34x_config,
+	.get_config       = adxl34x_get_config,
+	.name             = "adxl34x",	/* 5 or 6 */
+	.type             = EXT_SLAVE_TYPE_ACCEL,
+	.id               = ACCEL_ID_ADXL34X,
+	.read_reg         = 0x32,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_LITTLE_ENDIAN,
+	.range            = {2, 0},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *adxl34x_get_slave_descr(void)
+{
+	return &adxl34x_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct adxl34x_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int adxl34x_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct adxl34x_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					adxl34x_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int adxl34x_mod_remove(struct i2c_client *client)
+{
+	struct adxl34x_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				adxl34x_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id adxl34x_mod_id[] = {
+	{ "adxl34x", ACCEL_ID_ADXL34X },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, adxl34x_mod_id);
+
+static struct i2c_driver adxl34x_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = adxl34x_mod_probe,
+	.remove = adxl34x_mod_remove,
+	.id_table = adxl34x_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "adxl34x_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init adxl34x_mod_init(void)
+{
+	int res = i2c_add_driver(&adxl34x_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "adxl34x_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit adxl34x_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&adxl34x_mod_driver);
+}
+
+module_init(adxl34x_mod_init);
+module_exit(adxl34x_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate ADXL34X sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("adxl34x_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/accel/bma150.c b/drivers/misc/inv_mpu/accel/bma150.c
new file mode 100644
index 0000000..745d90a
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/bma150.c
@@ -0,0 +1,777 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup ACCELDL
+ *  @brief      Provides the interface to setup and handle an accelerometer.
+ *
+ *  @{
+ *      @file   bma150.c
+ *      @brief  Accelerometer setup and handling methods for Bosch BMA150.
+ */
+
+/* -------------------------------------------------------------------------- */
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+
+/* -------------------------------------------------------------------------- */
+/* registers */
+#define BMA150_CTRL_REG			(0x14)
+#define BMA150_INT_REG			(0x15)
+#define BMA150_PWR_REG			(0x0A)
+
+/* masks */
+#define BMA150_CTRL_MASK		(0x18)
+#define BMA150_CTRL_MASK_ODR		(0xF8)
+#define BMA150_CTRL_MASK_FSR		(0xE7)
+#define BMA150_INT_MASK_WUP		(0xF8)
+#define BMA150_INT_MASK_IRQ		(0xDF)
+#define BMA150_PWR_MASK_SLEEP		(0x01)
+#define BMA150_PWR_MASK_SOFT_RESET	(0x02)
+
+/* -------------------------------------------------------------------------- */
+struct bma150_config {
+	unsigned int odr;	/** < output data rate mHz */
+	unsigned int fsr;	/** < full scale range mgees */
+	unsigned int irq_type;	/** < type of IRQ, see bma150_set_irq */
+	unsigned char ctrl_reg;	/** < control register value */
+	unsigned char int_reg;	/** < interrupt control register value */
+};
+
+struct bma150_private_data {
+	struct bma150_config suspend;	/** < suspend configuration */
+	struct bma150_config resume;	/** < resume configuration */
+};
+
+/**
+ *  @brief Simply disables the IRQ since it is not usable on BMA150 devices.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *              configuration to apply to, suspend or resume
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param irq_type
+ *              the type of IRQ.  Valid values are
+ *              - MPU_SLAVE_IRQ_TYPE_NONE
+ *              - MPU_SLAVE_IRQ_TYPE_MOTION
+ *              - MPU_SLAVE_IRQ_TYPE_DATA_READY
+ *              The only supported IRQ type is MPU_SLAVE_IRQ_TYPE_NONE which
+ *              corresponds to disabling the IRQ completely.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma150_set_irq(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct bma150_config *config,
+			  int apply,
+			  long irq_type)
+{
+	int result = INV_SUCCESS;
+
+	if (irq_type != MPU_SLAVE_IRQ_TYPE_NONE)
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+
+	config->irq_type = MPU_SLAVE_IRQ_TYPE_NONE;
+	config->int_reg = 0x00;
+
+	if (apply) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+			 BMA150_CTRL_REG, config->ctrl_reg);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+			 BMA150_INT_REG, config->int_reg);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+	return result;
+}
+
+/**
+ *  @brief Set the output data rate for the particular configuration.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *             Config to modify with new ODR.
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param odr
+ *             Output data rate in units of 1/1000Hz (mHz).
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma150_set_odr(void *mlsl_handle,
+			struct ext_slave_platform_data *pdata,
+			struct bma150_config *config,
+			int apply,
+			long odr)
+{
+	unsigned char odr_bits = 0;
+	unsigned char wup_bits = 0;
+	int result = INV_SUCCESS;
+
+	if (odr > 100000) {
+		config->odr = 190000;
+		odr_bits = 0x03;
+	} else if (odr > 50000) {
+		config->odr = 100000;
+		odr_bits = 0x02;
+	} else if (odr > 25000) {
+		config->odr = 50000;
+		odr_bits = 0x01;
+	} else if (odr > 0) {
+		config->odr = 25000;
+		odr_bits = 0x00;
+	} else {
+		config->odr = 0;
+		wup_bits = 0x00;
+	}
+
+	config->int_reg &= BMA150_INT_MASK_WUP;
+	config->ctrl_reg &= BMA150_CTRL_MASK_ODR;
+	config->ctrl_reg |= odr_bits;
+
+	MPL_LOGV("ODR: %d\n", config->odr);
+	if (apply) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					BMA150_CTRL_REG, config->ctrl_reg);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					BMA150_INT_REG, config->int_reg);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	return result;
+}
+
+/**
+ *  @brief Set the full scale range of the accels
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *             pointer to configuration.
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param fsr
+ *             requested full scale range.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma150_set_fsr(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct bma150_config *config,
+			  int apply,
+			  long fsr)
+{
+	unsigned char fsr_bits;
+	int result = INV_SUCCESS;
+
+	if (fsr <= 2048) {
+		fsr_bits = 0x00;
+		config->fsr = 2048;
+	} else if (fsr <= 4096) {
+		fsr_bits = 0x08;
+		config->fsr = 4096;
+	} else {
+		fsr_bits = 0x10;
+		config->fsr = 8192;
+	}
+
+	config->ctrl_reg &= BMA150_CTRL_MASK_FSR;
+	config->ctrl_reg |= fsr_bits;
+
+	MPL_LOGV("FSR: %d\n", config->fsr);
+	if (apply) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA150_CTRL_REG, config->ctrl_reg);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA150_CTRL_REG, config->ctrl_reg);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+	return result;
+}
+
+/**
+ *  @brief one-time device driver initialization function.
+ *         If the driver is built as a kernel module, this function will be
+ *         called when the module is loaded in the kernel.
+ *         If the driver is built-in in the kernel, this function will be
+ *         called at boot time.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma150_init(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	int result;
+	unsigned char reg;
+	long range;
+
+	struct bma150_private_data *private_data;
+	private_data = (struct bma150_private_data *)
+	    kzalloc(sizeof(struct bma150_private_data), GFP_KERNEL);
+
+	if (!private_data)
+		return INV_ERROR_MEMORY_EXAUSTED;
+
+	pdata->private_data = private_data;
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			BMA150_PWR_REG, BMA150_PWR_MASK_SOFT_RESET);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(1);
+
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 BMA150_CTRL_REG, 1, &reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	private_data->resume.ctrl_reg = reg;
+	private_data->suspend.ctrl_reg = reg;
+
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 BMA150_INT_REG, 1, &reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	private_data->resume.int_reg = reg;
+	private_data->suspend.int_reg = reg;
+
+	result = bma150_set_odr(mlsl_handle, pdata, &private_data->suspend,
+				false, 0);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = bma150_set_odr(mlsl_handle, pdata, &private_data->resume,
+				false, 200000);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	range = range_fixedpoint_to_long_mg(slave->range);
+	result = bma150_set_fsr(mlsl_handle, pdata, &private_data->suspend,
+				false, range);
+	result = bma150_set_fsr(mlsl_handle, pdata, &private_data->resume,
+				false, range);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = bma150_set_irq(mlsl_handle, pdata, &private_data->suspend,
+				false, MPU_SLAVE_IRQ_TYPE_NONE);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = bma150_set_irq(mlsl_handle, pdata, &private_data->resume,
+				false, MPU_SLAVE_IRQ_TYPE_NONE);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       BMA150_PWR_REG, BMA150_PWR_MASK_SLEEP);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+/**
+ *  @brief one-time device driver exit function.
+ *         If the driver is built as a kernel module, this function will be
+ *         called when the module is removed from the kernel.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma150_exit(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata)
+{
+	kfree(pdata->private_data);
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief device configuration facility.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a pointer to the configuration data structure.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma150_config(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata,
+			 struct ext_slave_config *data)
+{
+	struct bma150_private_data *private_data =
+			(struct bma150_private_data *)(pdata->private_data);
+
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		return bma150_set_odr(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		return bma150_set_odr(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		return bma150_set_fsr(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		return bma150_set_fsr(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		return bma150_set_irq(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		return bma150_set_irq(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply,
+				      *((long *)data->data));
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief facility to retrieve the device configuration.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a pointer to store the returned configuration data structure.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma150_get_config(void *mlsl_handle,
+				struct ext_slave_descr *slave,
+				struct ext_slave_platform_data *pdata,
+				struct ext_slave_config *data)
+{
+	struct bma150_private_data *private_data =
+			(struct bma150_private_data *)(pdata->private_data);
+
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.odr;
+		break;
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.odr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.irq_type;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.irq_type;
+		break;
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief suspends the device to put it in its lowest power mode.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma150_suspend(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata)
+{
+	int result;
+	unsigned char ctrl_reg;
+	unsigned char int_reg;
+
+	struct bma150_private_data *private_data =
+			(struct bma150_private_data *)(pdata->private_data);
+
+	ctrl_reg = private_data->suspend.ctrl_reg;
+	int_reg = private_data->suspend.int_reg;
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			BMA150_PWR_REG, BMA150_PWR_MASK_SOFT_RESET);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(1);
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			BMA150_CTRL_REG, ctrl_reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			BMA150_INT_REG, int_reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+		BMA150_PWR_REG, BMA150_PWR_MASK_SLEEP);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+/**
+ *  @brief resume the device in the proper power state given the configuration
+ *         chosen.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma150_resume(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata)
+{
+	int result;
+	unsigned char ctrl_reg;
+	unsigned char int_reg;
+
+	struct bma150_private_data *private_data =
+			(struct bma150_private_data *)(pdata->private_data);
+
+	ctrl_reg = private_data->resume.ctrl_reg;
+	int_reg = private_data->resume.int_reg;
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA150_PWR_REG, BMA150_PWR_MASK_SOFT_RESET);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(1);
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA150_CTRL_REG, ctrl_reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA150_INT_REG, int_reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA150_PWR_REG, 0x00);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+/**
+ *  @brief read the sensor data from the device.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a buffer to store the data read.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma150_read(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata,
+		       unsigned char *data)
+{
+	return inv_serial_read(mlsl_handle, pdata->address,
+			       slave->read_reg, slave->read_len, data);
+}
+
+static struct ext_slave_descr bma150_descr = {
+	.init             = bma150_init,
+	.exit             = bma150_exit,
+	.suspend          = bma150_suspend,
+	.resume           = bma150_resume,
+	.read             = bma150_read,
+	.config           = bma150_config,
+	.get_config       = bma150_get_config,
+	.name             = "bma150",
+	.type             = EXT_SLAVE_TYPE_ACCEL,
+	.id               = ACCEL_ID_BMA150,
+	.read_reg         = 0x02,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_LITTLE_ENDIAN,
+	.range            = {2, 0},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *bma150_get_slave_descr(void)
+{
+	return &bma150_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+
+/* Platform data for the MPU */
+struct bma150_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int bma150_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct bma150_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					bma150_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int bma150_mod_remove(struct i2c_client *client)
+{
+	struct bma150_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				bma150_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id bma150_mod_id[] = {
+	{ "bma150", ACCEL_ID_BMA150 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, bma150_mod_id);
+
+static struct i2c_driver bma150_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = bma150_mod_probe,
+	.remove = bma150_mod_remove,
+	.id_table = bma150_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "bma150_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init bma150_mod_init(void)
+{
+	int res = i2c_add_driver(&bma150_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "bma150_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit bma150_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&bma150_mod_driver);
+}
+
+module_init(bma150_mod_init);
+module_exit(bma150_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate BMA150 sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("bma150_mod");
+
+/**
+ *  @}
+ */
+
diff --git a/drivers/misc/inv_mpu/accel/bma222.c b/drivers/misc/inv_mpu/accel/bma222.c
new file mode 100644
index 0000000..e9fc99b
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/bma222.c
@@ -0,0 +1,654 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/*
+ *  @addtogroup ACCELDL
+ *  @brief      Provides the interface to setup and handle an accelerometer.
+ *
+ *  @{
+ *      @file   bma222.c
+ *      @brief  Accelerometer setup and handling methods for Bosch BMA222.
+ */
+
+/* ------------------ */
+/* - Include Files. - */
+/* ------------------ */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+
+/* -------------------------------------------------------------------------- */
+
+#define BMA222_STATUS_REG	(0x0A)
+#define BMA222_FSR_REG		(0x0F)
+#define ADXL34X_ODR_REG		(0x10)
+#define BMA222_PWR_REG		(0x11)
+#define BMA222_SOFTRESET_REG	(0x14)
+
+#define BMA222_STATUS_RDY_MASK	(0x80)
+#define BMA222_FSR_MASK		(0x0F)
+#define BMA222_ODR_MASK		(0x1F)
+#define BMA222_PWR_SLEEP_MASK	(0x80)
+#define BMA222_PWR_AWAKE_MASK	(0x00)
+#define BMA222_SOFTRESET_MASK	(0xB6)
+#define BMA222_SOFTRESET_MASK	(0xB6)
+
+/* -------------------------------------------------------------------------- */
+
+struct bma222_config {
+	unsigned int odr;		/** < output data rate in mHz */
+	unsigned int fsr;		/** < full scale range mg */
+};
+
+struct bma222_private_data {
+	struct bma222_config suspend;	/** < suspend configuration */
+	struct bma222_config resume;	/** < resume configuration */
+};
+
+
+/* -------------------------------------------------------------------------- */
+
+/**
+ *  @brief Set the output data rate for the particular configuration.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *             Config to modify with new ODR.
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param odr
+ *             Output data rate in units of 1/1000Hz (mHz).
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma222_set_odr(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct bma222_config *config,
+			  int apply,
+			  long odr)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg_odr;
+
+	if (odr >= 1000000) {
+		reg_odr = 0x0F;
+		config->odr = 1000000;
+	} else if (odr >= 500000) {
+		reg_odr = 0x0E;
+		config->odr = 500000;
+	} else if (odr >= 250000) {
+		reg_odr = 0x0D;
+		config->odr = 250000;
+	} else if (odr >= 125000) {
+		reg_odr = 0x0C;
+		config->odr = 125000;
+	} else if (odr >= 62500) {
+		reg_odr = 0x0B;
+		config->odr = 62500;
+	} else if (odr >= 32000) {
+		reg_odr = 0x0A;
+		config->odr = 32000;
+	} else if (odr >= 16000) {
+		reg_odr = 0x09;
+		config->odr = 16000;
+	} else {
+		reg_odr = 0x08;
+		config->odr = 8000;
+	}
+
+	if (apply) {
+		MPL_LOGV("ODR: %d\n", config->odr);
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					ADXL34X_ODR_REG, reg_odr);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+	return result;
+}
+
+/**
+ *  @brief Set the full scale range of the accels
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *             pointer to configuration.
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param fsr
+ *             requested full scale range.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma222_set_fsr(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct bma222_config *config,
+			  int apply,
+			  long fsr)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg_fsr_mask;
+
+	if (fsr <= 2000) {
+		reg_fsr_mask = 0x03;
+		config->fsr = 2000;
+	} else if (fsr <= 4000) {
+		reg_fsr_mask = 0x05;
+		config->fsr = 4000;
+	} else if (fsr <= 8000) {
+		reg_fsr_mask = 0x08;
+		config->fsr = 8000;
+	} else { /* 8001 -> oo */
+		reg_fsr_mask = 0x0C;
+		config->fsr = 16000;
+	}
+
+	if (apply) {
+		MPL_LOGV("FSR: %d\n", config->fsr);
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA222_FSR_REG, reg_fsr_mask);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+	return result;
+}
+
+/**
+ *  @brief one-time device driver initialization function.
+ *         If the driver is built as a kernel module, this function will be
+ *         called when the module is loaded in the kernel.
+ *         If the driver is built-in in the kernel, this function will be
+ *         called at boot time.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma222_init(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata)
+{
+	int result;
+
+	struct bma222_private_data *private_data;
+	private_data = (struct bma222_private_data *)
+	    kzalloc(sizeof(struct bma222_private_data), GFP_KERNEL);
+
+	if (!private_data)
+		return INV_ERROR_MEMORY_EXAUSTED;
+
+	pdata->private_data = private_data;
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			BMA222_SOFTRESET_REG, BMA222_SOFTRESET_MASK);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(1);
+
+	result = bma222_set_odr(mlsl_handle, pdata, &private_data->suspend,
+				false, 0);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = bma222_set_odr(mlsl_handle, pdata, &private_data->resume,
+				false, 200000);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = bma222_set_fsr(mlsl_handle, pdata, &private_data->suspend,
+				false, 2000);
+	result = bma222_set_fsr(mlsl_handle, pdata, &private_data->resume,
+				false, 2000);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA222_PWR_REG, BMA222_PWR_SLEEP_MASK);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+/**
+ *  @brief one-time device driver exit function.
+ *         If the driver is built as a kernel module, this function will be
+ *         called when the module is removed from the kernel.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma222_exit(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata)
+{
+	kfree(pdata->private_data);
+	return INV_SUCCESS;
+}
+
+
+/**
+ *  @brief facility to retrieve the device configuration.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a pointer to store the returned configuration data structure.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma222_get_config(void *mlsl_handle,
+				struct ext_slave_descr *slave,
+				struct ext_slave_platform_data *pdata,
+				struct ext_slave_config *data)
+{
+	struct bma222_private_data *private_data =
+			(struct bma222_private_data *)(pdata->private_data);
+
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.odr;
+		break;
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.odr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief device configuration facility.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a pointer to the configuration data structure.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma222_config(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata,
+			 struct ext_slave_config *data)
+{
+	struct bma222_private_data *private_data =
+			(struct bma222_private_data *)(pdata->private_data);
+
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		return bma222_set_odr(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		return bma222_set_odr(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		return bma222_set_fsr(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		return bma222_set_fsr(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief suspends the device to put it in its lowest power mode.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma222_suspend(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	int result;
+	struct bma222_config *suspend_config =
+		&((struct bma222_private_data *)pdata->private_data)->suspend;
+
+	result = bma222_set_odr(mlsl_handle, pdata, suspend_config,
+				true, suspend_config->odr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = bma222_set_fsr(mlsl_handle, pdata, suspend_config,
+				true, suspend_config->fsr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA222_PWR_REG, BMA222_PWR_SLEEP_MASK);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	msleep(3); /* 3 ms powerup time maximum */
+	return result;
+}
+
+/**
+ *  @brief resume the device in the proper power state given the configuration
+ *         chosen.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma222_resume(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata)
+{
+	int result;
+	struct bma222_config *resume_config =
+		&((struct bma222_private_data *)pdata->private_data)->resume;
+
+	/* Soft reset */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			BMA222_SOFTRESET_REG, BMA222_SOFTRESET_MASK);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(10);
+
+	result = bma222_set_odr(mlsl_handle, pdata, resume_config,
+				true, resume_config->odr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = bma222_set_fsr(mlsl_handle, pdata, resume_config,
+				true, resume_config->fsr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+/**
+ *  @brief read the sensor data from the device.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a buffer to store the data read.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma222_read(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata,
+		       unsigned char *data)
+{
+	int result = INV_SUCCESS;
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				BMA222_STATUS_REG, 1, data);
+	if (data[0] & BMA222_STATUS_RDY_MASK) {
+		result = inv_serial_read(mlsl_handle, pdata->address,
+				 slave->read_reg, slave->read_len, data);
+	return result;
+	} else
+		return INV_ERROR_ACCEL_DATA_NOT_READY;
+}
+
+static struct ext_slave_descr bma222_descr = {
+	.init             = bma222_init,
+	.exit             = bma222_exit,
+	.suspend          = bma222_suspend,
+	.resume           = bma222_resume,
+	.read             = bma222_read,
+	.config           = bma222_config,
+	.get_config       = bma222_get_config,
+	.name             = "bma222",
+	.type             = EXT_SLAVE_TYPE_ACCEL,
+	.id               = ACCEL_ID_BMA222,
+	.read_reg         = 0x02,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_LITTLE_ENDIAN,
+	.range            = {2, 0},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *bma222_get_slave_descr(void)
+{
+	return &bma222_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+
+struct bma222_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int bma222_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct bma222_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					bma222_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int bma222_mod_remove(struct i2c_client *client)
+{
+	struct bma222_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				bma222_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id bma222_mod_id[] = {
+	{ "bma222", ACCEL_ID_BMA222 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, bma222_mod_id);
+
+static struct i2c_driver bma222_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = bma222_mod_probe,
+	.remove = bma222_mod_remove,
+	.id_table = bma222_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "bma222_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init bma222_mod_init(void)
+{
+	int res = i2c_add_driver(&bma222_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "bma222_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit bma222_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&bma222_mod_driver);
+}
+
+module_init(bma222_mod_init);
+module_exit(bma222_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate BMA222 sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("bma222_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/accel/bma250.c b/drivers/misc/inv_mpu/accel/bma250.c
new file mode 100644
index 0000000..6a245f4
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/bma250.c
@@ -0,0 +1,787 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup ACCELDL
+ *  @brief      Provides the interface to setup and handle an accelerometer.
+ *
+ *  @{
+ *      @file   bma250.c
+ *      @brief  Accelerometer setup and handling methods for Bosch BMA250.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+
+/* -------------------------------------------------------------------------- */
+
+/* registers */
+#define BMA250_STATUS_REG	(0x0A)
+#define BMA250_FSR_REG		(0x0F)
+#define BMA250_ODR_REG		(0x10)
+#define BMA250_PWR_REG		(0x11)
+#define BMA250_SOFTRESET_REG	(0x14)
+#define BMA250_INT_TYPE_REG	(0x17)
+#define BMA250_INT_DST_REG	(0x1A)
+#define BMA250_INT_SRC_REG	(0x1E)
+
+/* masks */
+#define BMA250_STATUS_RDY_MASK	(0x80)
+#define BMA250_FSR_MASK		(0x0F)
+#define BMA250_ODR_MASK		(0x1F)
+#define BMA250_PWR_SLEEP_MASK	(0x80)
+#define BMA250_PWR_AWAKE_MASK	(0x00)
+#define BMA250_SOFTRESET_MASK   (0xB6)
+#define BMA250_INT_TYPE_MASK	(0x10)
+#define BMA250_INT_DST_1_MASK	(0x01)
+#define BMA250_INT_DST_2_MASK	(0x80)
+#define BMA250_INT_SRC_MASK	(0x00)
+
+/* -------------------------------------------------------------------------- */
+
+struct bma250_config {
+	unsigned int odr;		/** < output data rate in mHz */
+	unsigned int fsr;		/** < full scale range mg */
+	unsigned char irq_type;
+};
+
+struct bma250_private_data {
+	struct bma250_config suspend;	/** < suspend configuration */
+	struct bma250_config resume;	/** < resume configuration */
+};
+
+/* -------------------------------------------------------------------------- */
+/**
+ *  @brief Sets the IRQ to fire when one of the IRQ events occur.
+ *         Threshold and duration will not be used unless the type is MOT or
+ *         NMOT.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *              configuration to apply to, suspend or resume
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param irq_type
+ *              the type of IRQ.  Valid values are
+ * - MPU_SLAVE_IRQ_TYPE_NONE
+ * - MPU_SLAVE_IRQ_TYPE_MOTION
+ * - MPU_SLAVE_IRQ_TYPE_DATA_READY
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma250_set_irq(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct bma250_config *config,
+			  int apply, long irq_type)
+{
+	int result = INV_SUCCESS;
+	unsigned char irqtype_reg;
+	unsigned char irqdst_reg;
+	unsigned char irqsrc_reg;
+
+	switch (irq_type) {
+	case MPU_SLAVE_IRQ_TYPE_DATA_READY:
+		/* data ready int. */
+		irqtype_reg = BMA250_INT_TYPE_MASK;
+		/* routed to interrupt pin 1 */
+		irqdst_reg = BMA250_INT_DST_1_MASK;
+		/* from filtered data */
+		irqsrc_reg = BMA250_INT_SRC_MASK;
+		break;
+	/* unfinished
+	case MPU_SLAVE_IRQ_TYPE_MOTION:
+		reg1 = 0x00;
+		reg2 = config->mot_int1_cfg;
+		reg3 = ;
+		break;
+	*/
+	case MPU_SLAVE_IRQ_TYPE_NONE:
+		irqtype_reg = 0x00;
+		irqdst_reg = 0x00;
+		irqsrc_reg = 0x00;
+		break;
+	default:
+		return INV_ERROR_INVALID_PARAMETER;
+		break;
+	}
+
+	config->irq_type = (unsigned char)irq_type;
+
+	if (apply) {
+		/* select the type of interrupt to use */
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA250_INT_TYPE_REG, irqtype_reg);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		/* select to which interrupt pin to route it to */
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA250_INT_DST_REG, irqdst_reg);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		/* select whether the interrupt works off filtered or
+		   unfiltered data */
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA250_INT_SRC_REG, irqsrc_reg);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+	return result;
+}
+
+/**
+ *  @brief Set the output data rate for the particular configuration.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *             Config to modify with new ODR.
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param odr
+ *             Output data rate in units of 1/1000Hz (mHz).
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma250_set_odr(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct bma250_config *config,
+			  int apply,
+			  long odr)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg_odr;
+
+	/* Table uses bandwidth which is half the sample rate */
+	odr = odr >> 1;
+	if (odr >= 1000000) {
+		reg_odr = 0x0F;
+		config->odr = 2000000;
+	} else if (odr >= 500000) {
+		reg_odr = 0x0E;
+		config->odr = 1000000;
+	} else if (odr >= 250000) {
+		reg_odr = 0x0D;
+		config->odr = 500000;
+	} else if (odr >= 125000) {
+		reg_odr = 0x0C;
+		config->odr = 250000;
+	} else if (odr >= 62500) {
+		reg_odr = 0x0B;
+		config->odr = 125000;
+	} else if (odr >= 31250) {
+		reg_odr = 0x0A;
+		config->odr = 62500;
+	} else if (odr >= 15630) {
+		reg_odr = 0x09;
+		config->odr = 31250;
+	} else {
+		reg_odr = 0x08;
+		config->odr = 15630;
+	}
+
+	if (apply) {
+		MPL_LOGV("ODR: %d\n", config->odr);
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA250_ODR_REG, reg_odr);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	return result;
+}
+
+/**
+ *  @brief Set the full scale range of the accels
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *             pointer to configuration.
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param fsr
+ *             requested full scale range.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma250_set_fsr(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct bma250_config *config,
+			  int apply,
+			  long fsr)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg_fsr_mask;
+
+	if (fsr <= 2000) {
+		reg_fsr_mask = 0x03;
+		config->fsr = 2000;
+	} else if (fsr <= 4000) {
+		reg_fsr_mask = 0x05;
+		config->fsr = 4000;
+	} else if (fsr <= 8000) {
+		reg_fsr_mask = 0x08;
+		config->fsr = 8000;
+	} else { /* 8001 -> oo */
+		reg_fsr_mask = 0x0C;
+		config->fsr = 16000;
+	}
+
+	if (apply) {
+		MPL_LOGV("FSR: %d\n", config->fsr);
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA250_FSR_REG, reg_fsr_mask);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+	return result;
+}
+
+/**
+ *  @brief one-time device driver initialization function.
+ *         If the driver is built as a kernel module, this function will be
+ *         called when the module is loaded in the kernel.
+ *         If the driver is built-in in the kernel, this function will be
+ *         called at boot time.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma250_init(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata)
+{
+	int result;
+	long range;
+
+	struct bma250_private_data *private_data;
+	private_data = kzalloc(sizeof(struct bma250_private_data), GFP_KERNEL);
+
+	if (!private_data)
+		return INV_ERROR_MEMORY_EXAUSTED;
+
+	pdata->private_data = private_data;
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			BMA250_SOFTRESET_REG, BMA250_SOFTRESET_MASK);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(1);
+
+	result = bma250_set_odr(mlsl_handle, pdata, &private_data->suspend,
+				false, 0);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = bma250_set_odr(mlsl_handle, pdata, &private_data->resume,
+				false, 200000);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	range = range_fixedpoint_to_long_mg(slave->range);
+	result = bma250_set_fsr(mlsl_handle, pdata, &private_data->suspend,
+				false, range);
+	result = bma250_set_fsr(mlsl_handle, pdata, &private_data->resume,
+				false, range);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = bma250_set_irq(mlsl_handle, pdata, &private_data->suspend,
+				false, MPU_SLAVE_IRQ_TYPE_NONE);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = bma250_set_irq(mlsl_handle, pdata, &private_data->resume,
+				false, MPU_SLAVE_IRQ_TYPE_NONE);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA250_PWR_REG, BMA250_PWR_SLEEP_MASK);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+/**
+ *  @brief one-time device driver exit function.
+ *         If the driver is built as a kernel module, this function will be
+ *         called when the module is removed from the kernel.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma250_exit(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata)
+{
+	kfree(pdata->private_data);
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief device configuration facility.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a pointer to the configuration data structure.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma250_config(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata,
+			 struct ext_slave_config *data)
+{
+	struct bma250_private_data *private_data =
+			(struct bma250_private_data *)(pdata->private_data);
+
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		return bma250_set_odr(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		return bma250_set_odr(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		return bma250_set_fsr(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		return bma250_set_fsr(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		return bma250_set_irq(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply,
+				      *((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		return bma250_set_irq(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply,
+				      *((long *)data->data));
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief facility to retrieve the device configuration.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a pointer to store the returned configuration data structure.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma250_get_config(void *mlsl_handle,
+			     struct ext_slave_descr *slave,
+			     struct ext_slave_platform_data *pdata,
+			     struct ext_slave_config *data)
+{
+	struct bma250_private_data *private_data =
+			(struct bma250_private_data *)(pdata->private_data);
+
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.odr;
+		break;
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.odr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.irq_type;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.irq_type;
+		break;
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief suspends the device to put it in its lowest power mode.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma250_suspend(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	int result;
+	struct bma250_config *suspend_config =
+		&((struct bma250_private_data *)pdata->private_data)->suspend;
+
+	result = bma250_set_odr(mlsl_handle, pdata, suspend_config,
+				true, suspend_config->odr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = bma250_set_fsr(mlsl_handle, pdata, suspend_config,
+				true, suspend_config->fsr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = bma250_set_irq(mlsl_handle, pdata, suspend_config,
+				true, suspend_config->irq_type);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				BMA250_PWR_REG, BMA250_PWR_SLEEP_MASK);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	msleep(3); /* 3 ms powerup time maximum */
+	return result;
+}
+
+/**
+ *  @brief resume the device in the proper power state given the configuration
+ *         chosen.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma250_resume(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata)
+{
+	int result;
+	struct bma250_config *resume_config =
+		&((struct bma250_private_data *)pdata->private_data)->resume;
+
+	result = bma250_set_odr(mlsl_handle, pdata, resume_config,
+				true, resume_config->odr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = bma250_set_fsr(mlsl_handle, pdata, resume_config,
+				true, resume_config->fsr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = bma250_set_irq(mlsl_handle, pdata, resume_config,
+				true, resume_config->irq_type);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			BMA250_PWR_REG, BMA250_PWR_AWAKE_MASK);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+/**
+ *  @brief read the sensor data from the device.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a buffer to store the data read.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int bma250_read(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata,
+		       unsigned char *data)
+{
+	int result = INV_SUCCESS;
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				BMA250_STATUS_REG, 1, data);
+	if (1) { /* KLP - workaroud for small data ready window */
+		result = inv_serial_read(mlsl_handle, pdata->address,
+				slave->read_reg, slave->read_len, data);
+		return result;
+	} else
+		return INV_ERROR_ACCEL_DATA_NOT_READY;
+}
+
+static struct ext_slave_descr bma250_descr = {
+	.init             = bma250_init,
+	.exit             = bma250_exit,
+	.suspend          = bma250_suspend,
+	.resume           = bma250_resume,
+	.read             = bma250_read,
+	.config           = bma250_config,
+	.get_config       = bma250_get_config,
+	.name             = "bma250",
+	.type             = EXT_SLAVE_TYPE_ACCEL,
+	.id               = ACCEL_ID_BMA250,
+	.read_reg         = 0x02,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_LITTLE_ENDIAN,
+	.range            = {2, 0},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *bma250_get_slave_descr(void)
+{
+	return &bma250_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+
+/* Platform data for the MPU */
+struct bma250_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int bma250_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct bma250_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					bma250_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int bma250_mod_remove(struct i2c_client *client)
+{
+	struct bma250_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				bma250_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id bma250_mod_id[] = {
+	{ "bma250", ACCEL_ID_BMA250 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, bma250_mod_id);
+
+static struct i2c_driver bma250_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = bma250_mod_probe,
+	.remove = bma250_mod_remove,
+	.id_table = bma250_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "bma250_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init bma250_mod_init(void)
+{
+	int res = i2c_add_driver(&bma250_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "bma250_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit bma250_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&bma250_mod_driver);
+}
+
+module_init(bma250_mod_init);
+module_exit(bma250_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate BMA250 sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("bma250_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/accel/cma3000.c b/drivers/misc/inv_mpu/accel/cma3000.c
new file mode 100644
index 0000000..496d1f2
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/cma3000.c
@@ -0,0 +1,222 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/*
+ *  @addtogroup ACCELDL
+ *  @brief      Accelerometer setup and handling methods for VTI CMA3000.
+ *
+ *  @{
+ *      @file   cma3000.c
+ *      @brief  Accelerometer setup and handling methods for VTI CMA3000
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-acc"
+
+/* -------------------------------------------------------------------------- */
+
+static int cma3000_suspend(void *mlsl_handle,
+			   struct ext_slave_descr *slave,
+			   struct ext_slave_platform_data *pdata)
+{
+	int result;
+	/* RAM reset */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address, 0x1d, 0xcd);
+	return result;
+}
+
+static int cma3000_resume(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+
+	return INV_SUCCESS;
+}
+
+static int cma3000_read(void *mlsl_handle,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata,
+			unsigned char *data)
+{
+	int result;
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 slave->reg, slave->len, data);
+	return result;
+}
+
+static struct ext_slave_descr cma3000_descr = {
+	.init             = NULL,
+	.exit             = NULL,
+	.suspend          = cma3000_suspend,
+	.resume           = cma3000_resume,
+	.read             = cma3000_read,
+	.config           = NULL,
+	.get_config       = NULL,
+	.name             = "cma3000",
+	.type             = EXT_SLAVE_TYPE_ACCEL,
+	.id               = ID_INVALID,
+	.read_reg         = 0x06,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_LITTLE_ENDIAN,
+	.range            = {2, 0},
+	.trigger          = NULL,
+
+};
+
+static
+struct ext_slave_descr *cma3000_get_slave_descr(void)
+{
+	return &cma3000_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+
+struct cma3000_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int cma3000_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct cma3000_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					cma3000_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int cma3000_mod_remove(struct i2c_client *client)
+{
+	struct cma3000_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				cma3000_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id cma3000_mod_id[] = {
+	{ "cma3000", ACCEL_ID_CMA3000 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, cma3000_mod_id);
+
+static struct i2c_driver cma3000_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = cma3000_mod_probe,
+	.remove = cma3000_mod_remove,
+	.id_table = cma3000_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "cma3000_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init cma3000_mod_init(void)
+{
+	int res = i2c_add_driver(&cma3000_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "cma3000_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit cma3000_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&cma3000_mod_driver);
+}
+
+module_init(cma3000_mod_init);
+module_exit(cma3000_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate CMA3000 sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("cma3000_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/accel/kxsd9.c b/drivers/misc/inv_mpu/accel/kxsd9.c
new file mode 100644
index 0000000..5cb4eaf
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/kxsd9.c
@@ -0,0 +1,264 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup ACCELDL
+ *  @brief      Accelerometer setup and handling methods for Kionix KXSD9.
+ *
+ *  @{
+ *      @file   kxsd9.c
+ *      @brief  Accelerometer setup and handling methods for Kionix KXSD9.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-acc"
+
+/* -------------------------------------------------------------------------- */
+
+static int kxsd9_suspend(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata)
+{
+	int result;
+	/* CTRL_REGB: low-power standby mode */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address, 0x0d, 0x0);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return result;
+}
+
+/* full scale setting - register and mask */
+#define ACCEL_KIONIX_CTRL_REG      (0x0C)
+#define ACCEL_KIONIX_CTRL_MASK     (0x3)
+
+static int kxsd9_resume(void *mlsl_handle,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg;
+
+	/* Full Scale */
+	reg = 0x0;
+	reg &= ~ACCEL_KIONIX_CTRL_MASK;
+	reg |= 0x00;
+	if (slave->range.mantissa == 4) {		/* 4g scale = 4.9951 */
+		reg |= 0x2;
+		slave->range.fraction = 9951;
+	} else if (slave->range.mantissa == 7) {	/* 6g scale = 7.5018 */
+		reg |= 0x1;
+		slave->range.fraction = 5018;
+	} else if (slave->range.mantissa == 9) {	/* 8g scale = 9.9902 */
+		reg |= 0x0;
+		slave->range.fraction = 9902;
+	} else {
+		slave->range.mantissa = 2;		/* 2g scale = 2.5006 */
+		slave->range.fraction = 5006;
+		reg |= 0x3;
+	}
+	reg |= 0xC0;		/* 100Hz LPF */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    ACCEL_KIONIX_CTRL_REG, reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* normal operation */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address, 0x0d, 0x40);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return INV_SUCCESS;
+}
+
+static int kxsd9_read(void *mlsl_handle,
+		      struct ext_slave_descr *slave,
+		      struct ext_slave_platform_data *pdata,
+		      unsigned char *data)
+{
+	int result;
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 slave->read_reg, slave->read_len, data);
+	return result;
+}
+
+static struct ext_slave_descr kxsd9_descr = {
+	.init             = NULL,
+	.exit             = NULL,
+	.suspend          = kxsd9_suspend,
+	.resume           = kxsd9_resume,
+	.read             = kxsd9_read,
+	.config           = NULL,
+	.get_config       = NULL,
+	.name             = "kxsd9",
+	.type             = EXT_SLAVE_TYPE_ACCEL,
+	.id               = ACCEL_ID_KXSD9,
+	.read_reg         = 0x00,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_BIG_ENDIAN,
+	.range            = {2, 5006},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *kxsd9_get_slave_descr(void)
+{
+	return &kxsd9_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct kxsd9_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int kxsd9_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct kxsd9_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					kxsd9_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int kxsd9_mod_remove(struct i2c_client *client)
+{
+	struct kxsd9_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				kxsd9_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id kxsd9_mod_id[] = {
+	{ "kxsd9", ACCEL_ID_KXSD9 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, kxsd9_mod_id);
+
+static struct i2c_driver kxsd9_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = kxsd9_mod_probe,
+	.remove = kxsd9_mod_remove,
+	.id_table = kxsd9_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "kxsd9_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init kxsd9_mod_init(void)
+{
+	int res = i2c_add_driver(&kxsd9_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "kxsd9_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit kxsd9_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&kxsd9_mod_driver);
+}
+
+module_init(kxsd9_mod_init);
+module_exit(kxsd9_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate KXSD9 sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("kxsd9_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/accel/kxtf9.c b/drivers/misc/inv_mpu/accel/kxtf9.c
new file mode 100644
index 0000000..80776f2
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/kxtf9.c
@@ -0,0 +1,841 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup ACCELDL
+ *  @brief      Accelerometer setup and handling methods for Kionix KXTF9.
+ *
+ *  @{
+ *      @file   kxtf9.c
+ *      @brief  Accelerometer setup and handling methods for Kionix KXTF9.
+*/
+
+/* -------------------------------------------------------------------------- */
+
+#undef MPL_LOG_NDEBUG
+#define MPL_LOG_NDEBUG 1
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-acc"
+
+#define KXTF9_XOUT_HPF_L                (0x00)	/* 0000 0000 */
+#define KXTF9_XOUT_HPF_H                (0x01)	/* 0000 0001 */
+#define KXTF9_YOUT_HPF_L                (0x02)	/* 0000 0010 */
+#define KXTF9_YOUT_HPF_H                (0x03)	/* 0000 0011 */
+#define KXTF9_ZOUT_HPF_L                (0x04)	/* 0001 0100 */
+#define KXTF9_ZOUT_HPF_H                (0x05)	/* 0001 0101 */
+#define KXTF9_XOUT_L                    (0x06)	/* 0000 0110 */
+#define KXTF9_XOUT_H                    (0x07)	/* 0000 0111 */
+#define KXTF9_YOUT_L                    (0x08)	/* 0000 1000 */
+#define KXTF9_YOUT_H                    (0x09)	/* 0000 1001 */
+#define KXTF9_ZOUT_L                    (0x0A)	/* 0001 1010 */
+#define KXTF9_ZOUT_H                    (0x0B)	/* 0001 1011 */
+#define KXTF9_ST_RESP                   (0x0C)	/* 0000 1100 */
+#define KXTF9_WHO_AM_I                  (0x0F)	/* 0000 1111 */
+#define KXTF9_TILT_POS_CUR              (0x10)	/* 0001 0000 */
+#define KXTF9_TILT_POS_PRE              (0x11)	/* 0001 0001 */
+#define KXTF9_INT_SRC_REG1              (0x15)	/* 0001 0101 */
+#define KXTF9_INT_SRC_REG2              (0x16)	/* 0001 0110 */
+#define KXTF9_STATUS_REG                (0x18)	/* 0001 1000 */
+#define KXTF9_INT_REL                   (0x1A)	/* 0001 1010 */
+#define KXTF9_CTRL_REG1                 (0x1B)	/* 0001 1011 */
+#define KXTF9_CTRL_REG2                 (0x1C)	/* 0001 1100 */
+#define KXTF9_CTRL_REG3                 (0x1D)	/* 0001 1101 */
+#define KXTF9_INT_CTRL_REG1             (0x1E)	/* 0001 1110 */
+#define KXTF9_INT_CTRL_REG2             (0x1F)	/* 0001 1111 */
+#define KXTF9_INT_CTRL_REG3             (0x20)	/* 0010 0000 */
+#define KXTF9_DATA_CTRL_REG             (0x21)	/* 0010 0001 */
+#define KXTF9_TILT_TIMER                (0x28)	/* 0010 1000 */
+#define KXTF9_WUF_TIMER                 (0x29)	/* 0010 1001 */
+#define KXTF9_TDT_TIMER                 (0x2B)	/* 0010 1011 */
+#define KXTF9_TDT_H_THRESH              (0x2C)	/* 0010 1100 */
+#define KXTF9_TDT_L_THRESH              (0x2D)	/* 0010 1101 */
+#define KXTF9_TDT_TAP_TIMER             (0x2E)	/* 0010 1110 */
+#define KXTF9_TDT_TOTAL_TIMER           (0x2F)	/* 0010 1111 */
+#define KXTF9_TDT_LATENCY_TIMER         (0x30)	/* 0011 0000 */
+#define KXTF9_TDT_WINDOW_TIMER          (0x31)	/* 0011 0001 */
+#define KXTF9_WUF_THRESH                (0x5A)	/* 0101 1010 */
+#define KXTF9_TILT_ANGLE                (0x5C)	/* 0101 1100 */
+#define KXTF9_HYST_SET                  (0x5F)	/* 0101 1111 */
+
+#define KXTF9_MAX_DUR (0xFF)
+#define KXTF9_MAX_THS (0xFF)
+#define KXTF9_THS_COUNTS_P_G (32)
+
+/* -------------------------------------------------------------------------- */
+
+struct kxtf9_config {
+	unsigned long odr;	/* Output data rate mHz */
+	unsigned int fsr;	/* full scale range mg */
+	unsigned int ths;	/* Motion no-motion thseshold mg */
+	unsigned int dur;	/* Motion no-motion duration ms */
+	unsigned int irq_type;
+	unsigned char reg_ths;
+	unsigned char reg_dur;
+	unsigned char reg_odr;
+	unsigned char reg_int_cfg1;
+	unsigned char reg_int_cfg2;
+	unsigned char ctrl_reg1;
+};
+
+struct kxtf9_private_data {
+	struct kxtf9_config suspend;
+	struct kxtf9_config resume;
+};
+
+static int kxtf9_set_ths(void *mlsl_handle,
+			 struct ext_slave_platform_data *pdata,
+			 struct kxtf9_config *config, int apply, long ths)
+{
+	int result = INV_SUCCESS;
+	if ((ths * KXTF9_THS_COUNTS_P_G / 1000) > KXTF9_MAX_THS)
+		ths = (long)(KXTF9_MAX_THS * 1000) / KXTF9_THS_COUNTS_P_G;
+
+	if (ths < 0)
+		ths = 0;
+
+	config->ths = ths;
+	config->reg_ths = (unsigned char)
+	    ((long)(ths * KXTF9_THS_COUNTS_P_G) / 1000);
+	MPL_LOGV("THS: %d, 0x%02x\n", config->ths, (int)config->reg_ths);
+	if (apply)
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 KXTF9_WUF_THRESH,
+						 config->reg_ths);
+	return result;
+}
+
+static int kxtf9_set_dur(void *mlsl_handle,
+			 struct ext_slave_platform_data *pdata,
+			 struct kxtf9_config *config, int apply, long dur)
+{
+	int result = INV_SUCCESS;
+	long reg_dur = (dur * config->odr) / 1000000L;
+	config->dur = dur;
+
+	if (reg_dur > KXTF9_MAX_DUR)
+		reg_dur = KXTF9_MAX_DUR;
+
+	config->reg_dur = (unsigned char)reg_dur;
+	MPL_LOGV("DUR: %d, 0x%02x\n", config->dur, (int)config->reg_dur);
+	if (apply)
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 KXTF9_WUF_TIMER,
+						 (unsigned char)reg_dur);
+	return result;
+}
+
+/**
+ * Sets the IRQ to fire when one of the IRQ events occur.  Threshold and
+ * duration will not be used uless the type is MOT or NMOT.
+ *
+ * @param config configuration to apply to, suspend or resume
+ * @param irq_type The type of IRQ.  Valid values are
+ * - MPU_SLAVE_IRQ_TYPE_NONE
+ * - MPU_SLAVE_IRQ_TYPE_MOTION
+ * - MPU_SLAVE_IRQ_TYPE_DATA_READY
+ */
+static int kxtf9_set_irq(void *mlsl_handle,
+			 struct ext_slave_platform_data *pdata,
+			 struct kxtf9_config *config, int apply, long irq_type)
+{
+	int result = INV_SUCCESS;
+	struct kxtf9_private_data *private_data = pdata->private_data;
+
+	config->irq_type = (unsigned char)irq_type;
+	config->ctrl_reg1 &= ~0x22;
+	if (irq_type == MPU_SLAVE_IRQ_TYPE_DATA_READY) {
+		config->ctrl_reg1 |= 0x20;
+		config->reg_int_cfg1 = 0x38;
+		config->reg_int_cfg2 = 0x00;
+	} else if (irq_type == MPU_SLAVE_IRQ_TYPE_MOTION) {
+		config->ctrl_reg1 |= 0x02;
+		if ((unsigned long)config ==
+		    (unsigned long)&private_data->suspend)
+			config->reg_int_cfg1 = 0x34;
+		else
+			config->reg_int_cfg1 = 0x24;
+		config->reg_int_cfg2 = 0xE0;
+	} else {
+		config->reg_int_cfg1 = 0x00;
+		config->reg_int_cfg2 = 0x00;
+	}
+
+	if (apply) {
+		/* Must clear bit 7 before writing new configuration */
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 KXTF9_CTRL_REG1, 0x40);
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 KXTF9_INT_CTRL_REG1,
+						 config->reg_int_cfg1);
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 KXTF9_INT_CTRL_REG2,
+						 config->reg_int_cfg2);
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 KXTF9_CTRL_REG1,
+						 config->ctrl_reg1);
+	}
+	MPL_LOGV("CTRL_REG1: %lx, INT_CFG1: %lx, INT_CFG2: %lx\n",
+		 (unsigned long)config->ctrl_reg1,
+		 (unsigned long)config->reg_int_cfg1,
+		 (unsigned long)config->reg_int_cfg2);
+
+	return result;
+}
+
+/**
+ * Set the Output data rate for the particular configuration
+ *
+ * @param config Config to modify with new ODR
+ * @param odr Output data rate in units of 1/1000Hz
+ */
+static int kxtf9_set_odr(void *mlsl_handle,
+			 struct ext_slave_platform_data *pdata,
+			 struct kxtf9_config *config, int apply, long odr)
+{
+	unsigned char bits;
+	int result = INV_SUCCESS;
+
+	/* Data sheet says there is 12.5 hz, but that seems to produce a single
+	 * correct data value, thus we remove it from the table */
+	if (odr > 400000L) {
+		config->odr = 800000L;
+		bits = 0x06;
+	} else if (odr > 200000L) {
+		config->odr = 400000L;
+		bits = 0x05;
+	} else if (odr > 100000L) {
+		config->odr = 200000L;
+		bits = 0x04;
+	} else if (odr > 50000) {
+		config->odr = 100000L;
+		bits = 0x03;
+	} else if (odr > 25000) {
+		config->odr = 50000;
+		bits = 0x02;
+	} else if (odr != 0) {
+		config->odr = 25000;
+		bits = 0x01;
+	} else {
+		config->odr = 0;
+		bits = 0;
+	}
+
+	if (odr != 0)
+		config->ctrl_reg1 |= 0x80;
+	else
+		config->ctrl_reg1 &= ~0x80;
+
+	config->reg_odr = bits;
+	kxtf9_set_dur(mlsl_handle, pdata, config, apply, config->dur);
+	MPL_LOGV("ODR: %ld, 0x%02x\n", config->odr, (int)config->ctrl_reg1);
+	if (apply) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 KXTF9_DATA_CTRL_REG,
+						 config->reg_odr);
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 KXTF9_CTRL_REG1, 0x40);
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 KXTF9_CTRL_REG1,
+						 config->ctrl_reg1);
+	}
+	return result;
+}
+
+/**
+ * Set the full scale range of the accels
+ *
+ * @param config pointer to configuration
+ * @param fsr requested full scale range
+ */
+static int kxtf9_set_fsr(void *mlsl_handle,
+			 struct ext_slave_platform_data *pdata,
+			 struct kxtf9_config *config, int apply, long fsr)
+{
+	int result = INV_SUCCESS;
+
+	config->ctrl_reg1 = (config->ctrl_reg1 & 0xE7);
+	if (fsr <= 2000) {
+		config->fsr = 2000;
+		config->ctrl_reg1 |= 0x00;
+	} else if (fsr <= 4000) {
+		config->fsr = 4000;
+		config->ctrl_reg1 |= 0x08;
+	} else {
+		config->fsr = 8000;
+		config->ctrl_reg1 |= 0x10;
+	}
+
+	MPL_LOGV("FSR: %d\n", config->fsr);
+	if (apply) {
+		/* Must clear bit 7 before writing new configuration */
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 KXTF9_CTRL_REG1, 0x40);
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 KXTF9_CTRL_REG1,
+						 config->ctrl_reg1);
+	}
+	return result;
+}
+
+static int kxtf9_suspend(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata)
+{
+	int result;
+	unsigned char data;
+	struct kxtf9_private_data *private_data = pdata->private_data;
+
+	/* Wake up */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 KXTF9_CTRL_REG1, 0x40);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* INT_CTRL_REG1: */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 KXTF9_INT_CTRL_REG1,
+					 private_data->suspend.reg_int_cfg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* WUF_THRESH: */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 KXTF9_WUF_THRESH,
+					 private_data->suspend.reg_ths);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* DATA_CTRL_REG */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 KXTF9_DATA_CTRL_REG,
+					 private_data->suspend.reg_odr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* WUF_TIMER */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 KXTF9_WUF_TIMER,
+					 private_data->suspend.reg_dur);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Normal operation  */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 KXTF9_CTRL_REG1,
+					 private_data->suspend.ctrl_reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 KXTF9_INT_REL, 1, &data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+/* full scale setting - register and mask */
+#define ACCEL_KIONIX_CTRL_REG      (0x1b)
+#define ACCEL_KIONIX_CTRL_MASK     (0x18)
+
+static int kxtf9_resume(void *mlsl_handle,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	unsigned char data;
+	struct kxtf9_private_data *private_data = pdata->private_data;
+
+	/* Wake up */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 KXTF9_CTRL_REG1, 0x40);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* INT_CTRL_REG1: */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 KXTF9_INT_CTRL_REG1,
+					 private_data->resume.reg_int_cfg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* WUF_THRESH: */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 KXTF9_WUF_THRESH,
+					 private_data->resume.reg_ths);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* DATA_CTRL_REG */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 KXTF9_DATA_CTRL_REG,
+					 private_data->resume.reg_odr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* WUF_TIMER */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 KXTF9_WUF_TIMER,
+					 private_data->resume.reg_dur);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Normal operation  */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 KXTF9_CTRL_REG1,
+					 private_data->resume.ctrl_reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 KXTF9_INT_REL, 1, &data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return INV_SUCCESS;
+}
+
+static int kxtf9_init(void *mlsl_handle,
+		      struct ext_slave_descr *slave,
+		      struct ext_slave_platform_data *pdata)
+{
+
+	struct kxtf9_private_data *private_data;
+	int result = INV_SUCCESS;
+
+	private_data = (struct kxtf9_private_data *)
+	    kzalloc(sizeof(struct kxtf9_private_data), GFP_KERNEL);
+
+	if (!private_data)
+		return INV_ERROR_MEMORY_EXAUSTED;
+
+	/* RAM reset */
+	/* Fastest Reset */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 KXTF9_CTRL_REG1, 0x40);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Fastest Reset */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 KXTF9_DATA_CTRL_REG, 0x36);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Reset */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 KXTF9_CTRL_REG3, 0xcd);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(2);
+
+	pdata->private_data = private_data;
+
+	private_data->resume.ctrl_reg1 = 0xC0;
+	private_data->suspend.ctrl_reg1 = 0x40;
+
+	result = kxtf9_set_dur(mlsl_handle, pdata, &private_data->suspend,
+			       false, 1000);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = kxtf9_set_dur(mlsl_handle, pdata, &private_data->resume,
+			       false, 2540);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = kxtf9_set_odr(mlsl_handle, pdata, &private_data->suspend,
+			       false, 50000);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = kxtf9_set_odr(mlsl_handle, pdata, &private_data->resume,
+			       false, 200000L);
+
+	result = kxtf9_set_fsr(mlsl_handle, pdata, &private_data->suspend,
+			       false, 2000);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = kxtf9_set_fsr(mlsl_handle, pdata, &private_data->resume,
+			       false, 2000);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = kxtf9_set_ths(mlsl_handle, pdata, &private_data->suspend,
+			       false, 80);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = kxtf9_set_ths(mlsl_handle, pdata, &private_data->resume,
+			       false, 40);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = kxtf9_set_irq(mlsl_handle, pdata, &private_data->suspend,
+			       false, MPU_SLAVE_IRQ_TYPE_NONE);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = kxtf9_set_irq(mlsl_handle, pdata, &private_data->resume,
+			       false, MPU_SLAVE_IRQ_TYPE_NONE);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return result;
+}
+
+static int kxtf9_exit(void *mlsl_handle,
+		      struct ext_slave_descr *slave,
+		      struct ext_slave_platform_data *pdata)
+{
+	kfree(pdata->private_data);
+	return INV_SUCCESS;
+}
+
+static int kxtf9_config(void *mlsl_handle,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata,
+			struct ext_slave_config *data)
+{
+	struct kxtf9_private_data *private_data = pdata->private_data;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		return kxtf9_set_odr(mlsl_handle, pdata,
+				     &private_data->suspend,
+				     data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		return kxtf9_set_odr(mlsl_handle, pdata,
+				     &private_data->resume,
+				     data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		return kxtf9_set_fsr(mlsl_handle, pdata,
+				     &private_data->suspend,
+				     data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		return kxtf9_set_fsr(mlsl_handle, pdata,
+				     &private_data->resume,
+				     data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_MOT_THS:
+		return kxtf9_set_ths(mlsl_handle, pdata,
+				     &private_data->suspend,
+				     data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+		return kxtf9_set_ths(mlsl_handle, pdata,
+				     &private_data->resume,
+				     data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+		return kxtf9_set_dur(mlsl_handle, pdata,
+				     &private_data->suspend,
+				     data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+		return kxtf9_set_dur(mlsl_handle, pdata,
+				     &private_data->resume,
+				     data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		return kxtf9_set_irq(mlsl_handle, pdata,
+				     &private_data->suspend,
+				     data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		return kxtf9_set_irq(mlsl_handle, pdata,
+				     &private_data->resume,
+				     data->apply, *((long *)data->data));
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+static int kxtf9_get_config(void *mlsl_handle,
+			    struct ext_slave_descr *slave,
+			    struct ext_slave_platform_data *pdata,
+			    struct ext_slave_config *data)
+{
+	struct kxtf9_private_data *private_data = pdata->private_data;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.odr;
+		break;
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.odr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_MOT_THS:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.ths;
+		break;
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.ths;
+		break;
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.dur;
+		break;
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.dur;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.irq_type;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.irq_type;
+		break;
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+static int kxtf9_read(void *mlsl_handle,
+		      struct ext_slave_descr *slave,
+		      struct ext_slave_platform_data *pdata,
+		      unsigned char *data)
+{
+	int result;
+	unsigned char reg;
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 KXTF9_INT_SRC_REG2, 1, &reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	if (!(reg & 0x10))
+		return INV_ERROR_ACCEL_DATA_NOT_READY;
+
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 slave->read_reg, slave->read_len, data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return result;
+}
+
+static struct ext_slave_descr kxtf9_descr = {
+	.init             = kxtf9_init,
+	.exit             = kxtf9_exit,
+	.suspend          = kxtf9_suspend,
+	.resume           = kxtf9_resume,
+	.read             = kxtf9_read,
+	.config           = kxtf9_config,
+	.get_config       = kxtf9_get_config,
+	.name             = "kxtf9",
+	.type             = EXT_SLAVE_TYPE_ACCEL,
+	.id               = ACCEL_ID_KXTF9,
+	.read_reg         = 0x06,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_LITTLE_ENDIAN,
+	.range            = {2, 0},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *kxtf9_get_slave_descr(void)
+{
+	return &kxtf9_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct kxtf9_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int kxtf9_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct kxtf9_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					kxtf9_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int kxtf9_mod_remove(struct i2c_client *client)
+{
+	struct kxtf9_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				kxtf9_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id kxtf9_mod_id[] = {
+	{ "kxtf9", ACCEL_ID_KXTF9 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, kxtf9_mod_id);
+
+static struct i2c_driver kxtf9_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = kxtf9_mod_probe,
+	.remove = kxtf9_mod_remove,
+	.id_table = kxtf9_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "kxtf9_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init kxtf9_mod_init(void)
+{
+	int res = i2c_add_driver(&kxtf9_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "kxtf9_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit kxtf9_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&kxtf9_mod_driver);
+}
+
+module_init(kxtf9_mod_init);
+module_exit(kxtf9_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate KXTF9 sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("kxtf9_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/accel/lis331.c b/drivers/misc/inv_mpu/accel/lis331.c
new file mode 100644
index 0000000..bcbec25
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/lis331.c
@@ -0,0 +1,745 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup ACCELDL
+ *  @brief      Provides the interface to setup and handle an accelerometer.
+ *
+ *  @{
+ *      @file   lis331.c
+ *      @brief  Accelerometer setup and handling methods for ST LIS331DLH.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#undef MPL_LOG_NDEBUG
+#define MPL_LOG_NDEBUG 1
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-acc"
+
+/* full scale setting - register & mask */
+#define LIS331DLH_CTRL_REG1         (0x20)
+#define LIS331DLH_CTRL_REG2         (0x21)
+#define LIS331DLH_CTRL_REG3         (0x22)
+#define LIS331DLH_CTRL_REG4         (0x23)
+#define LIS331DLH_CTRL_REG5         (0x24)
+#define LIS331DLH_HP_FILTER_RESET   (0x25)
+#define LIS331DLH_REFERENCE         (0x26)
+#define LIS331DLH_STATUS_REG        (0x27)
+#define LIS331DLH_OUT_X_L           (0x28)
+#define LIS331DLH_OUT_X_H           (0x29)
+#define LIS331DLH_OUT_Y_L           (0x2a)
+#define LIS331DLH_OUT_Y_H           (0x2b)
+#define LIS331DLH_OUT_Z_L           (0x2b)
+#define LIS331DLH_OUT_Z_H           (0x2d)
+
+#define LIS331DLH_INT1_CFG          (0x30)
+#define LIS331DLH_INT1_SRC          (0x31)
+#define LIS331DLH_INT1_THS          (0x32)
+#define LIS331DLH_INT1_DURATION     (0x33)
+
+#define LIS331DLH_INT2_CFG          (0x34)
+#define LIS331DLH_INT2_SRC          (0x35)
+#define LIS331DLH_INT2_THS          (0x36)
+#define LIS331DLH_INT2_DURATION     (0x37)
+
+/* CTRL_REG1 */
+#define LIS331DLH_CTRL_MASK         (0x30)
+#define LIS331DLH_SLEEP_MASK        (0x20)
+#define LIS331DLH_PWR_MODE_NORMAL   (0x20)
+
+#define LIS331DLH_MAX_DUR           (0x7F)
+
+
+/* -------------------------------------------------------------------------- */
+
+struct lis331dlh_config {
+	unsigned int odr;
+	unsigned int fsr;	/* full scale range mg */
+	unsigned int ths;	/* Motion no-motion thseshold mg */
+	unsigned int dur;	/* Motion no-motion duration ms */
+	unsigned char reg_ths;
+	unsigned char reg_dur;
+	unsigned char ctrl_reg1;
+	unsigned char irq_type;
+	unsigned char mot_int1_cfg;
+};
+
+struct lis331dlh_private_data {
+	struct lis331dlh_config suspend;
+	struct lis331dlh_config resume;
+};
+
+/* -------------------------------------------------------------------------- */
+static int lis331dlh_set_ths(void *mlsl_handle,
+			     struct ext_slave_platform_data *pdata,
+			     struct lis331dlh_config *config,
+			     int apply, long ths)
+{
+	int result = INV_SUCCESS;
+	if ((unsigned int)ths >= config->fsr)
+		ths = (long)config->fsr - 1;
+
+	if (ths < 0)
+		ths = 0;
+
+	config->ths = ths;
+	config->reg_ths = (unsigned char)(long)((ths * 128L) / (config->fsr));
+	MPL_LOGV("THS: %d, 0x%02x\n", config->ths, (int)config->reg_ths);
+	if (apply)
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 LIS331DLH_INT1_THS,
+						 config->reg_ths);
+	return result;
+}
+
+static int lis331dlh_set_dur(void *mlsl_handle,
+			     struct ext_slave_platform_data *pdata,
+			     struct lis331dlh_config *config,
+			     int apply, long dur)
+{
+	int result = INV_SUCCESS;
+	long reg_dur = (dur * config->odr) / 1000000L;
+	config->dur = dur;
+
+	if (reg_dur > LIS331DLH_MAX_DUR)
+		reg_dur = LIS331DLH_MAX_DUR;
+
+	config->reg_dur = (unsigned char)reg_dur;
+	MPL_LOGV("DUR: %d, 0x%02x\n", config->dur, (int)config->reg_dur);
+	if (apply)
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 LIS331DLH_INT1_DURATION,
+						 (unsigned char)reg_dur);
+	return result;
+}
+
+/**
+ * Sets the IRQ to fire when one of the IRQ events occur.  Threshold and
+ * duration will not be used uless the type is MOT or NMOT.
+ *
+ * @param config configuration to apply to, suspend or resume
+ * @param irq_type The type of IRQ.  Valid values are
+ * - MPU_SLAVE_IRQ_TYPE_NONE
+ * - MPU_SLAVE_IRQ_TYPE_MOTION
+ * - MPU_SLAVE_IRQ_TYPE_DATA_READY
+ */
+static int lis331dlh_set_irq(void *mlsl_handle,
+			     struct ext_slave_platform_data *pdata,
+			     struct lis331dlh_config *config,
+			     int apply, long irq_type)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg1;
+	unsigned char reg2;
+
+	config->irq_type = (unsigned char)irq_type;
+	if (irq_type == MPU_SLAVE_IRQ_TYPE_DATA_READY) {
+		reg1 = 0x02;
+		reg2 = 0x00;
+	} else if (irq_type == MPU_SLAVE_IRQ_TYPE_MOTION) {
+		reg1 = 0x00;
+		reg2 = config->mot_int1_cfg;
+	} else {
+		reg1 = 0x00;
+		reg2 = 0x00;
+	}
+
+	if (apply) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 LIS331DLH_CTRL_REG3, reg1);
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 LIS331DLH_INT1_CFG, reg2);
+	}
+
+	return result;
+}
+
+/**
+ * Set the Output data rate for the particular configuration
+ *
+ * @param config Config to modify with new ODR
+ * @param odr Output data rate in units of 1/1000Hz
+ */
+static int lis331dlh_set_odr(void *mlsl_handle,
+			     struct ext_slave_platform_data *pdata,
+			     struct lis331dlh_config *config,
+			     int apply, long odr)
+{
+	unsigned char bits;
+	int result = INV_SUCCESS;
+
+	/* normal power modes */
+	if (odr > 400000) {
+		config->odr = 1000000;
+		bits = LIS331DLH_PWR_MODE_NORMAL | 0x18;
+	} else if (odr > 100000) {
+		config->odr = 400000;
+		bits = LIS331DLH_PWR_MODE_NORMAL | 0x10;
+	} else if (odr > 50000) {
+		config->odr = 100000;
+		bits = LIS331DLH_PWR_MODE_NORMAL | 0x08;
+	} else if (odr > 10000) {
+		config->odr = 50000;
+		bits = LIS331DLH_PWR_MODE_NORMAL | 0x00;
+	/* low power modes */
+	} else if (odr > 5000) {
+		config->odr = 10000;
+		bits = 0xC0;
+	} else if (odr > 2000) {
+		config->odr = 5000;
+		bits = 0xA0;
+	} else if (odr > 1000) {
+		config->odr = 2000;
+		bits = 0x80;
+	} else if (odr > 500) {
+		config->odr = 1000;
+		bits = 0x60;
+	} else if (odr > 0) {
+		config->odr = 500;
+		bits = 0x40;
+	} else {
+		config->odr = 0;
+		bits = 0;
+	}
+
+	config->ctrl_reg1 = bits | (config->ctrl_reg1 & 0x7);
+	lis331dlh_set_dur(mlsl_handle, pdata, config, apply, config->dur);
+	MPL_LOGV("ODR: %d, 0x%02x\n", config->odr, (int)config->ctrl_reg1);
+	if (apply)
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 LIS331DLH_CTRL_REG1,
+						 config->ctrl_reg1);
+	return result;
+}
+
+/**
+ * Set the full scale range of the accels
+ *
+ * @param config pointer to configuration
+ * @param fsr requested full scale range
+ */
+static int lis331dlh_set_fsr(void *mlsl_handle,
+			     struct ext_slave_platform_data *pdata,
+			     struct lis331dlh_config *config,
+			     int apply, long fsr)
+{
+	unsigned char reg1 = 0x40;
+	int result = INV_SUCCESS;
+
+	if (fsr <= 2048) {
+		config->fsr = 2048;
+	} else if (fsr <= 4096) {
+		reg1 |= 0x30;
+		config->fsr = 4096;
+	} else {
+		reg1 |= 0x10;
+		config->fsr = 8192;
+	}
+
+	lis331dlh_set_ths(mlsl_handle, pdata, config, apply, config->ths);
+	MPL_LOGV("FSR: %d\n", config->fsr);
+	if (apply)
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 LIS331DLH_CTRL_REG4, reg1);
+
+	return result;
+}
+
+static int lis331dlh_suspend(void *mlsl_handle,
+			     struct ext_slave_descr *slave,
+			     struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg1;
+	unsigned char reg2;
+	struct lis331dlh_private_data *private_data =
+		(struct lis331dlh_private_data *)(pdata->private_data);
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS331DLH_CTRL_REG1,
+					 private_data->suspend.ctrl_reg1);
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS331DLH_CTRL_REG2, 0x0f);
+	reg1 = 0x40;
+	if (private_data->suspend.fsr == 8192)
+		reg1 |= 0x30;
+	else if (private_data->suspend.fsr == 4096)
+		reg1 |= 0x10;
+	/* else bits [4..5] are already zero */
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS331DLH_CTRL_REG4, reg1);
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS331DLH_INT1_THS,
+					 private_data->suspend.reg_ths);
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS331DLH_INT1_DURATION,
+					 private_data->suspend.reg_dur);
+
+	if (private_data->suspend.irq_type == MPU_SLAVE_IRQ_TYPE_DATA_READY) {
+		reg1 = 0x02;
+		reg2 = 0x00;
+	} else if (private_data->suspend.irq_type ==
+		   MPU_SLAVE_IRQ_TYPE_MOTION) {
+		reg1 = 0x00;
+		reg2 = private_data->suspend.mot_int1_cfg;
+	} else {
+		reg1 = 0x00;
+		reg2 = 0x00;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS331DLH_CTRL_REG3, reg1);
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS331DLH_INT1_CFG, reg2);
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 LIS331DLH_HP_FILTER_RESET, 1, &reg1);
+	return result;
+}
+
+static int lis331dlh_resume(void *mlsl_handle,
+			    struct ext_slave_descr *slave,
+			    struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg1;
+	unsigned char reg2;
+	struct lis331dlh_private_data *private_data =
+		(struct lis331dlh_private_data *)(pdata->private_data);
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS331DLH_CTRL_REG1,
+					 private_data->resume.ctrl_reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(6);
+
+	/* Full Scale */
+	reg1 = 0x40;
+	if (private_data->resume.fsr == 8192)
+		reg1 |= 0x30;
+	else if (private_data->resume.fsr == 4096)
+		reg1 |= 0x10;
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS331DLH_CTRL_REG4, reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Configure high pass filter */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS331DLH_CTRL_REG2, 0x0F);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	if (private_data->resume.irq_type == MPU_SLAVE_IRQ_TYPE_DATA_READY) {
+		reg1 = 0x02;
+		reg2 = 0x00;
+	} else if (private_data->resume.irq_type == MPU_SLAVE_IRQ_TYPE_MOTION) {
+		reg1 = 0x00;
+		reg2 = private_data->resume.mot_int1_cfg;
+	} else {
+		reg1 = 0x00;
+		reg2 = 0x00;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS331DLH_CTRL_REG3, reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS331DLH_INT1_THS,
+					 private_data->resume.reg_ths);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS331DLH_INT1_DURATION,
+					 private_data->resume.reg_dur);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS331DLH_INT1_CFG, reg2);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 LIS331DLH_HP_FILTER_RESET, 1, &reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return result;
+}
+
+static int lis331dlh_read(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata,
+			  unsigned char *data)
+{
+	int result = INV_SUCCESS;
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 LIS331DLH_STATUS_REG, 1, data);
+	if (data[0] & 0x0F) {
+		result = inv_serial_read(mlsl_handle, pdata->address,
+					 slave->read_reg, slave->read_len,
+					 data);
+		return result;
+	} else
+		return INV_ERROR_ACCEL_DATA_NOT_READY;
+}
+
+static int lis331dlh_init(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	struct lis331dlh_private_data *private_data;
+	long range;
+	private_data = (struct lis331dlh_private_data *)
+	    kzalloc(sizeof(struct lis331dlh_private_data), GFP_KERNEL);
+
+	if (!private_data)
+		return INV_ERROR_MEMORY_EXAUSTED;
+
+	pdata->private_data = private_data;
+
+	private_data->resume.ctrl_reg1 = 0x37;
+	private_data->suspend.ctrl_reg1 = 0x47;
+	private_data->resume.mot_int1_cfg = 0x95;
+	private_data->suspend.mot_int1_cfg = 0x2a;
+
+	lis331dlh_set_odr(mlsl_handle, pdata, &private_data->suspend, false, 0);
+	lis331dlh_set_odr(mlsl_handle, pdata, &private_data->resume,
+			  false, 200000);
+
+	range = range_fixedpoint_to_long_mg(slave->range);
+	lis331dlh_set_fsr(mlsl_handle, pdata, &private_data->suspend,
+			false, range);
+	lis331dlh_set_fsr(mlsl_handle, pdata, &private_data->resume,
+			false, range);
+
+	lis331dlh_set_ths(mlsl_handle, pdata, &private_data->suspend,
+			  false, 80);
+	lis331dlh_set_ths(mlsl_handle, pdata, &private_data->resume, false, 40);
+
+
+	lis331dlh_set_dur(mlsl_handle, pdata, &private_data->suspend,
+			  false, 1000);
+	lis331dlh_set_dur(mlsl_handle, pdata, &private_data->resume,
+			  false, 2540);
+
+	lis331dlh_set_irq(mlsl_handle, pdata, &private_data->suspend,
+			  false, MPU_SLAVE_IRQ_TYPE_NONE);
+	lis331dlh_set_irq(mlsl_handle, pdata, &private_data->resume,
+			  false, MPU_SLAVE_IRQ_TYPE_NONE);
+	return INV_SUCCESS;
+}
+
+static int lis331dlh_exit(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	kfree(pdata->private_data);
+	return INV_SUCCESS;
+}
+
+static int lis331dlh_config(void *mlsl_handle,
+			    struct ext_slave_descr *slave,
+			    struct ext_slave_platform_data *pdata,
+			    struct ext_slave_config *data)
+{
+	struct lis331dlh_private_data *private_data = pdata->private_data;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		return lis331dlh_set_odr(mlsl_handle, pdata,
+					 &private_data->suspend,
+					 data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		return lis331dlh_set_odr(mlsl_handle, pdata,
+					 &private_data->resume,
+					 data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		return lis331dlh_set_fsr(mlsl_handle, pdata,
+					 &private_data->suspend,
+					 data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		return lis331dlh_set_fsr(mlsl_handle, pdata,
+					 &private_data->resume,
+					 data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_MOT_THS:
+		return lis331dlh_set_ths(mlsl_handle, pdata,
+					 &private_data->suspend,
+					 data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+		return lis331dlh_set_ths(mlsl_handle, pdata,
+					 &private_data->resume,
+					 data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+		return lis331dlh_set_dur(mlsl_handle, pdata,
+					 &private_data->suspend,
+					 data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+		return lis331dlh_set_dur(mlsl_handle, pdata,
+					 &private_data->resume,
+					 data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		return lis331dlh_set_irq(mlsl_handle, pdata,
+					 &private_data->suspend,
+					 data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		return lis331dlh_set_irq(mlsl_handle, pdata,
+					 &private_data->resume,
+					 data->apply, *((long *)data->data));
+	default:
+		LOG_RESULT_LOCATION(INV_ERROR_FEATURE_NOT_IMPLEMENTED);
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+static int lis331dlh_get_config(void *mlsl_handle,
+				struct ext_slave_descr *slave,
+				struct ext_slave_platform_data *pdata,
+				struct ext_slave_config *data)
+{
+	struct lis331dlh_private_data *private_data = pdata->private_data;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.odr;
+		break;
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.odr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_MOT_THS:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.ths;
+		break;
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.ths;
+		break;
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.dur;
+		break;
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.dur;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.irq_type;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.irq_type;
+		break;
+	default:
+		LOG_RESULT_LOCATION(INV_ERROR_FEATURE_NOT_IMPLEMENTED);
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+static struct ext_slave_descr lis331dlh_descr = {
+	.init             = lis331dlh_init,
+	.exit             = lis331dlh_exit,
+	.suspend          = lis331dlh_suspend,
+	.resume           = lis331dlh_resume,
+	.read             = lis331dlh_read,
+	.config           = lis331dlh_config,
+	.get_config       = lis331dlh_get_config,
+	.name             = "lis331dlh",
+	.type             = EXT_SLAVE_TYPE_ACCEL,
+	.id               = ACCEL_ID_LIS331,
+	.read_reg         = (0x28 | 0x80), /* 0x80 for burst reads */
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_BIG_ENDIAN,
+	.range            = {2, 480},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *lis331_get_slave_descr(void)
+{
+	return &lis331dlh_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct lis331_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int lis331_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct lis331_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					lis331_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int lis331_mod_remove(struct i2c_client *client)
+{
+	struct lis331_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				lis331_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id lis331_mod_id[] = {
+	{ "lis331", ACCEL_ID_LIS331 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, lis331_mod_id);
+
+static struct i2c_driver lis331_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = lis331_mod_probe,
+	.remove = lis331_mod_remove,
+	.id_table = lis331_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "lis331_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init lis331_mod_init(void)
+{
+	int res = i2c_add_driver(&lis331_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "lis331_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit lis331_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&lis331_mod_driver);
+}
+
+module_init(lis331_mod_init);
+module_exit(lis331_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate LIS331 sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("lis331_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/accel/lis3dh.c b/drivers/misc/inv_mpu/accel/lis3dh.c
new file mode 100644
index 0000000..27206e4
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/lis3dh.c
@@ -0,0 +1,728 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup ACCELDL
+ *  @brief      Provides the interface to setup and handle an accelerometer.
+ *
+ *  @{
+ *      @file   lis3dh.c
+ *      @brief  Accelerometer setup and handling methods for ST LIS3DH.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#undef MPL_LOG_NDEBUG
+#define MPL_LOG_NDEBUG 0
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-acc"
+
+/* full scale setting - register & mask */
+#define LIS3DH_CTRL_REG1         (0x20)
+#define LIS3DH_CTRL_REG2         (0x21)
+#define LIS3DH_CTRL_REG3         (0x22)
+#define LIS3DH_CTRL_REG4         (0x23)
+#define LIS3DH_CTRL_REG5         (0x24)
+#define LIS3DH_CTRL_REG6         (0x25)
+#define LIS3DH_REFERENCE         (0x26)
+#define LIS3DH_STATUS_REG        (0x27)
+#define LIS3DH_OUT_X_L           (0x28)
+#define LIS3DH_OUT_X_H           (0x29)
+#define LIS3DH_OUT_Y_L           (0x2a)
+#define LIS3DH_OUT_Y_H           (0x2b)
+#define LIS3DH_OUT_Z_L           (0x2c)
+#define LIS3DH_OUT_Z_H           (0x2d)
+
+#define LIS3DH_INT1_CFG          (0x30)
+#define LIS3DH_INT1_SRC          (0x31)
+#define LIS3DH_INT1_THS          (0x32)
+#define LIS3DH_INT1_DURATION     (0x33)
+
+#define LIS3DH_MAX_DUR (0x7F)
+
+/* -------------------------------------------------------------------------- */
+
+struct lis3dh_config {
+	unsigned long odr;
+	unsigned int fsr;	/* full scale range mg */
+	unsigned int ths;	/* Motion no-motion thseshold mg */
+	unsigned int dur;	/* Motion no-motion duration ms */
+	unsigned char reg_ths;
+	unsigned char reg_dur;
+	unsigned char ctrl_reg1;
+	unsigned char irq_type;
+	unsigned char mot_int1_cfg;
+};
+
+struct lis3dh_private_data {
+	struct lis3dh_config suspend;
+	struct lis3dh_config resume;
+};
+
+/* -------------------------------------------------------------------------- */
+
+static int lis3dh_set_ths(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct lis3dh_config *config, int apply, long ths)
+{
+	int result = INV_SUCCESS;
+	if ((unsigned int)ths > 1000 * config->fsr)
+		ths = (long)1000 * config->fsr;
+
+	if (ths < 0)
+		ths = 0;
+
+	config->ths = ths;
+	config->reg_ths = (unsigned char)(long)((ths * 128L) / (config->fsr));
+	MPL_LOGV("THS: %d, 0x%02x\n", config->ths, (int)config->reg_ths);
+	if (apply)
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 LIS3DH_INT1_THS,
+						 config->reg_ths);
+	return result;
+}
+
+static int lis3dh_set_dur(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct lis3dh_config *config, int apply, long dur)
+{
+	int result = INV_SUCCESS;
+	long reg_dur = (dur * config->odr) / 1000000L;
+	config->dur = dur;
+
+	if (reg_dur > LIS3DH_MAX_DUR)
+		reg_dur = LIS3DH_MAX_DUR;
+
+	config->reg_dur = (unsigned char)reg_dur;
+	MPL_LOGV("DUR: %d, 0x%02x\n", config->dur, (int)config->reg_dur);
+	if (apply)
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 LIS3DH_INT1_DURATION,
+						 (unsigned char)reg_dur);
+	return result;
+}
+
+/**
+ * Sets the IRQ to fire when one of the IRQ events occur.  Threshold and
+ * duration will not be used uless the type is MOT or NMOT.
+ *
+ * @param config configuration to apply to, suspend or resume
+ * @param irq_type The type of IRQ.  Valid values are
+ * - MPU_SLAVE_IRQ_TYPE_NONE
+ * - MPU_SLAVE_IRQ_TYPE_MOTION
+ * - MPU_SLAVE_IRQ_TYPE_DATA_READY
+ */
+static int lis3dh_set_irq(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct lis3dh_config *config,
+			  int apply, long irq_type)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg1;
+	unsigned char reg2;
+
+	config->irq_type = (unsigned char)irq_type;
+	if (irq_type == MPU_SLAVE_IRQ_TYPE_DATA_READY) {
+		reg1 = 0x10;
+		reg2 = 0x00;
+	} else if (irq_type == MPU_SLAVE_IRQ_TYPE_MOTION) {
+		reg1 = 0x40;
+		reg2 = config->mot_int1_cfg;
+	} else {
+		reg1 = 0x00;
+		reg2 = 0x00;
+	}
+
+	if (apply) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 LIS3DH_CTRL_REG3, reg1);
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 LIS3DH_INT1_CFG, reg2);
+	}
+
+	return result;
+}
+
+/**
+ * Set the Output data rate for the particular configuration
+ *
+ * @param config Config to modify with new ODR
+ * @param odr Output data rate in units of 1/1000Hz
+ */
+static int lis3dh_set_odr(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct lis3dh_config *config, int apply, long odr)
+{
+	unsigned char bits;
+	int result = INV_SUCCESS;
+
+	if (odr > 400000L) {
+		config->odr = 1250000L;
+		bits = 0x90;
+	} else if (odr > 200000L) {
+		config->odr = 400000L;
+		bits = 0x70;
+	} else if (odr > 100000L) {
+		config->odr = 200000L;
+		bits = 0x60;
+	} else if (odr > 50000) {
+		config->odr = 100000L;
+		bits = 0x50;
+	} else if (odr > 25000) {
+		config->odr = 50000;
+		bits = 0x40;
+	} else if (odr > 10000) {
+		config->odr = 25000;
+		bits = 0x30;
+	} else if (odr > 1000) {
+		config->odr = 10000;
+		bits = 0x20;
+	} else if (odr > 500) {
+		config->odr = 1000;
+		bits = 0x10;
+	} else {
+		config->odr = 0;
+		bits = 0;
+	}
+
+	config->ctrl_reg1 = bits | (config->ctrl_reg1 & 0xf);
+	lis3dh_set_dur(mlsl_handle, pdata, config, apply, config->dur);
+	MPL_LOGV("ODR: %ld, 0x%02x\n", config->odr, (int)config->ctrl_reg1);
+	if (apply)
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 LIS3DH_CTRL_REG1,
+						 config->ctrl_reg1);
+	return result;
+}
+
+/**
+ * Set the full scale range of the accels
+ *
+ * @param config pointer to configuration
+ * @param fsr requested full scale range
+ */
+static int lis3dh_set_fsr(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct lis3dh_config *config, int apply, long fsr)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg1 = 0x48;
+
+	if (fsr <= 2048) {
+		config->fsr = 2048;
+	} else if (fsr <= 4096) {
+		reg1 |= 0x10;
+		config->fsr = 4096;
+	} else if (fsr <= 8192) {
+		reg1 |= 0x20;
+		config->fsr = 8192;
+	} else {
+		reg1 |= 0x30;
+		config->fsr = 16348;
+	}
+
+	lis3dh_set_ths(mlsl_handle, pdata, config, apply, config->ths);
+	MPL_LOGV("FSR: %d\n", config->fsr);
+	if (apply)
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 LIS3DH_CTRL_REG4, reg1);
+
+	return result;
+}
+
+static int lis3dh_suspend(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg1;
+	unsigned char reg2;
+	struct lis3dh_private_data *private_data = pdata->private_data;
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS3DH_CTRL_REG1,
+					 private_data->suspend.ctrl_reg1);
+
+	reg1 = 0x48;
+	if (private_data->suspend.fsr == 16384)
+		reg1 |= 0x30;
+	else if (private_data->suspend.fsr == 8192)
+		reg1 |= 0x20;
+	else if (private_data->suspend.fsr == 4096)
+		reg1 |= 0x10;
+	else if (private_data->suspend.fsr == 2048)
+		reg1 |= 0x00;
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS3DH_CTRL_REG4, reg1);
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS3DH_INT1_THS,
+					 private_data->suspend.reg_ths);
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS3DH_INT1_DURATION,
+					 private_data->suspend.reg_dur);
+
+	if (private_data->suspend.irq_type == MPU_SLAVE_IRQ_TYPE_DATA_READY) {
+		reg1 = 0x10;
+		reg2 = 0x00;
+	} else if (private_data->suspend.irq_type ==
+		   MPU_SLAVE_IRQ_TYPE_MOTION) {
+		reg1 = 0x40;
+		reg2 = private_data->suspend.mot_int1_cfg;
+	} else {
+		reg1 = 0x00;
+		reg2 = 0x00;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS3DH_CTRL_REG3, reg1);
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS3DH_INT1_CFG, reg2);
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 LIS3DH_CTRL_REG6, 1, &reg1);
+
+	return result;
+}
+
+static int lis3dh_resume(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata)
+{
+	int result;
+	unsigned char reg1;
+	unsigned char reg2;
+	struct lis3dh_private_data *private_data = pdata->private_data;
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS3DH_CTRL_REG1,
+					 private_data->resume.ctrl_reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(6);
+
+	/* Full Scale */
+	reg1 = 0x48;
+	if (private_data->suspend.fsr == 16384)
+		reg1 |= 0x30;
+	else if (private_data->suspend.fsr == 8192)
+		reg1 |= 0x20;
+	else if (private_data->suspend.fsr == 4096)
+		reg1 |= 0x10;
+	else if (private_data->suspend.fsr == 2048)
+		reg1 |= 0x00;
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS3DH_CTRL_REG4, reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	if (private_data->resume.irq_type == MPU_SLAVE_IRQ_TYPE_DATA_READY) {
+		reg1 = 0x10;
+		reg2 = 0x00;
+	} else if (private_data->resume.irq_type == MPU_SLAVE_IRQ_TYPE_MOTION) {
+		reg1 = 0x40;
+		reg2 = private_data->resume.mot_int1_cfg;
+	} else {
+		reg1 = 0x00;
+		reg2 = 0x00;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS3DH_CTRL_REG3, reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS3DH_INT1_THS,
+					 private_data->resume.reg_ths);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS3DH_INT1_DURATION,
+					 private_data->resume.reg_dur);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS3DH_INT1_CFG, reg2);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 LIS3DH_CTRL_REG6, 1, &reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return result;
+}
+
+static int lis3dh_read(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata,
+		       unsigned char *data)
+{
+	int result = INV_SUCCESS;
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 LIS3DH_STATUS_REG, 1, data);
+	if (data[0] & 0x0F) {
+		result = inv_serial_read(mlsl_handle, pdata->address,
+					 slave->read_reg, slave->read_len,
+					 data);
+		return result;
+	} else
+		return INV_ERROR_ACCEL_DATA_NOT_READY;
+}
+
+static int lis3dh_init(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata)
+{
+	int result;
+	long range;
+	struct lis3dh_private_data *private_data;
+	private_data = (struct lis3dh_private_data *)
+	    kzalloc(sizeof(struct lis3dh_private_data), GFP_KERNEL);
+
+	if (!private_data)
+		return INV_ERROR_MEMORY_EXAUSTED;
+
+	pdata->private_data = private_data;
+
+	private_data->resume.ctrl_reg1 = 0x67;
+	private_data->suspend.ctrl_reg1 = 0x18;
+	private_data->resume.mot_int1_cfg = 0x95;
+	private_data->suspend.mot_int1_cfg = 0x2a;
+
+	lis3dh_set_odr(mlsl_handle, pdata, &private_data->suspend, false, 0);
+	lis3dh_set_odr(mlsl_handle, pdata, &private_data->resume,
+		       false, 200000L);
+
+	range = range_fixedpoint_to_long_mg(slave->range);
+	lis3dh_set_fsr(mlsl_handle, pdata, &private_data->suspend,
+			false, range);
+	lis3dh_set_fsr(mlsl_handle, pdata, &private_data->resume,
+			false, range);
+
+	lis3dh_set_ths(mlsl_handle, pdata, &private_data->suspend,
+			false, 80);
+	lis3dh_set_ths(mlsl_handle, pdata, &private_data->resume,
+			false, 40);
+
+	lis3dh_set_dur(mlsl_handle, pdata, &private_data->suspend,
+			false, 1000);
+	lis3dh_set_dur(mlsl_handle, pdata, &private_data->resume,
+			false, 2540);
+
+	lis3dh_set_irq(mlsl_handle, pdata, &private_data->suspend,
+			false, MPU_SLAVE_IRQ_TYPE_NONE);
+	lis3dh_set_irq(mlsl_handle, pdata, &private_data->resume,
+			false, MPU_SLAVE_IRQ_TYPE_NONE);
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 LIS3DH_CTRL_REG1, 0x07);
+	msleep(6);
+
+	return INV_SUCCESS;
+}
+
+static int lis3dh_exit(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata)
+{
+	kfree(pdata->private_data);
+	return INV_SUCCESS;
+}
+
+static int lis3dh_config(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata,
+			 struct ext_slave_config *data)
+{
+	struct lis3dh_private_data *private_data = pdata->private_data;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		return lis3dh_set_odr(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		return lis3dh_set_odr(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		return lis3dh_set_fsr(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		return lis3dh_set_fsr(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_MOT_THS:
+		return lis3dh_set_ths(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+		return lis3dh_set_ths(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+		return lis3dh_set_dur(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+		return lis3dh_set_dur(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		return lis3dh_set_irq(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		return lis3dh_set_irq(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply, *((long *)data->data));
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+	return INV_SUCCESS;
+}
+
+static int lis3dh_get_config(void *mlsl_handle,
+			     struct ext_slave_descr *slave,
+			     struct ext_slave_platform_data *pdata,
+			     struct ext_slave_config *data)
+{
+	struct lis3dh_private_data *private_data = pdata->private_data;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.odr;
+		break;
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.odr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_MOT_THS:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.ths;
+		break;
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.ths;
+		break;
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.dur;
+		break;
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.dur;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.irq_type;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.irq_type;
+		break;
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+static struct ext_slave_descr lis3dh_descr = {
+	.init             = lis3dh_init,
+	.exit             = lis3dh_exit,
+	.suspend          = lis3dh_suspend,
+	.resume           = lis3dh_resume,
+	.read             = lis3dh_read,
+	.config           = lis3dh_config,
+	.get_config       = lis3dh_get_config,
+	.name             = "lis3dh",
+	.type             = EXT_SLAVE_TYPE_ACCEL,
+	.id               = ACCEL_ID_LIS3DH,
+	.read_reg         = 0x28 | 0x80, /* 0x80 for burst reads */
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_BIG_ENDIAN,
+	.range            = {2, 480},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *lis3dh_get_slave_descr(void)
+{
+	return &lis3dh_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct lis3dh_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int lis3dh_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct lis3dh_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					lis3dh_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int lis3dh_mod_remove(struct i2c_client *client)
+{
+	struct lis3dh_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				lis3dh_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id lis3dh_mod_id[] = {
+	{ "lis3dh", ACCEL_ID_LIS3DH },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, lis3dh_mod_id);
+
+static struct i2c_driver lis3dh_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = lis3dh_mod_probe,
+	.remove = lis3dh_mod_remove,
+	.id_table = lis3dh_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "lis3dh_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init lis3dh_mod_init(void)
+{
+	int res = i2c_add_driver(&lis3dh_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "lis3dh_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit lis3dh_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&lis3dh_mod_driver);
+}
+
+module_init(lis3dh_mod_init);
+module_exit(lis3dh_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate LIS3DH sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("lis3dh_mod");
+
+/*
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/accel/lsm303dlx_a.c b/drivers/misc/inv_mpu/accel/lsm303dlx_a.c
new file mode 100644
index 0000000..576282a
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/lsm303dlx_a.c
@@ -0,0 +1,881 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup ACCELDL
+ *  @brief      Provides the interface to setup and handle an accelerometer.
+ *
+ *  @{
+ *      @file   lsm303dlx_a.c
+ *      @brief  Accelerometer setup and handling methods for ST LSM303DLH
+ *              or LSM303DLM accel.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-acc"
+
+/* -------------------------------------------------------------------------- */
+
+/* full scale setting - register & mask */
+#define LSM303DLx_CTRL_REG1         (0x20)
+#define LSM303DLx_CTRL_REG2         (0x21)
+#define LSM303DLx_CTRL_REG3         (0x22)
+#define LSM303DLx_CTRL_REG4         (0x23)
+#define LSM303DLx_CTRL_REG5         (0x24)
+#define LSM303DLx_HP_FILTER_RESET   (0x25)
+#define LSM303DLx_REFERENCE         (0x26)
+#define LSM303DLx_STATUS_REG        (0x27)
+#define LSM303DLx_OUT_X_L           (0x28)
+#define LSM303DLx_OUT_X_H           (0x29)
+#define LSM303DLx_OUT_Y_L           (0x2a)
+#define LSM303DLx_OUT_Y_H           (0x2b)
+#define LSM303DLx_OUT_Z_L           (0x2b)
+#define LSM303DLx_OUT_Z_H           (0x2d)
+
+#define LSM303DLx_INT1_CFG          (0x30)
+#define LSM303DLx_INT1_SRC          (0x31)
+#define LSM303DLx_INT1_THS          (0x32)
+#define LSM303DLx_INT1_DURATION     (0x33)
+
+#define LSM303DLx_INT2_CFG          (0x34)
+#define LSM303DLx_INT2_SRC          (0x35)
+#define LSM303DLx_INT2_THS          (0x36)
+#define LSM303DLx_INT2_DURATION     (0x37)
+
+#define LSM303DLx_CTRL_MASK         (0x30)
+#define LSM303DLx_SLEEP_MASK        (0x20)
+#define LSM303DLx_PWR_MODE_NORMAL   (0x20)
+
+#define LSM303DLx_MAX_DUR           (0x7F)
+
+/* -------------------------------------------------------------------------- */
+
+struct lsm303dlx_a_config {
+	unsigned int odr;
+	unsigned int fsr; /** < full scale range mg */
+	unsigned int ths; /** < Motion no-motion thseshold mg */
+	unsigned int dur; /** < Motion no-motion duration ms */
+	unsigned char reg_ths;
+	unsigned char reg_dur;
+	unsigned char ctrl_reg1;
+	unsigned char irq_type;
+	unsigned char mot_int1_cfg;
+};
+
+struct lsm303dlx_a_private_data {
+	struct lsm303dlx_a_config suspend;
+	struct lsm303dlx_a_config resume;
+};
+
+/* -------------------------------------------------------------------------- */
+
+static int lsm303dlx_a_set_ths(void *mlsl_handle,
+			       struct ext_slave_platform_data *pdata,
+			       struct lsm303dlx_a_config *config,
+			       int apply,
+			       long ths)
+{
+	int result = INV_SUCCESS;
+	if ((unsigned int) ths >= config->fsr)
+		ths = (long) config->fsr - 1;
+
+	if (ths < 0)
+		ths = 0;
+
+	config->ths = ths;
+	config->reg_ths = (unsigned char)(long)((ths * 128L) / (config->fsr));
+	MPL_LOGV("THS: %d, 0x%02x\n", config->ths, (int)config->reg_ths);
+	if (apply)
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					LSM303DLx_INT1_THS,
+					config->reg_ths);
+	return result;
+}
+
+static int lsm303dlx_a_set_dur(void *mlsl_handle,
+			       struct ext_slave_platform_data *pdata,
+			       struct lsm303dlx_a_config *config,
+			       int apply,
+			       long dur)
+{
+	int result = INV_SUCCESS;
+	long reg_dur = (dur * config->odr) / 1000000L;
+	config->dur = dur;
+
+	if (reg_dur > LSM303DLx_MAX_DUR)
+		reg_dur = LSM303DLx_MAX_DUR;
+
+	config->reg_dur = (unsigned char) reg_dur;
+	MPL_LOGV("DUR: %d, 0x%02x\n", config->dur, (int)config->reg_dur);
+	if (apply)
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					LSM303DLx_INT1_DURATION,
+					(unsigned char)reg_dur);
+	return result;
+}
+
+/**
+ * Sets the IRQ to fire when one of the IRQ events occur.  Threshold and
+ * duration will not be used uless the type is MOT or NMOT.
+ *
+ * @param config configuration to apply to, suspend or resume
+ * @param irq_type The type of IRQ.  Valid values are
+ * - MPU_SLAVE_IRQ_TYPE_NONE
+ * - MPU_SLAVE_IRQ_TYPE_MOTION
+ * - MPU_SLAVE_IRQ_TYPE_DATA_READY
+ */
+static int lsm303dlx_a_set_irq(void *mlsl_handle,
+			       struct ext_slave_platform_data *pdata,
+			       struct lsm303dlx_a_config *config,
+			       int apply,
+			       long irq_type)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg1;
+	unsigned char reg2;
+
+	config->irq_type = (unsigned char)irq_type;
+	if (irq_type == MPU_SLAVE_IRQ_TYPE_DATA_READY) {
+		reg1 = 0x02;
+		reg2 = 0x00;
+	} else if (irq_type == MPU_SLAVE_IRQ_TYPE_MOTION) {
+		reg1 = 0x00;
+		reg2 = config->mot_int1_cfg;
+	} else {
+		reg1 = 0x00;
+		reg2 = 0x00;
+	}
+
+	if (apply) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					LSM303DLx_CTRL_REG3, reg1);
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					LSM303DLx_INT1_CFG, reg2);
+	}
+
+	return result;
+}
+
+/**
+ *  @brief Set the output data rate for the particular configuration.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *             Config to modify with new ODR.
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param odr
+ *             Output data rate in units of 1/1000Hz (mHz).
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int lsm303dlx_a_set_odr(void *mlsl_handle,
+			       struct ext_slave_platform_data *pdata,
+			       struct lsm303dlx_a_config *config,
+			       int apply,
+			       long odr)
+{
+	unsigned char bits;
+	int result = INV_SUCCESS;
+
+	/* normal power modes */
+	if (odr > 400000) {
+		config->odr = 1000000;
+		bits = LSM303DLx_PWR_MODE_NORMAL | 0x18;
+	} else if (odr > 100000) {
+		config->odr = 400000;
+		bits = LSM303DLx_PWR_MODE_NORMAL | 0x10;
+	} else if (odr > 50000) {
+		config->odr = 100000;
+		bits = LSM303DLx_PWR_MODE_NORMAL | 0x08;
+	} else if (odr > 10000) {
+		config->odr = 50000;
+		bits = LSM303DLx_PWR_MODE_NORMAL | 0x00;
+	/* low power modes */
+	} else if (odr > 5000) {
+		config->odr = 10000;
+		bits = 0xC0;
+	} else if (odr > 2000) {
+		config->odr = 5000;
+		bits = 0xA0;
+	} else if (odr > 1000) {
+		config->odr = 2000;
+		bits = 0x80;
+	} else if (odr > 500) {
+		config->odr = 1000;
+		bits = 0x60;
+	} else if (odr > 0) {
+		config->odr = 500;
+		bits = 0x40;
+	} else {
+		config->odr = 0;
+		bits = 0;
+	}
+
+	config->ctrl_reg1 = bits | (config->ctrl_reg1 & 0x7);
+	lsm303dlx_a_set_dur(mlsl_handle, pdata, config, apply, config->dur);
+	MPL_LOGV("ODR: %d, 0x%02x\n", config->odr, (int)config->ctrl_reg1);
+	if (apply)
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					LSM303DLx_CTRL_REG1,
+					config->ctrl_reg1);
+	return result;
+}
+
+/**
+ *  @brief Set the full scale range of the accels
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *             pointer to configuration.
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param fsr
+ *             requested full scale range.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int lsm303dlx_a_set_fsr(void *mlsl_handle,
+			       struct ext_slave_platform_data *pdata,
+			       struct lsm303dlx_a_config *config,
+			       int apply,
+			       long fsr)
+{
+	unsigned char reg1 = 0x40;
+	int result = INV_SUCCESS;
+
+	if (fsr <= 2048) {
+		config->fsr = 2048;
+	} else if (fsr <= 4096) {
+		reg1 |= 0x30;
+		config->fsr = 4096;
+	} else {
+		reg1 |= 0x10;
+		config->fsr = 8192;
+	}
+
+	lsm303dlx_a_set_ths(mlsl_handle, pdata,
+			config, apply, config->ths);
+	MPL_LOGV("FSR: %d\n", config->fsr);
+	if (apply)
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					LSM303DLx_CTRL_REG4, reg1);
+
+	return result;
+}
+
+/**
+ *  @brief suspends the device to put it in its lowest power mode.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int lsm303dlx_a_suspend(void *mlsl_handle,
+			       struct ext_slave_descr *slave,
+			       struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg1;
+	unsigned char reg2;
+	struct lsm303dlx_a_private_data *private_data =
+		(struct lsm303dlx_a_private_data *)(pdata->private_data);
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       LSM303DLx_CTRL_REG1,
+				       private_data->suspend.ctrl_reg1);
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       LSM303DLx_CTRL_REG2, 0x0f);
+	reg1 = 0x40;
+	if (private_data->suspend.fsr == 8192)
+		reg1 |= 0x30;
+	else if (private_data->suspend.fsr == 4096)
+		reg1 |= 0x10;
+	/* else bits [4..5] are already zero */
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       LSM303DLx_CTRL_REG4, reg1);
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       LSM303DLx_INT1_THS,
+				       private_data->suspend.reg_ths);
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       LSM303DLx_INT1_DURATION,
+				       private_data->suspend.reg_dur);
+
+	if (private_data->suspend.irq_type == MPU_SLAVE_IRQ_TYPE_DATA_READY) {
+		reg1 = 0x02;
+		reg2 = 0x00;
+	} else if (private_data->suspend.irq_type ==
+		   MPU_SLAVE_IRQ_TYPE_MOTION) {
+		reg1 = 0x00;
+		reg2 = private_data->suspend.mot_int1_cfg;
+	} else {
+		reg1 = 0x00;
+		reg2 = 0x00;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       LSM303DLx_CTRL_REG3, reg1);
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       LSM303DLx_INT1_CFG, reg2);
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				LSM303DLx_HP_FILTER_RESET, 1, &reg1);
+	return result;
+}
+
+/**
+ *  @brief resume the device in the proper power state given the configuration
+ *         chosen.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int lsm303dlx_a_resume(void *mlsl_handle,
+			      struct ext_slave_descr *slave,
+			      struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg1;
+	unsigned char reg2;
+	struct lsm303dlx_a_private_data *private_data =
+		(struct lsm303dlx_a_private_data *)(pdata->private_data);
+
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       LSM303DLx_CTRL_REG1,
+				       private_data->resume.ctrl_reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(6);
+
+	/* Full Scale */
+	reg1 = 0x40;
+	if (private_data->resume.fsr == 8192)
+		reg1 |= 0x30;
+	else if (private_data->resume.fsr == 4096)
+		reg1 |= 0x10;
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       LSM303DLx_CTRL_REG4, reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Configure high pass filter */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       LSM303DLx_CTRL_REG2, 0x0F);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	if (private_data->resume.irq_type == MPU_SLAVE_IRQ_TYPE_DATA_READY) {
+		reg1 = 0x02;
+		reg2 = 0x00;
+	} else if (private_data->resume.irq_type ==
+		   MPU_SLAVE_IRQ_TYPE_MOTION) {
+		reg1 = 0x00;
+		reg2 = private_data->resume.mot_int1_cfg;
+	} else {
+		reg1 = 0x00;
+		reg2 = 0x00;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       LSM303DLx_CTRL_REG3, reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       LSM303DLx_INT1_THS,
+				       private_data->resume.reg_ths);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       LSM303DLx_INT1_DURATION,
+				       private_data->resume.reg_dur);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       LSM303DLx_INT1_CFG, reg2);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				LSM303DLx_HP_FILTER_RESET, 1, &reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return result;
+}
+
+/**
+ *  @brief read the sensor data from the device.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a buffer to store the data read.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int lsm303dlx_a_read(void *mlsl_handle,
+			    struct ext_slave_descr *slave,
+			    struct ext_slave_platform_data *pdata,
+			    unsigned char *data)
+{
+	int result = INV_SUCCESS;
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				LSM303DLx_STATUS_REG, 1, data);
+	if (data[0] & 0x0F) {
+		result = inv_serial_read(mlsl_handle, pdata->address,
+					slave->read_reg, slave->read_len, data);
+	return result;
+	} else
+		return INV_ERROR_ACCEL_DATA_NOT_READY;
+}
+
+/**
+ *  @brief one-time device driver initialization function.
+ *         If the driver is built as a kernel module, this function will be
+ *         called when the module is loaded in the kernel.
+ *         If the driver is built-in in the kernel, this function will be
+ *         called at boot time.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int lsm303dlx_a_init(void *mlsl_handle,
+			    struct ext_slave_descr *slave,
+			    struct ext_slave_platform_data *pdata)
+{
+	long range;
+	struct lsm303dlx_a_private_data *private_data;
+	private_data = (struct lsm303dlx_a_private_data *)
+	    kzalloc(sizeof(struct lsm303dlx_a_private_data), GFP_KERNEL);
+
+	if (!private_data)
+		return INV_ERROR_MEMORY_EXAUSTED;
+
+	pdata->private_data = private_data;
+
+	private_data->resume.ctrl_reg1 = 0x37;
+	private_data->suspend.ctrl_reg1 = 0x47;
+	private_data->resume.mot_int1_cfg = 0x95;
+	private_data->suspend.mot_int1_cfg = 0x2a;
+
+	lsm303dlx_a_set_odr(mlsl_handle, pdata, &private_data->suspend,
+			false, 0);
+	lsm303dlx_a_set_odr(mlsl_handle, pdata, &private_data->resume,
+			false, 200000);
+
+	range = range_fixedpoint_to_long_mg(slave->range);
+	lsm303dlx_a_set_fsr(mlsl_handle, pdata, &private_data->suspend,
+			false, range);
+	lsm303dlx_a_set_fsr(mlsl_handle, pdata, &private_data->resume,
+			false, range);
+
+	lsm303dlx_a_set_ths(mlsl_handle, pdata, &private_data->suspend,
+			false, 80);
+	lsm303dlx_a_set_ths(mlsl_handle, pdata, &private_data->resume,
+			false, 40);
+
+	lsm303dlx_a_set_dur(mlsl_handle, pdata, &private_data->suspend,
+			false, 1000);
+	lsm303dlx_a_set_dur(mlsl_handle, pdata, &private_data->resume,
+			false, 2540);
+
+	lsm303dlx_a_set_irq(mlsl_handle, pdata, &private_data->suspend,
+			false, MPU_SLAVE_IRQ_TYPE_NONE);
+	lsm303dlx_a_set_irq(mlsl_handle, pdata, &private_data->resume,
+			false, MPU_SLAVE_IRQ_TYPE_NONE);
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief one-time device driver exit function.
+ *         If the driver is built as a kernel module, this function will be
+ *         called when the module is removed from the kernel.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int lsm303dlx_a_exit(void *mlsl_handle,
+			    struct ext_slave_descr *slave,
+			    struct ext_slave_platform_data *pdata)
+{
+	kfree(pdata->private_data);
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief device configuration facility.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a pointer to the configuration data structure.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int lsm303dlx_a_config(void *mlsl_handle,
+			      struct ext_slave_descr *slave,
+			      struct ext_slave_platform_data *pdata,
+			      struct ext_slave_config *data)
+{
+	struct lsm303dlx_a_private_data *private_data = pdata->private_data;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		return lsm303dlx_a_set_odr(mlsl_handle, pdata,
+					&private_data->suspend,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		return lsm303dlx_a_set_odr(mlsl_handle, pdata,
+					&private_data->resume,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		return lsm303dlx_a_set_fsr(mlsl_handle, pdata,
+					&private_data->suspend,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		return lsm303dlx_a_set_fsr(mlsl_handle, pdata,
+					&private_data->resume,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_MOT_THS:
+		return lsm303dlx_a_set_ths(mlsl_handle, pdata,
+					&private_data->suspend,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+		return lsm303dlx_a_set_ths(mlsl_handle, pdata,
+					&private_data->resume,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+		return lsm303dlx_a_set_dur(mlsl_handle, pdata,
+					&private_data->suspend,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+		return lsm303dlx_a_set_dur(mlsl_handle, pdata,
+					&private_data->resume,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		return lsm303dlx_a_set_irq(mlsl_handle, pdata,
+					&private_data->suspend,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		return lsm303dlx_a_set_irq(mlsl_handle, pdata,
+					&private_data->resume,
+					data->apply,
+					*((long *)data->data));
+	default:
+		LOG_RESULT_LOCATION(INV_ERROR_FEATURE_NOT_IMPLEMENTED);
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief facility to retrieve the device configuration.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a pointer to store the returned configuration data structure.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int lsm303dlx_a_get_config(void *mlsl_handle,
+				  struct ext_slave_descr *slave,
+				  struct ext_slave_platform_data *pdata,
+				  struct ext_slave_config *data)
+{
+	struct lsm303dlx_a_private_data *private_data = pdata->private_data;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.odr;
+		break;
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.odr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_MOT_THS:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.ths;
+		break;
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.ths;
+		break;
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.dur;
+		break;
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.dur;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.irq_type;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.irq_type;
+		break;
+	default:
+		LOG_RESULT_LOCATION(INV_ERROR_FEATURE_NOT_IMPLEMENTED);
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+static struct ext_slave_descr lsm303dlx_a_descr = {
+	.init             = lsm303dlx_a_init,
+	.exit             = lsm303dlx_a_exit,
+	.suspend          = lsm303dlx_a_suspend,
+	.resume           = lsm303dlx_a_resume,
+	.read             = lsm303dlx_a_read,
+	.config           = lsm303dlx_a_config,
+	.get_config       = lsm303dlx_a_get_config,
+	.name             = "lsm303dlx_a",
+	.type             = EXT_SLAVE_TYPE_ACCEL,
+	.id               = ACCEL_ID_LSM303DLX,
+	.read_reg         = (0x28 | 0x80), /* 0x80 for burst reads */
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_BIG_ENDIAN,
+	.range            = {2, 480},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *lsm303dlx_a_get_slave_descr(void)
+{
+	return &lsm303dlx_a_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct lsm303dlx_a_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int lsm303dlx_a_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct lsm303dlx_a_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					lsm303dlx_a_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int lsm303dlx_a_mod_remove(struct i2c_client *client)
+{
+	struct lsm303dlx_a_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				lsm303dlx_a_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id lsm303dlx_a_mod_id[] = {
+	{ "lsm303dlx", ACCEL_ID_LSM303DLX },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, lsm303dlx_a_mod_id);
+
+static struct i2c_driver lsm303dlx_a_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = lsm303dlx_a_mod_probe,
+	.remove = lsm303dlx_a_mod_remove,
+	.id_table = lsm303dlx_a_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "lsm303dlx_a_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init lsm303dlx_a_mod_init(void)
+{
+	int res = i2c_add_driver(&lsm303dlx_a_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "lsm303dlx_a_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit lsm303dlx_a_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&lsm303dlx_a_mod_driver);
+}
+
+module_init(lsm303dlx_a_mod_init);
+module_exit(lsm303dlx_a_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate LSM303DLX_A sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("lsm303dlx_a_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/accel/mma8450.c b/drivers/misc/inv_mpu/accel/mma8450.c
new file mode 100644
index 0000000..f698ee9
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/mma8450.c
@@ -0,0 +1,804 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup ACCELDL
+ *  @brief      Provides the interface to setup and handle an accelerometer.
+ *
+ *  @{
+ *      @file   mma8450.c
+ *      @brief  Accelerometer setup and handling methods for Freescale MMA8450.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-acc"
+
+/* full scale setting - register & mask */
+#define ACCEL_MMA8450_XYZ_DATA_CFG	(0x16)
+
+#define ACCEL_MMA8450_CTRL_REG1		(0x38)
+#define ACCEL_MMA8450_CTRL_REG2     (0x39)
+#define ACCEL_MMA8450_CTRL_REG4		(0x3B)
+#define ACCEL_MMA8450_CTRL_REG5		(0x3C)
+
+#define ACCEL_MMA8450_CTRL_REG		(0x38)
+#define ACCEL_MMA8450_CTRL_MASK		(0x03)
+
+#define ACCEL_MMA8450_SLEEP_MASK	(0x03)
+
+/* -------------------------------------------------------------------------- */
+
+struct mma8450_config {
+	unsigned int odr;
+	unsigned int fsr;	/** < full scale range mg */
+	unsigned int ths;	/** < Motion no-motion thseshold mg */
+	unsigned int dur;	/** < Motion no-motion duration ms */
+	unsigned char reg_ths;
+	unsigned char reg_dur;
+	unsigned char ctrl_reg1;
+	unsigned char irq_type;
+	unsigned char mot_int1_cfg;
+};
+
+struct mma8450_private_data {
+	struct mma8450_config suspend;
+	struct mma8450_config resume;
+};
+
+
+/* -------------------------------------------------------------------------- */
+
+static int mma8450_set_ths(void *mlsl_handle,
+			struct ext_slave_platform_data *pdata,
+			struct mma8450_config *config,
+			int apply,
+			long ths)
+{
+	return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+static int mma8450_set_dur(void *mlsl_handle,
+			struct ext_slave_platform_data *pdata,
+			struct mma8450_config *config,
+			int apply,
+			long dur)
+{
+	return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+/**
+ *  @brief Sets the IRQ to fire when one of the IRQ events occur.
+ *         Threshold and duration will not be used unless the type is MOT or
+ *         NMOT.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *              configuration to apply to, suspend or resume
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param irq_type
+ *              the type of IRQ.  Valid values are
+ *              - MPU_SLAVE_IRQ_TYPE_NONE
+ *              - MPU_SLAVE_IRQ_TYPE_MOTION
+ *              - MPU_SLAVE_IRQ_TYPE_DATA_READY
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma8450_set_irq(void *mlsl_handle,
+		struct ext_slave_platform_data *pdata,
+		struct mma8450_config *config,
+		int apply,
+		long irq_type)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg1;
+	unsigned char reg2;
+	unsigned char reg3;
+
+	config->irq_type = (unsigned char)irq_type;
+	if (irq_type == MPU_SLAVE_IRQ_TYPE_DATA_READY) {
+		reg1 = 0x01;
+		reg2 = 0x01;
+		reg3 = 0x07;
+	} else if (irq_type == MPU_SLAVE_IRQ_TYPE_NONE) {
+		reg1 = 0x00;
+		reg2 = 0x00;
+		reg3 = 0x00;
+	} else {
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	}
+
+	if (apply) {
+		/* XYZ_DATA_CFG: event flag enabled on Z axis */
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					ACCEL_MMA8450_XYZ_DATA_CFG, reg3);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					ACCEL_MMA8450_CTRL_REG4, reg1);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					ACCEL_MMA8450_CTRL_REG5, reg2);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	return result;
+}
+
+/**
+ *  @brief Set the output data rate for the particular configuration.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *             Config to modify with new ODR.
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param odr
+ *             Output data rate in units of 1/1000Hz (mHz).
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma8450_set_odr(void *mlsl_handle,
+		struct ext_slave_platform_data *pdata,
+		struct mma8450_config *config,
+		int apply,
+		long odr)
+{
+	unsigned char bits;
+	int result = INV_SUCCESS;
+
+	if (odr > 200000) {
+		config->odr = 400000;
+		bits = 0x00;
+	} else if (odr > 100000) {
+		config->odr = 200000;
+		bits = 0x04;
+	} else if (odr > 50000) {
+		config->odr = 100000;
+		bits = 0x08;
+	} else if (odr > 25000) {
+		config->odr = 50000;
+		bits = 0x0C;
+	} else if (odr > 12500) {
+		config->odr = 25000;
+		bits = 0x40; /* Sleep -> Auto wake mode */
+	} else if (odr > 1563) {
+		config->odr = 12500;
+		bits = 0x10;
+	} else if (odr > 0) {
+		config->odr = 1563;
+		bits = 0x14;
+	} else {
+		config->ctrl_reg1 = 0; /* Set FS1.FS2 to Standby */
+		config->odr = 0;
+		bits = 0;
+	}
+
+	config->ctrl_reg1 = bits | (config->ctrl_reg1 & 0x3);
+	if (apply) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				ACCEL_MMA8450_CTRL_REG1, 0);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				ACCEL_MMA8450_CTRL_REG1, config->ctrl_reg1);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		MPL_LOGV("ODR: %d mHz, 0x%02x\n",
+			config->odr, (int)config->ctrl_reg1);
+	}
+	return result;
+}
+
+/**
+ *  @brief Set the full scale range of the accels
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *             pointer to configuration.
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param fsr
+ *             requested full scale range.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma8450_set_fsr(void *mlsl_handle,
+		struct ext_slave_platform_data *pdata,
+		struct mma8450_config *config,
+		int apply,
+		long fsr)
+{
+	unsigned char bits;
+	int result = INV_SUCCESS;
+
+	if (fsr <= 2000) {
+		bits = 0x01;
+		config->fsr = 2000;
+	} else if (fsr <= 4000) {
+		bits = 0x02;
+		config->fsr = 4000;
+	} else {
+		bits = 0x03;
+		config->fsr = 8000;
+	}
+
+	config->ctrl_reg1 = bits | (config->ctrl_reg1 & 0xFC);
+	if (apply) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				ACCEL_MMA8450_CTRL_REG1, config->ctrl_reg1);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		MPL_LOGV("FSR: %d mg\n", config->fsr);
+	}
+	return result;
+}
+
+/**
+ *  @brief suspends the device to put it in its lowest power mode.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma8450_suspend(void *mlsl_handle,
+		    struct ext_slave_descr *slave,
+		    struct ext_slave_platform_data *pdata)
+{
+	int result;
+	struct mma8450_private_data *private_data = pdata->private_data;
+
+	if (private_data->suspend.fsr == 4000)
+		slave->range.mantissa = 4;
+	else if (private_data->suspend.fsr == 8000)
+		slave->range.mantissa = 8;
+	else
+		slave->range.mantissa = 2;
+	slave->range.fraction = 0;
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			ACCEL_MMA8450_CTRL_REG1, 0);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	if (private_data->suspend.ctrl_reg1) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				ACCEL_MMA8450_CTRL_REG1,
+				private_data->suspend.ctrl_reg1);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	result = mma8450_set_irq(mlsl_handle, pdata,
+				&private_data->suspend,
+				true, private_data->suspend.irq_type);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return result;
+}
+
+/**
+ *  @brief resume the device in the proper power state given the configuration
+ *         chosen.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma8450_resume(void *mlsl_handle,
+		   struct ext_slave_descr *slave,
+		   struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	struct mma8450_private_data *private_data = pdata->private_data;
+
+	/* Full Scale */
+	if (private_data->resume.fsr == 4000)
+		slave->range.mantissa = 4;
+	else if (private_data->resume.fsr == 8000)
+		slave->range.mantissa = 8;
+	else
+		slave->range.mantissa = 2;
+	slave->range.fraction = 0;
+
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			ACCEL_MMA8450_CTRL_REG1, 0);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	if (private_data->resume.ctrl_reg1) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				ACCEL_MMA8450_CTRL_REG1,
+				private_data->resume.ctrl_reg1);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+	result = mma8450_set_irq(mlsl_handle, pdata,
+			&private_data->resume,
+			true, private_data->resume.irq_type);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+/**
+ *  @brief read the sensor data from the device.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a buffer to store the data read.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma8450_read(void *mlsl_handle,
+		 struct ext_slave_descr *slave,
+		 struct ext_slave_platform_data *pdata, unsigned char *data)
+{
+	int result;
+	unsigned char local_data[4];	/* Status register + 3 bytes data */
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				0x00, sizeof(local_data), local_data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	memcpy(data, &local_data[1], (slave->read_len) - 1);
+
+	MPL_LOGV("Data Not Ready: %02x %02x %02x %02x\n",
+		 local_data[0], local_data[1],
+		 local_data[2], local_data[3]);
+
+	return result;
+}
+
+/**
+ *  @brief one-time device driver initialization function.
+ *         If the driver is built as a kernel module, this function will be
+ *         called when the module is loaded in the kernel.
+ *         If the driver is built-in in the kernel, this function will be
+ *         called at boot time.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma8450_init(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	struct mma8450_private_data *private_data;
+	private_data = (struct mma8450_private_data *)
+	    kzalloc(sizeof(struct mma8450_private_data), GFP_KERNEL);
+
+	if (!private_data)
+		return INV_ERROR_MEMORY_EXAUSTED;
+
+	pdata->private_data = private_data;
+
+	mma8450_set_odr(mlsl_handle, pdata, &private_data->suspend,
+			false, 0);
+	mma8450_set_odr(mlsl_handle, pdata, &private_data->resume,
+			false, 200000);
+	mma8450_set_fsr(mlsl_handle, pdata, &private_data->suspend,
+			false, 2000);
+	mma8450_set_fsr(mlsl_handle, pdata, &private_data->resume,
+			false, 2000);
+	mma8450_set_irq(mlsl_handle, pdata, &private_data->suspend,
+			false,
+			MPU_SLAVE_IRQ_TYPE_NONE);
+	mma8450_set_irq(mlsl_handle, pdata, &private_data->resume,
+			false,
+			MPU_SLAVE_IRQ_TYPE_NONE);
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief one-time device driver exit function.
+ *         If the driver is built as a kernel module, this function will be
+ *         called when the module is removed from the kernel.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma8450_exit(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	kfree(pdata->private_data);
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief device configuration facility.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a pointer to the configuration data structure.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma8450_config(void *mlsl_handle,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata,
+			struct ext_slave_config *data)
+{
+	struct mma8450_private_data *private_data = pdata->private_data;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		return mma8450_set_odr(mlsl_handle, pdata,
+					&private_data->suspend,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		return mma8450_set_odr(mlsl_handle, pdata,
+					&private_data->resume,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		return mma8450_set_fsr(mlsl_handle, pdata,
+					&private_data->suspend,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		return mma8450_set_fsr(mlsl_handle, pdata,
+					&private_data->resume,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_MOT_THS:
+		return mma8450_set_ths(mlsl_handle, pdata,
+					&private_data->suspend,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+		return mma8450_set_ths(mlsl_handle, pdata,
+					&private_data->resume,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+		return mma8450_set_dur(mlsl_handle, pdata,
+					&private_data->suspend,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+		return mma8450_set_dur(mlsl_handle, pdata,
+					&private_data->resume,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		return mma8450_set_irq(mlsl_handle, pdata,
+					&private_data->suspend,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		return mma8450_set_irq(mlsl_handle, pdata,
+					&private_data->resume,
+					data->apply,
+					*((long *)data->data));
+	default:
+		LOG_RESULT_LOCATION(INV_ERROR_FEATURE_NOT_IMPLEMENTED);
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+/**
+ *  @brief facility to retrieve the device configuration.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a pointer to store the returned configuration data structure.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma8450_get_config(void *mlsl_handle,
+				struct ext_slave_descr *slave,
+				struct ext_slave_platform_data *pdata,
+				struct ext_slave_config *data)
+{
+	struct mma8450_private_data *private_data = pdata->private_data;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.odr;
+		break;
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.odr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_MOT_THS:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.ths;
+		break;
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.ths;
+		break;
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.dur;
+		break;
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.dur;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.irq_type;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.irq_type;
+		break;
+	default:
+		LOG_RESULT_LOCATION(INV_ERROR_FEATURE_NOT_IMPLEMENTED);
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+static struct ext_slave_descr mma8450_descr = {
+	.init             = mma8450_init,
+	.exit             = mma8450_exit,
+	.suspend          = mma8450_suspend,
+	.resume           = mma8450_resume,
+	.read             = mma8450_read,
+	.config           = mma8450_config,
+	.get_config       = mma8450_get_config,
+	.name             = "mma8450",
+	.type             = EXT_SLAVE_TYPE_ACCEL,
+	.id               = ACCEL_ID_MMA8450,
+	.read_reg         = 0x00,
+	.read_len         = 4,
+	.endian           = EXT_SLAVE_FS8_BIG_ENDIAN,
+	.range            = {2, 0},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *mma8450_get_slave_descr(void)
+{
+	return &mma8450_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct mma8450_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int mma8450_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct mma8450_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					mma8450_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int mma8450_mod_remove(struct i2c_client *client)
+{
+	struct mma8450_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				mma8450_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id mma8450_mod_id[] = {
+	{ "mma8450", ACCEL_ID_MMA8450 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, mma8450_mod_id);
+
+static struct i2c_driver mma8450_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = mma8450_mod_probe,
+	.remove = mma8450_mod_remove,
+	.id_table = mma8450_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "mma8450_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init mma8450_mod_init(void)
+{
+	int res = i2c_add_driver(&mma8450_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "mma8450_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit mma8450_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&mma8450_mod_driver);
+}
+
+module_init(mma8450_mod_init);
+module_exit(mma8450_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate MMA8450 sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("mma8450_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/accel/mma845x.c b/drivers/misc/inv_mpu/accel/mma845x.c
new file mode 100644
index 0000000..5f62b22
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/mma845x.c
@@ -0,0 +1,713 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup ACCELDL
+ *  @brief      Provides the interface to setup and handle an accelerometer.
+ *
+ *  @{
+ *      @file   mma845x.c
+ *      @brief  Accelerometer setup and handling methods for Freescale MMA845X
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-acc"
+
+#define ACCEL_MMA845X_XYZ_DATA_CFG	(0x0E)
+#define ACCEL_MMA845X_CTRL_REG1      (0x2A)
+#define ACCEL_MMA845X_CTRL_REG4		(0x2D)
+#define ACCEL_MMA845X_CTRL_REG5		(0x2E)
+
+#define ACCEL_MMA845X_SLEEP_MASK     (0x01)
+
+/* full scale setting - register & mask */
+#define ACCEL_MMA845X_CFG_REG       (0x0E)
+#define ACCEL_MMA845X_CTRL_MASK     (0x03)
+
+/* -------------------------------------------------------------------------- */
+
+struct mma845x_config {
+	unsigned int odr;
+	unsigned int fsr;		/** < full scale range mg */
+	unsigned int ths;		/** < Motion no-motion thseshold mg */
+	unsigned int dur;		/** < Motion no-motion duration ms */
+	unsigned char reg_ths;
+	unsigned char reg_dur;
+	unsigned char ctrl_reg1;
+	unsigned char irq_type;
+	unsigned char mot_int1_cfg;
+};
+
+struct mma845x_private_data {
+	struct mma845x_config suspend;
+	struct mma845x_config resume;
+};
+
+/* -------------------------------------------------------------------------- */
+
+static int mma845x_set_ths(void *mlsl_handle,
+		struct ext_slave_platform_data *pdata,
+		struct mma845x_config *config,
+		int apply,
+		long ths)
+{
+	return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+static int mma845x_set_dur(void *mlsl_handle,
+		struct ext_slave_platform_data *pdata,
+		struct mma845x_config *config,
+		int apply,
+		long dur)
+{
+	return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+/**
+ *  @brief Sets the IRQ to fire when one of the IRQ events occur.
+ *         Threshold and duration will not be used unless the type is MOT or
+ *         NMOT.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *              configuration to apply to, suspend or resume
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param irq_type
+ *              the type of IRQ.  Valid values are
+ *              - MPU_SLAVE_IRQ_TYPE_NONE
+ *              - MPU_SLAVE_IRQ_TYPE_MOTION
+ *              - MPU_SLAVE_IRQ_TYPE_DATA_READY
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma845x_set_irq(void *mlsl_handle,
+		struct ext_slave_platform_data *pdata,
+		struct mma845x_config *config,
+		int apply,
+		long irq_type)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg1;
+	unsigned char reg2;
+
+	config->irq_type = (unsigned char)irq_type;
+	if (irq_type == MPU_SLAVE_IRQ_TYPE_DATA_READY) {
+		reg1 = 0x01;
+		reg2 = 0x01;
+	} else if (irq_type == MPU_SLAVE_IRQ_TYPE_NONE) {
+		reg1 = 0x00;
+		reg2 = 0x00;
+	} else {
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	}
+
+	if (apply) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					ACCEL_MMA845X_CTRL_REG4, reg1);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					ACCEL_MMA845X_CTRL_REG5, reg2);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	return result;
+}
+
+/**
+ *  @brief Set the output data rate for the particular configuration.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *             Config to modify with new ODR.
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param odr
+ *             Output data rate in units of 1/1000Hz (mHz).
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma845x_set_odr(void *mlsl_handle,
+			struct ext_slave_platform_data *pdata,
+			struct mma845x_config *config,
+			int apply,
+			long odr)
+{
+	unsigned char bits;
+	int result = INV_SUCCESS;
+
+	if (odr > 400000) {
+		config->odr = 800000;
+		bits = 0x01;
+	} else if (odr > 200000) {
+		config->odr = 400000;
+		bits = 0x09;
+	} else if (odr > 100000) {
+		config->odr = 200000;
+		bits = 0x11;
+	} else if (odr > 50000) {
+		config->odr = 100000;
+		bits = 0x19;
+	} else if (odr > 12500) {
+		config->odr = 50000;
+		bits = 0x21;
+	} else if (odr > 6250) {
+		config->odr = 12500;
+		bits = 0x29;
+	} else if (odr > 1560) {
+		config->odr = 6250;
+		bits = 0x31;
+	} else if (odr > 0) {
+		config->odr = 1560;
+		bits = 0x39;
+	} else {
+		config->ctrl_reg1 = 0; /* Set FS1.FS2 to Standby */
+		config->odr = 0;
+		bits = 0;
+	}
+
+	config->ctrl_reg1 = bits;
+	if (apply) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				ACCEL_MMA845X_CTRL_REG1,
+				config->ctrl_reg1);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		MPL_LOGV("ODR: %d mHz, 0x%02x\n", config->odr,
+			 (int)config->ctrl_reg1);
+	}
+	return result;
+}
+
+/**
+ *  @brief Set the full scale range of the accels
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param config
+ *             pointer to configuration.
+ *  @param apply
+ *             whether to apply immediately or save the settings to be applied
+ *             at the next resume.
+ *  @param fsr
+ *             requested full scale range.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma845x_set_fsr(void *mlsl_handle,
+		struct ext_slave_platform_data *pdata,
+		struct mma845x_config *config,
+		int apply,
+		long fsr)
+{
+	unsigned char bits;
+	int result = INV_SUCCESS;
+
+	if (fsr <= 2000) {
+		bits = 0x00;
+		config->fsr = 2000;
+	} else if (fsr <= 4000) {
+		bits = 0x01;
+		config->fsr = 4000;
+	} else {
+		bits = 0x02;
+		config->fsr = 8000;
+	}
+
+	if (apply) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+				ACCEL_MMA845X_XYZ_DATA_CFG,
+				bits);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		MPL_LOGV("FSR: %d mg\n", config->fsr);
+	}
+	return result;
+}
+
+/**
+ *  @brief suspends the device to put it in its lowest power mode.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma845x_suspend(void *mlsl_handle,
+		    struct ext_slave_descr *slave,
+		    struct ext_slave_platform_data *pdata)
+{
+	int result;
+	struct mma845x_private_data *private_data = pdata->private_data;
+
+	/* Full Scale */
+	if (private_data->suspend.fsr == 4000)
+		slave->range.mantissa = 4;
+	else if (private_data->suspend.fsr == 8000)
+		slave->range.mantissa = 8;
+	else
+		slave->range.mantissa = 2;
+
+	slave->range.fraction = 0;
+
+	result = mma845x_set_fsr(mlsl_handle, pdata,
+				&private_data->suspend,
+				true, private_data->suspend.fsr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					ACCEL_MMA845X_CTRL_REG1,
+					private_data->suspend.ctrl_reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+/**
+ *  @brief resume the device in the proper power state given the configuration
+ *         chosen.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma845x_resume(void *mlsl_handle,
+		   struct ext_slave_descr *slave,
+		   struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	struct mma845x_private_data *private_data = pdata->private_data;
+
+	/* Full Scale */
+	if (private_data->resume.fsr == 4000)
+		slave->range.mantissa = 4;
+	else if (private_data->resume.fsr == 8000)
+		slave->range.mantissa = 8;
+	else
+		slave->range.mantissa = 2;
+
+	slave->range.fraction = 0;
+
+	result = mma845x_set_fsr(mlsl_handle, pdata,
+			&private_data->resume,
+			true, private_data->resume.fsr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+			ACCEL_MMA845X_CTRL_REG1,
+			private_data->resume.ctrl_reg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+/**
+ *  @brief read the sensor data from the device.
+ *
+ *  @param mlsl_handle
+ *             the handle to the serial channel the device is connected to.
+ *  @param slave
+ *             a pointer to the slave descriptor data structure.
+ *  @param pdata
+ *             a pointer to the slave platform data.
+ *  @param data
+ *             a buffer to store the data read.
+ *
+ *  @return INV_SUCCESS if successful or a non-zero error code.
+ */
+static int mma845x_read(void *mlsl_handle,
+		 struct ext_slave_descr *slave,
+		 struct ext_slave_platform_data *pdata, unsigned char *data)
+{
+	int result;
+	unsigned char local_data[7];	/* Status register + 6 bytes data */
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 slave->read_reg, sizeof(local_data),
+				 local_data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	memcpy(data, &local_data[1], slave->read_len);
+	return result;
+}
+
+static int mma845x_init(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	long range;
+	struct mma845x_private_data *private_data;
+	private_data = (struct mma845x_private_data *)
+	    kzalloc(sizeof(struct mma845x_private_data), GFP_KERNEL);
+
+	if (!private_data)
+		return INV_ERROR_MEMORY_EXAUSTED;
+
+	pdata->private_data = private_data;
+
+	mma845x_set_odr(mlsl_handle, pdata, &private_data->suspend,
+			false, 0);
+	mma845x_set_odr(mlsl_handle, pdata, &private_data->resume,
+			false, 200000);
+
+	range = range_fixedpoint_to_long_mg(slave->range);
+	mma845x_set_fsr(mlsl_handle, pdata, &private_data->suspend,
+			false, range);
+	mma845x_set_fsr(mlsl_handle, pdata, &private_data->resume,
+			false, range);
+
+	mma845x_set_irq(mlsl_handle, pdata, &private_data->suspend,
+			false, MPU_SLAVE_IRQ_TYPE_NONE);
+	mma845x_set_irq(mlsl_handle, pdata, &private_data->resume,
+			false, MPU_SLAVE_IRQ_TYPE_NONE);
+	return INV_SUCCESS;
+}
+
+static int mma845x_exit(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	kfree(pdata->private_data);
+	return INV_SUCCESS;
+}
+
+static int mma845x_config(void *mlsl_handle,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata,
+			struct ext_slave_config *data)
+{
+	struct mma845x_private_data *private_data = pdata->private_data;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		return mma845x_set_odr(mlsl_handle, pdata,
+					&private_data->suspend,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		return mma845x_set_odr(mlsl_handle, pdata,
+					&private_data->resume,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		return mma845x_set_fsr(mlsl_handle, pdata,
+					&private_data->suspend,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		return mma845x_set_fsr(mlsl_handle, pdata,
+					&private_data->resume,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_MOT_THS:
+		return mma845x_set_ths(mlsl_handle, pdata,
+					&private_data->suspend,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+		return mma845x_set_ths(mlsl_handle, pdata,
+					&private_data->resume,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+		return mma845x_set_dur(mlsl_handle, pdata,
+					&private_data->suspend,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+		return mma845x_set_dur(mlsl_handle, pdata,
+					&private_data->resume,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		return mma845x_set_irq(mlsl_handle, pdata,
+					&private_data->suspend,
+					data->apply,
+					*((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		return mma845x_set_irq(mlsl_handle, pdata,
+					&private_data->resume,
+					data->apply,
+					*((long *)data->data));
+	default:
+		LOG_RESULT_LOCATION(INV_ERROR_FEATURE_NOT_IMPLEMENTED);
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+static int mma845x_get_config(void *mlsl_handle,
+				struct ext_slave_descr *slave,
+				struct ext_slave_platform_data *pdata,
+				struct ext_slave_config *data)
+{
+	struct mma845x_private_data *private_data = pdata->private_data;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.odr;
+		break;
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.odr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_MOT_THS:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.ths;
+		break;
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.ths;
+		break;
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.dur;
+		break;
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.dur;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->suspend.irq_type;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		(*(unsigned long *)data->data) =
+			(unsigned long) private_data->resume.irq_type;
+		break;
+	default:
+		LOG_RESULT_LOCATION(INV_ERROR_FEATURE_NOT_IMPLEMENTED);
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+static struct ext_slave_descr mma845x_descr = {
+	.init             = mma845x_init,
+	.exit             = mma845x_exit,
+	.suspend          = mma845x_suspend,
+	.resume           = mma845x_resume,
+	.read             = mma845x_read,
+	.config           = mma845x_config,
+	.get_config       = mma845x_get_config,
+	.name             = "mma845x",
+	.type             = EXT_SLAVE_TYPE_ACCEL,
+	.id               = ACCEL_ID_MMA845X,
+	.read_reg         = 0x00,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_FS16_BIG_ENDIAN,
+	.range            = {2, 0},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *mma845x_get_slave_descr(void)
+{
+	return &mma845x_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct mma845x_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int mma845x_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct mma845x_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					mma845x_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int mma845x_mod_remove(struct i2c_client *client)
+{
+	struct mma845x_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				mma845x_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id mma845x_mod_id[] = {
+	{ "mma845x", ACCEL_ID_MMA845X },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, mma845x_mod_id);
+
+static struct i2c_driver mma845x_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = mma845x_mod_probe,
+	.remove = mma845x_mod_remove,
+	.id_table = mma845x_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "mma845x_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init mma845x_mod_init(void)
+{
+	int res = i2c_add_driver(&mma845x_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "mma845x_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit mma845x_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&mma845x_mod_driver);
+}
+
+module_init(mma845x_mod_init);
+module_exit(mma845x_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate MMA845X sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("mma845x_mod");
+
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/accel/mpu6050.c b/drivers/misc/inv_mpu/accel/mpu6050.c
new file mode 100644
index 0000000..93299ca
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/mpu6050.c
@@ -0,0 +1,699 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup ACCELDL
+ *  @brief      Provides the interface to setup and handle an accelerometer.
+ *
+ *  @{
+ *      @file   mpu6050.c
+ *      @brief  Accelerometer setup and handling methods for Invensense MPU6050
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mpu6050b1.h"
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-acc"
+
+/* -------------------------------------------------------------------------- */
+
+struct mpu6050_config {
+	unsigned int odr;		/**< output data rate 1/1000 Hz */
+	unsigned int fsr;		/**< full scale range mg */
+	unsigned int ths;		/**< mot/no-mot thseshold mg */
+	unsigned int dur;		/**< mot/no-mot duration ms */
+	unsigned int irq_type;		/**< irq type */
+};
+
+struct mpu6050_private_data {
+	struct mpu6050_config suspend;
+	struct mpu6050_config resume;
+	struct mldl_cfg *mldl_cfg_ref;
+};
+
+/* -------------------------------------------------------------------------- */
+
+static int mpu6050_set_mldl_cfg_ref(void *mlsl_handle,
+			struct ext_slave_platform_data *pdata,
+			struct mldl_cfg *mldl_cfg_ref)
+{
+	struct mpu6050_private_data *private_data =
+			(struct mpu6050_private_data *)pdata->private_data;
+	private_data->mldl_cfg_ref = mldl_cfg_ref;
+	return 0;
+}
+static int mpu6050_set_lp_mode(void *mlsl_handle,
+			struct ext_slave_platform_data *pdata,
+			unsigned char lpa_freq)
+{
+	unsigned char b = 0;
+	/* Reducing the duration setting for lp mode */
+	b = 1;
+	inv_serial_single_write(mlsl_handle, pdata->address,
+				MPUREG_ACCEL_MOT_DUR, b);
+	/* Setting the cycle bit and LPA wake up freq */
+	inv_serial_read(mlsl_handle, pdata->address, MPUREG_PWR_MGMT_1, 1,
+			&b);
+	b |= BIT_CYCLE | BIT_PD_PTAT;
+	inv_serial_single_write(mlsl_handle, pdata->address,
+				MPUREG_PWR_MGMT_1,
+				b);
+	inv_serial_read(mlsl_handle, pdata->address,
+			MPUREG_PWR_MGMT_2, 1, &b);
+	b |= lpa_freq & BITS_LPA_WAKE_CTRL;
+	inv_serial_single_write(mlsl_handle, pdata->address,
+				MPUREG_PWR_MGMT_2, b);
+
+	return INV_SUCCESS;
+}
+
+static int mpu6050_set_fp_mode(void *mlsl_handle,
+				struct ext_slave_platform_data *pdata)
+{
+	unsigned char b;
+	struct mpu6050_private_data *private_data =
+			(struct mpu6050_private_data *)pdata->private_data;
+	/* Resetting the cycle bit and LPA wake up freq */
+	inv_serial_read(mlsl_handle, pdata->address,
+			MPUREG_PWR_MGMT_1, 1, &b);
+	b &= ~BIT_CYCLE & ~BIT_PD_PTAT;
+	inv_serial_single_write(mlsl_handle, pdata->address,
+				MPUREG_PWR_MGMT_1, b);
+	inv_serial_read(mlsl_handle, pdata->address,
+			MPUREG_PWR_MGMT_2, 1, &b);
+	b &= ~BITS_LPA_WAKE_CTRL;
+	inv_serial_single_write(mlsl_handle, pdata->address,
+				MPUREG_PWR_MGMT_2, b);
+	/* Resetting the duration setting for fp mode */
+	b = (unsigned char)private_data->suspend.ths / ACCEL_MOT_DUR_LSB;
+	inv_serial_single_write(mlsl_handle, pdata->address,
+				MPUREG_ACCEL_MOT_DUR, b);
+
+	return INV_SUCCESS;
+}
+/**
+ * Record the odr for use in computing duration values.
+ *
+ * @param config Config to set, suspend or resume structure
+ * @param odr output data rate in 1/1000 hz
+ */
+static int mpu6050_set_odr(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct mpu6050_config *config, long apply, long odr)
+{
+	int result;
+	unsigned char b;
+	unsigned char lpa_freq = 1; /* Default value */
+	long base;
+	int total_divider;
+	struct mpu6050_private_data *private_data =
+			(struct mpu6050_private_data *)pdata->private_data;
+	struct mldl_cfg *mldl_cfg_ref =
+			(struct mldl_cfg *)private_data->mldl_cfg_ref;
+
+	if (mldl_cfg_ref) {
+		base = 1000 *
+			inv_mpu_get_sampling_rate_hz(mldl_cfg_ref->mpu_gyro_cfg)
+			* (mldl_cfg_ref->mpu_gyro_cfg->divider + 1);
+	} else {
+		/* have no reference to mldl_cfg => assume base rate is 1000 */
+		base = 1000000L;
+	}
+
+	if (odr != 0) {
+		total_divider = (base / odr) - 1;
+		/* final odr MAY be different from requested odr due to
+		   integer truncation */
+		config->odr = base / (total_divider + 1);
+	} else {
+		config->odr = 0;
+		return 0;
+	}
+
+	/* if the DMP and/or gyros are on, don't set the ODR =>
+	   the DMP/gyro mldl_cfg->divider setting will handle it */
+	if (apply
+	    && (mldl_cfg_ref &&
+	    !(mldl_cfg_ref->inv_mpu_cfg->requested_sensors &
+		    INV_DMP_PROCESSOR))) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					MPUREG_SMPLRT_DIV,
+					(unsigned char)total_divider);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		MPL_LOGI("ODR : %d mHz\n", config->odr);
+	}
+	/* Decide whether to put accel in LP mode or pull out of LP mode
+	   based on the odr. */
+	switch (odr) {
+	case 1000:
+		lpa_freq = BITS_LPA_WAKE_1HZ;
+		break;
+	case 2000:
+		lpa_freq = BITS_LPA_WAKE_2HZ;
+		break;
+	case 10000:
+		lpa_freq = BITS_LPA_WAKE_10HZ;
+		break;
+	case 40000:
+		lpa_freq = BITS_LPA_WAKE_40HZ;
+		break;
+	default:
+		inv_serial_read(mlsl_handle, pdata->address,
+				MPUREG_PWR_MGMT_1, 1, &b);
+		b &= BIT_CYCLE;
+		if (b == BIT_CYCLE) {
+			MPL_LOGI(" Accel LP - > FP mode. \n ");
+			mpu6050_set_fp_mode(mlsl_handle, pdata);
+		}
+	}
+	/* If lpa_freq default value was changed, set into LP mode */
+	if (lpa_freq != 1) {
+		MPL_LOGI(" Accel FP - > LP mode. \n ");
+		mpu6050_set_lp_mode(mlsl_handle, pdata, lpa_freq);
+	}
+	return 0;
+}
+
+static int mpu6050_set_fsr(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct mpu6050_config *config, long apply, long fsr)
+{
+	unsigned char fsr_mask;
+	int result;
+
+	if (fsr <= 2000) {
+		config->fsr = 2000;
+		fsr_mask = 0x00;
+	} else if (fsr <= 4000) {
+		config->fsr = 4000;
+		fsr_mask = 0x08;
+	} else if (fsr <= 8000) {
+		config->fsr = 8000;
+		fsr_mask = 0x10;
+	} else { /* fsr = [8001, oo) */
+		config->fsr = 16000;
+		fsr_mask = 0x18;
+	}
+
+	if (apply) {
+		unsigned char reg;
+		result = inv_serial_read(mlsl_handle, pdata->address,
+					 MPUREG_ACCEL_CONFIG, 1, &reg);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 MPUREG_ACCEL_CONFIG,
+						 reg | fsr_mask);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		MPL_LOGV("FSR: %d\n", config->fsr);
+	}
+	return 0;
+}
+
+static int mpu6050_set_irq(void *mlsl_handle,
+			  struct ext_slave_platform_data *pdata,
+			  struct mpu6050_config *config, long apply,
+			  long irq_type)
+{
+	//int result;
+	//unsigned char reg_int_cfg;
+
+	/* HACK, no need for interrupts for MPU6050 accel
+		- use of soft interrupt is required */
+#if 0
+	switch (irq_type) {
+	case MPU_SLAVE_IRQ_TYPE_DATA_READY:
+		config->irq_type = irq_type;
+		reg_int_cfg = BIT_RAW_RDY_EN;
+		break;
+	/* todo: add MOTION, NO_MOTION, and FREEFALL */
+	case MPU_SLAVE_IRQ_TYPE_NONE:
+		/* Do nothing, not even set the interrupt because it is
+		   shared with the gyro */
+		config->irq_type = irq_type;
+		return 0;
+	default:
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+
+	if (apply) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+						 MPUREG_INT_ENABLE,
+						 reg_int_cfg);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		MPL_LOGV("irq_type: %d\n", config->irq_type);
+	}
+#endif
+
+	return 0;
+}
+
+static int mpu6050_set_ths(void *mlsl_handle,
+			  struct ext_slave_platform_data *slave,
+			  struct mpu6050_config *config, long apply, long ths)
+{
+	if (ths < 0)
+		ths = 0;
+
+	config->ths = ths;
+	MPL_LOGV("THS: %d\n", config->ths);
+	return 0;
+}
+
+static int mpu6050_set_dur(void *mlsl_handle,
+			  struct ext_slave_platform_data *slave,
+			  struct mpu6050_config *config, long apply, long dur)
+{
+	if (dur < 0)
+		dur = 0;
+
+	config->dur = dur;
+	MPL_LOGV("DUR: %d\n", config->dur);
+	return 0;
+}
+
+
+static int mpu6050_init(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata)
+{
+	int result;
+	struct mpu6050_private_data *private_data;
+
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+
+	if (!private_data)
+		return INV_ERROR_MEMORY_EXAUSTED;
+
+	pdata->private_data = private_data;
+
+	result = mpu6050_set_odr(mlsl_handle, pdata, &private_data->suspend,
+				 false, 0);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = mpu6050_set_odr(mlsl_handle, pdata, &private_data->resume,
+				 false, 200000);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = mpu6050_set_fsr(mlsl_handle, pdata, &private_data->suspend,
+				 false, 2000);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = mpu6050_set_fsr(mlsl_handle, pdata, &private_data->resume,
+				 false, 2000);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = mpu6050_set_irq(mlsl_handle, pdata, &private_data->suspend,
+				 false, MPU_SLAVE_IRQ_TYPE_NONE);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = mpu6050_set_irq(mlsl_handle, pdata, &private_data->resume,
+				 false, MPU_SLAVE_IRQ_TYPE_NONE);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = mpu6050_set_ths(mlsl_handle, pdata, &private_data->suspend,
+				 false, 80);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = mpu6050_set_ths(mlsl_handle, pdata, &private_data->resume,
+				 false, 40);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = mpu6050_set_dur(mlsl_handle, pdata, &private_data->suspend,
+				 false, 1000);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = mpu6050_set_dur(mlsl_handle, pdata, &private_data->resume,
+				 false, 2540);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return 0;
+}
+
+static int mpu6050_exit(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata)
+{
+	kfree(pdata->private_data);
+	pdata->private_data = NULL;
+	return 0;
+}
+
+static int mpu6050_suspend(void *mlsl_handle,
+			   struct ext_slave_descr *slave,
+			   struct ext_slave_platform_data *pdata)
+{
+	unsigned char reg;
+	int result;
+	struct mpu6050_private_data *private_data =
+			(struct mpu6050_private_data *)pdata->private_data;
+
+	result = mpu6050_set_odr(mlsl_handle, pdata, &private_data->suspend,
+				true, private_data->suspend.odr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = mpu6050_set_irq(mlsl_handle, pdata, &private_data->suspend,
+				true, private_data->suspend.irq_type);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 MPUREG_PWR_MGMT_2, 1, &reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	reg |= (BIT_STBY_XA | BIT_STBY_YA | BIT_STBY_ZA);
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 MPUREG_PWR_MGMT_2, reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return 0;
+}
+
+static int mpu6050_resume(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	int result;
+	unsigned char reg;
+	struct mpu6050_private_data *private_data =
+		(struct mpu6050_private_data *)pdata->private_data;
+
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 MPUREG_PWR_MGMT_1, 1, &reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	if (reg & BIT_SLEEP) {
+		result = inv_serial_single_write(mlsl_handle, pdata->address,
+					MPUREG_PWR_MGMT_1, reg & ~BIT_SLEEP);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+	msleep(2);
+
+	result = inv_serial_read(mlsl_handle, pdata->address,
+			MPUREG_PWR_MGMT_2, 1, &reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	reg &= ~(BIT_STBY_XA | BIT_STBY_YA | BIT_STBY_ZA);
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       MPUREG_PWR_MGMT_2, reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* settings */
+
+	result = mpu6050_set_fsr(mlsl_handle, pdata, &private_data->resume,
+				 true, private_data->resume.fsr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = mpu6050_set_odr(mlsl_handle, pdata, &private_data->resume,
+				 true, private_data->resume.odr);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = mpu6050_set_irq(mlsl_handle, pdata, &private_data->resume,
+				 true, private_data->resume.irq_type);
+
+	/* motion, no_motion */
+	/* TODO : port these in their respective _set_thrs and _set_dur
+		  functions and use the APPLY paremeter to apply just like
+		  _set_odr, _set_irq, and _set_fsr. */
+	reg = (unsigned char)private_data->suspend.ths / ACCEL_MOT_THR_LSB;
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 MPUREG_ACCEL_MOT_THR, reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	reg = (unsigned char)
+	    ACCEL_ZRMOT_THR_LSB_CONVERSION(private_data->resume.ths);
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 MPUREG_ACCEL_ZRMOT_THR, reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	reg = (unsigned char)private_data->suspend.ths / ACCEL_MOT_DUR_LSB;
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 MPUREG_ACCEL_MOT_DUR, reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	reg = (unsigned char)private_data->resume.ths / ACCEL_ZRMOT_DUR_LSB;
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 MPUREG_ACCEL_ZRMOT_DUR, reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return 0;
+}
+
+static int mpu6050_read(void *mlsl_handle,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata,
+			unsigned char *data)
+{
+	int result;
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 slave->read_reg, slave->read_len, data);
+	return result;
+}
+
+static int mpu6050_config(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata,
+			 struct ext_slave_config *data)
+{
+	struct mpu6050_private_data *private_data =
+		(struct mpu6050_private_data *)pdata->private_data;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		return mpu6050_set_odr(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		return mpu6050_set_odr(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		return mpu6050_set_fsr(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		return mpu6050_set_fsr(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_MOT_THS:
+		return mpu6050_set_ths(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+		return mpu6050_set_ths(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+		return mpu6050_set_dur(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+		return mpu6050_set_dur(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		return mpu6050_set_irq(mlsl_handle, pdata,
+				      &private_data->suspend,
+				      data->apply, *((long *)data->data));
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		return mpu6050_set_irq(mlsl_handle, pdata,
+				      &private_data->resume,
+				      data->apply, *((long *)data->data));
+	case MPU_SLAVE_CONFIG_INTERNAL_REFERENCE:
+		return mpu6050_set_mldl_cfg_ref(mlsl_handle, pdata,
+					       (struct mldl_cfg *)data->data);
+		break;
+
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return 0;
+}
+
+static int mpu6050_get_config(void *mlsl_handle,
+			     struct ext_slave_descr *slave,
+			     struct ext_slave_platform_data *pdata,
+			     struct ext_slave_config *data)
+{
+	struct mpu6050_private_data *private_data =
+		(struct mpu6050_private_data *)pdata->private_data;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.odr;
+		break;
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.odr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.fsr;
+		break;
+	case MPU_SLAVE_CONFIG_MOT_THS:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.ths;
+		break;
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.ths;
+		break;
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.dur;
+		break;
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.dur;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->suspend.irq_type;
+		break;
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+		(*(unsigned long *)data->data) =
+		    (unsigned long)private_data->resume.irq_type;
+		break;
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return 0;
+}
+
+static struct ext_slave_descr mpu6050_descr = {
+	.init             = mpu6050_init,
+	.exit             = mpu6050_exit,
+	.suspend          = mpu6050_suspend,
+	.resume           = mpu6050_resume,
+	.read             = mpu6050_read,
+	.config           = mpu6050_config,
+	.get_config       = mpu6050_get_config,
+	.name             = "mpu6050",
+	.type             = EXT_SLAVE_TYPE_ACCEL,
+	.id               = ACCEL_ID_MPU6050,
+	.read_reg         = 0x3B,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_BIG_ENDIAN,
+	.range            = {2, 0},
+	.trigger          = NULL,
+};
+
+struct ext_slave_descr *mpu6050_get_slave_descr(void)
+{
+	return &mpu6050_descr;
+}
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/accel/mpu6050.h b/drivers/misc/inv_mpu/accel/mpu6050.h
new file mode 100644
index 0000000..c347bcb
--- /dev/null
+++ b/drivers/misc/inv_mpu/accel/mpu6050.h
@@ -0,0 +1,28 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+
+#ifndef __MPU6050_H__
+#define __MPU6050_H__
+
+#include <linux/mpu.h>
+
+struct ext_slave_descr *mpu6050_get_slave_descr(void);
+
+#endif
diff --git a/drivers/misc/inv_mpu/compass/Kconfig b/drivers/misc/inv_mpu/compass/Kconfig
new file mode 100644
index 0000000..6c4c13a
--- /dev/null
+++ b/drivers/misc/inv_mpu/compass/Kconfig
@@ -0,0 +1,121 @@
+menuconfig INV_SENSORS_COMPASS
+	bool "Compass Slave Sensors"
+	default y
+	---help---
+	  Say Y here to get to see options for device drivers for various
+	  compasses. This option alone does not add any kernel code.
+
+	  If you say N, all options in this submenu will be skipped and disabled.
+
+if INV_SENSORS_COMPASS
+
+config MPU_SENSORS_AK8975
+	tristate "AKM ak8975"
+	help
+	  This enables support for the AKM ak8975 compass
+	  This support is for integration with the MPU3050 or MPU6050 gyroscope
+	  device driver.  Only one compass can be registered at a time.
+	  Specifying more that one compass in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_AK8972
+	tristate "AKM ak8972"
+	help
+	  This enables support for the AKM ak8972 compass
+	  This support is for integration with the MPU3050 or MPU6050 gyroscope
+	  device driver.  Only one compass can be registered at a time.
+	  Specifying more that one compass in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_MMC314X
+	tristate "MEMSIC mmc314x"
+	help
+	  This enables support for the MEMSIC mmc314x compass
+	  This support is for integration with the MPU3050 or MPU6050 gyroscope
+	  device driver.  Only one compass can be registered at a time.
+	  Specifying more that one compass in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_AMI30X
+	tristate "Aichi Steel ami30X"
+	help
+	  This enables support for the Aichi Steel ami304/ami305 compass
+	  This support is for integration with the MPU3050 or MPU6050 gyroscope
+	  device driver.  Only one compass can be registered at a time.
+	  Specifying more that one compass in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_AMI306
+	tristate "Aichi Steel ami306"
+	help
+	  This enables support for the Aichi Steel ami306 compass
+	  This support is for integration with the MPU3050 or MPU6050 gyroscope
+	  device driver.  Only one compass can be registered at a time.
+	  Specifying more that one compass in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_HMC5883
+	tristate "Honeywell hmc5883"
+	help
+	  This enables support for the Honeywell hmc5883 compass
+	  This support is for integration with the MPU3050 or MPU6050 gyroscope
+	  device driver.  Only one compass can be registered at a time.
+	  Specifying more that one compass in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_LSM303DLX_M
+	tristate "ST lsm303dlx"
+	help
+	  This enables support for the ST lsm303dlh and lsm303dlm compasses
+	  This support is for integration with the MPU3050 or MPU6050 gyroscope
+	  device driver.  Only one compass can be registered at a time.
+	  Specifying more that one compass in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_MMC314XMS
+	tristate "MEMSIC mmc314xMS"
+	help
+	  This enables support for the MEMSIC mmc314xMS compass
+	  This support is for integration with the MPU3050 or MPU6050 gyroscope
+	  device driver.  Only one compass can be registered at a time.
+	  Specifying more that one compass in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_YAS529
+	tristate "Yamaha yas529"
+	depends on INPUT_YAS_MAGNETOMETER
+	help
+	  This enables support for the Yamaha yas529 compass
+	  This support is for integration with the MPU3050 or MPU6050 gyroscope
+	  device driver.  Only one compass can be registered at a time.
+	  Specifying more that one compass in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_YAS530
+	tristate "Yamaha yas530"
+	help
+	  This enables support for the Yamaha yas530 compass
+	  This support is for integration with the MPU3050 or MPU6050 gyroscope
+	  device driver.  Only one compass can be registered at a time.
+	  Specifying more that one compass in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_HSCDTD002B
+	tristate "Alps hscdtd002b"
+	help
+	  This enables support for the Alps hscdtd002b compass
+	  This support is for integration with the MPU3050 or MPU6050 gyroscope
+	  device driver.  Only one compass can be registered at a time.
+	  Specifying more that one compass in the board file will result
+	  in runtime errors.
+
+config MPU_SENSORS_HSCDTD004A
+	tristate "Alps hscdtd004a"
+	help
+	  This enables support for the Alps hscdtd004a compass
+	  This support is for integration with the MPU3050 or MPU6050 gyroscope
+	  device driver.  Only one compass can be registered at a time.
+	  Specifying more that one compass in the board file will result
+	  in runtime errors.
+
+endif
diff --git a/drivers/misc/inv_mpu/compass/Makefile b/drivers/misc/inv_mpu/compass/Makefile
new file mode 100644
index 0000000..aa8aa6a
--- /dev/null
+++ b/drivers/misc/inv_mpu/compass/Makefile
@@ -0,0 +1,38 @@
+#
+# Compass Slaves MPUxxxx
+#
+obj-$(CONFIG_MPU_SENSORS_AMI30X) += inv_mpu_ami30x.o
+inv_mpu_ami30x-objs +=	ami30x.o
+
+obj-$(CONFIG_MPU_SENSORS_AMI306) += inv_mpu_ami306.o
+inv_mpu_ami306-objs +=	ami306.o
+
+obj-$(CONFIG_MPU_SENSORS_HMC5883) += inv_mpu_hmc5883.o
+inv_mpu_hmc5883-objs +=	hmc5883.o
+
+obj-$(CONFIG_MPU_SENSORS_LSM303DLX_M) += inv_mpu_lsm303dlx_m.o
+inv_mpu_lsm303dlx_m-objs +=	lsm303dlx_m.o
+
+obj-$(CONFIG_MPU_SENSORS_MMC314X) += inv_mpu_mmc314x.o
+inv_mpu_mmc314x-objs +=	mmc314x.o
+
+obj-$(CONFIG_MPU_SENSORS_YAS529) += inv_mpu_yas529.o
+inv_mpu_yas529-objs +=	yas529-kernel.o
+
+obj-$(CONFIG_MPU_SENSORS_YAS530) += inv_mpu_yas530.o
+inv_mpu_yas530-objs +=	yas530.o
+
+obj-$(CONFIG_MPU_SENSORS_HSCDTD002B) += inv_mpu_hscdtd002b.o
+inv_mpu_hscdtd002b-objs +=	hscdtd002b.o
+
+obj-$(CONFIG_MPU_SENSORS_HSCDTD004A) += inv_mpu_hscdtd004a.o
+inv_mpu_hscdtd004a-objs +=	hscdtd004a.o
+
+obj-$(CONFIG_MPU_SENSORS_AK8975) += inv_mpu_ak8975.o
+inv_mpu_ak8975-objs +=	ak8975.o
+
+obj-$(CONFIG_MPU_SENSORS_AK8972) += inv_mpu_ak8972.o
+inv_mpu_ak8972-objs +=	ak8972.o
+
+EXTRA_CFLAGS += -Idrivers/misc/inv_mpu
+EXTRA_CFLAGS += -D__C99_DESIGNATED_INITIALIZER
diff --git a/drivers/misc/inv_mpu/compass/ak8972.c b/drivers/misc/inv_mpu/compass/ak8972.c
new file mode 100644
index 0000000..1e55d4f
--- /dev/null
+++ b/drivers/misc/inv_mpu/compass/ak8972.c
@@ -0,0 +1,499 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup COMPASSDL
+ *
+ *  @{
+ *      @file   ak8972.c
+ *      @brief  Magnetometer setup and handling methods for the AKM AK8972 compass device.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-compass"
+
+/* -------------------------------------------------------------------------- */
+#define AK8972_REG_ST1  (0x02)
+#define AK8972_REG_HXL  (0x03)
+#define AK8972_REG_ST2  (0x09)
+
+#define AK8972_REG_CNTL (0x0A)
+#define AK8972_REG_ASAX (0x10)
+#define AK8972_REG_ASAY (0x11)
+#define AK8972_REG_ASAZ (0x12)
+
+#define AK8972_CNTL_MODE_POWER_DOWN         (0x00)
+#define AK8972_CNTL_MODE_SINGLE_MEASUREMENT (0x01)
+#define AK8972_CNTL_MODE_FUSE_ROM_ACCESS    (0x0f)
+
+/* -------------------------------------------------------------------------- */
+struct ak8972_config {
+	char asa[COMPASS_NUM_AXES];	/* axis sensitivity adjustment */
+};
+
+struct ak8972_private_data {
+	struct ak8972_config init;
+};
+
+/* -------------------------------------------------------------------------- */
+static int ak8972_init(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata)
+{
+	int result;
+	unsigned char serial_data[COMPASS_NUM_AXES];
+
+	struct ak8972_private_data *private_data;
+	private_data = (struct ak8972_private_data *)
+	    kzalloc(sizeof(struct ak8972_private_data), GFP_KERNEL);
+
+	if (!private_data)
+		return INV_ERROR_MEMORY_EXAUSTED;
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 AK8972_REG_CNTL,
+					 AK8972_CNTL_MODE_POWER_DOWN);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Wait at least 100us */
+	udelay(100);
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 AK8972_REG_CNTL,
+					 AK8972_CNTL_MODE_FUSE_ROM_ACCESS);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Wait at least 200us */
+	udelay(200);
+
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 AK8972_REG_ASAX,
+				 COMPASS_NUM_AXES, serial_data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	pdata->private_data = private_data;
+
+	private_data->init.asa[0] = serial_data[0];
+	private_data->init.asa[1] = serial_data[1];
+	private_data->init.asa[2] = serial_data[2];
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 AK8972_REG_CNTL,
+					 AK8972_CNTL_MODE_POWER_DOWN);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	udelay(100);
+	return INV_SUCCESS;
+}
+
+static int ak8972_exit(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata)
+{
+	kfree(pdata->private_data);
+	return INV_SUCCESS;
+}
+
+static int ak8972_suspend(void *mlsl_handle,
+		   struct ext_slave_descr *slave,
+		   struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    AK8972_REG_CNTL,
+				    AK8972_CNTL_MODE_POWER_DOWN);
+	msleep(1);		/* wait at least 100us */
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return result;
+}
+
+static int ak8972_resume(void *mlsl_handle,
+		  struct ext_slave_descr *slave,
+		  struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    AK8972_REG_CNTL,
+				    AK8972_CNTL_MODE_SINGLE_MEASUREMENT);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return result;
+}
+
+static int ak8972_read(void *mlsl_handle,
+		struct ext_slave_descr *slave,
+		struct ext_slave_platform_data *pdata, unsigned char *data)
+{
+	unsigned char regs[8];
+	unsigned char *stat = &regs[0];
+	unsigned char *stat2 = &regs[7];
+	int result = INV_SUCCESS;
+	int status = INV_SUCCESS;
+
+	result =
+	    inv_serial_read(mlsl_handle, pdata->address, AK8972_REG_ST1,
+			    8, regs);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Always return the data and the status registers */
+	memcpy(data, &regs[1], 6);
+	data[6] = regs[0];
+	data[7] = regs[7];
+
+	/*
+	 * ST : data ready -
+	 * Measurement has been completed and data is ready to be read.
+	 */
+	if (*stat & 0x01)
+		status = INV_SUCCESS;
+
+	/*
+	 * ST2 : data error -
+	 * occurs when data read is started outside of a readable period;
+	 * data read would not be correct.
+	 * Valid in continuous measurement mode only.
+	 * In single measurement mode this error should not occour but we
+	 * stil account for it and return an error, since the data would be
+	 * corrupted.
+	 * DERR bit is self-clearing when ST2 register is read.
+	 */
+	if (*stat2 & 0x04)
+		status = INV_ERROR_COMPASS_DATA_ERROR;
+	/*
+	 * ST2 : overflow -
+	 * the sum of the absolute values of all axis |X|+|Y|+|Z| < 2400uT.
+	 * This is likely to happen in presence of an external magnetic
+	 * disturbance; it indicates, the sensor data is incorrect and should
+	 * be ignored.
+	 * An error is returned.
+	 * HOFL bit clears when a new measurement starts.
+	 */
+	if (*stat2 & 0x08)
+		status = INV_ERROR_COMPASS_DATA_OVERFLOW;
+	/*
+	 * ST : overrun -
+	 * the previous sample was not fetched and lost.
+	 * Valid in continuous measurement mode only.
+	 * In single measurement mode this error should not occour and we
+	 * don't consider this condition an error.
+	 * DOR bit is self-clearing when ST2 or any meas. data register is
+	 * read.
+	 */
+	if (*stat & 0x02) {
+		/* status = INV_ERROR_COMPASS_DATA_UNDERFLOW; */
+		status = INV_SUCCESS;
+	}
+
+	/*
+	 * trigger next measurement if:
+	 *    - stat is non zero;
+	 *    - if stat is zero and stat2 is non zero.
+	 * Won't trigger if data is not ready and there was no error.
+	 */
+	if (*stat != 0x00 || *stat2 != 0x00) {
+		result = inv_serial_single_write(
+		    mlsl_handle, pdata->address,
+		    AK8972_REG_CNTL, AK8972_CNTL_MODE_SINGLE_MEASUREMENT);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	return status;
+}
+
+static int ak8972_config(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata,
+			 struct ext_slave_config *data)
+{
+	int result;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_WRITE_REGISTERS:
+		result = inv_serial_write(mlsl_handle, pdata->address,
+					  data->len,
+					  (unsigned char *)data->data);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		break;
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+	case MPU_SLAVE_CONFIG_MOT_THS:
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+static int ak8972_get_config(void *mlsl_handle,
+			     struct ext_slave_descr *slave,
+			     struct ext_slave_platform_data *pdata,
+			     struct ext_slave_config *data)
+{
+	struct ak8972_private_data *private_data = pdata->private_data;
+	int result;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_READ_REGISTERS:
+		{
+			unsigned char *serial_data =
+			    (unsigned char *)data->data;
+			result =
+			    inv_serial_read(mlsl_handle, pdata->address,
+					    serial_data[0], data->len - 1,
+					    &serial_data[1]);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+			break;
+		}
+	case MPU_SLAVE_READ_SCALE:
+		{
+			unsigned char *serial_data =
+			    (unsigned char *)data->data;
+			serial_data[0] = private_data->init.asa[0];
+			serial_data[1] = private_data->init.asa[1];
+			serial_data[2] = private_data->init.asa[2];
+			result = INV_SUCCESS;
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+			break;
+		}
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		(*(unsigned long *)data->data) = 0;
+		break;
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		(*(unsigned long *)data->data) = 8000;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+	case MPU_SLAVE_CONFIG_MOT_THS:
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+static struct ext_slave_read_trigger ak8972_read_trigger = {
+	/*.reg              = */ 0x0A,
+	/*.value            = */ 0x01
+};
+
+static struct ext_slave_descr ak8972_descr = {
+	.init             = ak8972_init,
+	.exit             = ak8972_exit,
+	.suspend          = ak8972_suspend,
+	.resume           = ak8972_resume,
+	.read             = ak8972_read,
+	.config           = ak8972_config,
+	.get_config       = ak8972_get_config,
+	.name             = "ak8972",
+	.type             = EXT_SLAVE_TYPE_COMPASS,
+	.id               = COMPASS_ID_AK8972,
+	.read_reg         = 0x01,
+	.read_len         = 9,
+	.endian           = EXT_SLAVE_LITTLE_ENDIAN,
+	.range            = {19660, 8000},
+	.trigger          = &ak8972_read_trigger,
+};
+
+static
+struct ext_slave_descr *ak8972_get_slave_descr(void)
+{
+	return &ak8972_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct ak8972_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int ak8972_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct ak8972_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					ak8972_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int ak8972_mod_remove(struct i2c_client *client)
+{
+	struct ak8972_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				ak8972_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id ak8972_mod_id[] = {
+	{ "ak8972", COMPASS_ID_AK8972 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, ak8972_mod_id);
+
+static struct i2c_driver ak8972_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = ak8972_mod_probe,
+	.remove = ak8972_mod_remove,
+	.id_table = ak8972_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "ak8972_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init ak8972_mod_init(void)
+{
+	int res = i2c_add_driver(&ak8972_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "ak8972_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit ak8972_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&ak8972_mod_driver);
+}
+
+module_init(ak8972_mod_init);
+module_exit(ak8972_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate AK8972 sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ak8972_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/compass/ak8975.c b/drivers/misc/inv_mpu/compass/ak8975.c
new file mode 100644
index 0000000..3642e29
--- /dev/null
+++ b/drivers/misc/inv_mpu/compass/ak8975.c
@@ -0,0 +1,500 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup COMPASSDL
+ *
+ *  @{
+ *      @file   ak8975.c
+ *      @brief  Magnetometer setup and handling methods for the AKM AK8975,
+ *              AKM AK8975B, and AKM AK8975C compass devices.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-compass"
+
+/* -------------------------------------------------------------------------- */
+#define AK8975_REG_ST1  (0x02)
+#define AK8975_REG_HXL  (0x03)
+#define AK8975_REG_ST2  (0x09)
+
+#define AK8975_REG_CNTL (0x0A)
+#define AK8975_REG_ASAX (0x10)
+#define AK8975_REG_ASAY (0x11)
+#define AK8975_REG_ASAZ (0x12)
+
+#define AK8975_CNTL_MODE_POWER_DOWN         (0x00)
+#define AK8975_CNTL_MODE_SINGLE_MEASUREMENT (0x01)
+#define AK8975_CNTL_MODE_FUSE_ROM_ACCESS    (0x0f)
+
+/* -------------------------------------------------------------------------- */
+struct ak8975_config {
+	char asa[COMPASS_NUM_AXES];	/* axis sensitivity adjustment */
+};
+
+struct ak8975_private_data {
+	struct ak8975_config init;
+};
+
+/* -------------------------------------------------------------------------- */
+static int ak8975_init(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata)
+{
+	int result;
+	unsigned char serial_data[COMPASS_NUM_AXES];
+
+	struct ak8975_private_data *private_data;
+	private_data = (struct ak8975_private_data *)
+	    kzalloc(sizeof(struct ak8975_private_data), GFP_KERNEL);
+
+	if (!private_data)
+		return INV_ERROR_MEMORY_EXAUSTED;
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 AK8975_REG_CNTL,
+					 AK8975_CNTL_MODE_POWER_DOWN);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Wait at least 100us */
+	udelay(100);
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 AK8975_REG_CNTL,
+					 AK8975_CNTL_MODE_FUSE_ROM_ACCESS);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Wait at least 200us */
+	udelay(200);
+
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 AK8975_REG_ASAX,
+				 COMPASS_NUM_AXES, serial_data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	pdata->private_data = private_data;
+
+	private_data->init.asa[0] = serial_data[0];
+	private_data->init.asa[1] = serial_data[1];
+	private_data->init.asa[2] = serial_data[2];
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 AK8975_REG_CNTL,
+					 AK8975_CNTL_MODE_POWER_DOWN);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	udelay(100);
+	return INV_SUCCESS;
+}
+
+static int ak8975_exit(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata)
+{
+	kfree(pdata->private_data);
+	return INV_SUCCESS;
+}
+
+static int ak8975_suspend(void *mlsl_handle,
+		   struct ext_slave_descr *slave,
+		   struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    AK8975_REG_CNTL,
+				    AK8975_CNTL_MODE_POWER_DOWN);
+	msleep(1);		/* wait at least 100us */
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return result;
+}
+
+static int ak8975_resume(void *mlsl_handle,
+		  struct ext_slave_descr *slave,
+		  struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    AK8975_REG_CNTL,
+				    AK8975_CNTL_MODE_SINGLE_MEASUREMENT);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return result;
+}
+
+static int ak8975_read(void *mlsl_handle,
+		struct ext_slave_descr *slave,
+		struct ext_slave_platform_data *pdata, unsigned char *data)
+{
+	unsigned char regs[8];
+	unsigned char *stat = &regs[0];
+	unsigned char *stat2 = &regs[7];
+	int result = INV_SUCCESS;
+	int status = INV_SUCCESS;
+
+	result =
+	    inv_serial_read(mlsl_handle, pdata->address, AK8975_REG_ST1,
+			    8, regs);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Always return the data and the status registers */
+	memcpy(data, &regs[1], 6);
+	data[6] = regs[0];
+	data[7] = regs[7];
+
+	/*
+	 * ST : data ready -
+	 * Measurement has been completed and data is ready to be read.
+	 */
+	if (*stat & 0x01)
+		status = INV_SUCCESS;
+
+	/*
+	 * ST2 : data error -
+	 * occurs when data read is started outside of a readable period;
+	 * data read would not be correct.
+	 * Valid in continuous measurement mode only.
+	 * In single measurement mode this error should not occour but we
+	 * stil account for it and return an error, since the data would be
+	 * corrupted.
+	 * DERR bit is self-clearing when ST2 register is read.
+	 */
+	if (*stat2 & 0x04)
+		status = INV_ERROR_COMPASS_DATA_ERROR;
+	/*
+	 * ST2 : overflow -
+	 * the sum of the absolute values of all axis |X|+|Y|+|Z| < 2400uT.
+	 * This is likely to happen in presence of an external magnetic
+	 * disturbance; it indicates, the sensor data is incorrect and should
+	 * be ignored.
+	 * An error is returned.
+	 * HOFL bit clears when a new measurement starts.
+	 */
+	if (*stat2 & 0x08)
+		status = INV_ERROR_COMPASS_DATA_OVERFLOW;
+	/*
+	 * ST : overrun -
+	 * the previous sample was not fetched and lost.
+	 * Valid in continuous measurement mode only.
+	 * In single measurement mode this error should not occour and we
+	 * don't consider this condition an error.
+	 * DOR bit is self-clearing when ST2 or any meas. data register is
+	 * read.
+	 */
+	if (*stat & 0x02) {
+		/* status = INV_ERROR_COMPASS_DATA_UNDERFLOW; */
+		status = INV_SUCCESS;
+	}
+
+	/*
+	 * trigger next measurement if:
+	 *    - stat is non zero;
+	 *    - if stat is zero and stat2 is non zero.
+	 * Won't trigger if data is not ready and there was no error.
+	 */
+	if (*stat != 0x00 || *stat2 != 0x00) {
+		result = inv_serial_single_write(
+		    mlsl_handle, pdata->address,
+		    AK8975_REG_CNTL, AK8975_CNTL_MODE_SINGLE_MEASUREMENT);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	return status;
+}
+
+static int ak8975_config(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata,
+			 struct ext_slave_config *data)
+{
+	int result;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_WRITE_REGISTERS:
+		result = inv_serial_write(mlsl_handle, pdata->address,
+					  data->len,
+					  (unsigned char *)data->data);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		break;
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+	case MPU_SLAVE_CONFIG_MOT_THS:
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+static int ak8975_get_config(void *mlsl_handle,
+			     struct ext_slave_descr *slave,
+			     struct ext_slave_platform_data *pdata,
+			     struct ext_slave_config *data)
+{
+	struct ak8975_private_data *private_data = pdata->private_data;
+	int result;
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_READ_REGISTERS:
+		{
+			unsigned char *serial_data =
+			    (unsigned char *)data->data;
+			result =
+			    inv_serial_read(mlsl_handle, pdata->address,
+					    serial_data[0], data->len - 1,
+					    &serial_data[1]);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+			break;
+		}
+	case MPU_SLAVE_READ_SCALE:
+		{
+			unsigned char *serial_data =
+			    (unsigned char *)data->data;
+			serial_data[0] = private_data->init.asa[0];
+			serial_data[1] = private_data->init.asa[1];
+			serial_data[2] = private_data->init.asa[2];
+			result = INV_SUCCESS;
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+			break;
+		}
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		(*(unsigned long *)data->data) = 0;
+		break;
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		(*(unsigned long *)data->data) = 8000;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+	case MPU_SLAVE_CONFIG_MOT_THS:
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+	default:
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+static struct ext_slave_read_trigger ak8975_read_trigger = {
+	/*.reg              = */ 0x0A,
+	/*.value            = */ 0x01
+};
+
+static struct ext_slave_descr ak8975_descr = {
+	.init             = ak8975_init,
+	.exit             = ak8975_exit,
+	.suspend          = ak8975_suspend,
+	.resume           = ak8975_resume,
+	.read             = ak8975_read,
+	.config           = ak8975_config,
+	.get_config       = ak8975_get_config,
+	.name             = "ak8975",
+	.type             = EXT_SLAVE_TYPE_COMPASS,
+	.id               = COMPASS_ID_AK8975,
+	.read_reg         = 0x01,
+	.read_len         = 10,
+	.endian           = EXT_SLAVE_LITTLE_ENDIAN,
+	.range            = {9830, 4000},
+	.trigger          = &ak8975_read_trigger,
+};
+
+static
+struct ext_slave_descr *ak8975_get_slave_descr(void)
+{
+	return &ak8975_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct ak8975_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int ak8975_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct ak8975_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					ak8975_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int ak8975_mod_remove(struct i2c_client *client)
+{
+	struct ak8975_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				ak8975_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id ak8975_mod_id[] = {
+	{ "ak8975", COMPASS_ID_AK8975 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, ak8975_mod_id);
+
+static struct i2c_driver ak8975_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = ak8975_mod_probe,
+	.remove = ak8975_mod_remove,
+	.id_table = ak8975_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "ak8975_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init ak8975_mod_init(void)
+{
+	int res = i2c_add_driver(&ak8975_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "ak8975_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit ak8975_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&ak8975_mod_driver);
+}
+
+module_init(ak8975_mod_init);
+module_exit(ak8975_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate AK8975 sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ak8975_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/compass/ami306.c b/drivers/misc/inv_mpu/compass/ami306.c
new file mode 100644
index 0000000..f645457
--- /dev/null
+++ b/drivers/misc/inv_mpu/compass/ami306.c
@@ -0,0 +1,1020 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup COMPASSDL
+ *
+ *  @{
+ *      @file   ami306.c
+ *      @brief  Magnetometer setup and handling methods for Aichi AMI306
+ *              compass.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include "ami_hw.h"
+#include "ami_sensor_def.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-compass"
+
+/* -------------------------------------------------------------------------- */
+#define AMI306_REG_DATAX		(0x10)
+#define AMI306_REG_STAT1		(0x18)
+#define AMI306_REG_CNTL1		(0x1B)
+#define AMI306_REG_CNTL2		(0x1C)
+#define AMI306_REG_CNTL3		(0x1D)
+#define AMI306_REG_CNTL4_1		(0x5C)
+#define AMI306_REG_CNTL4_2		(0x5D)
+
+#define AMI306_BIT_CNTL1_PC1		(0x80)
+#define AMI306_BIT_CNTL1_ODR1		(0x10)
+#define AMI306_BIT_CNTL1_FS1		(0x02)
+
+#define AMI306_BIT_CNTL2_IEN		(0x10)
+#define AMI306_BIT_CNTL2_DREN		(0x08)
+#define AMI306_BIT_CNTL2_DRP		(0x04)
+#define AMI306_BIT_CNTL3_F0RCE		(0x40)
+
+#define AMI_FINE_MAX			(96)
+#define AMI_STANDARD_OFFSET		(0x800)
+#define AMI_GAIN_COR_DEFAULT		(1000)
+
+/* -------------------------------------------------------------------------- */
+struct ami306_private_data {
+	int isstandby;
+	unsigned char fine[3];
+	struct ami_sensor_parametor param;
+	struct ami_win_parameter win;
+};
+
+/* -------------------------------------------------------------------------- */
+static inline unsigned short little_u8_to_u16(unsigned char *p_u8)
+{
+	return p_u8[0] | (p_u8[1] << 8);
+}
+
+static int ami306_set_bits8(void *mlsl_handle,
+			    struct ext_slave_platform_data *pdata,
+			    unsigned char reg, unsigned char bits)
+{
+	int result;
+	unsigned char buf;
+
+	result = inv_serial_read(mlsl_handle, pdata->address, reg, 1, &buf);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	buf |= bits;
+	result = inv_serial_single_write(mlsl_handle, pdata->address, reg, buf);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return result;
+}
+
+static int ami306_wait_data_ready(void *mlsl_handle,
+				  struct ext_slave_platform_data *pdata,
+				  unsigned long usecs, unsigned long times)
+{
+	int result = 0;
+	unsigned char buf;
+
+	for (; 0 < times; --times) {
+		udelay(usecs);
+		result = inv_serial_read(mlsl_handle, pdata->address,
+					 AMI_REG_STA1, 1, &buf);
+		if (buf & AMI_STA1_DRDY_BIT)
+			return 0;
+		else if (buf & AMI_STA1_DOR_BIT)
+			return INV_ERROR_COMPASS_DATA_OVERFLOW;
+	}
+	return INV_ERROR_COMPASS_DATA_NOT_READY;
+}
+
+static int ami306_read_raw_data(void *mlsl_handle,
+				struct ext_slave_platform_data *pdata,
+				short dat[3])
+{
+	int result;
+	unsigned char buf[6];
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 AMI_REG_DATAX, sizeof(buf), buf);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dat[0] = little_u8_to_u16(&buf[0]);
+	dat[1] = little_u8_to_u16(&buf[2]);
+	dat[2] = little_u8_to_u16(&buf[4]);
+	return result;
+}
+
+#define AMI_WAIT_DATAREADY_RETRY		3	/* retry times */
+#define AMI_DRDYWAIT				800	/* u(micro) sec */
+static int ami306_force_mesurement(void *mlsl_handle,
+				   struct ext_slave_platform_data *pdata,
+				   short ver[3])
+{
+	int result;
+	int status;
+	result = ami306_set_bits8(mlsl_handle, pdata,
+				  AMI_REG_CTRL3, AMI_CTRL3_FORCE_BIT);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = ami306_wait_data_ready(mlsl_handle, pdata,
+					AMI_DRDYWAIT, AMI_WAIT_DATAREADY_RETRY);
+	if (result && result != INV_ERROR_COMPASS_DATA_OVERFLOW) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/*  READ DATA X,Y,Z */
+	status = ami306_read_raw_data(mlsl_handle, pdata, ver);
+	if (status) {
+		LOG_RESULT_LOCATION(status);
+		return status;
+	}
+
+	return result;
+}
+
+static int ami306_mea(void *mlsl_handle,
+		      struct ext_slave_platform_data *pdata, short val[3])
+{
+	int result = ami306_force_mesurement(mlsl_handle, pdata, val);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	val[0] += AMI_STANDARD_OFFSET;
+	val[1] += AMI_STANDARD_OFFSET;
+	val[2] += AMI_STANDARD_OFFSET;
+	return result;
+}
+
+static int ami306_write_offset(void *mlsl_handle,
+			       struct ext_slave_platform_data *pdata,
+			       unsigned char *fine)
+{
+	int result = 0;
+	unsigned char dat[3];
+	dat[0] = AMI_REG_OFFX;
+	dat[1] = 0x7f & fine[0];
+	dat[2] = 0;
+	result = inv_serial_write(mlsl_handle, pdata->address,
+				  sizeof(dat), dat);
+	dat[0] = AMI_REG_OFFY;
+	dat[1] = 0x7f & fine[1];
+	dat[2] = 0;
+	result = inv_serial_write(mlsl_handle, pdata->address,
+				  sizeof(dat), dat);
+	dat[0] = AMI_REG_OFFZ;
+	dat[1] = 0x7f & fine[2];
+	dat[2] = 0;
+	result = inv_serial_write(mlsl_handle, pdata->address,
+				  sizeof(dat), dat);
+	return result;
+}
+
+static int ami306_start_sensor(void *mlsl_handle,
+			       struct ext_slave_platform_data *pdata)
+{
+	int result = 0;
+	unsigned char buf[3];
+	struct ami306_private_data *private_data = pdata->private_data;
+
+	/* Step 1 */
+	result = ami306_set_bits8(mlsl_handle, pdata,
+				  AMI_REG_CTRL1,
+				  AMI_CTRL1_PC1 | AMI_CTRL1_FS1_FORCE);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Step 2 */
+	result = ami306_set_bits8(mlsl_handle, pdata,
+				  AMI_REG_CTRL2, AMI_CTRL2_DREN);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Step 3 */
+	buf[0] = AMI_REG_CTRL4;
+	buf[1] = AMI_CTRL4_HS & 0xFF;
+	buf[2] = (AMI_CTRL4_HS >> 8) & 0xFF;
+	result = inv_serial_write(mlsl_handle, pdata->address,
+				  sizeof(buf), buf);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Step 4 */
+	result = ami306_write_offset(mlsl_handle, pdata, private_data->fine);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return result;
+}
+
+/**
+ * This function does this.
+ *
+ * @param mlsl_handle this param is this.
+ * @param slave
+ * @param pdata
+ *
+ * @return INV_SUCCESS or non-zero error code.
+ */
+static int ami306_read_param(void *mlsl_handle,
+			     struct ext_slave_descr *slave,
+			     struct ext_slave_platform_data *pdata)
+{
+	int result = 0;
+	unsigned char regs[12];
+	struct ami306_private_data *private_data = pdata->private_data;
+	struct ami_sensor_parametor *param = &private_data->param;
+
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 AMI_REG_SENX, sizeof(regs), regs);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Little endian 16 bit registers */
+	param->m_gain.x = little_u8_to_u16(&regs[0]);
+	param->m_gain.y = little_u8_to_u16(&regs[2]);
+	param->m_gain.z = little_u8_to_u16(&regs[4]);
+
+	param->m_interference.xy = regs[7];
+	param->m_interference.xz = regs[6];
+	param->m_interference.yx = regs[9];
+	param->m_interference.yz = regs[8];
+	param->m_interference.zx = regs[11];
+	param->m_interference.zy = regs[10];
+
+	param->m_offset.x = AMI_STANDARD_OFFSET;
+	param->m_offset.y = AMI_STANDARD_OFFSET;
+	param->m_offset.z = AMI_STANDARD_OFFSET;
+
+	param->m_gain_cor.x = AMI_GAIN_COR_DEFAULT;
+	param->m_gain_cor.y = AMI_GAIN_COR_DEFAULT;
+	param->m_gain_cor.z = AMI_GAIN_COR_DEFAULT;
+
+	return result;
+}
+
+static int ami306_initial_b0_adjust(void *mlsl_handle,
+				    struct ext_slave_descr *slave,
+				    struct ext_slave_platform_data *pdata)
+{
+	int result;
+	unsigned char fine[3] = { 0 };
+	short data[3];
+	int diff[3] = { 0x7fff, 0x7fff, 0x7fff };
+	int fn = 0;
+	int ax = 0;
+	unsigned char buf[3];
+	struct ami306_private_data *private_data = pdata->private_data;
+
+	result = ami306_set_bits8(mlsl_handle, pdata,
+				  AMI_REG_CTRL2, AMI_CTRL2_DREN);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	buf[0] = AMI_REG_CTRL4;
+	buf[1] = AMI_CTRL4_HS & 0xFF;
+	buf[2] = (AMI_CTRL4_HS >> 8) & 0xFF;
+	result = inv_serial_write(mlsl_handle, pdata->address,
+				  sizeof(buf), buf);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	for (fn = 0; fn < AMI_FINE_MAX; ++fn) {	/* fine 0 -> 95 */
+		fine[0] = fine[1] = fine[2] = fn;
+		result = ami306_write_offset(mlsl_handle, pdata, fine);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+
+		result = ami306_force_mesurement(mlsl_handle, pdata, data);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		MPL_LOGV("[%d] x:%-5d y:%-5d z:%-5d\n",
+			 fn, data[0], data[1], data[2]);
+
+		for (ax = 0; ax < 3; ax++) {
+			/* search point most close to zero. */
+			if (diff[ax] > abs(data[ax])) {
+				private_data->fine[ax] = fn;
+				diff[ax] = abs(data[ax]);
+			}
+		}
+	}
+	MPL_LOGV("fine x:%-5d y:%-5d z:%-5d\n",
+		 private_data->fine[0], private_data->fine[1],
+		 private_data->fine[2]);
+
+	result = ami306_write_offset(mlsl_handle, pdata, private_data->fine);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Software Reset */
+	result = ami306_set_bits8(mlsl_handle, pdata,
+				  AMI_REG_CTRL3, AMI_CTRL3_SRST_BIT);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return result;
+}
+
+#define SEH_RANGE_MIN 100
+#define SEH_RANGE_MAX 3950
+static int ami306_search_offset(void *mlsl_handle,
+				struct ext_slave_descr *slave,
+				struct ext_slave_platform_data *pdata)
+{
+	int result;
+	int axis;
+	unsigned char regs[6];
+	unsigned char run_flg[3] = { 1, 1, 1 };
+	unsigned char fine[3];
+	unsigned char win_range_fine[3];
+	unsigned short fine_output[3];
+	short val[3];
+	unsigned short cnt[3] = { 0 };
+	struct ami306_private_data *private_data = pdata->private_data;
+
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 AMI_FINEOUTPUT_X, sizeof(regs), regs);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	fine_output[0] = little_u8_to_u16(&regs[0]);
+	fine_output[1] = little_u8_to_u16(&regs[2]);
+	fine_output[2] = little_u8_to_u16(&regs[4]);
+
+	for (axis = 0; axis < 3; ++axis) {
+		if (fine_output[axis] == 0) {
+			MPL_LOGV("error fine_output %d  axis:%d\n",
+				 __LINE__, axis);
+			return -1;
+		}
+		/*  fines per a window */
+		win_range_fine[axis] = (SEH_RANGE_MAX - SEH_RANGE_MIN)
+		    / fine_output[axis];
+	}
+
+	/* get current fine */
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 AMI_REG_OFFX, 2, &regs[0]);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 AMI_REG_OFFY, 2, &regs[2]);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 AMI_REG_OFFZ, 2, &regs[4]);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	fine[0] = (unsigned char)(regs[0] & 0x7f);
+	fine[1] = (unsigned char)(regs[2] & 0x7f);
+	fine[2] = (unsigned char)(regs[4] & 0x7f);
+
+	while (run_flg[0] == 1 || run_flg[1] == 1 || run_flg[2] == 1) {
+
+		result = ami306_mea(mlsl_handle, pdata, val);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		MPL_LOGV("val  x:%-5d y:%-5d z:%-5d\n", val[0], val[1], val[2]);
+		MPL_LOGV("now fine x:%-5d y:%-5d z:%-5d\n",
+			 fine[0], fine[1], fine[2]);
+
+		for (axis = 0; axis < 3; ++axis) {
+			if (axis == 0) {	/* X-axis is reversed */
+				val[axis] = 0x0FFF & ~val[axis];
+			}
+			if (val[axis] < SEH_RANGE_MIN) {
+				/* At the case of less low limmit. */
+				fine[axis] -= win_range_fine[axis];
+				MPL_LOGV("min : fine=%d diff=%d\n",
+					 fine[axis], win_range_fine[axis]);
+			}
+			if (val[axis] > SEH_RANGE_MAX) {
+				/* At the case of over high limmit. */
+				fine[axis] += win_range_fine[axis];
+				MPL_LOGV("max : fine=%d diff=%d\n",
+					 fine[axis], win_range_fine[axis]);
+			}
+			if (SEH_RANGE_MIN <= val[axis] &&
+			    val[axis] <= SEH_RANGE_MAX) {
+				/* In the current window. */
+				int diff_fine =
+				    (val[axis] - AMI_STANDARD_OFFSET) /
+				    fine_output[axis];
+				fine[axis] += diff_fine;
+				run_flg[axis] = 0;
+				MPL_LOGV("mid : fine=%d diff=%d\n",
+					 fine[axis], diff_fine);
+			}
+
+			if (!(0 <= fine[axis] && fine[axis] < AMI_FINE_MAX)) {
+				MPL_LOGE("fine err :%d\n", cnt[axis]);
+				goto out;
+			}
+			if (cnt[axis] > 3) {
+				MPL_LOGE("cnt err :%d\n", cnt[axis]);
+				goto out;
+			}
+			cnt[axis]++;
+		}
+		MPL_LOGV("new fine x:%-5d y:%-5d z:%-5d\n",
+			 fine[0], fine[1], fine[2]);
+
+		/* set current fine */
+		result = ami306_write_offset(mlsl_handle, pdata, fine);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+	memcpy(private_data->fine, fine, sizeof(fine));
+out:
+	result = ami306_set_bits8(mlsl_handle, pdata,
+				  AMI_REG_CTRL3, AMI_CTRL3_SRST_BIT);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	udelay(250 + 50);
+	return 0;
+}
+
+static int ami306_read_win(void *mlsl_handle,
+			   struct ext_slave_descr *slave,
+			   struct ext_slave_platform_data *pdata)
+{
+	int result = 0;
+	unsigned char regs[6];
+	struct ami306_private_data *private_data = pdata->private_data;
+	struct ami_win_parameter *win = &private_data->win;
+
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 AMI_REG_OFFOTPX, sizeof(regs), regs);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	win->m_0Gauss_fine.x = (unsigned char)(regs[0] & 0x7f);
+	win->m_0Gauss_fine.y = (unsigned char)(regs[2] & 0x7f);
+	win->m_0Gauss_fine.z = (unsigned char)(regs[4] & 0x7f);
+
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 AMI_REG_OFFX, 2, &regs[0]);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 AMI_REG_OFFY, 2, &regs[2]);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 AMI_REG_OFFZ, 2, &regs[4]);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	win->m_fine.x = (unsigned char)(regs[0] & 0x7f);
+	win->m_fine.y = (unsigned char)(regs[2] & 0x7f);
+	win->m_fine.z = (unsigned char)(regs[4] & 0x7f);
+
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 AMI_FINEOUTPUT_X, sizeof(regs), regs);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	win->m_fine_output.x = little_u8_to_u16(&regs[0]);
+	win->m_fine_output.y = little_u8_to_u16(&regs[2]);
+	win->m_fine_output.z = little_u8_to_u16(&regs[4]);
+
+	return result;
+}
+
+static int ami306_suspend(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	int result;
+	unsigned char reg;
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 AMI306_REG_CNTL1, 1, &reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	reg &= ~(AMI306_BIT_CNTL1_PC1 | AMI306_BIT_CNTL1_FS1);
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 AMI306_REG_CNTL1, reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+static int ami306_resume(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	unsigned char regs[] = {
+		AMI306_REG_CNTL4_1,
+		0x7E,
+		0xA0
+	};
+	/* Step1. Set CNTL1 reg to power model active (Write CNTL1:PC1=1) */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 AMI306_REG_CNTL1,
+					 AMI306_BIT_CNTL1_PC1 |
+					 AMI306_BIT_CNTL1_FS1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Step2. Set CNTL2 reg to DRDY active high and enabled
+	   (Write CNTL2:DREN=1) */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 AMI306_REG_CNTL2,
+					 AMI306_BIT_CNTL2_DREN |
+					 AMI306_BIT_CNTL2_DRP);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Step3. Set CNTL4 reg to for measurement speed: Write CNTL4, 0xA07E */
+	result = inv_serial_write(mlsl_handle, pdata->address,
+				ARRAY_SIZE(regs), regs);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Step4. skipped */
+
+	/* Step5. Set CNTL3 reg to forced measurement period
+	   (Write CNTL3:FORCE=1) */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 AMI306_REG_CNTL3,
+					 AMI306_BIT_CNTL3_F0RCE);
+
+	return result;
+}
+
+static int ami306_read(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata,
+		       unsigned char *data)
+{
+	int result = INV_SUCCESS;
+	int ii;
+	short val[COMPASS_NUM_AXES];
+
+	result = ami306_mea(mlsl_handle, pdata, val);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	for (ii = 0; ii < COMPASS_NUM_AXES; ii++) {
+		val[ii] -= AMI_STANDARD_OFFSET;
+		data[2 * ii] = val[ii] & 0xFF;
+		data[(2 * ii) + 1] = (val[ii] >> 8) & 0xFF;
+	}
+	return result;
+}
+
+static int ami306_init(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata)
+{
+	int result;
+	struct ami306_private_data *private_data;
+	private_data = (struct ami306_private_data *)
+	    kzalloc(sizeof(struct ami306_private_data), GFP_KERNEL);
+
+	if (!private_data)
+		return INV_ERROR_MEMORY_EXAUSTED;
+
+	pdata->private_data = private_data;
+	result = ami306_set_bits8(mlsl_handle, pdata,
+				  AMI_REG_CTRL1,
+				  AMI_CTRL1_PC1 | AMI_CTRL1_FS1_FORCE);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Read Parameters */
+	result = ami306_read_param(mlsl_handle, slave, pdata);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Read Window */
+	result = ami306_initial_b0_adjust(mlsl_handle, slave, pdata);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = ami306_start_sensor(mlsl_handle, pdata);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = ami306_read_win(mlsl_handle, slave, pdata);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 AMI306_REG_CNTL1, 0);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return INV_SUCCESS;
+}
+
+static int ami306_exit(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata)
+{
+	kfree(pdata->private_data);
+	return INV_SUCCESS;
+}
+
+static int ami306_config(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata,
+			 struct ext_slave_config *data)
+{
+	if (!data->data) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+
+	switch (data->key) {
+	case MPU_SLAVE_PARAM:
+	case MPU_SLAVE_WINDOW:
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+	case MPU_SLAVE_CONFIG_MOT_THS:
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+	default:
+		LOG_RESULT_LOCATION(INV_ERROR_FEATURE_NOT_IMPLEMENTED);
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+static int ami306_get_config(void *mlsl_handle,
+			     struct ext_slave_descr *slave,
+			     struct ext_slave_platform_data *pdata,
+			     struct ext_slave_config *data)
+{
+	int result;
+	struct ami306_private_data *private_data = pdata->private_data;
+	if (!data->data) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+
+	switch (data->key) {
+	case MPU_SLAVE_PARAM:
+		if (sizeof(struct ami_sensor_parametor) > data->len) {
+			LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+			return INV_ERROR_INVALID_PARAMETER;
+		}
+		if (data->apply) {
+			result = ami306_read_param(mlsl_handle, slave, pdata);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+		}
+		memcpy(data->data, &private_data->param,
+		       sizeof(struct ami_sensor_parametor));
+		break;
+	case MPU_SLAVE_WINDOW:
+		if (sizeof(struct ami_win_parameter) > data->len) {
+			LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+			return INV_ERROR_INVALID_PARAMETER;
+		}
+		if (data->apply) {
+			result = ami306_read_win(mlsl_handle, slave, pdata);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+		}
+		memcpy(data->data, &private_data->win,
+		       sizeof(struct ami_win_parameter));
+		break;
+	case MPU_SLAVE_SEARCHOFFSET:
+		if (sizeof(struct ami_win_parameter) > data->len) {
+			LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+			return INV_ERROR_INVALID_PARAMETER;
+		}
+		if (data->apply) {
+			result = ami306_search_offset(mlsl_handle,
+						      slave, pdata);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+			/* Start sensor */
+			result = ami306_start_sensor(mlsl_handle, pdata);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+			result = ami306_read_win(mlsl_handle, slave, pdata);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+		}
+		memcpy(data->data, &private_data->win,
+		       sizeof(struct ami_win_parameter));
+		break;
+	case MPU_SLAVE_READWINPARAMS:
+		if (sizeof(struct ami_win_parameter) > data->len) {
+			LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+			return INV_ERROR_INVALID_PARAMETER;
+		}
+		if (data->apply) {
+			result = ami306_initial_b0_adjust(mlsl_handle,
+							  slave, pdata);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+			/* Start sensor */
+			result = ami306_start_sensor(mlsl_handle, pdata);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+			result = ami306_read_win(mlsl_handle, slave, pdata);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+		}
+		memcpy(data->data, &private_data->win,
+		       sizeof(struct ami_win_parameter));
+		break;
+	case MPU_SLAVE_CONFIG_ODR_SUSPEND:
+		(*(unsigned long *)data->data) = 0;
+		break;
+	case MPU_SLAVE_CONFIG_ODR_RESUME:
+		(*(unsigned long *)data->data) = 50000;
+		break;
+	case MPU_SLAVE_CONFIG_FSR_SUSPEND:
+	case MPU_SLAVE_CONFIG_FSR_RESUME:
+	case MPU_SLAVE_CONFIG_MOT_THS:
+	case MPU_SLAVE_CONFIG_NMOT_THS:
+	case MPU_SLAVE_CONFIG_MOT_DUR:
+	case MPU_SLAVE_CONFIG_NMOT_DUR:
+	case MPU_SLAVE_CONFIG_IRQ_SUSPEND:
+	case MPU_SLAVE_CONFIG_IRQ_RESUME:
+	case MPU_SLAVE_READ_SCALE:
+	default:
+		LOG_RESULT_LOCATION(INV_ERROR_FEATURE_NOT_IMPLEMENTED);
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+static struct ext_slave_read_trigger ami306_read_trigger = {
+	/*.reg              = */ AMI_REG_CTRL3,
+	/*.value            = */ AMI_CTRL3_FORCE_BIT
+};
+
+static struct ext_slave_descr ami306_descr = {
+	.init             = ami306_init,
+	.exit             = ami306_exit,
+	.suspend          = ami306_suspend,
+	.resume           = ami306_resume,
+	.read             = ami306_read,
+	.config           = ami306_config,
+	.get_config       = ami306_get_config,
+	.name             = "ami306",
+	.type             = EXT_SLAVE_TYPE_COMPASS,
+	.id               = COMPASS_ID_AMI306,
+	.read_reg         = 0x0E,
+	.read_len         = 13,
+	.endian           = EXT_SLAVE_LITTLE_ENDIAN,
+	.range            = {5461, 3333},
+	.trigger          = &ami306_read_trigger,
+};
+
+static
+struct ext_slave_descr *ami306_get_slave_descr(void)
+{
+	return &ami306_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct ami306_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int ami306_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct ami306_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					ami306_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int ami306_mod_remove(struct i2c_client *client)
+{
+	struct ami306_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				ami306_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id ami306_mod_id[] = {
+	{ "ami306", COMPASS_ID_AMI306 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, ami306_mod_id);
+
+static struct i2c_driver ami306_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = ami306_mod_probe,
+	.remove = ami306_mod_remove,
+	.id_table = ami306_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "ami306_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init ami306_mod_init(void)
+{
+	int res = i2c_add_driver(&ami306_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "ami306_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit ami306_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&ami306_mod_driver);
+}
+
+module_init(ami306_mod_init);
+module_exit(ami306_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate AMI306 sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ami306_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/compass/ami30x.c b/drivers/misc/inv_mpu/compass/ami30x.c
new file mode 100644
index 0000000..0c4937c
--- /dev/null
+++ b/drivers/misc/inv_mpu/compass/ami30x.c
@@ -0,0 +1,308 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup COMPASSDL
+ *
+ *  @{
+ *      @file   ami30x.c
+ *      @brief  Magnetometer setup and handling methods for Aichi AMI304
+ *              and AMI305 compass devices.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-compass"
+
+/* -------------------------------------------------------------------------- */
+#define AMI30X_REG_DATAX (0x10)
+#define AMI30X_REG_STAT1 (0x18)
+#define AMI30X_REG_CNTL1 (0x1B)
+#define AMI30X_REG_CNTL2 (0x1C)
+#define AMI30X_REG_CNTL3 (0x1D)
+
+#define AMI30X_BIT_CNTL1_PC1  (0x80)
+#define AMI30X_BIT_CNTL1_ODR1 (0x10)
+#define AMI30X_BIT_CNTL1_FS1  (0x02)
+
+#define AMI30X_BIT_CNTL2_IEN  (0x10)
+#define AMI30X_BIT_CNTL2_DREN (0x08)
+#define AMI30X_BIT_CNTL2_DRP  (0x04)
+#define AMI30X_BIT_CNTL3_F0RCE (0x40)
+
+/* -------------------------------------------------------------------------- */
+static int ami30x_suspend(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	int result;
+	unsigned char reg;
+	result =
+	    inv_serial_read(mlsl_handle, pdata->address, AMI30X_REG_CNTL1,
+			    1, &reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	reg &= ~(AMI30X_BIT_CNTL1_PC1 | AMI30X_BIT_CNTL1_FS1);
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    AMI30X_REG_CNTL1, reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+static int ami30x_resume(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+
+	/* Set CNTL1 reg to power model active */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    AMI30X_REG_CNTL1,
+				    AMI30X_BIT_CNTL1_PC1 |
+				    AMI30X_BIT_CNTL1_FS1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Set CNTL2 reg to DRDY active high and enabled */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    AMI30X_REG_CNTL2,
+				    AMI30X_BIT_CNTL2_DREN |
+				    AMI30X_BIT_CNTL2_DRP);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Set CNTL3 reg to forced measurement period */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    AMI30X_REG_CNTL3, AMI30X_BIT_CNTL3_F0RCE);
+
+	return result;
+}
+
+static int ami30x_read(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata,
+		       unsigned char *data)
+{
+	unsigned char stat;
+	int result = INV_SUCCESS;
+
+	/* Read status reg and check if data ready (DRDY) */
+	result =
+	    inv_serial_read(mlsl_handle, pdata->address, AMI30X_REG_STAT1,
+			    1, &stat);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	if (stat & 0x40) {
+		result =
+		    inv_serial_read(mlsl_handle, pdata->address,
+				    AMI30X_REG_DATAX, 6, (unsigned char *)data);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		/* start another measurement */
+		result =
+		    inv_serial_single_write(mlsl_handle, pdata->address,
+					    AMI30X_REG_CNTL3,
+					    AMI30X_BIT_CNTL3_F0RCE);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+
+		return INV_SUCCESS;
+	}
+
+	return INV_ERROR_COMPASS_DATA_NOT_READY;
+}
+
+
+/* For AMI305,the range field needs to be modified to {9830.4f} */
+static struct ext_slave_descr ami30x_descr = {
+	.init             = NULL,
+	.exit             = NULL,
+	.suspend          = ami30x_suspend,
+	.resume           = ami30x_resume,
+	.read             = ami30x_read,
+	.config           = NULL,
+	.get_config       = NULL,
+	.name             = "ami30x",
+	.type             = EXT_SLAVE_TYPE_COMPASS,
+	.id               = COMPASS_ID_AMI30X,
+	.read_reg         = 0x06,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_LITTLE_ENDIAN,
+	.range            = {5461, 3333},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *ami30x_get_slave_descr(void)
+{
+	return &ami30x_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct ami30x_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int ami30x_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct ami30x_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					ami30x_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int ami30x_mod_remove(struct i2c_client *client)
+{
+	struct ami30x_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				ami30x_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id ami30x_mod_id[] = {
+	{ "ami30x", COMPASS_ID_AMI30X },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, ami30x_mod_id);
+
+static struct i2c_driver ami30x_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = ami30x_mod_probe,
+	.remove = ami30x_mod_remove,
+	.id_table = ami30x_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "ami30x_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init ami30x_mod_init(void)
+{
+	int res = i2c_add_driver(&ami30x_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "ami30x_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit ami30x_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&ami30x_mod_driver);
+}
+
+module_init(ami30x_mod_init);
+module_exit(ami30x_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate AMI30X sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("ami30x_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/compass/ami_hw.h b/drivers/misc/inv_mpu/compass/ami_hw.h
new file mode 100644
index 0000000..32a04e9
--- /dev/null
+++ b/drivers/misc/inv_mpu/compass/ami_hw.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2010 Information System Products Co.,Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AMI_HW_H
+#define AMI_HW_H
+
+#define	AMI_I2C_BUS_NUM			2
+
+#ifdef	AMI304_MODEL
+#define AMI_I2C_ADDRESS			0x0F
+#else
+#define AMI_I2C_ADDRESS			0x0E
+#endif
+
+#define AMI_GPIO_INT			152
+#define AMI_GPIO_DRDY			153
+
+/* AMI-Sensor Internal Register Address
+ *(Please refer to AMI-Sensor Specifications)
+ */
+#define AMI_MOREINFO_CMDCODE		0x0d
+#define AMI_WHOIAM_CMDCODE		0x0f
+#define AMI_REG_DATAX			0x10
+#define AMI_REG_DATAY			0x12
+#define AMI_REG_DATAZ			0x14
+#define AMI_REG_STA1			0x18
+#define AMI_REG_CTRL1			0x1b
+#define AMI_REG_CTRL2			0x1c
+#define AMI_REG_CTRL3			0x1d
+#define AMI_REG_B0X			0x20
+#define AMI_REG_B0Y			0x22
+#define AMI_REG_B0Z			0x24
+#define AMI_REG_CTRL5			0x40
+#define AMI_REG_CTRL4			0x5c
+#define AMI_REG_TEMP			0x60
+#define AMI_REG_DELAYX			0x68
+#define AMI_REG_DELAYY			0x6e
+#define AMI_REG_DELAYZ			0x74
+#define AMI_REG_OFFX			0x6c
+#define AMI_REG_OFFY			0x72
+#define AMI_REG_OFFZ			0x78
+#define AMI_FINEOUTPUT_X		0x90
+#define AMI_FINEOUTPUT_Y		0x92
+#define AMI_FINEOUTPUT_Z		0x94
+#define AMI_REG_SENX			0x96
+#define AMI_REG_SENY			0x98
+#define AMI_REG_SENZ			0x9a
+#define AMI_REG_GAINX			0x9c
+#define AMI_REG_GAINY			0x9e
+#define AMI_REG_GAINZ			0xa0
+#define AMI_GETVERSION_CMDCODE		0xe8
+#define AMI_SERIALNUMBER_CMDCODE	0xea
+#define AMI_REG_B0OTPX			0xa2
+#define AMI_REG_B0OTPY			0xb8
+#define AMI_REG_B0OTPZ			0xce
+#define AMI_REG_OFFOTPX			0xf8
+#define AMI_REG_OFFOTPY			0xfa
+#define AMI_REG_OFFOTPZ			0xfc
+
+/* AMI-Sensor Control Bit  (Please refer to AMI-Sensor Specifications) */
+#define AMI_CTRL1_PC1			0x80
+#define AMI_CTRL1_FS1_FORCE		0x02
+#define AMI_CTRL1_ODR1			0x10
+#define AMI_CTRL2_DREN			0x08
+#define AMI_CTRL2_DRP			0x04
+#define AMI_CTRL3_FORCE_BIT		0x40
+#define AMI_CTRL3_B0_LO_BIT		0x10
+#define AMI_CTRL3_SRST_BIT		0x80
+#define AMI_CTRL4_HS			0xa07e
+#define AMI_CTRL4_AB			0x0001
+#define AMI_STA1_DRDY_BIT		0x40
+#define AMI_STA1_DOR_BIT		0x20
+
+#endif
diff --git a/drivers/misc/inv_mpu/compass/ami_sensor_def.h b/drivers/misc/inv_mpu/compass/ami_sensor_def.h
new file mode 100644
index 0000000..64032e2
--- /dev/null
+++ b/drivers/misc/inv_mpu/compass/ami_sensor_def.h
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2010 Information System Products Co.,Ltd.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Definitions for ami306 compass chip.
+ */
+#ifndef AMI_SENSOR_DEF_H
+#define AMI_SENSOR_DEF_H
+
+/*********************************************************************
+ Constant
+ *********************************************************************/
+#define	AMI_OK		0x00			/**< Normal */
+#define	AMI_PARAM_ERR	0x01			/**< Parameter Error  */
+#define	AMI_SEQ_ERR	0x02			/**< Squence Error  */
+#define	AMI_SYSTEM_ERR	0x10			/**< System Error  */
+#define AMI_BLOCK_ERR	0x20			/**< Block Error */
+#define	AMI_ERROR	0x99			/**< other Error  */
+
+/*********************************************************************
+ Struct definition
+ *********************************************************************/
+/** axis sensitivity(gain) calibration parameter information  */
+struct ami_vector3d {
+	signed short x;			/**< X-axis  */
+	signed short y;			/**< Y-axis  */
+	signed short z;			/**< Z-axis  */
+};
+
+/** axis interference information  */
+struct ami_interference {
+	/**< Y-axis magnetic field for X-axis correction value  */
+	signed short xy;
+	/**< Z-axis magnetic field for X-axis correction value  */
+	signed short xz;
+	/**< X-axis magnetic field for Y-axis correction value  */
+	signed short yx;
+	/**< Z-axis magnetic field for Y-axis correction value  */
+	signed short yz;
+	/**< X-axis magnetic field for Z-axis correction value  */
+	signed short zx;
+	/**< Y-axis magnetic field for Z-axis correction value  */
+	signed short zy;
+};
+
+/** sensor calibration Parameter information  */
+struct ami_sensor_parametor {
+	/**< geomagnetic field sensor gain  */
+	struct ami_vector3d m_gain;
+	/**< geomagnetic field sensor gain correction parameter  */
+	struct ami_vector3d m_gain_cor;
+	/**< geomagnetic field sensor offset  */
+	struct ami_vector3d m_offset;
+	/**< geomagnetic field sensor axis interference parameter */
+	struct ami_interference m_interference;
+#ifdef AMI_6AXIS
+	/**< acceleration sensor gain  */
+	struct ami_vector3d a_gain;
+	/**< acceleration sensor offset  */
+	struct ami_vector3d a_offset;
+	/**< acceleration sensor deviation  */
+	signed short a_deviation;
+#endif
+};
+
+/** G2-Sensor measurement value (voltage ADC value ) */
+struct ami_sensor_rawvalue {
+	/**< geomagnetic field sensor measurement X-axis value
+	(mounted position/direction reference) */
+	unsigned short mx;
+	/**< geomagnetic field sensor measurement Y-axis value
+	(mounted position/direction reference) */
+	unsigned short my;
+	/**< geomagnetic field sensor measurement Z-axis value
+	(mounted position/direction reference) */
+	unsigned short mz;
+#ifdef AMI_6AXIS
+	/**< acceleration sensor measurement X-axis value
+	(mounted position/direction reference) */
+	unsigned short ax;
+	/**< acceleration sensor measurement Y-axis value
+	(mounted position/direction reference) */
+	unsigned short ay;
+	/**< acceleration sensor measurement Z-axis value
+	(mounted position/direction reference) */
+	unsigned short az;
+#endif
+	/**< temperature sensor measurement value  */
+	unsigned short temperature;
+};
+
+/** Window function Parameter information  */
+struct ami_win_parameter {
+	/**< current fine value  */
+	struct ami_vector3d m_fine;
+	/**< change per 1coarse */
+	struct ami_vector3d m_fine_output;
+	/**< fine value at zero gauss */
+	struct ami_vector3d m_0Gauss_fine;
+#ifdef AMI304
+	/**< current b0 value  */
+	struct ami_vector3d m_b0;
+	/**< current coarse value  */
+	struct ami_vector3d m_coar;
+	/**< change per 1fine */
+	struct ami_vector3d m_coar_output;
+	/**< coarse value at zero gauss */
+	struct ami_vector3d m_0Gauss_coar;
+	/**< delay value  */
+	struct ami_vector3d m_delay;
+#endif
+};
+
+/** AMI chip information ex) 1)model 2)s/n 3)ver 4)more info in the chip */
+struct ami_chipinfo {
+	unsigned short info;	/* INFO 0x0d/0x0e reg.  */
+	unsigned short ver;	/* VER  0xe8/0xe9 reg.  */
+	unsigned short sn;	/* SN   0xea/0xeb reg.  */
+	unsigned char wia;	/* WIA  0x0f      reg.  */
+};
+
+/** AMI Driver Information  */
+struct ami_driverinfo {
+	unsigned char remarks[40];	/* Some Information   */
+	unsigned char datetime[30];	/* compiled date&time */
+	unsigned char ver_major;	/* major version */
+	unsigned char ver_middle;	/* middle.. */
+	unsigned char ver_minor;	/* minor .. */
+};
+
+#endif
diff --git a/drivers/misc/inv_mpu/compass/hmc5883.c b/drivers/misc/inv_mpu/compass/hmc5883.c
new file mode 100644
index 0000000..fdf2ac0
--- /dev/null
+++ b/drivers/misc/inv_mpu/compass/hmc5883.c
@@ -0,0 +1,391 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup COMPASSDL
+ *
+ *  @{
+ *      @file   hmc5883.c
+ *      @brief  Magnetometer setup and handling methods for Honeywell
+ *              HMC5883 compass.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-compass"
+
+/* -------------------------------------------------------------------------- */
+enum HMC_REG {
+	HMC_REG_CONF_A = 0x0,
+	HMC_REG_CONF_B = 0x1,
+	HMC_REG_MODE = 0x2,
+	HMC_REG_X_M = 0x3,
+	HMC_REG_X_L = 0x4,
+	HMC_REG_Z_M = 0x5,
+	HMC_REG_Z_L = 0x6,
+	HMC_REG_Y_M = 0x7,
+	HMC_REG_Y_L = 0x8,
+	HMC_REG_STATUS = 0x9,
+	HMC_REG_ID_A = 0xA,
+	HMC_REG_ID_B = 0xB,
+	HMC_REG_ID_C = 0xC
+};
+
+enum HMC_CONF_A {
+	HMC_CONF_A_DRATE_MASK = 0x1C,
+	HMC_CONF_A_DRATE_0_75 = 0x00,
+	HMC_CONF_A_DRATE_1_5 = 0x04,
+	HMC_CONF_A_DRATE_3 = 0x08,
+	HMC_CONF_A_DRATE_7_5 = 0x0C,
+	HMC_CONF_A_DRATE_15 = 0x10,
+	HMC_CONF_A_DRATE_30 = 0x14,
+	HMC_CONF_A_DRATE_75 = 0x18,
+	HMC_CONF_A_MEAS_MASK = 0x3,
+	HMC_CONF_A_MEAS_NORM = 0x0,
+	HMC_CONF_A_MEAS_POS = 0x1,
+	HMC_CONF_A_MEAS_NEG = 0x2
+};
+
+enum HMC_CONF_B {
+	HMC_CONF_B_GAIN_MASK = 0xE0,
+	HMC_CONF_B_GAIN_0_9 = 0x00,
+	HMC_CONF_B_GAIN_1_2 = 0x20,
+	HMC_CONF_B_GAIN_1_9 = 0x40,
+	HMC_CONF_B_GAIN_2_5 = 0x60,
+	HMC_CONF_B_GAIN_4_0 = 0x80,
+	HMC_CONF_B_GAIN_4_6 = 0xA0,
+	HMC_CONF_B_GAIN_5_5 = 0xC0,
+	HMC_CONF_B_GAIN_7_9 = 0xE0
+};
+
+enum HMC_MODE {
+	HMC_MODE_MASK = 0x3,
+	HMC_MODE_CONT = 0x0,
+	HMC_MODE_SINGLE = 0x1,
+	HMC_MODE_IDLE = 0x2,
+	HMC_MODE_SLEEP = 0x3
+};
+
+/* -------------------------------------------------------------------------- */
+static int hmc5883_suspend(void *mlsl_handle,
+			   struct ext_slave_descr *slave,
+			   struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    HMC_REG_MODE, HMC_MODE_SLEEP);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(3);
+
+	return result;
+}
+
+static int hmc5883_resume(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+
+	/* Use single measurement mode. Start at sleep state. */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    HMC_REG_MODE, HMC_MODE_SLEEP);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Config normal measurement */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    HMC_REG_CONF_A, 0);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Adjust gain to 307 LSB/Gauss */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    HMC_REG_CONF_B, HMC_CONF_B_GAIN_5_5);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+static int hmc5883_read(void *mlsl_handle,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata,
+			unsigned char *data)
+{
+	unsigned char stat;
+	int result = INV_SUCCESS;
+	unsigned char tmp;
+	short axisFixed;
+
+	/* Read status reg. to check if data is ready */
+	result =
+	    inv_serial_read(mlsl_handle, pdata->address, HMC_REG_STATUS, 1,
+			    &stat);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	if (stat & 0x01) {
+		result =
+		    inv_serial_read(mlsl_handle, pdata->address,
+				    HMC_REG_X_M, 6, (unsigned char *)data);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+
+		/* switch YZ axis to proper position */
+		tmp = data[2];
+		data[2] = data[4];
+		data[4] = tmp;
+		tmp = data[3];
+		data[3] = data[5];
+		data[5] = tmp;
+
+		/*drop data if overflows */
+		if ((data[0] == 0xf0) || (data[2] == 0xf0)
+		    || (data[4] == 0xf0)) {
+			/* trigger next measurement read */
+			result =
+			    inv_serial_single_write(mlsl_handle,
+						    pdata->address,
+						    HMC_REG_MODE,
+						    HMC_MODE_SINGLE);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+			return INV_ERROR_COMPASS_DATA_OVERFLOW;
+		}
+		/* convert to fixed point and apply sensitivity correction for
+		   Z-axis */
+		axisFixed =
+		    (short)((unsigned short)data[5] +
+			    (unsigned short)data[4] * 256);
+		/* scale up by 1.125 (36/32) */
+		axisFixed = (short)(axisFixed * 36);
+		data[4] = axisFixed >> 8;
+		data[5] = axisFixed & 0xFF;
+
+		axisFixed =
+		    (short)((unsigned short)data[3] +
+			    (unsigned short)data[2] * 256);
+		axisFixed = (short)(axisFixed * 32);
+		data[2] = axisFixed >> 8;
+		data[3] = axisFixed & 0xFF;
+
+		axisFixed =
+		    (short)((unsigned short)data[1] +
+			    (unsigned short)data[0] * 256);
+		axisFixed = (short)(axisFixed * 32);
+		data[0] = axisFixed >> 8;
+		data[1] = axisFixed & 0xFF;
+
+		/* trigger next measurement read */
+		result =
+		    inv_serial_single_write(mlsl_handle, pdata->address,
+					    HMC_REG_MODE, HMC_MODE_SINGLE);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+
+		return INV_SUCCESS;
+	} else {
+		/* trigger next measurement read */
+		result =
+		    inv_serial_single_write(mlsl_handle, pdata->address,
+					    HMC_REG_MODE, HMC_MODE_SINGLE);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+
+		return INV_ERROR_COMPASS_DATA_NOT_READY;
+	}
+}
+
+static struct ext_slave_descr hmc5883_descr = {
+	.init             = NULL,
+	.exit             = NULL,
+	.suspend          = hmc5883_suspend,
+	.resume           = hmc5883_resume,
+	.read             = hmc5883_read,
+	.config           = NULL,
+	.get_config       = NULL,
+	.name             = "hmc5883",
+	.type             = EXT_SLAVE_TYPE_COMPASS,
+	.id               = COMPASS_ID_HMC5883,
+	.read_reg         = 0x06,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_BIG_ENDIAN,
+	.range            = {10673, 6156},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *hmc5883_get_slave_descr(void)
+{
+	return &hmc5883_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct hmc5883_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int hmc5883_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct hmc5883_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					hmc5883_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int hmc5883_mod_remove(struct i2c_client *client)
+{
+	struct hmc5883_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				hmc5883_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id hmc5883_mod_id[] = {
+	{ "hmc5883", COMPASS_ID_HMC5883 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, hmc5883_mod_id);
+
+static struct i2c_driver hmc5883_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = hmc5883_mod_probe,
+	.remove = hmc5883_mod_remove,
+	.id_table = hmc5883_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "hmc5883_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init hmc5883_mod_init(void)
+{
+	int res = i2c_add_driver(&hmc5883_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "hmc5883_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit hmc5883_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&hmc5883_mod_driver);
+}
+
+module_init(hmc5883_mod_init);
+module_exit(hmc5883_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate HMC5883 sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("hmc5883_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/compass/hscdtd002b.c b/drivers/misc/inv_mpu/compass/hscdtd002b.c
new file mode 100644
index 0000000..4f6013c
--- /dev/null
+++ b/drivers/misc/inv_mpu/compass/hscdtd002b.c
@@ -0,0 +1,294 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup COMPASSDL
+ *
+ *  @{
+ *      @file   hscdtd002b.c
+ *      @brief  Magnetometer setup and handling methods for Alps HSCDTD002B
+ *              compass.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-compass"
+
+/* -------------------------------------------------------------------------- */
+#define COMPASS_HSCDTD002B_STAT          (0x18)
+#define COMPASS_HSCDTD002B_CTRL1         (0x1B)
+#define COMPASS_HSCDTD002B_CTRL2         (0x1C)
+#define COMPASS_HSCDTD002B_CTRL3         (0x1D)
+#define COMPASS_HSCDTD002B_DATAX         (0x10)
+
+/* -------------------------------------------------------------------------- */
+static int hscdtd002b_suspend(void *mlsl_handle,
+			      struct ext_slave_descr *slave,
+			      struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+
+	/* Power mode: stand-by */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    COMPASS_HSCDTD002B_CTRL1, 0x00);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(1);		/* turn-off time */
+
+	return result;
+}
+
+static int hscdtd002b_resume(void *mlsl_handle,
+			     struct ext_slave_descr *slave,
+			     struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+
+	/* Soft reset */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    COMPASS_HSCDTD002B_CTRL3, 0x80);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Force state; Power mode: active */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    COMPASS_HSCDTD002B_CTRL1, 0x82);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Data ready enable */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    COMPASS_HSCDTD002B_CTRL2, 0x08);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(1);		/* turn-on time */
+
+	return result;
+}
+
+static int hscdtd002b_read(void *mlsl_handle,
+			   struct ext_slave_descr *slave,
+			   struct ext_slave_platform_data *pdata,
+			   unsigned char *data)
+{
+	unsigned char stat;
+	int result = INV_SUCCESS;
+	int status = INV_SUCCESS;
+
+	/* Read status reg. to check if data is ready */
+	result =
+	    inv_serial_read(mlsl_handle, pdata->address,
+			    COMPASS_HSCDTD002B_STAT, 1, &stat);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	if (stat & 0x40) {
+		result =
+		    inv_serial_read(mlsl_handle, pdata->address,
+				    COMPASS_HSCDTD002B_DATAX, 6,
+				    (unsigned char *)data);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		status = INV_SUCCESS;
+	} else if (stat & 0x20) {
+		status = INV_ERROR_COMPASS_DATA_OVERFLOW;
+	} else {
+		status = INV_ERROR_COMPASS_DATA_NOT_READY;
+	}
+	/* trigger next measurement read */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    COMPASS_HSCDTD002B_CTRL3, 0x40);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return status;
+}
+
+static struct ext_slave_descr hscdtd002b_descr = {
+	.init             = NULL,
+	.exit             = NULL,
+	.suspend          = hscdtd002b_suspend,
+	.resume           = hscdtd002b_resume,
+	.read             = hscdtd002b_read,
+	.config           = NULL,
+	.get_config       = NULL,
+	.name             = "hscdtd002b",
+	.type             = EXT_SLAVE_TYPE_COMPASS,
+	.id               = COMPASS_ID_HSCDTD002B,
+	.read_reg         = 0x10,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_LITTLE_ENDIAN,
+	.range            = {9830, 4000},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *hscdtd002b_get_slave_descr(void)
+{
+	return &hscdtd002b_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct hscdtd002b_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int hscdtd002b_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct hscdtd002b_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					hscdtd002b_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int hscdtd002b_mod_remove(struct i2c_client *client)
+{
+	struct hscdtd002b_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				hscdtd002b_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id hscdtd002b_mod_id[] = {
+	{ "hscdtd002b", COMPASS_ID_HSCDTD002B },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, hscdtd002b_mod_id);
+
+static struct i2c_driver hscdtd002b_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = hscdtd002b_mod_probe,
+	.remove = hscdtd002b_mod_remove,
+	.id_table = hscdtd002b_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "hscdtd002b_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init hscdtd002b_mod_init(void)
+{
+	int res = i2c_add_driver(&hscdtd002b_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "hscdtd002b_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit hscdtd002b_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&hscdtd002b_mod_driver);
+}
+
+module_init(hscdtd002b_mod_init);
+module_exit(hscdtd002b_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate HSCDTD002B sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("hscdtd002b_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/compass/hscdtd004a.c b/drivers/misc/inv_mpu/compass/hscdtd004a.c
new file mode 100644
index 0000000..f091559
--- /dev/null
+++ b/drivers/misc/inv_mpu/compass/hscdtd004a.c
@@ -0,0 +1,318 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup COMPASSDL
+ *
+ *  @{
+ *      @file   hscdtd004a.c
+ *      @brief  Magnetometer setup and handling methods for Alps HSCDTD004A
+ *              compass.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-compass"
+
+/* -------------------------------------------------------------------------- */
+#define COMPASS_HSCDTD004A_STAT          (0x18)
+#define COMPASS_HSCDTD004A_CTRL1         (0x1B)
+#define COMPASS_HSCDTD004A_CTRL2         (0x1C)
+#define COMPASS_HSCDTD004A_CTRL3         (0x1D)
+#define COMPASS_HSCDTD004A_DATAX         (0x10)
+
+/* -------------------------------------------------------------------------- */
+
+static int hscdtd004a_suspend(void *mlsl_handle,
+			      struct ext_slave_descr *slave,
+			      struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+
+	/* Power mode: stand-by */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    COMPASS_HSCDTD004A_CTRL1, 0x00);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(1);		/* turn-off time */
+
+	return result;
+}
+
+static int hscdtd004a_init(void *mlsl_handle,
+			   struct ext_slave_descr *slave,
+			   struct ext_slave_platform_data *pdata)
+{
+	int result;
+	unsigned char data1, data2[2];
+
+	result = inv_serial_read(mlsl_handle, pdata->address, 0xf, 1, &data1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_read(mlsl_handle, pdata->address, 0xd, 2, data2);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	if (data1 != 0x49 || data2[0] != 0x45 || data2[1] != 0x54) {
+		LOG_RESULT_LOCATION(INV_ERROR_SERIAL_DEVICE_NOT_RECOGNIZED);
+		return INV_ERROR_SERIAL_DEVICE_NOT_RECOGNIZED;
+	}
+	return result;
+}
+
+static int hscdtd004a_resume(void *mlsl_handle,
+			     struct ext_slave_descr *slave,
+			     struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+
+	/* Soft reset */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    COMPASS_HSCDTD004A_CTRL3, 0x80);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Normal state; Power mode: active */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    COMPASS_HSCDTD004A_CTRL1, 0x82);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Data ready enable */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    COMPASS_HSCDTD004A_CTRL2, 0x7C);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(1);		/* turn-on time */
+	return result;
+}
+
+static int hscdtd004a_read(void *mlsl_handle,
+			   struct ext_slave_descr *slave,
+			   struct ext_slave_platform_data *pdata,
+			   unsigned char *data)
+{
+	unsigned char stat;
+	int result = INV_SUCCESS;
+	int status = INV_SUCCESS;
+
+	/* Read status reg. to check if data is ready */
+	result =
+	    inv_serial_read(mlsl_handle, pdata->address,
+			    COMPASS_HSCDTD004A_STAT, 1, &stat);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	if (stat & 0x48) {
+		result =
+		    inv_serial_read(mlsl_handle, pdata->address,
+				    COMPASS_HSCDTD004A_DATAX, 6,
+				    (unsigned char *)data);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		status = INV_SUCCESS;
+	} else if (stat & 0x68) {
+		status = INV_ERROR_COMPASS_DATA_OVERFLOW;
+	} else {
+		status = INV_ERROR_COMPASS_DATA_NOT_READY;
+	}
+	/* trigger next measurement read */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    COMPASS_HSCDTD004A_CTRL3, 0x40);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return status;
+
+}
+
+static struct ext_slave_descr hscdtd004a_descr = {
+	.init             = hscdtd004a_init,
+	.exit             = NULL,
+	.suspend          = hscdtd004a_suspend,
+	.resume           = hscdtd004a_resume,
+	.read             = hscdtd004a_read,
+	.config           = NULL,
+	.get_config       = NULL,
+	.name             = "hscdtd004a",
+	.type             = EXT_SLAVE_TYPE_COMPASS,
+	.id               = COMPASS_ID_HSCDTD004A,
+	.read_reg         = 0x10,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_LITTLE_ENDIAN,
+	.range            = {9830, 4000},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *hscdtd004a_get_slave_descr(void)
+{
+	return &hscdtd004a_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct hscdtd004a_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int hscdtd004a_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct hscdtd004a_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					hscdtd004a_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int hscdtd004a_mod_remove(struct i2c_client *client)
+{
+	struct hscdtd004a_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				hscdtd004a_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id hscdtd004a_mod_id[] = {
+	{ "hscdtd004a", COMPASS_ID_HSCDTD004A },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, hscdtd004a_mod_id);
+
+static struct i2c_driver hscdtd004a_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = hscdtd004a_mod_probe,
+	.remove = hscdtd004a_mod_remove,
+	.id_table = hscdtd004a_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "hscdtd004a_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init hscdtd004a_mod_init(void)
+{
+	int res = i2c_add_driver(&hscdtd004a_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "hscdtd004a_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit hscdtd004a_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&hscdtd004a_mod_driver);
+}
+
+module_init(hscdtd004a_mod_init);
+module_exit(hscdtd004a_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate HSCDTD004A sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("hscdtd004a_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/compass/lsm303dlx_m.c b/drivers/misc/inv_mpu/compass/lsm303dlx_m.c
new file mode 100644
index 0000000..32f8cdd
--- /dev/null
+++ b/drivers/misc/inv_mpu/compass/lsm303dlx_m.c
@@ -0,0 +1,395 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup COMPASSDL
+ *
+ *  @{
+ *      @file   lsm303dlx_m.c
+ *      @brief  Magnetometer setup and handling methods for ST LSM303
+ *              compass.
+ *              This magnetometer device is part of a combo chip with the
+ *              ST LIS331DLH accelerometer and the logic in entirely based
+ *              on the Honeywell HMC5883 magnetometer.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-compass"
+
+/* -------------------------------------------------------------------------- */
+enum LSM_REG {
+	LSM_REG_CONF_A = 0x0,
+	LSM_REG_CONF_B = 0x1,
+	LSM_REG_MODE = 0x2,
+	LSM_REG_X_M = 0x3,
+	LSM_REG_X_L = 0x4,
+	LSM_REG_Z_M = 0x5,
+	LSM_REG_Z_L = 0x6,
+	LSM_REG_Y_M = 0x7,
+	LSM_REG_Y_L = 0x8,
+	LSM_REG_STATUS = 0x9,
+	LSM_REG_ID_A = 0xA,
+	LSM_REG_ID_B = 0xB,
+	LSM_REG_ID_C = 0xC
+};
+
+enum LSM_CONF_A {
+	LSM_CONF_A_DRATE_MASK = 0x1C,
+	LSM_CONF_A_DRATE_0_75 = 0x00,
+	LSM_CONF_A_DRATE_1_5 = 0x04,
+	LSM_CONF_A_DRATE_3 = 0x08,
+	LSM_CONF_A_DRATE_7_5 = 0x0C,
+	LSM_CONF_A_DRATE_15 = 0x10,
+	LSM_CONF_A_DRATE_30 = 0x14,
+	LSM_CONF_A_DRATE_75 = 0x18,
+	LSM_CONF_A_MEAS_MASK = 0x3,
+	LSM_CONF_A_MEAS_NORM = 0x0,
+	LSM_CONF_A_MEAS_POS = 0x1,
+	LSM_CONF_A_MEAS_NEG = 0x2
+};
+
+enum LSM_CONF_B {
+	LSM_CONF_B_GAIN_MASK = 0xE0,
+	LSM_CONF_B_GAIN_0_9 = 0x00,
+	LSM_CONF_B_GAIN_1_2 = 0x20,
+	LSM_CONF_B_GAIN_1_9 = 0x40,
+	LSM_CONF_B_GAIN_2_5 = 0x60,
+	LSM_CONF_B_GAIN_4_0 = 0x80,
+	LSM_CONF_B_GAIN_4_6 = 0xA0,
+	LSM_CONF_B_GAIN_5_5 = 0xC0,
+	LSM_CONF_B_GAIN_7_9 = 0xE0
+};
+
+enum LSM_MODE {
+	LSM_MODE_MASK = 0x3,
+	LSM_MODE_CONT = 0x0,
+	LSM_MODE_SINGLE = 0x1,
+	LSM_MODE_IDLE = 0x2,
+	LSM_MODE_SLEEP = 0x3
+};
+
+/* -------------------------------------------------------------------------- */
+
+static int lsm303dlx_m_suspend(void *mlsl_handle,
+			      struct ext_slave_descr *slave,
+			      struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    LSM_REG_MODE, LSM_MODE_SLEEP);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(3);
+
+	return result;
+}
+
+static int lsm303dlx_m_resume(void *mlsl_handle,
+			     struct ext_slave_descr *slave,
+			     struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+
+	/* Use single measurement mode. Start at sleep state. */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    LSM_REG_MODE, LSM_MODE_SLEEP);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Config normal measurement */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    LSM_REG_CONF_A, 0);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Adjust gain to 320 LSB/Gauss */
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    LSM_REG_CONF_B, LSM_CONF_B_GAIN_5_5);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+static int lsm303dlx_m_read(void *mlsl_handle,
+			   struct ext_slave_descr *slave,
+			   struct ext_slave_platform_data *pdata,
+			   unsigned char *data)
+{
+	unsigned char stat;
+	int result = INV_SUCCESS;
+	short axis_fixed;
+
+	/* Read status reg. to check if data is ready */
+	result =
+	    inv_serial_read(mlsl_handle, pdata->address, LSM_REG_STATUS, 1,
+			    &stat);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	if (stat & 0x01) {
+		result =
+		    inv_serial_read(mlsl_handle, pdata->address,
+				    LSM_REG_X_M, 6, (unsigned char *)data);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+
+		/*drop data if overflows */
+		if ((data[0] == 0xf0) || (data[2] == 0xf0)
+		    || (data[4] == 0xf0)) {
+			/* trigger next measurement read */
+			result =
+			    inv_serial_single_write(mlsl_handle,
+						    pdata->address,
+						    LSM_REG_MODE,
+						    LSM_MODE_SINGLE);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+			return INV_ERROR_COMPASS_DATA_OVERFLOW;
+		}
+		/* convert to fixed point and apply sensitivity correction for
+		   Z-axis */
+		axis_fixed =
+		    (short)((unsigned short)data[5] +
+			    (unsigned short)data[4] * 256);
+		/* scale up by 1.125 (36/32) approximate of 1.122 (320/285) */
+		if (slave->id == COMPASS_ID_LSM303DLM) {
+			/* NOTE/IMPORTANT:
+			   lsm303dlm compass axis definition doesn't
+			   respect the right hand rule. We invert
+			   the sign of the Z axis to fix that. */
+			axis_fixed = (short)(-1 * axis_fixed * 36);
+		} else {
+			axis_fixed = (short)(axis_fixed * 36);
+		}
+		data[4] = axis_fixed >> 8;
+		data[5] = axis_fixed & 0xFF;
+
+		axis_fixed =
+		    (short)((unsigned short)data[3] +
+			    (unsigned short)data[2] * 256);
+		axis_fixed = (short)(axis_fixed * 32);
+		data[2] = axis_fixed >> 8;
+		data[3] = axis_fixed & 0xFF;
+
+		axis_fixed =
+		    (short)((unsigned short)data[1] +
+			    (unsigned short)data[0] * 256);
+		axis_fixed = (short)(axis_fixed * 32);
+		data[0] = axis_fixed >> 8;
+		data[1] = axis_fixed & 0xFF;
+
+		/* trigger next measurement read */
+		result =
+		    inv_serial_single_write(mlsl_handle, pdata->address,
+					    LSM_REG_MODE, LSM_MODE_SINGLE);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+
+		return INV_SUCCESS;
+	} else {
+		/* trigger next measurement read */
+		result =
+		    inv_serial_single_write(mlsl_handle, pdata->address,
+					    LSM_REG_MODE, LSM_MODE_SINGLE);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+
+		return INV_ERROR_COMPASS_DATA_NOT_READY;
+	}
+}
+
+static struct ext_slave_descr lsm303dlx_m_descr = {
+	.init             = NULL,
+	.exit             = NULL,
+	.suspend          = lsm303dlx_m_suspend,
+	.resume           = lsm303dlx_m_resume,
+	.read             = lsm303dlx_m_read,
+	.config           = NULL,
+	.get_config       = NULL,
+	.name             = "lsm303dlx_m",
+	.type             = EXT_SLAVE_TYPE_COMPASS,
+	.id               = ID_INVALID,
+	.read_reg         = 0x06,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_BIG_ENDIAN,
+	.range            = {10240, 0},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *lsm303dlx_m_get_slave_descr(void)
+{
+	return &lsm303dlx_m_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct lsm303dlx_m_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static const struct i2c_device_id lsm303dlx_m_mod_id[] = {
+	{ "lsm303dlh", COMPASS_ID_LSM303DLH },
+	{ "lsm303dlm", COMPASS_ID_LSM303DLM },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, lsm303dlx_m_mod_id);
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int lsm303dlx_m_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct lsm303dlx_m_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+	lsm303dlx_m_descr.id = devid->driver_data;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					lsm303dlx_m_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int lsm303dlx_m_mod_remove(struct i2c_client *client)
+{
+	struct lsm303dlx_m_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				lsm303dlx_m_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static struct i2c_driver lsm303dlx_m_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = lsm303dlx_m_mod_probe,
+	.remove = lsm303dlx_m_mod_remove,
+	.id_table = lsm303dlx_m_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "lsm303dlx_m_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init lsm303dlx_m_mod_init(void)
+{
+	int res = i2c_add_driver(&lsm303dlx_m_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "lsm303dlx_m_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit lsm303dlx_m_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&lsm303dlx_m_mod_driver);
+}
+
+module_init(lsm303dlx_m_mod_init);
+module_exit(lsm303dlx_m_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate lsm303dlx_m sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("lsm303dlx_m_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/compass/mmc314x.c b/drivers/misc/inv_mpu/compass/mmc314x.c
new file mode 100644
index 0000000..786fadc
--- /dev/null
+++ b/drivers/misc/inv_mpu/compass/mmc314x.c
@@ -0,0 +1,313 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup COMPASSDL
+ *
+ *  @{
+ *      @file   mmc314x.c
+ *      @brief  Magnetometer setup and handling methods for the
+ *              MEMSIC MMC314x compass.
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-compass"
+
+/* -------------------------------------------------------------------------- */
+
+static int reset_int = 1000;
+static int read_count = 1;
+static char reset_mode;		/* in Z-init section */
+
+/* -------------------------------------------------------------------------- */
+#define MMC314X_REG_ST (0x00)
+#define MMC314X_REG_X_MSB (0x01)
+
+#define MMC314X_CNTL_MODE_WAKE_UP (0x01)
+#define MMC314X_CNTL_MODE_SET (0x02)
+#define MMC314X_CNTL_MODE_RESET (0x04)
+
+/* -------------------------------------------------------------------------- */
+
+static int mmc314x_suspend(void *mlsl_handle,
+			   struct ext_slave_descr *slave,
+			   struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+
+	return result;
+}
+
+static int mmc314x_resume(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+
+	int result;
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    MMC314X_REG_ST, MMC314X_CNTL_MODE_RESET);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(10);
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    MMC314X_REG_ST, MMC314X_CNTL_MODE_SET);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(10);
+	read_count = 1;
+	return INV_SUCCESS;
+}
+
+static int mmc314x_read(void *mlsl_handle,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata,
+			unsigned char *data)
+{
+	int result, ii;
+	short tmp[3];
+	unsigned char tmpdata[6];
+
+	if (read_count > 1000)
+		read_count = 1;
+
+	result =
+	    inv_serial_read(mlsl_handle, pdata->address, MMC314X_REG_X_MSB,
+			    6, (unsigned char *)data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	for (ii = 0; ii < 6; ii++)
+		tmpdata[ii] = data[ii];
+
+	for (ii = 0; ii < 3; ii++) {
+		tmp[ii] = (short)((tmpdata[2 * ii] << 8) + tmpdata[2 * ii + 1]);
+		tmp[ii] = tmp[ii] - 4096;
+		tmp[ii] = tmp[ii] * 16;
+	}
+
+	for (ii = 0; ii < 3; ii++) {
+		data[2 * ii] = (unsigned char)(tmp[ii] >> 8);
+		data[2 * ii + 1] = (unsigned char)(tmp[ii]);
+	}
+
+	if (read_count % reset_int == 0) {
+		if (reset_mode) {
+			result =
+			    inv_serial_single_write(mlsl_handle,
+						    pdata->address,
+						    MMC314X_REG_ST,
+						    MMC314X_CNTL_MODE_RESET);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+			reset_mode = 0;
+			return INV_ERROR_COMPASS_DATA_NOT_READY;
+		} else {
+			result =
+			    inv_serial_single_write(mlsl_handle,
+						    pdata->address,
+						    MMC314X_REG_ST,
+						    MMC314X_CNTL_MODE_SET);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+			reset_mode = 1;
+			read_count++;
+			return INV_ERROR_COMPASS_DATA_NOT_READY;
+		}
+	}
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    MMC314X_REG_ST, MMC314X_CNTL_MODE_WAKE_UP);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	read_count++;
+
+	return INV_SUCCESS;
+}
+
+static struct ext_slave_descr mmc314x_descr = {
+	.init             = NULL,
+	.exit             = NULL,
+	.suspend          = mmc314x_suspend,
+	.resume           = mmc314x_resume,
+	.read             = mmc314x_read,
+	.config           = NULL,
+	.get_config       = NULL,
+	.name             = "mmc314x",
+	.type             = EXT_SLAVE_TYPE_COMPASS,
+	.id               = COMPASS_ID_MMC314X,
+	.read_reg         = 0x01,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_BIG_ENDIAN,
+	.range            = {400, 0},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *mmc314x_get_slave_descr(void)
+{
+	return &mmc314x_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct mmc314x_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int mmc314x_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct mmc314x_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					mmc314x_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int mmc314x_mod_remove(struct i2c_client *client)
+{
+	struct mmc314x_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				mmc314x_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id mmc314x_mod_id[] = {
+	{ "mmc314x", COMPASS_ID_MMC314X },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, mmc314x_mod_id);
+
+static struct i2c_driver mmc314x_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = mmc314x_mod_probe,
+	.remove = mmc314x_mod_remove,
+	.id_table = mmc314x_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "mmc314x_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init mmc314x_mod_init(void)
+{
+	int res = i2c_add_driver(&mmc314x_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "mmc314x_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit mmc314x_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&mmc314x_mod_driver);
+}
+
+module_init(mmc314x_mod_init);
+module_exit(mmc314x_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate MMC314X sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("mmc314x_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/compass/yas529-kernel.c b/drivers/misc/inv_mpu/compass/yas529-kernel.c
new file mode 100644
index 0000000..f53223f
--- /dev/null
+++ b/drivers/misc/inv_mpu/compass/yas529-kernel.c
@@ -0,0 +1,611 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <log.h>
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-acc"
+
+/*----- YAMAHA YAS529 Registers ------*/
+enum YAS_REG {
+	YAS_REG_CMDR		= 0x00,	/* 000 < 5 */
+	YAS_REG_XOFFSETR	= 0x20,	/* 001 < 5 */
+	YAS_REG_Y1OFFSETR	= 0x40,	/* 010 < 5 */
+	YAS_REG_Y2OFFSETR	= 0x60,	/* 011 < 5 */
+	YAS_REG_ICOILR		= 0x80,	/* 100 < 5 */
+	YAS_REG_CAL		= 0xA0,	/* 101 < 5 */
+	YAS_REG_CONFR		= 0xC0,	/* 110 < 5 */
+	YAS_REG_DOUTR		= 0xE0	/* 111 < 5 */
+};
+
+/* -------------------------------------------------------------------------- */
+
+static long a1;
+static long a2;
+static long a3;
+static long a4;
+static long a5;
+static long a6;
+static long a7;
+static long a8;
+static long a9;
+
+/* -------------------------------------------------------------------------- */
+static int yas529_sensor_i2c_write(struct i2c_adapter *i2c_adap,
+				   unsigned char address,
+				   unsigned int len, unsigned char *data)
+{
+	struct i2c_msg msgs[1];
+	int res;
+
+	if (NULL == data || NULL == i2c_adap)
+		return -EINVAL;
+
+	msgs[0].addr = address;
+	msgs[0].flags = 0;	/* write */
+	msgs[0].buf = (unsigned char *)data;
+	msgs[0].len = len;
+
+	res = i2c_transfer(i2c_adap, msgs, 1);
+	if (res < 1)
+		return res;
+	else
+		return 0;
+}
+
+static int yas529_sensor_i2c_read(struct i2c_adapter *i2c_adap,
+				  unsigned char address,
+				  unsigned char reg,
+				  unsigned int len, unsigned char *data)
+{
+	struct i2c_msg msgs[2];
+	int res;
+
+	if (NULL == data || NULL == i2c_adap)
+		return -EINVAL;
+
+	msgs[0].addr = address;
+	msgs[0].flags = I2C_M_RD;
+	msgs[0].buf = data;
+	msgs[0].len = len;
+
+	res = i2c_transfer(i2c_adap, msgs, 1);
+	if (res < 1)
+		return res;
+	else
+		return 0;
+}
+
+static int yas529_suspend(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+
+	return result;
+}
+
+static int yas529_resume(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+
+	unsigned char dummyData[1] = { 0 };
+	unsigned char dummyRegister = 0;
+	unsigned char rawData[6];
+	unsigned char calData[9];
+
+	short xoffset, y1offset, y2offset;
+	short d2, d3, d4, d5, d6, d7, d8, d9;
+
+	/* YAS529 Application Manual MS-3C - Section 4.4.5 */
+	/* =============================================== */
+	/* Step 1 - register initialization */
+	/* zero initialization coil register - "100 00 000" */
+	dummyData[0] = YAS_REG_ICOILR | 0x00;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* zero config register - "110 00 000" */
+	dummyData[0] = YAS_REG_CONFR | 0x00;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Step 2 - initialization coil operation */
+	dummyData[0] = YAS_REG_ICOILR | 0x11;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_ICOILR | 0x01;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_ICOILR | 0x12;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_ICOILR | 0x02;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_ICOILR | 0x13;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_ICOILR | 0x03;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_ICOILR | 0x14;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_ICOILR | 0x04;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_ICOILR | 0x15;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_ICOILR | 0x05;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_ICOILR | 0x16;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_ICOILR | 0x06;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_ICOILR | 0x17;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_ICOILR | 0x07;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_ICOILR | 0x10;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_ICOILR | 0x00;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Step 3 - rough offset measurement */
+	/* Config register - Measurements results - "110 00 000" */
+	dummyData[0] = YAS_REG_CONFR | 0x00;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Measurements command register - Rough offset measurement -
+	   "000 00001" */
+	dummyData[0] = YAS_REG_CMDR | 0x01;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(2);		/* wait at least 1.5ms */
+
+	/* Measurement data read */
+	result =
+	    yas529_sensor_i2c_read(mlsl_handle, pdata->address,
+				   dummyRegister, 6, rawData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	xoffset =
+	    (short)((unsigned short)rawData[5] +
+		    ((unsigned short)rawData[4] & 0x7) * 256) - 5;
+	if (xoffset < 0)
+		xoffset = 0;
+	y1offset =
+	    (short)((unsigned short)rawData[3] +
+		    ((unsigned short)rawData[2] & 0x7) * 256) - 5;
+	if (y1offset < 0)
+		y1offset = 0;
+	y2offset =
+	    (short)((unsigned short)rawData[1] +
+		    ((unsigned short)rawData[0] & 0x7) * 256) - 5;
+	if (y2offset < 0)
+		y2offset = 0;
+
+	/* Step 4 - rough offset setting */
+	/* Set rough offset register values */
+	dummyData[0] = YAS_REG_XOFFSETR | xoffset;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_Y1OFFSETR | y1offset;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	dummyData[0] = YAS_REG_Y2OFFSETR | y2offset;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* CAL matrix read (first read is invalid) */
+	/* Config register - CAL register read - "110 01 000" */
+	dummyData[0] = YAS_REG_CONFR | 0x08;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* CAL data read */
+	result =
+	    yas529_sensor_i2c_read(mlsl_handle, pdata->address,
+				   dummyRegister, 9, calData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Config register - CAL register read - "110 01 000" */
+	dummyData[0] = YAS_REG_CONFR | 0x08;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* CAL data read */
+	result =
+	    yas529_sensor_i2c_read(mlsl_handle, pdata->address,
+				   dummyRegister, 9, calData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Calculate coefficients of the sensitivity correction matrix */
+	a1 = 100;
+	d2 = (calData[0] & 0xFC) >> 2;	/* [71..66] 6bit */
+	a2 = (short)(d2 - 32);
+	/* [65..62] 4bit */
+	d3 = ((calData[0] & 0x03) << 2) | ((calData[1] & 0xC0) >> 6);
+	a3 = (short)(d3 - 8);
+	d4 = (calData[1] & 0x3F);	/* [61..56] 6bit */
+	a4 = (short)(d4 - 32);
+	d5 = (calData[2] & 0xFC) >> 2;	/* [55..50] 6bit */
+	a5 = (short)(d5 - 32) + 70;
+	/* [49..44] 6bit */
+	d6 = ((calData[2] & 0x03) << 4) | ((calData[3] & 0xF0) >> 4);
+	a6 = (short)(d6 - 32);
+	/* [43..38] 6bit */
+	d7 = ((calData[3] & 0x0F) << 2) | ((calData[4] & 0xC0) >> 6);
+	a7 = (short)(d7 - 32);
+	d8 = (calData[4] & 0x3F);	/* [37..32] 6bit */
+	a8 = (short)(d8 - 32);
+	d9 = (calData[5] & 0xFE) >> 1;	/* [31..25] 7bit */
+	a9 = (short)(d9 - 64) + 130;
+
+	return result;
+}
+
+static int yas529_read(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata,
+		       unsigned char *data)
+{
+	unsigned char stat;
+	unsigned char rawData[6];
+	unsigned char dummyData[1] = { 0 };
+	unsigned char dummyRegister = 0;
+	int result = INV_SUCCESS;
+	short SX, SY1, SY2, SY, SZ;
+	short row1fixed, row2fixed, row3fixed;
+
+	/* Config register - Measurements results - "110 00 000" */
+	dummyData[0] = YAS_REG_CONFR | 0x00;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Measurements command register - Normal magnetic field measurement -
+	   "000 00000" */
+	dummyData[0] = YAS_REG_CMDR | 0x00;
+	result =
+	    yas529_sensor_i2c_write(mlsl_handle, pdata->address, 1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	msleep(10);
+	/* Measurement data read */
+	result =
+	    yas529_sensor_i2c_read(mlsl_handle, pdata->address,
+				   dummyRegister, 6, (unsigned char *)&rawData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	stat = rawData[0] & 0x80;
+	if (stat == 0x00) {
+		/* Extract raw data */
+		SX = (short)((unsigned short)rawData[5] +
+			     ((unsigned short)rawData[4] & 0x7) * 256);
+		SY1 =
+		    (short)((unsigned short)rawData[3] +
+			    ((unsigned short)rawData[2] & 0x7) * 256);
+		SY2 =
+		    (short)((unsigned short)rawData[1] +
+			    ((unsigned short)rawData[0] & 0x7) * 256);
+		if ((SX <= 1) || (SY1 <= 1) || (SY2 <= 1))
+			return INV_ERROR_COMPASS_DATA_UNDERFLOW;
+		if ((SX >= 1024) || (SY1 >= 1024) || (SY2 >= 1024))
+			return INV_ERROR_COMPASS_DATA_OVERFLOW;
+		/* Convert to XYZ axis */
+		SX = -1 * SX;
+		SY = SY2 - SY1;
+		SZ = SY1 + SY2;
+
+		/* Apply sensitivity correction matrix */
+		row1fixed = (short)((a1 * SX + a2 * SY + a3 * SZ) >> 7) * 41;
+		row2fixed = (short)((a4 * SX + a5 * SY + a6 * SZ) >> 7) * 41;
+		row3fixed = (short)((a7 * SX + a8 * SY + a9 * SZ) >> 7) * 41;
+
+		data[0] = row1fixed >> 8;
+		data[1] = row1fixed & 0xFF;
+		data[2] = row2fixed >> 8;
+		data[3] = row2fixed & 0xFF;
+		data[4] = row3fixed >> 8;
+		data[5] = row3fixed & 0xFF;
+
+		return INV_SUCCESS;
+	} else {
+		return INV_ERROR_COMPASS_DATA_NOT_READY;
+	}
+}
+
+static struct ext_slave_descr yas529_descr = {
+	.init             = NULL,
+	.exit             = NULL,
+	.suspend          = yas529_suspend,
+	.resume           = yas529_resume,
+	.read             = yas529_read,
+	.config           = NULL,
+	.get_config       = NULL,
+	.name             = "yas529",
+	.type             = EXT_SLAVE_TYPE_COMPASS,
+	.id               = COMPASS_ID_YAS529,
+	.read_reg         = 0x06,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_BIG_ENDIAN,
+	.range            = {19660, 8000},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *yas529_get_slave_descr(void)
+{
+	return &yas529_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct yas529_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int yas529_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct yas529_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					yas529_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int yas529_mod_remove(struct i2c_client *client)
+{
+	struct yas529_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				yas529_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id yas529_mod_id[] = {
+	{ "yas529", COMPASS_ID_YAS529 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, yas529_mod_id);
+
+static struct i2c_driver yas529_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = yas529_mod_probe,
+	.remove = yas529_mod_remove,
+	.id_table = yas529_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "yas529_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init yas529_mod_init(void)
+{
+	int res = i2c_add_driver(&yas529_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "yas529_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit yas529_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&yas529_mod_driver);
+}
+
+module_init(yas529_mod_init);
+module_exit(yas529_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate YAS529 sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("yas529_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/compass/yas530.c b/drivers/misc/inv_mpu/compass/yas530.c
new file mode 100644
index 0000000..fdca05b
--- /dev/null
+++ b/drivers/misc/inv_mpu/compass/yas530.c
@@ -0,0 +1,580 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+  *  @addtogroup COMPASSDL
+  *
+  *  @{
+  *      @file   yas530.c
+  *      @brief  Magnetometer setup and handling methods for Yamaha YAS530
+  *              compass when used in a user-space solution (no kernel driver).
+  */
+
+/* -------------------------------------------------------------------------- */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include "log.h"
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "MPL-compass"
+
+/* -------------------------------------------------------------------------- */
+#define YAS530_REGADDR_DEVICE_ID          (0x80)
+#define YAS530_REGADDR_ACTUATE_INIT_COIL  (0x81)
+#define YAS530_REGADDR_MEASURE_COMMAND    (0x82)
+#define YAS530_REGADDR_CONFIG             (0x83)
+#define YAS530_REGADDR_MEASURE_INTERVAL   (0x84)
+#define YAS530_REGADDR_OFFSET_X           (0x85)
+#define YAS530_REGADDR_OFFSET_Y1          (0x86)
+#define YAS530_REGADDR_OFFSET_Y2          (0x87)
+#define YAS530_REGADDR_TEST1              (0x88)
+#define YAS530_REGADDR_TEST2              (0x89)
+#define YAS530_REGADDR_CAL                (0x90)
+#define YAS530_REGADDR_MEASURE_DATA       (0xb0)
+
+/* -------------------------------------------------------------------------- */
+static int Cx, Cy1, Cy2;
+static int /*a1, */ a2, a3, a4, a5, a6, a7, a8, a9;
+static int k;
+
+static unsigned char dx, dy1, dy2;
+static unsigned char d2, d3, d4, d5, d6, d7, d8, d9, d0;
+static unsigned char dck;
+
+/* -------------------------------------------------------------------------- */
+
+static int set_hardware_offset(void *mlsl_handle,
+			       struct ext_slave_descr *slave,
+			       struct ext_slave_platform_data *pdata,
+			       char offset_x, char offset_y1, char offset_y2)
+{
+	char data;
+	int result = INV_SUCCESS;
+
+	data = offset_x & 0x3f;
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 YAS530_REGADDR_OFFSET_X, data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	data = offset_y1 & 0x3f;
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 YAS530_REGADDR_OFFSET_Y1, data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	data = offset_y2 & 0x3f;
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 YAS530_REGADDR_OFFSET_Y2, data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+static int set_measure_command(void *mlsl_handle,
+			       struct ext_slave_descr *slave,
+			       struct ext_slave_platform_data *pdata,
+			       int ldtc, int fors, int dlymes)
+{
+	int result = INV_SUCCESS;
+
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 YAS530_REGADDR_MEASURE_COMMAND, 0x01);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+static int measure_normal(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata,
+			  int *busy, unsigned short *t,
+			  unsigned short *x, unsigned short *y1,
+			  unsigned short *y2)
+{
+	unsigned char data[8];
+	unsigned short b, to, xo, y1o, y2o;
+	int result;
+	ktime_t sleeptime;
+	result = set_measure_command(mlsl_handle, slave, pdata, 0, 0, 0);
+	sleeptime = ktime_set(0, 2 * NSEC_PER_MSEC);
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_hrtimeout(&sleeptime, HRTIMER_MODE_REL);
+
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 YAS530_REGADDR_MEASURE_DATA, 8, data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	b = (data[0] >> 7) & 0x01;
+	to = ((data[0] << 2) & 0x1fc) | ((data[1] >> 6) & 0x03);
+	xo = ((data[2] << 5) & 0xfe0) | ((data[3] >> 3) & 0x1f);
+	y1o = ((data[4] << 5) & 0xfe0) | ((data[5] >> 3) & 0x1f);
+	y2o = ((data[6] << 5) & 0xfe0) | ((data[7] >> 3) & 0x1f);
+
+	*busy = b;
+	*t = to;
+	*x = xo;
+	*y1 = y1o;
+	*y2 = y2o;
+
+	return result;
+}
+
+static int check_offset(void *mlsl_handle,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata,
+			char offset_x, char offset_y1, char offset_y2,
+			int *flag_x, int *flag_y1, int *flag_y2)
+{
+	int result;
+	int busy;
+	short t, x, y1, y2;
+
+	result = set_hardware_offset(mlsl_handle, slave, pdata,
+				     offset_x, offset_y1, offset_y2);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = measure_normal(mlsl_handle, slave, pdata,
+				&busy, &t, &x, &y1, &y2);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	*flag_x = 0;
+	*flag_y1 = 0;
+	*flag_y2 = 0;
+
+	if (x > 2048)
+		*flag_x = 1;
+	if (y1 > 2048)
+		*flag_y1 = 1;
+	if (y2 > 2048)
+		*flag_y2 = 1;
+	if (x < 2048)
+		*flag_x = -1;
+	if (y1 < 2048)
+		*flag_y1 = -1;
+	if (y2 < 2048)
+		*flag_y2 = -1;
+
+	return result;
+}
+
+static int measure_and_set_offset(void *mlsl_handle,
+				  struct ext_slave_descr *slave,
+				  struct ext_slave_platform_data *pdata,
+				  char *offset)
+{
+	int i;
+	int result = INV_SUCCESS;
+	char offset_x = 0, offset_y1 = 0, offset_y2 = 0;
+	int flag_x = 0, flag_y1 = 0, flag_y2 = 0;
+	static const int correct[5] = { 16, 8, 4, 2, 1 };
+
+	for (i = 0; i < 5; i++) {
+		result = check_offset(mlsl_handle, slave, pdata,
+				      offset_x, offset_y1, offset_y2,
+				      &flag_x, &flag_y1, &flag_y2);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+
+		if (flag_x)
+			offset_x += flag_x * correct[i];
+		if (flag_y1)
+			offset_y1 += flag_y1 * correct[i];
+		if (flag_y2)
+			offset_y2 += flag_y2 * correct[i];
+	}
+
+	result = set_hardware_offset(mlsl_handle, slave, pdata,
+				     offset_x, offset_y1, offset_y2);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	offset[0] = offset_x;
+	offset[1] = offset_y1;
+	offset[2] = offset_y2;
+
+	return result;
+}
+
+static void coordinate_conversion(short x, short y1, short y2, short t,
+				  int32_t *xo, int32_t *yo, int32_t *zo)
+{
+	int32_t sx, sy1, sy2, sy, sz;
+	int32_t hx, hy, hz;
+
+	sx = x - (Cx * t) / 100;
+	sy1 = y1 - (Cy1 * t) / 100;
+	sy2 = y2 - (Cy2 * t) / 100;
+
+	sy = sy1 - sy2;
+	sz = -sy1 - sy2;
+
+	hx = k * ((100 * sx + a2 * sy + a3 * sz) / 10);
+	hy = k * ((a4 * sx + a5 * sy + a6 * sz) / 10);
+	hz = k * ((a7 * sx + a8 * sy + a9 * sz) / 10);
+
+	*xo = hx;
+	*yo = hy;
+	*zo = hz;
+}
+
+static int yas530_suspend(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+		   struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+
+	return result;
+}
+
+static int yas530_resume(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+
+	unsigned char dummyData = 0x00;
+	char offset[3] = { 0, 0, 0 };
+	unsigned char data[16];
+	unsigned char read_reg[1];
+
+	/* =============================================== */
+
+	/* Step 1 - Test register initialization */
+	dummyData = 0x00;
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 YAS530_REGADDR_TEST1, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result =
+	    inv_serial_single_write(mlsl_handle, pdata->address,
+				    YAS530_REGADDR_TEST2, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Device ID read  */
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 YAS530_REGADDR_DEVICE_ID, 1, read_reg);
+
+	/*Step 2 Read the CAL register */
+	/* CAL data read */
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 YAS530_REGADDR_CAL, 16, data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* CAL data Second Read */
+	result = inv_serial_read(mlsl_handle, pdata->address,
+				 YAS530_REGADDR_CAL, 16, data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/*Cal data */
+	dx = data[0];
+	dy1 = data[1];
+	dy2 = data[2];
+	d2 = (data[3] >> 2) & 0x03f;
+	d3 = ((data[3] << 2) & 0x0c) | ((data[4] >> 6) & 0x03);
+	d4 = data[4] & 0x3f;
+	d5 = (data[5] >> 2) & 0x3f;
+	d6 = ((data[5] << 4) & 0x30) | ((data[6] >> 4) & 0x0f);
+	d7 = ((data[6] << 3) & 0x78) | ((data[7] >> 5) & 0x07);
+	d8 = ((data[7] << 1) & 0x3e) | ((data[8] >> 7) & 0x01);
+	d9 = ((data[8] << 1) & 0xfe) | ((data[9] >> 7) & 0x01);
+	d0 = (data[9] >> 2) & 0x1f;
+	dck = ((data[9] << 1) & 0x06) | ((data[10] >> 7) & 0x01);
+
+	/*Correction Data */
+	Cx = (int)dx * 6 - 768;
+	Cy1 = (int)dy1 * 6 - 768;
+	Cy2 = (int)dy2 * 6 - 768;
+	a2 = (int)d2 - 32;
+	a3 = (int)d3 - 8;
+	a4 = (int)d4 - 32;
+	a5 = (int)d5 + 38;
+	a6 = (int)d6 - 32;
+	a7 = (int)d7 - 64;
+	a8 = (int)d8 - 32;
+	a9 = (int)d9;
+	k = (int)d0 + 10;
+
+	/*Obtain the [49:47] bits */
+	dck &= 0x07;
+
+	/*Step 3 : Storing the CONFIG with the CLK value */
+	dummyData = 0x00 | (dck << 2);
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 YAS530_REGADDR_CONFIG, dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/*Step 4 : Set Acquisition Interval Register */
+	dummyData = 0x00;
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 YAS530_REGADDR_MEASURE_INTERVAL,
+					 dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/*Step 5 : Reset Coil */
+	dummyData = 0x00;
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+					 YAS530_REGADDR_ACTUATE_INIT_COIL,
+					 dummyData);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Offset Measurement and Set */
+	result = measure_and_set_offset(mlsl_handle, slave, pdata, offset);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	return result;
+}
+
+static int yas530_read(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata,
+		       unsigned char *data)
+{
+	int result = INV_SUCCESS;
+
+	int busy;
+	short t, x, y1, y2;
+	int32_t xyz[3];
+	short rawfixed[3];
+
+	result = measure_normal(mlsl_handle, slave, pdata,
+				&busy, &t, &x, &y1, &y2);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	coordinate_conversion(x, y1, y2, t, &xyz[0], &xyz[1], &xyz[2]);
+
+	rawfixed[0] = (short)(xyz[0] / 100);
+	rawfixed[1] = (short)(xyz[1] / 100);
+	rawfixed[2] = (short)(xyz[2] / 100);
+
+	data[0] = rawfixed[0] >> 8;
+	data[1] = rawfixed[0] & 0xFF;
+	data[2] = rawfixed[1] >> 8;
+	data[3] = rawfixed[1] & 0xFF;
+	data[4] = rawfixed[2] >> 8;
+	data[5] = rawfixed[2] & 0xFF;
+
+	if (busy)
+		return INV_ERROR_COMPASS_DATA_NOT_READY;
+	return result;
+}
+
+static struct ext_slave_descr yas530_descr = {
+	.init             = NULL,
+	.exit             = NULL,
+	.suspend          = yas530_suspend,
+	.resume           = yas530_resume,
+	.read             = yas530_read,
+	.config           = NULL,
+	.get_config       = NULL,
+	.name             = "yas530",
+	.type             = EXT_SLAVE_TYPE_COMPASS,
+	.id               = COMPASS_ID_YAS530,
+	.read_reg         = 0x06,
+	.read_len         = 6,
+	.endian           = EXT_SLAVE_BIG_ENDIAN,
+	.range            = {3276, 8001},
+	.trigger          = NULL,
+};
+
+static
+struct ext_slave_descr *yas530_get_slave_descr(void)
+{
+	return &yas530_descr;
+}
+
+/* -------------------------------------------------------------------------- */
+struct yas530_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int yas530_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct yas530_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					yas530_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int yas530_mod_remove(struct i2c_client *client)
+{
+	struct yas530_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				yas530_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id yas530_mod_id[] = {
+	{ "yas530", COMPASS_ID_YAS530 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, yas530_mod_id);
+
+static struct i2c_driver yas530_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = yas530_mod_probe,
+	.remove = yas530_mod_remove,
+	.id_table = yas530_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "yas530_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init yas530_mod_init(void)
+{
+	int res = i2c_add_driver(&yas530_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "yas530_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit yas530_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&yas530_mod_driver);
+}
+
+module_init(yas530_mod_init);
+module_exit(yas530_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate YAS530 sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("yas530_mod");
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/log.h b/drivers/misc/inv_mpu/log.h
new file mode 100644
index 0000000..5630602e
--- /dev/null
+++ b/drivers/misc/inv_mpu/log.h
@@ -0,0 +1,287 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/*
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *
+ * Copyright (C) 2005 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * C/C++ logging functions.  See the logging documentation for API details.
+ *
+ * We'd like these to be available from C code (in case we import some from
+ * somewhere), so this has a C interface.
+ *
+ * The output will be correct when the log file is shared between multiple
+ * threads and/or multiple processes so long as the operating system
+ * supports O_APPEND.  These calls have mutex-protected data structures
+ * and so are NOT reentrant.  Do not use MPL_LOG in a signal handler.
+ */
+#ifndef _LIBS_CUTILS_MPL_LOG_H
+#define _LIBS_CUTILS_MPL_LOG_H
+
+#include "mltypes.h"
+#include <stdarg.h>
+
+
+#include <linux/kernel.h>
+
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Normally we strip MPL_LOGV (VERBOSE messages) from release builds.
+ * You can modify this (for example with "#define MPL_LOG_NDEBUG 0"
+ * at the top of your source file) to change that behavior.
+ */
+#ifndef MPL_LOG_NDEBUG
+#ifdef NDEBUG
+#define MPL_LOG_NDEBUG 1
+#else
+#define MPL_LOG_NDEBUG 0
+#endif
+#endif
+
+#define MPL_LOG_UNKNOWN MPL_LOG_VERBOSE
+#define MPL_LOG_DEFAULT KERN_DEFAULT
+#define MPL_LOG_VERBOSE KERN_CONT
+#define MPL_LOG_DEBUG   KERN_NOTICE
+#define MPL_LOG_INFO    KERN_INFO
+#define MPL_LOG_WARN    KERN_WARNING
+#define MPL_LOG_ERROR   KERN_ERR
+#define MPL_LOG_SILENT  MPL_LOG_VERBOSE
+
+
+
+/*
+ * This is the local tag used for the following simplified
+ * logging macros.  You can change this preprocessor definition
+ * before using the other macros to change the tag.
+ */
+#ifndef MPL_LOG_TAG
+#define MPL_LOG_TAG
+#endif
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Simplified macro to send a verbose log message using the current MPL_LOG_TAG.
+ */
+#ifndef MPL_LOGV
+#if MPL_LOG_NDEBUG
+#define MPL_LOGV(fmt, ...)						\
+	do {								\
+		if (0)							\
+			MPL_LOG(LOG_VERBOSE, MPL_LOG_TAG, fmt, ##__VA_ARGS__);\
+	} while (0)
+#else
+#define MPL_LOGV(fmt, ...) MPL_LOG(LOG_VERBOSE, MPL_LOG_TAG, fmt, ##__VA_ARGS__)
+#endif
+#endif
+
+#ifndef CONDITION
+#define CONDITION(cond)     ((cond) != 0)
+#endif
+
+#ifndef MPL_LOGV_IF
+#if MPL_LOG_NDEBUG
+#define MPL_LOGV_IF(cond, fmt, ...)  \
+	do { if (0) MPL_LOG(fmt, ##__VA_ARGS__); } while (0)
+#else
+#define MPL_LOGV_IF(cond, fmt, ...) \
+	((CONDITION(cond))						\
+		? MPL_LOG(LOG_VERBOSE, MPL_LOG_TAG, fmt, ##__VA_ARGS__) \
+		: (void)0)
+#endif
+#endif
+
+/*
+ * Simplified macro to send a debug log message using the current MPL_LOG_TAG.
+ */
+#ifndef MPL_LOGD
+#define MPL_LOGD(fmt, ...) MPL_LOG(LOG_DEBUG, MPL_LOG_TAG, fmt, ##__VA_ARGS__)
+#endif
+
+#ifndef MPL_LOGD_IF
+#define MPL_LOGD_IF(cond, fmt, ...) \
+	((CONDITION(cond))					       \
+		? MPL_LOG(LOG_DEBUG, MPL_LOG_TAG, fmt, ##__VA_ARGS__)  \
+		: (void)0)
+#endif
+
+/*
+ * Simplified macro to send an info log message using the current MPL_LOG_TAG.
+ */
+#ifndef MPL_LOGI
+#define MPL_LOGI(fmt, ...) pr_info(KERN_INFO MPL_LOG_TAG fmt, ##__VA_ARGS__)
+#endif
+
+#ifndef MPL_LOGI_IF
+#define MPL_LOGI_IF(cond, fmt, ...) \
+	((CONDITION(cond))                                              \
+		? MPL_LOG(LOG_INFO, MPL_LOG_TAG, fmt, ##__VA_ARGS__)   \
+		: (void)0)
+#endif
+
+/*
+ * Simplified macro to send a warning log message using the current MPL_LOG_TAG.
+ */
+#ifndef MPL_LOGW
+#define MPL_LOGW(fmt, ...) printk(KERN_WARNING MPL_LOG_TAG fmt, ##__VA_ARGS__)
+#endif
+
+#ifndef MPL_LOGW_IF
+#define MPL_LOGW_IF(cond, fmt, ...) \
+	((CONDITION(cond))					       \
+		? MPL_LOG(LOG_WARN, MPL_LOG_TAG, fmt, ##__VA_ARGS__)   \
+		: (void)0)
+#endif
+
+/*
+ * Simplified macro to send an error log message using the current MPL_LOG_TAG.
+ */
+#ifndef MPL_LOGE
+#define MPL_LOGE(fmt, ...) printk(KERN_ERR MPL_LOG_TAG fmt, ##__VA_ARGS__)
+#endif
+
+#ifndef MPL_LOGE_IF
+#define MPL_LOGE_IF(cond, fmt, ...) \
+	((CONDITION(cond))					       \
+		? MPL_LOG(LOG_ERROR, MPL_LOG_TAG, fmt, ##__VA_ARGS__)  \
+		: (void)0)
+#endif
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Log a fatal error.  If the given condition fails, this stops program
+ * execution like a normal assertion, but also generating the given message.
+ * It is NOT stripped from release builds.  Note that the condition test
+ * is -inverted- from the normal assert() semantics.
+ */
+#define MPL_LOG_ALWAYS_FATAL_IF(cond, fmt, ...) \
+	((CONDITION(cond))					   \
+		? ((void)android_printAssert(#cond, MPL_LOG_TAG,   \
+						fmt, ##__VA_ARGS__))	\
+		: (void)0)
+
+#define MPL_LOG_ALWAYS_FATAL(fmt, ...) \
+	(((void)android_printAssert(NULL, MPL_LOG_TAG, fmt, ##__VA_ARGS__)))
+
+/*
+ * Versions of MPL_LOG_ALWAYS_FATAL_IF and MPL_LOG_ALWAYS_FATAL that
+ * are stripped out of release builds.
+ */
+#if MPL_LOG_NDEBUG
+#define MPL_LOG_FATAL_IF(cond, fmt, ...)				\
+	do {								\
+		if (0)							\
+			MPL_LOG_ALWAYS_FATAL_IF(cond, fmt, ##__VA_ARGS__); \
+	} while (0)
+#define MPL_LOG_FATAL(fmt, ...)						\
+	do {								\
+		if (0)							\
+			MPL_LOG_ALWAYS_FATAL(fmt, ##__VA_ARGS__)	\
+	} while (0)
+#else
+#define MPL_LOG_FATAL_IF(cond, fmt, ...) \
+	MPL_LOG_ALWAYS_FATAL_IF(cond, fmt, ##__VA_ARGS__)
+#define MPL_LOG_FATAL(fmt, ...) \
+	MPL_LOG_ALWAYS_FATAL(fmt, ##__VA_ARGS__)
+#endif
+
+/*
+ * Assertion that generates a log message when the assertion fails.
+ * Stripped out of release builds.  Uses the current MPL_LOG_TAG.
+ */
+#define MPL_LOG_ASSERT(cond, fmt, ...)			\
+	MPL_LOG_FATAL_IF(!(cond), fmt, ##__VA_ARGS__)
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Basic log message macro.
+ *
+ * Example:
+ *  MPL_LOG(MPL_LOG_WARN, NULL, "Failed with error %d", errno);
+ *
+ * The second argument may be NULL or "" to indicate the "global" tag.
+ */
+#ifndef MPL_LOG
+#define MPL_LOG(priority, tag, fmt, ...)		\
+	MPL_LOG_PRI(priority, tag, fmt, ##__VA_ARGS__)
+#endif
+
+/*
+ * Log macro that allows you to specify a number for the priority.
+ */
+#ifndef MPL_LOG_PRI
+#define MPL_LOG_PRI(priority, tag, fmt, ...) \
+	pr_debug(MPL_##priority tag fmt, ##__VA_ARGS__)
+#endif
+
+/*
+ * Log macro that allows you to pass in a varargs ("args" is a va_list).
+ */
+#ifndef MPL_LOG_PRI_VA
+/* not allowed in the Kernel because there is no dev_dbg that takes a va_list */
+#endif
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * ===========================================================================
+ *
+ * The stuff in the rest of this file should not be used directly.
+ */
+
+int _MLPrintLog(int priority, const char *tag, const char *fmt,	...);
+int _MLPrintVaLog(int priority, const char *tag, const char *fmt, va_list args);
+/* Final implementation of actual writing to a character device */
+int _MLWriteLog(const char *buf, int buflen);
+
+static inline void __print_result_location(int result,
+					   const char *file,
+					   const char *func, int line)
+{
+	MPL_LOGE("%s|%s|%d returning %d\n", file, func, line, result);
+}
+
+#define LOG_RESULT_LOCATION(condition) \
+	do {								\
+		__print_result_location((int)(condition), __FILE__,	\
+					__func__, __LINE__);		\
+	} while (0)
+
+
+#endif				/* _LIBS_CUTILS_MPL_LOG_H */
diff --git a/drivers/misc/inv_mpu/mldl_cfg.c b/drivers/misc/inv_mpu/mldl_cfg.c
new file mode 100644
index 0000000..4d5896b
--- /dev/null
+++ b/drivers/misc/inv_mpu/mldl_cfg.c
@@ -0,0 +1,1966 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup MLDL
+ *
+ *  @{
+ *      @file   mldl_cfg.c
+ *      @brief  The Motion Library Driver Layer.
+ */
+
+/* -------------------------------------------------------------------------- */
+#include <linux/delay.h>
+#include <linux/slab.h>
+
+#include <stddef.h>
+
+#include "mldl_cfg.h"
+#include <linux/mpu.h>
+#include "mpu6050b1.h"
+
+#include "mlsl.h"
+#include "mldl_print_cfg.h"
+#include "log.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "mldl_cfg:"
+
+/* -------------------------------------------------------------------------- */
+
+#define SLEEP   0
+#define WAKE_UP 7
+#define RESET   1
+#define STANDBY 1
+
+/* -------------------------------------------------------------------------- */
+
+/**
+ * @brief Stop the DMP running
+ *
+ * @return INV_SUCCESS or non-zero error code
+ */
+static int dmp_stop(struct mldl_cfg *mldl_cfg, void *gyro_handle)
+{
+	unsigned char user_ctrl_reg;
+	int result;
+
+	if (mldl_cfg->inv_mpu_state->status & MPU_DMP_IS_SUSPENDED)
+		return INV_SUCCESS;
+
+	result = inv_serial_read(gyro_handle, mldl_cfg->mpu_chip_info->addr,
+				 MPUREG_USER_CTRL, 1, &user_ctrl_reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	user_ctrl_reg = (user_ctrl_reg & (~BIT_FIFO_EN)) | BIT_FIFO_RST;
+	user_ctrl_reg = (user_ctrl_reg & (~BIT_DMP_EN)) | BIT_DMP_RST;
+
+	result = inv_serial_single_write(gyro_handle,
+					 mldl_cfg->mpu_chip_info->addr,
+					 MPUREG_USER_CTRL, user_ctrl_reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	mldl_cfg->inv_mpu_state->status |= MPU_DMP_IS_SUSPENDED;
+
+	return result;
+}
+
+/**
+ * @brief Starts the DMP running
+ *
+ * @return INV_SUCCESS or non-zero error code
+ */
+static int dmp_start(struct mldl_cfg *mldl_cfg, void *mlsl_handle)
+{
+	unsigned char user_ctrl_reg;
+	int result;
+
+	if ((!(mldl_cfg->inv_mpu_state->status & MPU_DMP_IS_SUSPENDED) &&
+	    mldl_cfg->mpu_gyro_cfg->dmp_enable)
+		||
+	   ((mldl_cfg->inv_mpu_state->status & MPU_DMP_IS_SUSPENDED) &&
+		   !mldl_cfg->mpu_gyro_cfg->dmp_enable))
+		return INV_SUCCESS;
+
+	result = inv_serial_read(mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+				 MPUREG_USER_CTRL, 1, &user_ctrl_reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = inv_serial_single_write(
+		mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+		MPUREG_USER_CTRL,
+		((user_ctrl_reg & (~BIT_FIFO_EN))
+			| BIT_FIFO_RST));
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = inv_serial_single_write(
+		mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+		MPUREG_USER_CTRL, user_ctrl_reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = inv_serial_read(mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+				 MPUREG_USER_CTRL, 1, &user_ctrl_reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	user_ctrl_reg |= BIT_DMP_EN;
+
+	if (mldl_cfg->mpu_gyro_cfg->fifo_enable)
+		user_ctrl_reg |= BIT_FIFO_EN;
+	else
+		user_ctrl_reg &= ~BIT_FIFO_EN;
+
+	user_ctrl_reg |= BIT_DMP_RST;
+
+	result = inv_serial_single_write(
+		mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+		MPUREG_USER_CTRL, user_ctrl_reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	mldl_cfg->inv_mpu_state->status &= ~MPU_DMP_IS_SUSPENDED;
+
+	return result;
+}
+
+/**
+ *  @brief  enables/disables the I2C bypass to an external device
+ *          connected to MPU's secondary I2C bus.
+ *  @param  enable
+ *              Non-zero to enable pass through.
+ *  @return INV_SUCCESS if successful, a non-zero error code otherwise.
+ */
+static int mpu6050b1_set_i2c_bypass(struct mldl_cfg *mldl_cfg,
+				    void *mlsl_handle, unsigned char enable)
+{
+	unsigned char reg;
+	int result;
+	unsigned char status = mldl_cfg->inv_mpu_state->status;
+	if ((status & MPU_GYRO_IS_BYPASSED && enable) ||
+	    (!(status & MPU_GYRO_IS_BYPASSED) && !enable))
+		return INV_SUCCESS;
+
+	/*---- get current 'USER_CTRL' into b ----*/
+	result = inv_serial_read(mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+				 MPUREG_USER_CTRL, 1, &reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	if (!enable) {
+		/* setting int_config with the property flag BIT_BYPASS_EN
+		   should be done by the setup functions */
+		result = inv_serial_single_write(
+			mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+			MPUREG_INT_PIN_CFG,
+			(mldl_cfg->pdata->int_config & ~(BIT_BYPASS_EN)));
+		if (!(reg & BIT_I2C_MST_EN)) {
+			result =
+			    inv_serial_single_write(
+				    mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+				    MPUREG_USER_CTRL,
+				    (reg | BIT_I2C_MST_EN));
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+		}
+	} else if (enable) {
+		if (reg & BIT_AUX_IF_EN) {
+			result =
+			    inv_serial_single_write(
+				    mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+				    MPUREG_USER_CTRL,
+				    (reg & (~BIT_I2C_MST_EN)));
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+			/*****************************************
+			 * To avoid hanging the bus we must sleep until all
+			 * slave transactions have been completed.
+			 *  24 bytes max slave reads
+			 *  +1 byte possible extra write
+			 *  +4 max slave address
+			 * ---
+			 *  33 Maximum bytes
+			 *  x9 Approximate bits per byte
+			 * ---
+			 * 297 bits.
+			 * 2.97 ms minimum @ 100kbps
+			 * 0.75 ms minimum @ 400kbps.
+			 *****************************************/
+			msleep(3);
+		}
+		result = inv_serial_single_write(
+			mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+			MPUREG_INT_PIN_CFG,
+			(mldl_cfg->pdata->int_config | BIT_BYPASS_EN));
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+	if (enable)
+		mldl_cfg->inv_mpu_state->status |= MPU_GYRO_IS_BYPASSED;
+	else
+		mldl_cfg->inv_mpu_state->status &= ~MPU_GYRO_IS_BYPASSED;
+
+	return result;
+}
+
+
+
+
+/**
+ *  @brief  enables/disables the I2C bypass to an external device
+ *          connected to MPU's secondary I2C bus.
+ *  @param  enable
+ *              Non-zero to enable pass through.
+ *  @return INV_SUCCESS if successful, a non-zero error code otherwise.
+ */
+static int mpu_set_i2c_bypass(struct mldl_cfg *mldl_cfg, void *mlsl_handle,
+			      unsigned char enable)
+{
+	return mpu6050b1_set_i2c_bypass(mldl_cfg, mlsl_handle, enable);
+}
+
+
+#define NUM_OF_PROD_REVS (ARRAY_SIZE(prod_rev_map))
+
+/* NOTE : when not indicated, product revision
+	  is considered an 'npp'; non production part */
+
+/* produces an unique identifier for each device based on the
+   combination of product version and product revision */
+struct prod_rev_map_t {
+	unsigned short mpl_product_key;
+	unsigned char silicon_rev;
+	unsigned short gyro_trim;
+	unsigned short accel_trim;
+};
+
+/* NOTE: product entries are in chronological order */
+static struct prod_rev_map_t prod_rev_map[] = {
+	/* prod_ver = 0 */
+	{MPL_PROD_KEY(0,   1), MPU_SILICON_REV_A2, 131, 16384},
+	{MPL_PROD_KEY(0,   2), MPU_SILICON_REV_A2, 131, 16384},
+	{MPL_PROD_KEY(0,   3), MPU_SILICON_REV_A2, 131, 16384},
+	{MPL_PROD_KEY(0,   4), MPU_SILICON_REV_A2, 131, 16384},
+	{MPL_PROD_KEY(0,   5), MPU_SILICON_REV_A2, 131, 16384},
+	{MPL_PROD_KEY(0,   6), MPU_SILICON_REV_A2, 131, 16384}, /* (A2/C2-1) */
+	/* prod_ver = 1, forced to 0 for MPU6050 A2 */
+	{MPL_PROD_KEY(0,   7), MPU_SILICON_REV_A2, 131, 16384},
+	{MPL_PROD_KEY(0,   8), MPU_SILICON_REV_A2, 131, 16384},
+	{MPL_PROD_KEY(0,   9), MPU_SILICON_REV_A2, 131, 16384},
+	{MPL_PROD_KEY(0,  10), MPU_SILICON_REV_A2, 131, 16384},
+	{MPL_PROD_KEY(0,  11), MPU_SILICON_REV_A2, 131, 16384}, /* (A2/D2-1) */
+	{MPL_PROD_KEY(0,  12), MPU_SILICON_REV_A2, 131, 16384},
+	{MPL_PROD_KEY(0,  13), MPU_SILICON_REV_A2, 131, 16384},
+	{MPL_PROD_KEY(0,  14), MPU_SILICON_REV_A2, 131, 16384},
+	{MPL_PROD_KEY(0,  15), MPU_SILICON_REV_A2, 131, 16384},
+	{MPL_PROD_KEY(0,  27), MPU_SILICON_REV_A2, 131, 16384}, /* (A2/D4)	 */
+	/* prod_ver = 1 */
+	{MPL_PROD_KEY(1,  16), MPU_SILICON_REV_B1, 131, 16384}, /* (B1/D2-1) */
+	{MPL_PROD_KEY(1,  17), MPU_SILICON_REV_B1, 131, 16384}, /* (B1/D2-2) */
+	{MPL_PROD_KEY(1,  18), MPU_SILICON_REV_B1, 131, 16384}, /* (B1/D2-3) */
+	{MPL_PROD_KEY(1,  19), MPU_SILICON_REV_B1, 131, 16384}, /* (B1/D2-4) */
+	{MPL_PROD_KEY(1,  20), MPU_SILICON_REV_B1, 131, 16384}, /* (B1/D2-5) */
+	{MPL_PROD_KEY(1,  28), MPU_SILICON_REV_B1, 131, 16384}, /* (B1/D4)	 */
+	{MPL_PROD_KEY(1,   1), MPU_SILICON_REV_B1, 131, 16384}, /* (B1/E1-1) */
+	{MPL_PROD_KEY(1,   2), MPU_SILICON_REV_B1, 131, 16384}, /* (B1/E1-2) */
+	{MPL_PROD_KEY(1,   3), MPU_SILICON_REV_B1, 131, 16384}, /* (B1/E1-3) */
+	{MPL_PROD_KEY(1,   4), MPU_SILICON_REV_B1, 131, 16384}, /* (B1/E1-4) */
+	{MPL_PROD_KEY(1,   5), MPU_SILICON_REV_B1, 131, 16384}, /* (B1/E1-5) */
+	{MPL_PROD_KEY(1,   6), MPU_SILICON_REV_B1, 131, 16384}, /* (B1/E1-6) */
+	/* prod_ver = 2 */
+	{MPL_PROD_KEY(2,   7), MPU_SILICON_REV_B1, 131, 16384}, /* (B2/E1-1) */
+	{MPL_PROD_KEY(2,   8), MPU_SILICON_REV_B1, 131, 16384}, /* (B2/E1-2) */
+	{MPL_PROD_KEY(2,   9), MPU_SILICON_REV_B1, 131, 16384}, /* (B2/E1-3) */
+	{MPL_PROD_KEY(2,  10), MPU_SILICON_REV_B1, 131, 16384}, /* (B2/E1-4) */
+	{MPL_PROD_KEY(2,  11), MPU_SILICON_REV_B1, 131, 16384}, /* (B2/E1-5) */
+	{MPL_PROD_KEY(2,  12), MPU_SILICON_REV_B1, 131, 16384}, /* (B2/E1-6) */
+	{MPL_PROD_KEY(2,  29), MPU_SILICON_REV_B1, 131, 16384}, /* (B2/D4)	 */
+	/* prod_ver = 3 */
+	{MPL_PROD_KEY(3,  30), MPU_SILICON_REV_B1, 131, 16384}, /* (B2/E2)	 */
+	/* prod_ver = 4 */
+	{MPL_PROD_KEY(4,  31), MPU_SILICON_REV_B1, 131,  8192}, /* (B2/F1)	 */
+	{MPL_PROD_KEY(4,   1), MPU_SILICON_REV_B1, 131,  8192}, /* (B3/F1)	 */
+	{MPL_PROD_KEY(4,   3), MPU_SILICON_REV_B1, 131,  8192}, /* (B4/F1)	 */
+	/* prod_ver = 5 */
+	{MPL_PROD_KEY(5,   3), MPU_SILICON_REV_B1, 131, 16384}, /* (B4/F1)	 */
+	/* prod_ver = 6 */
+	{MPL_PROD_KEY(6,  19), MPU_SILICON_REV_B1, 131, 16384}, /* (B5/E2)	 */
+	/* prod_ver = 7 */
+	{MPL_PROD_KEY(7,  19), MPU_SILICON_REV_B1, 131, 16384}, /* (B5/E2)	 */
+	/* prod_ver = 8 */
+	{MPL_PROD_KEY(8,  19), MPU_SILICON_REV_B1, 131, 16384}, /* (B5/E2)	 */
+	/* prod_ver = 9 */
+	{MPL_PROD_KEY(9,  19), MPU_SILICON_REV_B1, 131, 16384}, /* (B5/E2)	 */
+	/* prod_ver = 10 */
+	{MPL_PROD_KEY(10, 19), MPU_SILICON_REV_B1, 131, 16384}	/* (B5/E2)	 */
+
+};
+
+/*
+   List of product software revisions
+
+   NOTE :
+   software revision 0 falls back to the old detection method
+   based off the product version and product revision per the
+   table above
+*/
+static struct prod_rev_map_t sw_rev_map[] = {
+	{0,		     0,   0,     0},
+	{1, MPU_SILICON_REV_B1, 131,  8192},	/* rev C */
+	{2, MPU_SILICON_REV_B1, 131, 16384}	/* rev D */
+ };
+
+/**
+ *  @internal
+ *  @brief  Inverse lookup of the index of an MPL product key .
+ *  @param  key
+ *              the MPL product indentifier also referred to as 'key'.
+ *  @return the index position of the key in the array, -1 if not found.
+ */
+short index_of_key(unsigned short key)
+{
+	int i;
+	for (i = 0; i < NUM_OF_PROD_REVS; i++)
+		if (prod_rev_map[i].mpl_product_key == key)
+			return (short)i;
+	return -1;
+}
+
+/**
+ *  @internal
+ *  @brief  Get the product revision and version for MPU6050 and
+ *          extract all per-part specific information.
+ *          The product version number is read from the PRODUCT_ID register in
+ *          user space register map.
+ *          The product revision number is in read from OTP bank 0, ADDR6[7:2].
+ *          These 2 numbers, combined, provide an unique key to be used to
+ *          retrieve some per-device information such as the silicon revision
+ *          and the gyro and accel sensitivity trim values.
+ *
+ *  @param  mldl_cfg
+ *              a pointer to the mldl config data structure.
+ *  @param  mlsl_handle
+ *              an file handle to the serial communication device the
+ *              device is connected to.
+ *
+ *  @return 0 on success, a non-zero error code otherwise.
+ */
+static int inv_get_silicon_rev_mpu6050(
+		struct mldl_cfg *mldl_cfg, void *mlsl_handle)
+{
+	unsigned char prod_ver, prod_rev;
+	struct prod_rev_map_t *p_rev;
+	unsigned sw_rev;
+	unsigned short key;
+	unsigned char bank =
+	    (BIT_PRFTCH_EN | BIT_CFG_USER_BANK | MPU_MEM_OTP_BANK_0);
+	unsigned short mem_addr = ((bank << 8) | 0x06);
+	short index;
+	unsigned char regs[5];
+	int result;
+	struct mpu_chip_info *mpu_chip_info = mldl_cfg->mpu_chip_info;
+
+	/* get the product version */
+	result = inv_serial_read(mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+				 MPUREG_PRODUCT_ID, 1, &prod_ver);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	prod_ver &= 0xF;
+
+	/* get the product revision */
+	result = inv_serial_read_mem(mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+				     mem_addr, 1, &prod_rev);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	prod_rev >>= 2;
+
+	/* clean the prefetch and cfg user bank bits */
+	result = inv_serial_single_write(
+		mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+		MPUREG_BANK_SEL, 0);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* get the software-product version */
+	result = inv_serial_read(mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+				 MPUREG_XA_OFFS_L, 5, regs);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	sw_rev = (regs[4] & 0x01) << 2 |	/* 0x0b, bit 0 */
+		 (regs[2] & 0x01) << 1 |	/* 0x09, bit 0 */
+		 (regs[0] & 0x01);		/* 0x07, bit 0 */
+
+	/* if 0, use the product key to determine the type of part */
+	if (sw_rev == 0) {
+		key = MPL_PROD_KEY(prod_ver, prod_rev);
+		if (key == 0) {
+			MPL_LOGE("Product id read as 0 "
+				 "indicates device is either "
+				 "incompatible or an MPU3050\n");
+			return INV_ERROR_INVALID_MODULE;
+		}
+		index = index_of_key(key);
+		if (index == -1 || index >= NUM_OF_PROD_REVS) {
+			MPL_LOGE("Unsupported product key %d in MPL\n", key);
+			return INV_ERROR_INVALID_MODULE;
+		}
+		/* check MPL is compiled for this device */
+		if (prod_rev_map[index].silicon_rev != MPU_SILICON_REV_B1) {
+			MPL_LOGE("MPL compiled for MPU6050B1 support "
+				 "but device is not MPU6050B1 (%d)\n", key);
+			return INV_ERROR_INVALID_MODULE;
+		}
+		p_rev = &prod_rev_map[index];
+
+	/* if valid, use the software product key */
+	} else if (sw_rev < ARRAY_SIZE(sw_rev_map)) {
+		p_rev = &sw_rev_map[sw_rev];
+
+	} else {
+		MPL_LOGE("Software revision key is outside of known "
+			 "range [0..%d] : %d\n", ARRAY_SIZE(sw_rev_map),ARRAY_SIZE(sw_rev_map));
+		return INV_ERROR_INVALID_MODULE;
+	}
+
+	mpu_chip_info->product_id = prod_ver;
+	mpu_chip_info->product_revision = prod_rev;
+	mpu_chip_info->silicon_revision = p_rev->silicon_rev;
+	mpu_chip_info->gyro_sens_trim = p_rev->gyro_trim;
+	mpu_chip_info->accel_sens_trim = p_rev->accel_trim;
+
+	return result;
+}
+#define inv_get_silicon_rev inv_get_silicon_rev_mpu6050
+
+
+/**
+ *  @brief  Enable / Disable the use MPU's secondary I2C interface level
+ *          shifters.
+ *          When enabled the secondary I2C interface to which the external
+ *          device is connected runs at VDD voltage (main supply).
+ *          When disabled the 2nd interface runs at VDDIO voltage.
+ *          See the device specification for more details.
+ *
+ *  @note   using this API may produce unpredictable results, depending on how
+ *          the MPU and slave device are setup on the target platform.
+ *          Use of this API should entirely be restricted to system
+ *          integrators. Once the correct value is found, there should be no
+ *          need to change the level shifter at runtime.
+ *
+ *  @pre    Must be called after inv_serial_start().
+ *  @note   Typically called before inv_dmp_open().
+ *
+ *  @param[in]  enable:
+ *                  0 to run at VDDIO (default),
+ *                  1 to run at VDD.
+ *
+ *  @return INV_SUCCESS if successfull, a non-zero error code otherwise.
+ */
+static int inv_mpu_set_level_shifter_bit(struct mldl_cfg *mldl_cfg,
+				  void *mlsl_handle, unsigned char enable)
+{
+	int result;
+	unsigned char regval;
+
+	result = inv_serial_read(mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+				 MPUREG_YG_OFFS_TC, 1, &regval);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	if (enable)
+		regval |= BIT_I2C_MST_VDDIO;
+
+	result = inv_serial_single_write(
+		mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+		MPUREG_YG_OFFS_TC, regval);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	return INV_SUCCESS;
+}
+
+
+/**
+ * @internal
+ * @brief MPU6050 B1 power management functions.
+ * @param mldl_cfg
+ *          a pointer to the internal mldl_cfg data structure.
+ * @param mlsl_handle
+ *          a file handle to the serial device used to communicate
+ *          with the MPU6050 B1 device.
+ * @param reset
+ *          1 to reset hardware.
+ * @param sensors
+ *          Bitfield of sensors to leave on
+ *
+ * @return 0 on success, a non-zero error code on error.
+ */
+static int mpu60xx_pwr_mgmt(struct mldl_cfg *mldl_cfg,
+				    void *mlsl_handle,
+				    unsigned int reset, unsigned long sensors)
+{
+	unsigned char pwr_mgmt[2];
+	unsigned char pwr_mgmt_prev[2];
+	int result;
+	int sleep = !(sensors & (INV_THREE_AXIS_GYRO | INV_THREE_AXIS_ACCEL
+				| INV_DMP_PROCESSOR));
+
+	if (reset) {
+		MPL_LOGI("Reset MPU6050 B1\n");
+		result = inv_serial_single_write(
+			mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+			MPUREG_PWR_MGMT_1, BIT_H_RESET);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		mldl_cfg->inv_mpu_state->status &= ~MPU_GYRO_IS_BYPASSED;
+		//msleep(15);
+		msleep(40);
+		//if (pwr_mgmt[0] != pwr_mgmt_prev[0] && !(pwr_mgmt[0] & BIT_SLEEP)) {
+ 		//msleep(5);
+ 	//}
+	}
+
+	/* NOTE : reading both PWR_MGMT_1 and PWR_MGMT_2 for efficiency because
+		  they are accessible even when the device is powered off */
+	result = inv_serial_read(mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+				 MPUREG_PWR_MGMT_1, 2, pwr_mgmt_prev);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	pwr_mgmt[0] = pwr_mgmt_prev[0];
+	pwr_mgmt[1] = pwr_mgmt_prev[1];
+
+	if (sleep) {
+		mldl_cfg->inv_mpu_state->status |= MPU_DEVICE_IS_SUSPENDED;
+		pwr_mgmt[0] |= BIT_SLEEP;
+	} else {
+		mldl_cfg->inv_mpu_state->status &= ~MPU_DEVICE_IS_SUSPENDED;
+		pwr_mgmt[0] &= ~BIT_SLEEP;
+	}
+	if (pwr_mgmt[0] != pwr_mgmt_prev[0]) {
+		result = inv_serial_single_write(
+			mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+			MPUREG_PWR_MGMT_1, pwr_mgmt[0]);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	pwr_mgmt[1] &= ~(BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG);
+	if (!(sensors & INV_X_GYRO))
+		pwr_mgmt[1] |= BIT_STBY_XG;
+	if (!(sensors & INV_Y_GYRO))
+		pwr_mgmt[1] |= BIT_STBY_YG;
+	if (!(sensors & INV_Z_GYRO))
+		pwr_mgmt[1] |= BIT_STBY_ZG;
+
+	if (pwr_mgmt[1] != pwr_mgmt_prev[1]) {
+		result = inv_serial_single_write(
+			mlsl_handle, mldl_cfg->mpu_chip_info->addr,
+			MPUREG_PWR_MGMT_2, pwr_mgmt[1]);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	if ((pwr_mgmt[1] & (BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)) ==
+	    (BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)) {
+		mldl_cfg->inv_mpu_state->status |= MPU_GYRO_IS_SUSPENDED;
+	} else {
+		mldl_cfg->inv_mpu_state->status &= ~MPU_GYRO_IS_SUSPENDED;
+	}
+
+	return INV_SUCCESS;
+}
+
+
+/**
+ *  @brief  sets the clock source for the gyros.
+ *  @param  mldl_cfg
+ *              a pointer to the struct mldl_cfg data structure.
+ *  @param  gyro_handle
+ *              an handle to the serial device the gyro is assigned to.
+ *  @return ML_SUCCESS if successful, a non-zero error code otherwise.
+ */
+static int mpu_set_clock_source(void *gyro_handle, struct mldl_cfg *mldl_cfg)
+{
+	int result;
+	unsigned char cur_clk_src;
+	unsigned char reg;
+
+	/* clock source selection */
+	result = inv_serial_read(gyro_handle, mldl_cfg->mpu_chip_info->addr,
+				 MPUREG_PWR_MGM, 1, &reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	cur_clk_src = reg & BITS_CLKSEL;
+	reg &= ~BITS_CLKSEL;
+
+
+	result = inv_serial_single_write(
+		gyro_handle, mldl_cfg->mpu_chip_info->addr,
+		MPUREG_PWR_MGM, mldl_cfg->mpu_gyro_cfg->clk_src | reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* ERRATA:
+	   workaroud to switch from any MPU_CLK_SEL_PLLGYROx to
+	   MPU_CLK_SEL_INTERNAL and XGyro is powered up:
+	   1) Select INT_OSC
+	   2) PD XGyro
+	   3) PU XGyro
+	 */
+	if ((cur_clk_src == MPU_CLK_SEL_PLLGYROX
+		 || cur_clk_src == MPU_CLK_SEL_PLLGYROY
+		 || cur_clk_src == MPU_CLK_SEL_PLLGYROZ)
+	    && mldl_cfg->mpu_gyro_cfg->clk_src == MPU_CLK_SEL_INTERNAL
+	    && mldl_cfg->inv_mpu_cfg->requested_sensors & INV_X_GYRO) {
+		unsigned char first_result = INV_SUCCESS;
+		mldl_cfg->inv_mpu_cfg->requested_sensors &= ~INV_X_GYRO;
+		result = mpu60xx_pwr_mgmt(
+			mldl_cfg, gyro_handle,
+			false, mldl_cfg->inv_mpu_cfg->requested_sensors);
+		ERROR_CHECK_FIRST(first_result, result);
+		mldl_cfg->inv_mpu_cfg->requested_sensors |= INV_X_GYRO;
+		result = mpu60xx_pwr_mgmt(
+			mldl_cfg, gyro_handle,
+			false, mldl_cfg->inv_mpu_cfg->requested_sensors);
+		ERROR_CHECK_FIRST(first_result, result);
+		result = first_result;
+	}
+	return result;
+}
+
+/**
+ * Configures the MPU I2C Master
+ *
+ * @mldl_cfg Handle to the configuration data
+ * @gyro_handle handle to the gyro communictation interface
+ * @slave Can be Null if turning off the slave
+ * @slave_pdata Can be null if turning off the slave
+ * @slave_id enum ext_slave_type to determine which index to use
+ *
+ *
+ * This fucntion configures the slaves by:
+ * 1) Setting up the read
+ *    a) Read Register
+ *    b) Read Length
+ * 2) Set up the data trigger (MPU6050 only)
+ *    a) Set trigger write register
+ *    b) Set Trigger write value
+ * 3) Set up the divider (MPU6050 only)
+ * 4) Set the slave bypass mode depending on slave
+ *
+ * returns INV_SUCCESS or non-zero error code
+ */
+
+static int mpu_set_slave_mpu60xx(struct mldl_cfg *mldl_cfg,
+				 void *gyro_handle,
+				 struct ext_slave_descr *slave,
+				 struct ext_slave_platform_data *slave_pdata,
+				 int slave_id)
+{
+	int result;
+	unsigned char reg;
+	/* Slave values */
+	unsigned char slave_reg;
+	unsigned char slave_len;
+	unsigned char slave_endian;
+	unsigned char slave_address;
+	/* Which MPU6050 registers to use */
+	unsigned char addr_reg;
+	unsigned char reg_reg;
+	unsigned char ctrl_reg;
+	/* Which MPU6050 registers to use for the trigger */
+	unsigned char addr_trig_reg;
+	unsigned char reg_trig_reg;
+	unsigned char ctrl_trig_reg;
+
+	unsigned char bits_slave_delay = 0;
+	/* Divide down rate for the Slave, from the mpu rate */
+	unsigned char d0_trig_reg;
+	unsigned char delay_ctrl_orig;
+	unsigned char delay_ctrl;
+	long divider;
+
+	if (NULL == slave || NULL == slave_pdata) {
+		slave_reg = 0;
+		slave_len = 0;
+		slave_endian = 0;
+		slave_address = 0;
+	} else {
+		slave_reg = slave->read_reg;
+		slave_len = slave->read_len;
+		slave_endian = slave->endian;
+		slave_address = slave_pdata->address;
+		slave_address |= BIT_I2C_READ;
+	}
+
+	switch (slave_id) {
+	case EXT_SLAVE_TYPE_ACCEL:
+		addr_reg = MPUREG_I2C_SLV1_ADDR;
+		reg_reg  = MPUREG_I2C_SLV1_REG;
+		ctrl_reg = MPUREG_I2C_SLV1_CTRL;
+		addr_trig_reg = 0;
+		reg_trig_reg  = 0;
+		ctrl_trig_reg = 0;
+		bits_slave_delay = BIT_SLV1_DLY_EN;
+		break;
+	case EXT_SLAVE_TYPE_COMPASS:
+		addr_reg = MPUREG_I2C_SLV0_ADDR;
+		reg_reg  = MPUREG_I2C_SLV0_REG;
+		ctrl_reg = MPUREG_I2C_SLV0_CTRL;
+		addr_trig_reg = MPUREG_I2C_SLV2_ADDR;
+		reg_trig_reg  = MPUREG_I2C_SLV2_REG;
+		ctrl_trig_reg = MPUREG_I2C_SLV2_CTRL;
+		d0_trig_reg   = MPUREG_I2C_SLV2_DO;
+		bits_slave_delay = BIT_SLV2_DLY_EN | BIT_SLV0_DLY_EN;
+		break;
+	case EXT_SLAVE_TYPE_PRESSURE:
+		addr_reg = MPUREG_I2C_SLV3_ADDR;
+		reg_reg  = MPUREG_I2C_SLV3_REG;
+		ctrl_reg = MPUREG_I2C_SLV3_CTRL;
+		addr_trig_reg = MPUREG_I2C_SLV4_ADDR;
+		reg_trig_reg  = MPUREG_I2C_SLV4_REG;
+		ctrl_trig_reg = MPUREG_I2C_SLV4_CTRL;
+		bits_slave_delay = BIT_SLV4_DLY_EN | BIT_SLV3_DLY_EN;
+		break;
+	default:
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+		return INV_ERROR_INVALID_PARAMETER;
+	};
+
+	/* return if this slave has already been set */
+	if ((slave_address &&
+	     ((mldl_cfg->inv_mpu_state->i2c_slaves_enabled & bits_slave_delay)
+		    == bits_slave_delay)) ||
+	    (!slave_address &&
+	     (mldl_cfg->inv_mpu_state->i2c_slaves_enabled & bits_slave_delay) ==
+		    0))
+		return 0;
+
+	result = mpu_set_i2c_bypass(mldl_cfg, gyro_handle, true);
+
+	/* Address */
+	result = inv_serial_single_write(gyro_handle,
+					 mldl_cfg->mpu_chip_info->addr,
+					 addr_reg, slave_address);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	/* Register */
+	result = inv_serial_single_write(gyro_handle,
+					 mldl_cfg->mpu_chip_info->addr,
+					 reg_reg, slave_reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Length, byte swapping, grouping & enable */
+	if (slave_len > BITS_SLV_LENG) {
+		MPL_LOGW("Limiting slave burst read length to "
+			 "the allowed maximum (15B, req. %d)\n", slave_len);
+		slave_len = BITS_SLV_LENG;
+		return INV_ERROR_INVALID_CONFIGURATION;
+	}
+	reg = slave_len;
+	if (slave_endian == EXT_SLAVE_LITTLE_ENDIAN) {
+		reg |= BIT_SLV_BYTE_SW;
+		if (slave_reg & 1)
+			reg |= BIT_SLV_GRP;
+	}
+	if (slave_address)
+		reg |= BIT_SLV_ENABLE;
+
+	result = inv_serial_single_write(gyro_handle,
+					 mldl_cfg->mpu_chip_info->addr,
+					 ctrl_reg, reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Trigger */
+	if (addr_trig_reg) {
+		/* If slave address is 0 this clears the trigger */
+		result = inv_serial_single_write(gyro_handle,
+						 mldl_cfg->mpu_chip_info->addr,
+						 addr_trig_reg,
+						 slave_address & ~BIT_I2C_READ);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	if (slave && slave->trigger && reg_trig_reg) {
+		result = inv_serial_single_write(gyro_handle,
+						 mldl_cfg->mpu_chip_info->addr,
+						 reg_trig_reg,
+						 slave->trigger->reg);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		result = inv_serial_single_write(gyro_handle,
+						 mldl_cfg->mpu_chip_info->addr,
+						 ctrl_trig_reg,
+						 BIT_SLV_ENABLE | 0x01);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		result = inv_serial_single_write(gyro_handle,
+						 mldl_cfg->mpu_chip_info->addr,
+						 d0_trig_reg,
+						 slave->trigger->value);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	} else if (ctrl_trig_reg) {
+		result = inv_serial_single_write(gyro_handle,
+						 mldl_cfg->mpu_chip_info->addr,
+						 ctrl_trig_reg, 0x00);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	/* Data rate */
+	if (slave) {
+		struct ext_slave_config config;
+		long data;
+		config.key = MPU_SLAVE_CONFIG_ODR_RESUME;
+		config.len = sizeof(long);
+		config.apply = false;
+		config.data = &data;
+		if (!(slave->get_config))
+			return INV_ERROR_INVALID_CONFIGURATION;
+
+		result = slave->get_config(NULL, slave, slave_pdata, &config);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		MPL_LOGI("Slave %d ODR: %ld Hz\n", slave_id, data / 1000);
+		divider = ((1000 * inv_mpu_get_sampling_rate_hz(
+				    mldl_cfg->mpu_gyro_cfg))
+			/ data) - 1;
+	} else {
+		divider = 0;
+	}
+
+	result = inv_serial_read(gyro_handle,
+				mldl_cfg->mpu_chip_info->addr,
+				MPUREG_I2C_MST_DELAY_CTRL,
+				1, &delay_ctrl_orig);
+	delay_ctrl = delay_ctrl_orig;
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	if (divider > 0 && divider <= MASK_I2C_MST_DLY) {
+		result = inv_serial_read(gyro_handle,
+					 mldl_cfg->mpu_chip_info->addr,
+					 MPUREG_I2C_SLV4_CTRL, 1, &reg);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		if ((reg & MASK_I2C_MST_DLY) &&
+			((long)(reg & MASK_I2C_MST_DLY) !=
+				(divider & MASK_I2C_MST_DLY))) {
+			MPL_LOGW("Changing slave divider: %ld to %ld\n",
+				 (long)(reg & MASK_I2C_MST_DLY),
+				 (divider & MASK_I2C_MST_DLY));
+
+		}
+		reg |= (unsigned char)(divider & MASK_I2C_MST_DLY);
+		result = inv_serial_single_write(gyro_handle,
+						 mldl_cfg->mpu_chip_info->addr,
+						 MPUREG_I2C_SLV4_CTRL,
+						 reg);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+
+		delay_ctrl |= bits_slave_delay;
+	} else {
+		delay_ctrl &= ~(bits_slave_delay);
+	}
+	if (delay_ctrl != delay_ctrl_orig) {
+		result = inv_serial_single_write(
+			gyro_handle, mldl_cfg->mpu_chip_info->addr,
+			MPUREG_I2C_MST_DELAY_CTRL,
+			delay_ctrl);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	if (slave_address)
+		mldl_cfg->inv_mpu_state->i2c_slaves_enabled |=
+			bits_slave_delay;
+	else
+		mldl_cfg->inv_mpu_state->i2c_slaves_enabled &=
+			~bits_slave_delay;
+
+	return result;
+}
+
+static int mpu_set_slave(struct mldl_cfg *mldl_cfg,
+			 void *gyro_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *slave_pdata,
+			 int slave_id)
+{
+	return mpu_set_slave_mpu60xx(mldl_cfg, gyro_handle, slave,
+				     slave_pdata, slave_id);
+}
+/**
+ * Check to see if the gyro was reset by testing a couple of registers known
+ * to change on reset.
+ *
+ * @mldl_cfg mldl configuration structure
+ * @gyro_handle handle used to communicate with the gyro
+ *
+ * @return INV_SUCCESS or non-zero error code
+ */
+static int mpu_was_reset(struct mldl_cfg *mldl_cfg, void *gyro_handle)
+{
+	int result = INV_SUCCESS;
+	unsigned char reg;
+
+	result = inv_serial_read(gyro_handle, mldl_cfg->mpu_chip_info->addr,
+				 MPUREG_DMP_CFG_2, 1, &reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	if (mldl_cfg->mpu_gyro_cfg->dmp_cfg2 != reg)
+		return true;
+
+	if (0 != mldl_cfg->mpu_gyro_cfg->dmp_cfg1)
+		return false;
+
+	/* Inconclusive assume it was reset */
+	return true;
+}
+
+
+int inv_mpu_set_firmware(struct mldl_cfg *mldl_cfg, void *mlsl_handle,
+			 const unsigned char *data, int size)
+{
+	int bank, offset, write_size;
+	int result;
+	unsigned char read[MPU_MEM_BANK_SIZE];
+
+	if (mldl_cfg->inv_mpu_state->status & MPU_DEVICE_IS_SUSPENDED) {
+#if INV_CACHE_DMP == 1
+		memcpy(mldl_cfg->mpu_ram->ram, data, size);
+		return INV_SUCCESS;
+#else
+		LOG_RESULT_LOCATION(INV_ERROR_MEMORY_SET);
+		return INV_ERROR_MEMORY_SET;
+#endif
+	}
+
+	if (!(mldl_cfg->inv_mpu_state->status & MPU_DMP_IS_SUSPENDED)) {
+		LOG_RESULT_LOCATION(INV_ERROR_MEMORY_SET);
+		return INV_ERROR_MEMORY_SET;
+	}
+	/* Write and verify memory */
+	for (bank = 0; size > 0; bank++,
+			size -= write_size,
+			data += write_size) {
+		if (size > MPU_MEM_BANK_SIZE)
+			write_size = MPU_MEM_BANK_SIZE;
+		else
+			write_size = size;
+
+		result = inv_serial_write_mem(mlsl_handle,
+				mldl_cfg->mpu_chip_info->addr,
+				((bank << 8) | 0x00),
+				write_size,
+				data);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			MPL_LOGE("Write mem error in bank %d\n", bank);
+			return result;
+		}
+		result = inv_serial_read_mem(mlsl_handle,
+				mldl_cfg->mpu_chip_info->addr,
+				((bank << 8) | 0x00),
+				write_size,
+				read);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			MPL_LOGE("Read mem error in bank %d\n", bank);
+			return result;
+		}
+
+#define ML_SKIP_CHECK 38
+		for (offset = 0; offset < write_size; offset++) {
+			/* skip the register memory locations */
+			if (bank == 0 && offset < ML_SKIP_CHECK)
+				continue;
+			if (data[offset] != read[offset]) {
+				result = INV_ERROR_SERIAL_WRITE;
+				break;
+			}
+		}
+		if (result != INV_SUCCESS) {
+			LOG_RESULT_LOCATION(result);
+			MPL_LOGE("Read data mismatch at bank %d, offset %d\n",
+				bank, offset);
+			return result;
+		}
+	}
+	return INV_SUCCESS;
+}
+
+static int gyro_resume(struct mldl_cfg *mldl_cfg, void *gyro_handle,
+		       unsigned long sensors)
+{
+	int result;
+	int ii;
+	unsigned char reg;
+	unsigned char regs[7];
+
+	/* Wake up the part */
+	result = mpu60xx_pwr_mgmt(mldl_cfg, gyro_handle, false, sensors);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Always set the INT_ENABLE and DIVIDER as the Accel Only mode for 6050
+	   can set these too */
+	result = inv_serial_single_write(
+		gyro_handle, mldl_cfg->mpu_chip_info->addr,
+		MPUREG_INT_ENABLE, (mldl_cfg->mpu_gyro_cfg->int_config));
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(
+		gyro_handle, mldl_cfg->mpu_chip_info->addr,
+		MPUREG_SMPLRT_DIV, mldl_cfg->mpu_gyro_cfg->divider);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	if (!(mldl_cfg->inv_mpu_state->status & MPU_GYRO_NEEDS_CONFIG) &&
+	    !mpu_was_reset(mldl_cfg, gyro_handle)) {
+		return INV_SUCCESS;
+	}
+
+	/* Configure the MPU */
+	result = mpu_set_i2c_bypass(mldl_cfg, gyro_handle, 1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = mpu_set_clock_source(gyro_handle, mldl_cfg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	reg = MPUREG_GYRO_CONFIG_VALUE(0, 0, 0,
+				       mldl_cfg->mpu_gyro_cfg->full_scale);
+	result = inv_serial_single_write(
+		gyro_handle, mldl_cfg->mpu_chip_info->addr,
+		MPUREG_GYRO_CONFIG, reg);
+	reg = MPUREG_CONFIG_VALUE(mldl_cfg->mpu_gyro_cfg->ext_sync,
+				  mldl_cfg->mpu_gyro_cfg->lpf);
+	result = inv_serial_single_write(
+		gyro_handle, mldl_cfg->mpu_chip_info->addr,
+		MPUREG_CONFIG, reg);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(
+		gyro_handle, mldl_cfg->mpu_chip_info->addr,
+		MPUREG_DMP_CFG_1, mldl_cfg->mpu_gyro_cfg->dmp_cfg1);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(
+		gyro_handle, mldl_cfg->mpu_chip_info->addr,
+		MPUREG_DMP_CFG_2, mldl_cfg->mpu_gyro_cfg->dmp_cfg2);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Write and verify memory */
+#if INV_CACHE_DMP != 0
+	inv_mpu_set_firmware(mldl_cfg, gyro_handle,
+		mldl_cfg->mpu_ram->ram, mldl_cfg->mpu_ram->length);
+#endif
+
+	result = inv_serial_single_write(
+		gyro_handle, mldl_cfg->mpu_chip_info->addr,
+		MPUREG_XG_OFFS_TC,
+		((mldl_cfg->mpu_offsets->tc[0] << 1) & BITS_XG_OFFS_TC));
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	regs[0] = ((mldl_cfg->mpu_offsets->tc[1] << 1) & BITS_YG_OFFS_TC);
+	result = inv_serial_single_write(
+		gyro_handle, mldl_cfg->mpu_chip_info->addr,
+		MPUREG_YG_OFFS_TC, regs[0]);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_single_write(
+		gyro_handle, mldl_cfg->mpu_chip_info->addr,
+		MPUREG_ZG_OFFS_TC,
+		((mldl_cfg->mpu_offsets->tc[2] << 1) & BITS_ZG_OFFS_TC));
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	regs[0] = MPUREG_X_OFFS_USRH;
+	for (ii = 0; ii < ARRAY_SIZE(mldl_cfg->mpu_offsets->gyro); ii++) {
+		regs[1 + ii * 2] =
+			(unsigned char)(mldl_cfg->mpu_offsets->gyro[ii] >> 8)
+			& 0xff;
+		regs[1 + ii * 2 + 1] =
+			(unsigned char)(mldl_cfg->mpu_offsets->gyro[ii] & 0xff);
+	}
+	result = inv_serial_write(gyro_handle, mldl_cfg->mpu_chip_info->addr,
+				  7, regs);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Configure slaves */
+	result = inv_mpu_set_level_shifter_bit(mldl_cfg, gyro_handle,
+					       mldl_cfg->pdata->level_shifter);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	mldl_cfg->inv_mpu_state->status &= ~MPU_GYRO_NEEDS_CONFIG;
+
+	return result;
+}
+
+int gyro_config(void *mlsl_handle,
+		struct mldl_cfg *mldl_cfg,
+		struct ext_slave_config *data)
+{
+	struct mpu_gyro_cfg *mpu_gyro_cfg = mldl_cfg->mpu_gyro_cfg;
+	struct mpu_chip_info *mpu_chip_info = mldl_cfg->mpu_chip_info;
+	struct mpu_offsets *mpu_offsets = mldl_cfg->mpu_offsets;
+	int ii;
+
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_INT_CONFIG:
+		mpu_gyro_cfg->int_config = *((__u8 *)data->data);
+		break;
+	case MPU_SLAVE_EXT_SYNC:
+		mpu_gyro_cfg->ext_sync = *((__u8 *)data->data);
+		break;
+	case MPU_SLAVE_FULL_SCALE:
+		mpu_gyro_cfg->full_scale = *((__u8 *)data->data);
+		break;
+	case MPU_SLAVE_LPF:
+		mpu_gyro_cfg->lpf = *((__u8 *)data->data);
+		break;
+	case MPU_SLAVE_CLK_SRC:
+		mpu_gyro_cfg->clk_src = *((__u8 *)data->data);
+		break;
+	case MPU_SLAVE_DIVIDER:
+		mpu_gyro_cfg->divider = *((__u8 *)data->data);
+		break;
+	case MPU_SLAVE_DMP_ENABLE:
+		mpu_gyro_cfg->dmp_enable = *((__u8 *)data->data);
+		break;
+	case MPU_SLAVE_FIFO_ENABLE:
+		mpu_gyro_cfg->fifo_enable = *((__u8 *)data->data);
+		break;
+	case MPU_SLAVE_DMP_CFG1:
+		mpu_gyro_cfg->dmp_cfg1 = *((__u8 *)data->data);
+		break;
+	case MPU_SLAVE_DMP_CFG2:
+		mpu_gyro_cfg->dmp_cfg2 = *((__u8 *)data->data);
+		break;
+	case MPU_SLAVE_TC:
+		for (ii = 0; ii < GYRO_NUM_AXES; ii++)
+			mpu_offsets->tc[ii] = ((__u8 *)data->data)[ii];
+		break;
+	case MPU_SLAVE_GYRO:
+		for (ii = 0; ii < GYRO_NUM_AXES; ii++)
+			mpu_offsets->gyro[ii] = ((__u16 *)data->data)[ii];
+		break;
+	case MPU_SLAVE_ADDR:
+		mpu_chip_info->addr = *((__u8 *)data->data);
+		break;
+	case MPU_SLAVE_PRODUCT_REVISION:
+		mpu_chip_info->product_revision = *((__u8 *)data->data);
+		break;
+	case MPU_SLAVE_SILICON_REVISION:
+		mpu_chip_info->silicon_revision = *((__u8 *)data->data);
+		break;
+	case MPU_SLAVE_PRODUCT_ID:
+		mpu_chip_info->product_id = *((__u8 *)data->data);
+		break;
+	case MPU_SLAVE_GYRO_SENS_TRIM:
+		mpu_chip_info->gyro_sens_trim = *((__u16 *)data->data);
+		break;
+	case MPU_SLAVE_ACCEL_SENS_TRIM:
+		mpu_chip_info->accel_sens_trim = *((__u16 *)data->data);
+		break;
+	case MPU_SLAVE_RAM:
+		if (data->len != mldl_cfg->mpu_ram->length)
+			return INV_ERROR_INVALID_PARAMETER;
+
+		memcpy(mldl_cfg->mpu_ram->ram, data->data, data->len);
+		break;
+	default:
+		LOG_RESULT_LOCATION(INV_ERROR_FEATURE_NOT_IMPLEMENTED);
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+	mldl_cfg->inv_mpu_state->status |= MPU_GYRO_NEEDS_CONFIG;
+	return INV_SUCCESS;
+}
+
+int gyro_get_config(void *mlsl_handle,
+		struct mldl_cfg *mldl_cfg,
+		struct ext_slave_config *data)
+{
+	struct mpu_gyro_cfg *mpu_gyro_cfg = mldl_cfg->mpu_gyro_cfg;
+	struct mpu_chip_info *mpu_chip_info = mldl_cfg->mpu_chip_info;
+	struct mpu_offsets *mpu_offsets = mldl_cfg->mpu_offsets;
+	int ii;
+
+	if (!data->data)
+		return INV_ERROR_INVALID_PARAMETER;
+
+	switch (data->key) {
+	case MPU_SLAVE_INT_CONFIG:
+		*((__u8 *)data->data) = mpu_gyro_cfg->int_config;
+		break;
+	case MPU_SLAVE_EXT_SYNC:
+		*((__u8 *)data->data) = mpu_gyro_cfg->ext_sync;
+		break;
+	case MPU_SLAVE_FULL_SCALE:
+		*((__u8 *)data->data) = mpu_gyro_cfg->full_scale;
+		break;
+	case MPU_SLAVE_LPF:
+		*((__u8 *)data->data) = mpu_gyro_cfg->lpf;
+		break;
+	case MPU_SLAVE_CLK_SRC:
+		*((__u8 *)data->data) = mpu_gyro_cfg->clk_src;
+		break;
+	case MPU_SLAVE_DIVIDER:
+		*((__u8 *)data->data) = mpu_gyro_cfg->divider;
+		break;
+	case MPU_SLAVE_DMP_ENABLE:
+		*((__u8 *)data->data) = mpu_gyro_cfg->dmp_enable;
+		break;
+	case MPU_SLAVE_FIFO_ENABLE:
+		*((__u8 *)data->data) = mpu_gyro_cfg->fifo_enable;
+		break;
+	case MPU_SLAVE_DMP_CFG1:
+		*((__u8 *)data->data) = mpu_gyro_cfg->dmp_cfg1;
+		break;
+	case MPU_SLAVE_DMP_CFG2:
+		*((__u8 *)data->data) = mpu_gyro_cfg->dmp_cfg2;
+		break;
+	case MPU_SLAVE_TC:
+		for (ii = 0; ii < GYRO_NUM_AXES; ii++)
+			((__u8 *)data->data)[ii] = mpu_offsets->tc[ii];
+		break;
+	case MPU_SLAVE_GYRO:
+		for (ii = 0; ii < GYRO_NUM_AXES; ii++)
+			((__u16 *)data->data)[ii] = mpu_offsets->gyro[ii];
+		break;
+	case MPU_SLAVE_ADDR:
+		*((__u8 *)data->data) = mpu_chip_info->addr;
+		break;
+	case MPU_SLAVE_PRODUCT_REVISION:
+		*((__u8 *)data->data) = mpu_chip_info->product_revision;
+		break;
+	case MPU_SLAVE_SILICON_REVISION:
+		*((__u8 *)data->data) = mpu_chip_info->silicon_revision;
+		break;
+	case MPU_SLAVE_PRODUCT_ID:
+		*((__u8 *)data->data) = mpu_chip_info->product_id;
+		break;
+	case MPU_SLAVE_GYRO_SENS_TRIM:
+		*((__u16 *)data->data) = mpu_chip_info->gyro_sens_trim;
+		break;
+	case MPU_SLAVE_ACCEL_SENS_TRIM:
+		*((__u16 *)data->data) = mpu_chip_info->accel_sens_trim;
+		break;
+	case MPU_SLAVE_RAM:
+		if (data->len != mldl_cfg->mpu_ram->length)
+			return INV_ERROR_INVALID_PARAMETER;
+
+		memcpy(data->data, mldl_cfg->mpu_ram->ram, data->len);
+		break;
+	default:
+		LOG_RESULT_LOCATION(INV_ERROR_FEATURE_NOT_IMPLEMENTED);
+		return INV_ERROR_FEATURE_NOT_IMPLEMENTED;
+	};
+
+	return INV_SUCCESS;
+}
+
+
+/*******************************************************************************
+ *******************************************************************************
+ * Exported functions
+ *******************************************************************************
+ ******************************************************************************/
+
+/**
+ * Initializes the pdata structure to defaults.
+ *
+ * Opens the device to read silicon revision, product id and whoami.
+ *
+ * @mldl_cfg
+ *          The internal device configuration data structure.
+ * @mlsl_handle
+ *          The serial communication handle.
+ *
+ * @return INV_SUCCESS if silicon revision, product id and woami are supported
+ *         by this software.
+ */
+int inv_mpu_open(struct mldl_cfg *mldl_cfg,
+		 void *gyro_handle,
+		 void *accel_handle,
+		 void *compass_handle, void *pressure_handle)
+{
+	int result;
+	void *slave_handle[EXT_SLAVE_NUM_TYPES];
+	int ii;
+
+	/* Default is Logic HIGH, pushpull, latch disabled, anyread to clear */
+	ii = 0;
+	mldl_cfg->inv_mpu_cfg->ignore_system_suspend = false;
+	mldl_cfg->mpu_gyro_cfg->int_config = BIT_DMP_INT_EN;
+	mldl_cfg->mpu_gyro_cfg->clk_src = MPU_CLK_SEL_PLLGYROZ;
+	mldl_cfg->mpu_gyro_cfg->lpf = MPU_FILTER_42HZ;
+	mldl_cfg->mpu_gyro_cfg->full_scale = MPU_FS_2000DPS;
+	mldl_cfg->mpu_gyro_cfg->divider = 4;
+	mldl_cfg->mpu_gyro_cfg->dmp_enable = 1;
+	mldl_cfg->mpu_gyro_cfg->fifo_enable = 1;
+	mldl_cfg->mpu_gyro_cfg->ext_sync = 0;
+	mldl_cfg->mpu_gyro_cfg->dmp_cfg1 = 0;
+	mldl_cfg->mpu_gyro_cfg->dmp_cfg2 = 0;
+	mldl_cfg->inv_mpu_state->status =
+		MPU_DMP_IS_SUSPENDED |
+		MPU_GYRO_IS_SUSPENDED |
+		MPU_ACCEL_IS_SUSPENDED |
+		MPU_COMPASS_IS_SUSPENDED |
+		MPU_PRESSURE_IS_SUSPENDED |
+		MPU_DEVICE_IS_SUSPENDED;
+	mldl_cfg->inv_mpu_state->i2c_slaves_enabled = 0;
+
+	slave_handle[EXT_SLAVE_TYPE_GYROSCOPE] = gyro_handle;
+	slave_handle[EXT_SLAVE_TYPE_ACCEL] = accel_handle;
+	slave_handle[EXT_SLAVE_TYPE_COMPASS] = compass_handle;
+	slave_handle[EXT_SLAVE_TYPE_PRESSURE] = pressure_handle;
+
+	if (mldl_cfg->mpu_chip_info->addr == 0) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+
+	/*
+	 * Reset,
+	 * Take the DMP out of sleep, and
+	 * read the product_id, sillicon rev and whoami
+	 */
+	mldl_cfg->inv_mpu_state->status &= ~MPU_GYRO_IS_BYPASSED;
+	result = mpu60xx_pwr_mgmt(mldl_cfg, gyro_handle, true,
+				  INV_THREE_AXIS_GYRO);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	result = inv_get_silicon_rev(mldl_cfg, gyro_handle);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Get the factory temperature compensation offsets */
+	result = inv_serial_read(gyro_handle, mldl_cfg->mpu_chip_info->addr,
+				 MPUREG_XG_OFFS_TC, 1,
+				 &mldl_cfg->mpu_offsets->tc[0]);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_read(gyro_handle, mldl_cfg->mpu_chip_info->addr,
+				 MPUREG_YG_OFFS_TC, 1,
+				 &mldl_cfg->mpu_offsets->tc[1]);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_serial_read(gyro_handle, mldl_cfg->mpu_chip_info->addr,
+				 MPUREG_ZG_OFFS_TC, 1,
+				 &mldl_cfg->mpu_offsets->tc[2]);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* Into bypass mode before sleeping and calling the slaves init */
+	result = mpu_set_i2c_bypass(mldl_cfg, gyro_handle, true);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	result = inv_mpu_set_level_shifter_bit(mldl_cfg, gyro_handle,
+			mldl_cfg->pdata->level_shifter);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	for (ii = 0; ii < GYRO_NUM_AXES; ii++) {
+		mldl_cfg->mpu_offsets->tc[ii] =
+		    (mldl_cfg->mpu_offsets->tc[ii] & BITS_XG_OFFS_TC) >> 1;
+	}
+
+#if INV_CACHE_DMP != 0
+	result = mpu60xx_pwr_mgmt(mldl_cfg, gyro_handle, false, 0);
+#endif
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+
+	return result;
+
+}
+
+/**
+ * Close the mpu interface
+ *
+ * @mldl_cfg pointer to the configuration structure
+ * @mlsl_handle pointer to the serial layer handle
+ *
+ * @return INV_SUCCESS or non-zero error code
+ */
+int inv_mpu_close(struct mldl_cfg *mldl_cfg,
+		  void *gyro_handle,
+		  void *accel_handle,
+		  void *compass_handle,
+		  void *pressure_handle)
+{
+	return 0;
+}
+
+/**
+ *  @brief  resume the MPU device and all the other sensor
+ *          devices from their low power state.
+ *
+ *  @mldl_cfg
+ *              pointer to the configuration structure
+ *  @gyro_handle
+ *              the main file handle to the MPU device.
+ *  @accel_handle
+ *              an handle to the accelerometer device, if sitting
+ *              onto a separate bus. Can match mlsl_handle if
+ *              the accelerometer device operates on the same
+ *              primary bus of MPU.
+ *  @compass_handle
+ *              an handle to the compass device, if sitting
+ *              onto a separate bus. Can match mlsl_handle if
+ *              the compass device operates on the same
+ *              primary bus of MPU.
+ *  @pressure_handle
+ *              an handle to the pressure sensor device, if sitting
+ *              onto a separate bus. Can match mlsl_handle if
+ *              the pressure sensor device operates on the same
+ *              primary bus of MPU.
+ *  @resume_gyro
+ *              whether resuming the gyroscope device is
+ *              actually needed (if the device supports low power
+ *              mode of some sort).
+ *  @resume_accel
+ *              whether resuming the accelerometer device is
+ *              actually needed (if the device supports low power
+ *              mode of some sort).
+ *  @resume_compass
+ *              whether resuming the compass device is
+ *              actually needed (if the device supports low power
+ *              mode of some sort).
+ *  @resume_pressure
+ *              whether resuming the pressure sensor device is
+ *              actually needed (if the device supports low power
+ *              mode of some sort).
+ *  @return  INV_SUCCESS or a non-zero error code.
+ */
+int inv_mpu_resume(struct mldl_cfg *mldl_cfg,
+		   void *gyro_handle,
+		   void *accel_handle,
+		   void *compass_handle,
+		   void *pressure_handle,
+		   unsigned long sensors)
+{
+	int result = INV_SUCCESS;
+	int ii;
+	bool resume_slave[EXT_SLAVE_NUM_TYPES];
+	bool resume_dmp = sensors & INV_DMP_PROCESSOR;
+	void *slave_handle[EXT_SLAVE_NUM_TYPES];
+	resume_slave[EXT_SLAVE_TYPE_GYROSCOPE] =
+		(sensors & (INV_X_GYRO | INV_Y_GYRO | INV_Z_GYRO));
+	resume_slave[EXT_SLAVE_TYPE_ACCEL] =
+		sensors & INV_THREE_AXIS_ACCEL;
+	resume_slave[EXT_SLAVE_TYPE_COMPASS] =
+		sensors & INV_THREE_AXIS_COMPASS;
+	resume_slave[EXT_SLAVE_TYPE_PRESSURE] =
+		sensors & INV_THREE_AXIS_PRESSURE;
+
+	slave_handle[EXT_SLAVE_TYPE_GYROSCOPE] = gyro_handle;
+	slave_handle[EXT_SLAVE_TYPE_ACCEL] = accel_handle;
+	slave_handle[EXT_SLAVE_TYPE_COMPASS] = compass_handle;
+	slave_handle[EXT_SLAVE_TYPE_PRESSURE] = pressure_handle;
+
+
+	mldl_print_cfg(mldl_cfg);
+
+	/* Skip the Gyro since slave[EXT_SLAVE_TYPE_GYROSCOPE] is NULL */
+	for (ii = EXT_SLAVE_TYPE_ACCEL; ii < EXT_SLAVE_NUM_TYPES; ii++) {
+		if (resume_slave[ii] &&
+		    ((!mldl_cfg->slave[ii]) ||
+			(!mldl_cfg->slave[ii]->resume))) {
+			LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+			return INV_ERROR_INVALID_PARAMETER;
+		}
+	}
+
+	if ((resume_slave[EXT_SLAVE_TYPE_GYROSCOPE] || resume_dmp)
+	    && ((mldl_cfg->inv_mpu_state->status & MPU_GYRO_IS_SUSPENDED) ||
+		(mldl_cfg->inv_mpu_state->status & MPU_GYRO_NEEDS_CONFIG))) {
+		result = mpu_set_i2c_bypass(mldl_cfg, gyro_handle, 1);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		result = dmp_stop(mldl_cfg, gyro_handle);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		result = gyro_resume(mldl_cfg, gyro_handle, sensors);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	for (ii = 0; ii < EXT_SLAVE_NUM_TYPES; ii++) {
+		if (!mldl_cfg->slave[ii] ||
+		    !mldl_cfg->pdata_slave[ii] ||
+		    !resume_slave[ii] ||
+		    !(mldl_cfg->inv_mpu_state->status & (1 << ii)))
+			continue;
+
+		if (EXT_SLAVE_BUS_SECONDARY ==
+		    mldl_cfg->pdata_slave[ii]->bus) {
+			result = mpu_set_i2c_bypass(mldl_cfg, gyro_handle,
+						    true);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+		}
+		result = mldl_cfg->slave[ii]->resume(slave_handle[ii],
+						mldl_cfg->slave[ii],
+						mldl_cfg->pdata_slave[ii]);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		mldl_cfg->inv_mpu_state->status &= ~(1 << ii);
+	}
+
+	for (ii = 0; ii < EXT_SLAVE_NUM_TYPES; ii++) {
+		if (resume_dmp &&
+		    !(mldl_cfg->inv_mpu_state->status & (1 << ii)) &&
+		    mldl_cfg->pdata_slave[ii] &&
+		    EXT_SLAVE_BUS_SECONDARY == mldl_cfg->pdata_slave[ii]->bus) {
+			result = mpu_set_slave(mldl_cfg,
+					gyro_handle,
+					mldl_cfg->slave[ii],
+					mldl_cfg->pdata_slave[ii],
+					mldl_cfg->slave[ii]->type);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+		}
+	}
+
+	/* Turn on the master i2c iterface if necessary */
+	if (resume_dmp) {
+		result = mpu_set_i2c_bypass(
+			mldl_cfg, gyro_handle,
+			!(mldl_cfg->inv_mpu_state->i2c_slaves_enabled));
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+
+		/* Now start */
+		result = dmp_start(mldl_cfg, gyro_handle);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+	mldl_cfg->inv_mpu_cfg->requested_sensors = sensors;
+
+	return result;
+}
+
+/**
+ *  @brief  suspend the MPU device and all the other sensor
+ *          devices into their low power state.
+ *  @mldl_cfg
+ *              a pointer to the struct mldl_cfg internal data
+ *              structure.
+ *  @gyro_handle
+ *              the main file handle to the MPU device.
+ *  @accel_handle
+ *              an handle to the accelerometer device, if sitting
+ *              onto a separate bus. Can match gyro_handle if
+ *              the accelerometer device operates on the same
+ *              primary bus of MPU.
+ *  @compass_handle
+ *              an handle to the compass device, if sitting
+ *              onto a separate bus. Can match gyro_handle if
+ *              the compass device operates on the same
+ *              primary bus of MPU.
+ *  @pressure_handle
+ *              an handle to the pressure sensor device, if sitting
+ *              onto a separate bus. Can match gyro_handle if
+ *              the pressure sensor device operates on the same
+ *              primary bus of MPU.
+ *  @accel
+ *              whether suspending the accelerometer device is
+ *              actually needed (if the device supports low power
+ *              mode of some sort).
+ *  @compass
+ *              whether suspending the compass device is
+ *              actually needed (if the device supports low power
+ *              mode of some sort).
+ *  @pressure
+ *              whether suspending the pressure sensor device is
+ *              actually needed (if the device supports low power
+ *              mode of some sort).
+ *  @return  INV_SUCCESS or a non-zero error code.
+ */
+int inv_mpu_suspend(struct mldl_cfg *mldl_cfg,
+		    void *gyro_handle,
+		    void *accel_handle,
+		    void *compass_handle,
+		    void *pressure_handle,
+		    unsigned long sensors)
+{
+	int result = INV_SUCCESS;
+	int ii;
+	struct ext_slave_descr **slave = mldl_cfg->slave;
+	struct ext_slave_platform_data **pdata_slave = mldl_cfg->pdata_slave;
+	bool suspend_dmp = ((sensors & INV_DMP_PROCESSOR) == INV_DMP_PROCESSOR);
+	bool suspend_slave[EXT_SLAVE_NUM_TYPES];
+	void *slave_handle[EXT_SLAVE_NUM_TYPES];
+
+	suspend_slave[EXT_SLAVE_TYPE_GYROSCOPE] =
+		((sensors & (INV_X_GYRO | INV_Y_GYRO | INV_Z_GYRO))
+			== (INV_X_GYRO | INV_Y_GYRO | INV_Z_GYRO));
+	suspend_slave[EXT_SLAVE_TYPE_ACCEL] =
+		((sensors & INV_THREE_AXIS_ACCEL) == INV_THREE_AXIS_ACCEL);
+	suspend_slave[EXT_SLAVE_TYPE_COMPASS] =
+		((sensors & INV_THREE_AXIS_COMPASS) == INV_THREE_AXIS_COMPASS);
+	suspend_slave[EXT_SLAVE_TYPE_PRESSURE] =
+		((sensors & INV_THREE_AXIS_PRESSURE) ==
+			INV_THREE_AXIS_PRESSURE);
+
+	slave_handle[EXT_SLAVE_TYPE_GYROSCOPE] = gyro_handle;
+	slave_handle[EXT_SLAVE_TYPE_ACCEL] = accel_handle;
+	slave_handle[EXT_SLAVE_TYPE_COMPASS] = compass_handle;
+	slave_handle[EXT_SLAVE_TYPE_PRESSURE] = pressure_handle;
+
+	if (suspend_dmp) {
+		result = mpu_set_i2c_bypass(mldl_cfg, gyro_handle, 1);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		result = dmp_stop(mldl_cfg, gyro_handle);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	/* Gyro */
+	if (suspend_slave[EXT_SLAVE_TYPE_GYROSCOPE] &&
+	    !(mldl_cfg->inv_mpu_state->status & MPU_GYRO_IS_SUSPENDED)) {
+		result = mpu60xx_pwr_mgmt(mldl_cfg, gyro_handle, false,
+					((~sensors) & INV_ALL_SENSORS));
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	for (ii = 0; ii < EXT_SLAVE_NUM_TYPES; ii++) {
+		bool is_suspended = mldl_cfg->inv_mpu_state->status & (1 << ii);
+		if (!slave[ii]   || !pdata_slave[ii] ||
+		    is_suspended || !suspend_slave[ii])
+			continue;
+
+		if (EXT_SLAVE_BUS_SECONDARY == pdata_slave[ii]->bus) {
+			result = mpu_set_i2c_bypass(mldl_cfg, gyro_handle, 1);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+		}
+		result = slave[ii]->suspend(slave_handle[ii],
+						  slave[ii],
+						  pdata_slave[ii]);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		if (EXT_SLAVE_BUS_SECONDARY == pdata_slave[ii]->bus) {
+			result = mpu_set_slave(mldl_cfg, gyro_handle,
+					       NULL, NULL,
+					       slave[ii]->type);
+			if (result) {
+				LOG_RESULT_LOCATION(result);
+				return result;
+			}
+		}
+		mldl_cfg->inv_mpu_state->status |= (1 << ii);
+	}
+
+	/* Re-enable the i2c master if there are configured slaves and DMP */
+	if (!suspend_dmp) {
+		result = mpu_set_i2c_bypass(
+			mldl_cfg, gyro_handle,
+			!(mldl_cfg->inv_mpu_state->i2c_slaves_enabled));
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+	mldl_cfg->inv_mpu_cfg->requested_sensors = (~sensors) & INV_ALL_SENSORS;
+
+	return result;
+}
+
+int inv_mpu_slave_read(struct mldl_cfg *mldl_cfg,
+		       void *gyro_handle,
+		       void *slave_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata,
+		       unsigned char *data)
+{
+	int result;
+	int bypass_result;
+	int remain_bypassed = true;
+
+	if (NULL == slave || NULL == slave->read) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_CONFIGURATION);
+		return INV_ERROR_INVALID_CONFIGURATION;
+	}
+
+	if ((EXT_SLAVE_BUS_SECONDARY == pdata->bus)
+	    && (!(mldl_cfg->inv_mpu_state->status & MPU_GYRO_IS_BYPASSED))) {
+		remain_bypassed = false;
+		result = mpu_set_i2c_bypass(mldl_cfg, gyro_handle, 1);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	result = slave->read(slave_handle, slave, pdata, data);
+
+	if (!remain_bypassed) {
+		bypass_result = mpu_set_i2c_bypass(mldl_cfg, gyro_handle, 0);
+		if (bypass_result) {
+			LOG_RESULT_LOCATION(bypass_result);
+			return bypass_result;
+		}
+	}
+	return result;
+}
+
+int inv_mpu_slave_config(struct mldl_cfg *mldl_cfg,
+			 void *gyro_handle,
+			 void *slave_handle,
+			 struct ext_slave_config *data,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata)
+{
+	int result;
+	int remain_bypassed = true;
+
+	if (NULL == slave || NULL == slave->config) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_CONFIGURATION);
+		return INV_ERROR_INVALID_CONFIGURATION;
+	}
+
+	if (data->apply && (EXT_SLAVE_BUS_SECONDARY == pdata->bus)
+	    && (!(mldl_cfg->inv_mpu_state->status & MPU_GYRO_IS_BYPASSED))) {
+		remain_bypassed = false;
+		result = mpu_set_i2c_bypass(mldl_cfg, gyro_handle, 1);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	result = slave->config(slave_handle, slave, pdata, data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	if (!remain_bypassed) {
+		result = mpu_set_i2c_bypass(mldl_cfg, gyro_handle, 0);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+	return result;
+}
+
+int inv_mpu_get_slave_config(struct mldl_cfg *mldl_cfg,
+			     void *gyro_handle,
+			     void *slave_handle,
+			     struct ext_slave_config *data,
+			     struct ext_slave_descr *slave,
+			     struct ext_slave_platform_data *pdata)
+{
+	int result;
+	int remain_bypassed = true;
+
+	if (NULL == slave || NULL == slave->get_config) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_CONFIGURATION);
+		return INV_ERROR_INVALID_CONFIGURATION;
+	}
+
+	if (data->apply && (EXT_SLAVE_BUS_SECONDARY == pdata->bus)
+	    && (!(mldl_cfg->inv_mpu_state->status & MPU_GYRO_IS_BYPASSED))) {
+		remain_bypassed = false;
+		result = mpu_set_i2c_bypass(mldl_cfg, gyro_handle, 1);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+
+	result = slave->get_config(slave_handle, slave, pdata, data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	if (!remain_bypassed) {
+		result = mpu_set_i2c_bypass(mldl_cfg, gyro_handle, 0);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+	}
+	return result;
+}
+
+/**
+ * @}
+ */
diff --git a/drivers/misc/inv_mpu/mldl_cfg.h b/drivers/misc/inv_mpu/mldl_cfg.h
new file mode 100644
index 0000000..a12fcc5
--- /dev/null
+++ b/drivers/misc/inv_mpu/mldl_cfg.h
@@ -0,0 +1,380 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup MLDL
+ *
+ *  @{
+ *      @file   mldl_cfg.h
+ *      @brief  The Motion Library Driver Layer Configuration header file.
+ */
+
+#ifndef __MLDL_CFG_H__
+#define __MLDL_CFG_H__
+
+#include "mltypes.h"
+#include "mlsl.h"
+#include <linux/mpu.h>
+#include "mpu6050b1.h"
+
+#include "log.h"
+
+/*************************************************************************
+ *  Sensors Bit definitions
+ *************************************************************************/
+
+#define INV_X_GYRO			(0x0001)
+#define INV_Y_GYRO			(0x0002)
+#define INV_Z_GYRO			(0x0004)
+#define INV_DMP_PROCESSOR		(0x0008)
+
+#define INV_X_ACCEL			(0x0010)
+#define INV_Y_ACCEL			(0x0020)
+#define INV_Z_ACCEL			(0x0040)
+
+#define INV_X_COMPASS			(0x0080)
+#define INV_Y_COMPASS			(0x0100)
+#define INV_Z_COMPASS			(0x0200)
+
+#define INV_X_PRESSURE			(0x0300)
+#define INV_Y_PRESSURE			(0x0800)
+#define INV_Z_PRESSURE			(0x1000)
+
+#define INV_TEMPERATURE			(0x2000)
+#define INV_TIME			(0x4000)
+
+#define INV_THREE_AXIS_GYRO		(0x000F)
+#define INV_THREE_AXIS_ACCEL		(0x0070)
+#define INV_THREE_AXIS_COMPASS		(0x0380)
+#define INV_THREE_AXIS_PRESSURE		(0x1C00)
+
+#define INV_FIVE_AXIS			(0x007B)
+#define INV_SIX_AXIS_GYRO_ACCEL		(0x007F)
+#define INV_SIX_AXIS_ACCEL_COMPASS	(0x03F0)
+#define INV_NINE_AXIS			(0x03FF)
+#define INV_ALL_SENSORS			(0x7FFF)
+
+#define MPL_PROD_KEY(ver, rev) (ver * 100 + rev)
+
+/* -------------------------------------------------------------------------- */
+struct mpu_ram {
+	__u16 length;
+	__u8 *ram;
+};
+
+struct mpu_gyro_cfg {
+	__u8 int_config;
+	__u8 ext_sync;
+	__u8 full_scale;
+	__u8 lpf;
+	__u8 clk_src;
+	__u8 divider;
+	__u8 dmp_enable;
+	__u8 fifo_enable;
+	__u8 dmp_cfg1;
+	__u8 dmp_cfg2;
+};
+
+/* Offset registers that can be calibrated */
+struct mpu_offsets {
+	__u8	tc[GYRO_NUM_AXES];
+	__u16	gyro[GYRO_NUM_AXES];
+};
+
+/* Chip related information that can be read and verified */
+struct mpu_chip_info {
+	__u8 addr;
+	__u8 product_revision;
+	__u8 silicon_revision;
+	__u8 product_id;
+	__u16 gyro_sens_trim;
+	/* Only used for MPU6050 */
+	__u16 accel_sens_trim;
+};
+
+
+struct inv_mpu_cfg {
+	__u32 requested_sensors;
+	__u8 ignore_system_suspend;
+};
+
+/* Driver related state information */
+struct inv_mpu_state {
+#define MPU_GYRO_IS_SUSPENDED		(0x01 << EXT_SLAVE_TYPE_GYROSCOPE)
+#define MPU_ACCEL_IS_SUSPENDED		(0x01 << EXT_SLAVE_TYPE_ACCEL)
+#define MPU_COMPASS_IS_SUSPENDED	(0x01 << EXT_SLAVE_TYPE_COMPASS)
+#define MPU_PRESSURE_IS_SUSPENDED	(0x01 << EXT_SLAVE_TYPE_PRESSURE)
+#define MPU_GYRO_IS_BYPASSED		(0x10)
+#define MPU_DMP_IS_SUSPENDED		(0x20)
+#define MPU_GYRO_NEEDS_CONFIG		(0x40)
+#define MPU_DEVICE_IS_SUSPENDED		(0x80)
+	__u8 status;
+	/* 0-1 for 3050, bitfield of BIT_SLVx_DLY_EN, x = [0..4] */
+	__u8 i2c_slaves_enabled;
+};
+
+/* Platform data for the MPU */
+struct mldl_cfg {
+	struct mpu_ram			*mpu_ram;
+	struct mpu_gyro_cfg		*mpu_gyro_cfg;
+	struct mpu_offsets		*mpu_offsets;
+	struct mpu_chip_info		*mpu_chip_info;
+
+	/* MPU Related stored status and info */
+	struct inv_mpu_cfg		*inv_mpu_cfg;
+	struct inv_mpu_state		*inv_mpu_state;
+
+	/* Slave related information */
+	struct ext_slave_descr		*slave[EXT_SLAVE_NUM_TYPES];
+	/* Platform Data */
+	struct mpu_platform_data	*pdata;
+	struct ext_slave_platform_data	*pdata_slave[EXT_SLAVE_NUM_TYPES];
+};
+
+/* -------------------------------------------------------------------------- */
+
+int inv_mpu_open(struct mldl_cfg *mldl_cfg,
+		 void *mlsl_handle,
+		 void *accel_handle,
+		 void *compass_handle,
+		 void *pressure_handle);
+int inv_mpu_close(struct mldl_cfg *mldl_cfg,
+		  void *mlsl_handle,
+		  void *accel_handle,
+		  void *compass_handle,
+		  void *pressure_handle);
+int inv_mpu_resume(struct mldl_cfg *mldl_cfg,
+		   void *gyro_handle,
+		   void *accel_handle,
+		   void *compass_handle,
+		   void *pressure_handle,
+		   unsigned long sensors);
+int inv_mpu_suspend(struct mldl_cfg *mldl_cfg,
+		    void *gyro_handle,
+		    void *accel_handle,
+		    void *compass_handle,
+		    void *pressure_handle,
+		    unsigned long sensors);
+int inv_mpu_set_firmware(struct mldl_cfg *mldl_cfg,
+			 void *mlsl_handle,
+			 const unsigned char *data,
+			 int size);
+
+/* -------------------------------------------------------------------------- */
+/* Slave Read functions */
+int inv_mpu_slave_read(struct mldl_cfg *mldl_cfg,
+		       void *gyro_handle,
+		       void *slave_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata,
+		       unsigned char *data);
+static inline int inv_mpu_read_accel(struct mldl_cfg *mldl_cfg,
+				     void *gyro_handle,
+				     void *accel_handle, unsigned char *data)
+{
+	if (!mldl_cfg) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+
+	return inv_mpu_slave_read(
+		mldl_cfg, gyro_handle, accel_handle,
+		mldl_cfg->slave[EXT_SLAVE_TYPE_ACCEL],
+		mldl_cfg->pdata_slave[EXT_SLAVE_TYPE_ACCEL],
+		data);
+}
+
+static inline int inv_mpu_read_compass(struct mldl_cfg *mldl_cfg,
+				       void *gyro_handle,
+				       void *compass_handle,
+				       unsigned char *data)
+{
+	if (!mldl_cfg) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+
+	return inv_mpu_slave_read(
+		mldl_cfg, gyro_handle, compass_handle,
+		mldl_cfg->slave[EXT_SLAVE_TYPE_COMPASS],
+		mldl_cfg->pdata_slave[EXT_SLAVE_TYPE_COMPASS],
+		data);
+}
+
+static inline int inv_mpu_read_pressure(struct mldl_cfg *mldl_cfg,
+					void *gyro_handle,
+					void *pressure_handle,
+					unsigned char *data)
+{
+	if (!mldl_cfg) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+
+	return inv_mpu_slave_read(
+		mldl_cfg, gyro_handle, pressure_handle,
+		mldl_cfg->slave[EXT_SLAVE_TYPE_PRESSURE],
+		mldl_cfg->pdata_slave[EXT_SLAVE_TYPE_PRESSURE],
+		data);
+}
+
+int gyro_config(void *mlsl_handle,
+		struct mldl_cfg *mldl_cfg,
+		struct ext_slave_config *data);
+
+/* Slave Config functions */
+int inv_mpu_slave_config(struct mldl_cfg *mldl_cfg,
+			 void *gyro_handle,
+			 void *slave_handle,
+			 struct ext_slave_config *data,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata);
+static inline int inv_mpu_config_accel(struct mldl_cfg *mldl_cfg,
+				       void *gyro_handle,
+				       void *accel_handle,
+				       struct ext_slave_config *data)
+{
+	if (!mldl_cfg) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+
+	return inv_mpu_slave_config(
+		mldl_cfg, gyro_handle, accel_handle, data,
+		mldl_cfg->slave[EXT_SLAVE_TYPE_ACCEL],
+		mldl_cfg->pdata_slave[EXT_SLAVE_TYPE_ACCEL]);
+}
+
+static inline int inv_mpu_config_compass(struct mldl_cfg *mldl_cfg,
+					 void *gyro_handle,
+					 void *compass_handle,
+					 struct ext_slave_config *data)
+{
+	if (!mldl_cfg) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+
+	return inv_mpu_slave_config(
+		mldl_cfg, gyro_handle, compass_handle, data,
+		mldl_cfg->slave[EXT_SLAVE_TYPE_COMPASS],
+		mldl_cfg->pdata_slave[EXT_SLAVE_TYPE_COMPASS]);
+}
+
+static inline int inv_mpu_config_pressure(struct mldl_cfg *mldl_cfg,
+					  void *gyro_handle,
+					  void *pressure_handle,
+					  struct ext_slave_config *data)
+{
+	if (!mldl_cfg) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+
+	return inv_mpu_slave_config(
+		mldl_cfg, gyro_handle, pressure_handle, data,
+		mldl_cfg->slave[EXT_SLAVE_TYPE_PRESSURE],
+		mldl_cfg->pdata_slave[EXT_SLAVE_TYPE_PRESSURE]);
+}
+
+int gyro_get_config(void *mlsl_handle,
+		struct mldl_cfg *mldl_cfg,
+		struct ext_slave_config *data);
+
+/* Slave get config functions */
+int inv_mpu_get_slave_config(struct mldl_cfg *mldl_cfg,
+			     void *gyro_handle,
+			     void *slave_handle,
+			     struct ext_slave_config *data,
+			     struct ext_slave_descr *slave,
+			     struct ext_slave_platform_data *pdata);
+
+static inline int inv_mpu_get_accel_config(struct mldl_cfg *mldl_cfg,
+					   void *gyro_handle,
+					   void *accel_handle,
+					   struct ext_slave_config *data)
+{
+	if (!mldl_cfg) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+
+	return inv_mpu_get_slave_config(
+		mldl_cfg, gyro_handle, accel_handle, data,
+		mldl_cfg->slave[EXT_SLAVE_TYPE_ACCEL],
+		mldl_cfg->pdata_slave[EXT_SLAVE_TYPE_ACCEL]);
+}
+
+static inline int inv_mpu_get_compass_config(struct mldl_cfg *mldl_cfg,
+					     void *gyro_handle,
+					     void *compass_handle,
+					     struct ext_slave_config *data)
+{
+	if (!mldl_cfg || !(mldl_cfg->pdata)) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+
+	return inv_mpu_get_slave_config(
+		mldl_cfg, gyro_handle, compass_handle, data,
+		mldl_cfg->slave[EXT_SLAVE_TYPE_COMPASS],
+		mldl_cfg->pdata_slave[EXT_SLAVE_TYPE_COMPASS]);
+}
+
+static inline int inv_mpu_get_pressure_config(struct mldl_cfg *mldl_cfg,
+					      void *gyro_handle,
+					      void *pressure_handle,
+					      struct ext_slave_config *data)
+{
+	if (!mldl_cfg || !(mldl_cfg->pdata)) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+
+	return inv_mpu_get_slave_config(
+		mldl_cfg, gyro_handle, pressure_handle, data,
+		mldl_cfg->slave[EXT_SLAVE_TYPE_PRESSURE],
+		mldl_cfg->pdata_slave[EXT_SLAVE_TYPE_PRESSURE]);
+}
+
+/* -------------------------------------------------------------------------- */
+
+static inline
+long inv_mpu_get_sampling_rate_hz(struct mpu_gyro_cfg *gyro_cfg)
+{
+	if (((gyro_cfg->lpf) == 0) || ((gyro_cfg->lpf) == 7))
+		return 8000L / (gyro_cfg->divider + 1);
+	else
+		return 1000L / (gyro_cfg->divider + 1);
+}
+
+static inline
+long inv_mpu_get_sampling_period_us(struct mpu_gyro_cfg *gyro_cfg)
+{
+	if (((gyro_cfg->lpf) == 0) || ((gyro_cfg->lpf) == 7))
+		return (long) (1000000L * (gyro_cfg->divider + 1)) / 8000L;
+	else
+		return (long) (1000000L * (gyro_cfg->divider + 1)) / 1000L;
+}
+
+#endif				/* __MLDL_CFG_H__ */
+
+/**
+ * @}
+ */
diff --git a/drivers/misc/inv_mpu/mldl_print_cfg.c b/drivers/misc/inv_mpu/mldl_print_cfg.c
new file mode 100644
index 0000000..7379a17
--- /dev/null
+++ b/drivers/misc/inv_mpu/mldl_print_cfg.c
@@ -0,0 +1,138 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @addtogroup MLDL
+ *
+ *  @{
+ *      @file   mldl_print_cfg.c
+ *      @brief  The Motion Library Driver Layer.
+ */
+
+#include <stddef.h>
+#include "mldl_cfg.h"
+#include "mlsl.h"
+#include "linux/mpu.h"
+
+#include "log.h"
+#undef MPL_LOG_TAG
+#define MPL_LOG_TAG "mldl_print_cfg:"
+
+#undef MPL_LOG_NDEBUG
+#define MPL_LOG_NDEBUG 1
+
+void mldl_print_cfg(struct mldl_cfg *mldl_cfg)
+{
+	struct mpu_gyro_cfg	*mpu_gyro_cfg	= mldl_cfg->mpu_gyro_cfg;
+	struct mpu_offsets	*mpu_offsets	= mldl_cfg->mpu_offsets;
+	struct mpu_chip_info	*mpu_chip_info	= mldl_cfg->mpu_chip_info;
+	struct inv_mpu_cfg	*inv_mpu_cfg	= mldl_cfg->inv_mpu_cfg;
+	struct inv_mpu_state	*inv_mpu_state	= mldl_cfg->inv_mpu_state;
+	struct ext_slave_descr	**slave		= mldl_cfg->slave;
+	struct mpu_platform_data *pdata		= mldl_cfg->pdata;
+	struct ext_slave_platform_data **pdata_slave = mldl_cfg->pdata_slave;
+	int ii;
+
+	/* mpu_gyro_cfg */
+	MPL_LOGV("int_config     = %02x\n", mpu_gyro_cfg->int_config);
+	MPL_LOGV("ext_sync       = %02x\n", mpu_gyro_cfg->ext_sync);
+	MPL_LOGV("full_scale     = %02x\n", mpu_gyro_cfg->full_scale);
+	MPL_LOGV("lpf            = %02x\n", mpu_gyro_cfg->lpf);
+	MPL_LOGV("clk_src        = %02x\n", mpu_gyro_cfg->clk_src);
+	MPL_LOGV("divider        = %02x\n", mpu_gyro_cfg->divider);
+	MPL_LOGV("dmp_enable     = %02x\n", mpu_gyro_cfg->dmp_enable);
+	MPL_LOGV("fifo_enable    = %02x\n", mpu_gyro_cfg->fifo_enable);
+	MPL_LOGV("dmp_cfg1       = %02x\n", mpu_gyro_cfg->dmp_cfg1);
+	MPL_LOGV("dmp_cfg2       = %02x\n", mpu_gyro_cfg->dmp_cfg2);
+	/* mpu_offsets */
+	MPL_LOGV("tc[0]      = %02x\n", mpu_offsets->tc[0]);
+	MPL_LOGV("tc[1]      = %02x\n", mpu_offsets->tc[1]);
+	MPL_LOGV("tc[2]      = %02x\n", mpu_offsets->tc[2]);
+	MPL_LOGV("gyro[0]    = %04x\n", mpu_offsets->gyro[0]);
+	MPL_LOGV("gyro[1]    = %04x\n", mpu_offsets->gyro[1]);
+	MPL_LOGV("gyro[2]    = %04x\n", mpu_offsets->gyro[2]);
+
+	/* mpu_chip_info */
+	MPL_LOGV("addr            = %02x\n", mldl_cfg->mpu_chip_info->addr);
+
+	MPL_LOGV("silicon_revision = %02x\n", mpu_chip_info->silicon_revision);
+	MPL_LOGV("product_revision = %02x\n", mpu_chip_info->product_revision);
+	MPL_LOGV("product_id       = %02x\n", mpu_chip_info->product_id);
+	MPL_LOGV("gyro_sens_trim   = %02x\n", mpu_chip_info->gyro_sens_trim);
+	MPL_LOGV("accel_sens_trim  = %02x\n", mpu_chip_info->accel_sens_trim);
+
+	MPL_LOGV("requested_sensors = %04x\n", inv_mpu_cfg->requested_sensors);
+	MPL_LOGV("ignore_system_suspend= %04x\n",
+		inv_mpu_cfg->ignore_system_suspend);
+	MPL_LOGV("status = %04x\n", inv_mpu_state->status);
+	MPL_LOGV("i2c_slaves_enabled= %04x\n",
+		inv_mpu_state->i2c_slaves_enabled);
+
+	for (ii = 0; ii < EXT_SLAVE_NUM_TYPES; ii++) {
+		if (!slave[ii])
+			continue;
+		MPL_LOGV("SLAVE %d:\n", ii);
+		MPL_LOGV("    suspend  = %02x\n", (int)slave[ii]->suspend);
+		MPL_LOGV("    resume   = %02x\n", (int)slave[ii]->resume);
+		MPL_LOGV("    read     = %02x\n", (int)slave[ii]->read);
+		MPL_LOGV("    type     = %02x\n", slave[ii]->type);
+		MPL_LOGV("    reg      = %02x\n", slave[ii]->read_reg);
+		MPL_LOGV("    len      = %02x\n", slave[ii]->read_len);
+		MPL_LOGV("    endian   = %02x\n", slave[ii]->endian);
+		MPL_LOGV("    range.mantissa= %02x\n",
+			slave[ii]->range.mantissa);
+		MPL_LOGV("    range.fraction= %02x\n",
+			slave[ii]->range.fraction);
+	}
+
+	for (ii = 0; ii < EXT_SLAVE_NUM_TYPES; ii++) {
+		if (!pdata_slave[ii])
+			continue;
+		MPL_LOGV("PDATA_SLAVE[%d]\n", ii);
+		MPL_LOGV("    irq        = %02x\n", pdata_slave[ii]->irq);
+		MPL_LOGV("    adapt_num  = %02x\n", pdata_slave[ii]->adapt_num);
+		MPL_LOGV("    bus        = %02x\n", pdata_slave[ii]->bus);
+		MPL_LOGV("    address    = %02x\n", pdata_slave[ii]->address);
+		MPL_LOGV("    orientation=\n"
+			"                            %2d %2d %2d\n"
+			"                            %2d %2d %2d\n"
+			"                            %2d %2d %2d\n",
+			pdata_slave[ii]->orientation[0],
+			pdata_slave[ii]->orientation[1],
+			pdata_slave[ii]->orientation[2],
+			pdata_slave[ii]->orientation[3],
+			pdata_slave[ii]->orientation[4],
+			pdata_slave[ii]->orientation[5],
+			pdata_slave[ii]->orientation[6],
+			pdata_slave[ii]->orientation[7],
+			pdata_slave[ii]->orientation[8]);
+	}
+
+	MPL_LOGV("pdata->int_config         = %02x\n", pdata->int_config);
+	MPL_LOGV("pdata->level_shifter      = %02x\n", pdata->level_shifter);
+	MPL_LOGV("pdata->orientation        =\n"
+		 "                            %2d %2d %2d\n"
+		 "                            %2d %2d %2d\n"
+		 "                            %2d %2d %2d\n",
+		 pdata->orientation[0], pdata->orientation[1],
+		 pdata->orientation[2], pdata->orientation[3],
+		 pdata->orientation[4], pdata->orientation[5],
+		 pdata->orientation[6], pdata->orientation[7],
+		 pdata->orientation[8]);
+}
diff --git a/drivers/misc/inv_mpu/mldl_print_cfg.h b/drivers/misc/inv_mpu/mldl_print_cfg.h
new file mode 100644
index 0000000..2e19114
--- /dev/null
+++ b/drivers/misc/inv_mpu/mldl_print_cfg.h
@@ -0,0 +1,38 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ * @defgroup
+ * @brief
+ *
+ * @{
+ * @file     mldl_print_cfg.h
+ * @brief
+ *
+ *
+ */
+#ifndef __MLDL_PRINT_CFG__
+#define __MLDL_PRINT_CFG__
+
+#include "mldl_cfg.h"
+
+
+void mldl_print_cfg(struct mldl_cfg *mldl_cfg);
+
+#endif /* __MLDL_PRINT_CFG__ */
diff --git a/drivers/misc/inv_mpu/mlsl-kernel.c b/drivers/misc/inv_mpu/mlsl-kernel.c
new file mode 100644
index 0000000..34f55fa
--- /dev/null
+++ b/drivers/misc/inv_mpu/mlsl-kernel.c
@@ -0,0 +1,420 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+#include "mlsl.h"
+#include <linux/i2c.h>
+#include "log.h"
+#include "mpu6050b1.h"
+#include <linux/module.h>
+static int inv_i2c_write(struct i2c_adapter *i2c_adap,
+			    unsigned char address,
+			    unsigned int len, unsigned char const *data)
+{
+	struct i2c_msg msgs[1];
+	int res;
+
+	if (!data || !i2c_adap) {
+		LOG_RESULT_LOCATION(-EINVAL);
+		return -EINVAL;
+	}
+
+	msgs[0].addr = address;
+	msgs[0].flags = 0;	/* write */
+	msgs[0].buf = (unsigned char *)data;
+	msgs[0].len = len;
+
+	res = i2c_transfer(i2c_adap, msgs, 1);
+	if (res < 1) {
+		if (res == 0)
+			res = -EIO;
+		LOG_RESULT_LOCATION(res);
+		return res;
+	} else
+		return 0;
+}
+
+static int inv_i2c_write_register(struct i2c_adapter *i2c_adap,
+				     unsigned char address,
+				     unsigned char reg, unsigned char value)
+{
+	unsigned char data[2];
+
+	data[0] = reg;
+	data[1] = value;
+	return inv_i2c_write(i2c_adap, address, 2, data);
+}
+
+static int inv_i2c_read(struct i2c_adapter *i2c_adap,
+			   unsigned char address, unsigned char reg,
+			   unsigned int len, unsigned char *data)
+{
+	struct i2c_msg msgs[2];
+	int res;
+
+	if (!data || !i2c_adap) {
+		LOG_RESULT_LOCATION(-EINVAL);
+		return -EINVAL;
+	}
+
+	msgs[0].addr = address;
+	msgs[0].flags = 0;	/* write */
+	msgs[0].buf = &reg;
+	msgs[0].len = 1;
+
+	msgs[1].addr = address;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].buf = data;
+	msgs[1].len = len;
+
+	res = i2c_transfer(i2c_adap, msgs, 2);
+	if (res < 2) {
+		if (res >= 0)
+			res = -EIO;
+		LOG_RESULT_LOCATION(res);
+		return res;
+	} else
+		return 0;
+}
+
+static int mpu_memory_read(struct i2c_adapter *i2c_adap,
+			   unsigned char mpu_addr,
+			   unsigned short mem_addr,
+			   unsigned int len, unsigned char *data)
+{
+	unsigned char bank[2];
+	unsigned char addr[2];
+	unsigned char buf;
+
+	struct i2c_msg msgs[4];
+	int res;
+
+	if (!data || !i2c_adap) {
+		LOG_RESULT_LOCATION(-EINVAL);
+		return -EINVAL;
+	}
+
+	bank[0] = MPUREG_BANK_SEL;
+	bank[1] = mem_addr >> 8;
+
+	addr[0] = MPUREG_MEM_START_ADDR;
+	addr[1] = mem_addr & 0xFF;
+
+	buf = MPUREG_MEM_R_W;
+
+	/* write message */
+	msgs[0].addr = mpu_addr;
+	msgs[0].flags = 0;
+	msgs[0].buf = bank;
+	msgs[0].len = sizeof(bank);
+
+	msgs[1].addr = mpu_addr;
+	msgs[1].flags = 0;
+	msgs[1].buf = addr;
+	msgs[1].len = sizeof(addr);
+
+	msgs[2].addr = mpu_addr;
+	msgs[2].flags = 0;
+	msgs[2].buf = &buf;
+	msgs[2].len = 1;
+
+	msgs[3].addr = mpu_addr;
+	msgs[3].flags = I2C_M_RD;
+	msgs[3].buf = data;
+	msgs[3].len = len;
+
+	res = i2c_transfer(i2c_adap, msgs, 4);
+	if (res != 4) {
+		if (res >= 0)
+			res = -EIO;
+		LOG_RESULT_LOCATION(res);
+		return res;
+	} else
+		return 0;
+}
+
+static int mpu_memory_write(struct i2c_adapter *i2c_adap,
+			    unsigned char mpu_addr,
+			    unsigned short mem_addr,
+			    unsigned int len, unsigned char const *data)
+{
+	unsigned char bank[2];
+	unsigned char addr[2];
+	unsigned char buf[513];
+
+	struct i2c_msg msgs[3];
+	int res;
+
+	if (!data || !i2c_adap) {
+		LOG_RESULT_LOCATION(-EINVAL);
+		return -EINVAL;
+	}
+	if (len >= (sizeof(buf) - 1)) {
+		LOG_RESULT_LOCATION(-ENOMEM);
+		return -ENOMEM;
+	}
+
+	bank[0] = MPUREG_BANK_SEL;
+	bank[1] = mem_addr >> 8;
+
+	addr[0] = MPUREG_MEM_START_ADDR;
+	addr[1] = mem_addr & 0xFF;
+
+	buf[0] = MPUREG_MEM_R_W;
+	memcpy(buf + 1, data, len);
+
+	/* write message */
+	msgs[0].addr = mpu_addr;
+	msgs[0].flags = 0;
+	msgs[0].buf = bank;
+	msgs[0].len = sizeof(bank);
+
+	msgs[1].addr = mpu_addr;
+	msgs[1].flags = 0;
+	msgs[1].buf = addr;
+	msgs[1].len = sizeof(addr);
+
+	msgs[2].addr = mpu_addr;
+	msgs[2].flags = 0;
+	msgs[2].buf = (unsigned char *)buf;
+	msgs[2].len = len + 1;
+
+	res = i2c_transfer(i2c_adap, msgs, 3);
+	if (res != 3) {
+		if (res >= 0)
+			res = -EIO;
+		LOG_RESULT_LOCATION(res);
+		return res;
+	} else
+		return 0;
+}
+
+int inv_serial_single_write(
+	void *sl_handle,
+	unsigned char slave_addr,
+	unsigned char register_addr,
+	unsigned char data)
+{
+	return inv_i2c_write_register((struct i2c_adapter *)sl_handle,
+				      slave_addr, register_addr, data);
+}
+EXPORT_SYMBOL(inv_serial_single_write);
+
+int inv_serial_write(
+	void *sl_handle,
+	unsigned char slave_addr,
+	unsigned short length,
+	unsigned char const *data)
+{
+	int result;
+	const unsigned short data_length = length - 1;
+	const unsigned char start_reg_addr = data[0];
+	unsigned char i2c_write[SERIAL_MAX_TRANSFER_SIZE + 1];
+	unsigned short bytes_written = 0;
+
+	while (bytes_written < data_length) {
+		unsigned short this_len = min(SERIAL_MAX_TRANSFER_SIZE,
+					     data_length - bytes_written);
+		if (bytes_written == 0) {
+			result = inv_i2c_write((struct i2c_adapter *)
+					       sl_handle, slave_addr,
+					       1 + this_len, data);
+		} else {
+			/* manually increment register addr between chunks */
+			i2c_write[0] = start_reg_addr + bytes_written;
+			memcpy(&i2c_write[1], &data[1 + bytes_written],
+				this_len);
+			result = inv_i2c_write((struct i2c_adapter *)
+					       sl_handle, slave_addr,
+					       1 + this_len, i2c_write);
+		}
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		bytes_written += this_len;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(inv_serial_write);
+
+int inv_serial_read(
+	void *sl_handle,
+	unsigned char slave_addr,
+	unsigned char register_addr,
+	unsigned short length,
+	unsigned char *data)
+{
+	int result;
+	unsigned short bytes_read = 0;
+
+	if ((slave_addr & 0x7E) == DEFAULT_MPU_SLAVEADDR
+		&& (register_addr == MPUREG_FIFO_R_W ||
+		    register_addr == MPUREG_MEM_R_W)) {
+		LOG_RESULT_LOCATION(INV_ERROR_INVALID_PARAMETER);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+
+	while (bytes_read < length) {
+		unsigned short this_len =
+		    min(SERIAL_MAX_TRANSFER_SIZE, length - bytes_read);
+		result = inv_i2c_read((struct i2c_adapter *)sl_handle,
+				      slave_addr, register_addr + bytes_read,
+				      this_len, &data[bytes_read]);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		bytes_read += this_len;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(inv_serial_read);
+
+int inv_serial_write_mem(
+	void *sl_handle,
+	unsigned char slave_addr,
+	unsigned short mem_addr,
+	unsigned short length,
+	unsigned char const *data)
+{
+	int result;
+	unsigned short bytes_written = 0;
+
+	if ((mem_addr & 0xFF) + length > MPU_MEM_BANK_SIZE) {
+		pr_err("memory read length (%d B) extends beyond its"
+		       " limits (%d) if started at location %d\n", length,
+		       MPU_MEM_BANK_SIZE, mem_addr & 0xFF);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+	while (bytes_written < length) {
+		unsigned short this_len =
+		    min(SERIAL_MAX_TRANSFER_SIZE, length - bytes_written);
+		result = mpu_memory_write((struct i2c_adapter *)sl_handle,
+					  slave_addr, mem_addr + bytes_written,
+					  this_len, &data[bytes_written]);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		bytes_written += this_len;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(inv_serial_write_mem);
+
+int inv_serial_read_mem(
+	void *sl_handle,
+	unsigned char slave_addr,
+	unsigned short mem_addr,
+	unsigned short length,
+	unsigned char *data)
+{
+	int result;
+	unsigned short bytes_read = 0;
+
+	if ((mem_addr & 0xFF) + length > MPU_MEM_BANK_SIZE) {
+		printk
+		    ("memory read length (%d B) extends beyond its limits (%d) "
+		     "if started at location %d\n", length,
+		     MPU_MEM_BANK_SIZE, mem_addr & 0xFF);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+	while (bytes_read < length) {
+		unsigned short this_len =
+		    min(SERIAL_MAX_TRANSFER_SIZE, length - bytes_read);
+		result =
+		    mpu_memory_read((struct i2c_adapter *)sl_handle,
+				    slave_addr, mem_addr + bytes_read,
+				    this_len, &data[bytes_read]);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		bytes_read += this_len;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(inv_serial_read_mem);
+
+int inv_serial_write_fifo(
+	void *sl_handle,
+	unsigned char slave_addr,
+	unsigned short length,
+	unsigned char const *data)
+{
+	int result;
+	unsigned char i2c_write[SERIAL_MAX_TRANSFER_SIZE + 1];
+	unsigned short bytes_written = 0;
+
+	if (length > FIFO_HW_SIZE) {
+		printk(KERN_ERR
+		       "maximum fifo write length is %d\n", FIFO_HW_SIZE);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+	while (bytes_written < length) {
+		unsigned short this_len =
+		    min(SERIAL_MAX_TRANSFER_SIZE, length - bytes_written);
+		i2c_write[0] = MPUREG_FIFO_R_W;
+		memcpy(&i2c_write[1], &data[bytes_written], this_len);
+		result = inv_i2c_write((struct i2c_adapter *)sl_handle,
+				       slave_addr, this_len + 1, i2c_write);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		bytes_written += this_len;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(inv_serial_write_fifo);
+
+int inv_serial_read_fifo(
+	void *sl_handle,
+	unsigned char slave_addr,
+	unsigned short length,
+	unsigned char *data)
+{
+	int result;
+	unsigned short bytes_read = 0;
+
+	if (length > FIFO_HW_SIZE) {
+		printk(KERN_ERR
+		       "maximum fifo read length is %d\n", FIFO_HW_SIZE);
+		return INV_ERROR_INVALID_PARAMETER;
+	}
+	while (bytes_read < length) {
+		unsigned short this_len =
+		    min(SERIAL_MAX_TRANSFER_SIZE, length - bytes_read);
+		result = inv_i2c_read((struct i2c_adapter *)sl_handle,
+				      slave_addr, MPUREG_FIFO_R_W, this_len,
+				      &data[bytes_read]);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			return result;
+		}
+		bytes_read += this_len;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(inv_serial_read_fifo);
+
+/**
+ *  @}
+ */
diff --git a/drivers/misc/inv_mpu/mlsl.h b/drivers/misc/inv_mpu/mlsl.h
new file mode 100644
index 0000000..204baed
--- /dev/null
+++ b/drivers/misc/inv_mpu/mlsl.h
@@ -0,0 +1,186 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+#ifndef __MLSL_H__
+#define __MLSL_H__
+
+/**
+ *  @defgroup   MLSL
+ *  @brief      Motion Library - Serial Layer.
+ *              The Motion Library System Layer provides the Motion Library
+ *              with the communication interface to the hardware.
+ *
+ *              The communication interface is assumed to support serial
+ *              transfers in burst of variable length up to
+ *              SERIAL_MAX_TRANSFER_SIZE.
+ *              The default value for SERIAL_MAX_TRANSFER_SIZE is 128 bytes.
+ *              Transfers of length greater than SERIAL_MAX_TRANSFER_SIZE, will
+ *              be subdivided in smaller transfers of length <=
+ *              SERIAL_MAX_TRANSFER_SIZE.
+ *              The SERIAL_MAX_TRANSFER_SIZE definition can be modified to
+ *              overcome any host processor transfer size limitation down to
+ *              1 B, the minimum.
+ *              An higher value for SERIAL_MAX_TRANSFER_SIZE will favor
+ *              performance and efficiency while requiring higher resource usage
+ *              (mostly buffering). A smaller value will increase overhead and
+ *              decrease efficiency but allows to operate with more resource
+ *              constrained processor and master serial controllers.
+ *              The SERIAL_MAX_TRANSFER_SIZE definition can be found in the
+ *              mlsl.h header file and master serial controllers.
+ *              The SERIAL_MAX_TRANSFER_SIZE definition can be found in the
+ *              mlsl.h header file.
+ *
+ *  @{
+ *      @file   mlsl.h
+ *      @brief  The Motion Library System Layer.
+ *
+ */
+
+#include "mltypes.h"
+#include <linux/mpu.h>
+
+
+/*
+ * NOTE : to properly support Yamaha compass reads,
+ *	  the max transfer size should be at least 9 B.
+ *	  Length in bytes, typically a power of 2 >= 2
+ */
+#define SERIAL_MAX_TRANSFER_SIZE 128
+
+
+/**
+ *  inv_serial_single_write() - used to write a single byte of data.
+ *  @sl_handle		pointer to the serial device used for the communication.
+ *  @slave_addr		I2C slave address of device.
+ *  @register_addr	Register address to write.
+ *  @data		Single byte of data to write.
+ *
+ *	It is called by the MPL to write a single byte of data to the MPU.
+ *
+ *  returns INV_SUCCESS if successful, a non-zero error code otherwise.
+ */
+int inv_serial_single_write(
+	void *sl_handle,
+	unsigned char slave_addr,
+	unsigned char register_addr,
+	unsigned char data);
+
+/**
+ *  inv_serial_write() - used to write multiple bytes of data to registers.
+ *  @sl_handle	a file handle to the serial device used for the communication.
+ *  @slave_addr	I2C slave address of device.
+ *  @register_addr	Register address to write.
+ *  @length	Length of burst of data.
+ *  @data	Pointer to block of data.
+ *
+ *  returns INV_SUCCESS if successful, a non-zero error code otherwise.
+ */
+int inv_serial_write(
+	void *sl_handle,
+	unsigned char slave_addr,
+	unsigned short length,
+	unsigned char const *data);
+
+/**
+ *  inv_serial_read() - used to read multiple bytes of data from registers.
+ *  @sl_handle	a file handle to the serial device used for the communication.
+ *  @slave_addr	I2C slave address of device.
+ *  @register_addr	Register address to read.
+ *  @length	Length of burst of data.
+ *  @data	Pointer to block of data.
+ *
+ *  returns INV_SUCCESS == 0 if successful; a non-zero error code otherwise.
+ */
+int inv_serial_read(
+	void *sl_handle,
+	unsigned char slave_addr,
+	unsigned char register_addr,
+	unsigned short length,
+	unsigned char *data);
+
+/**
+ *  inv_serial_read_mem() - used to read multiple bytes of data from the memory.
+ *	    This should be sent by I2C or SPI.
+ *
+ *  @sl_handle	a file handle to the serial device used for the communication.
+ *  @slave_addr	I2C slave address of device.
+ *  @mem_addr	The location in the memory to read from.
+ *  @length	Length of burst data.
+ *  @data	Pointer to block of data.
+ *
+ *  returns INV_SUCCESS == 0 if successful; a non-zero error code otherwise.
+ */
+int inv_serial_read_mem(
+	void *sl_handle,
+	unsigned char slave_addr,
+	unsigned short mem_addr,
+	unsigned short length,
+	unsigned char *data);
+
+/**
+ *  inv_serial_write_mem() - used to write multiple bytes of data to the memory.
+ *  @sl_handle	a file handle to the serial device used for the communication.
+ *  @slave_addr	I2C slave address of device.
+ *  @mem_addr	The location in the memory to write to.
+ *  @length	Length of burst data.
+ *  @data	Pointer to block of data.
+ *
+ *  returns INV_SUCCESS == 0 if successful; a non-zero error code otherwise.
+ */
+int inv_serial_write_mem(
+	void *sl_handle,
+	unsigned char slave_addr,
+	unsigned short mem_addr,
+	unsigned short length,
+	unsigned char const *data);
+
+/**
+ *  inv_serial_read_fifo() - used to read multiple bytes of data from the fifo.
+ *  @sl_handle	a file handle to the serial device used for the communication.
+ *  @slave_addr	I2C slave address of device.
+ *  @length	Length of burst of data.
+ *  @data	Pointer to block of data.
+ *
+ *  returns INV_SUCCESS == 0 if successful; a non-zero error code otherwise.
+ */
+int inv_serial_read_fifo(
+	void *sl_handle,
+	unsigned char slave_addr,
+	unsigned short length,
+	unsigned char *data);
+
+/**
+ *  inv_serial_write_fifo() - used to write multiple bytes of data to the fifo.
+ *  @sl_handle	a file handle to the serial device used for the communication.
+ *  @slave_addr	I2C slave address of device.
+ *  @length	Length of burst of data.
+ *  @data	Pointer to block of data.
+ *
+ *  returns INV_SUCCESS == 0 if successful; a non-zero error code otherwise.
+ */
+int inv_serial_write_fifo(
+	void *sl_handle,
+	unsigned char slave_addr,
+	unsigned short length,
+	unsigned char const *data);
+
+/**
+ * @}
+ */
+#endif				/* __MLSL_H__ */
diff --git a/drivers/misc/inv_mpu/mltypes.h b/drivers/misc/inv_mpu/mltypes.h
new file mode 100644
index 0000000..a249f93
--- /dev/null
+++ b/drivers/misc/inv_mpu/mltypes.h
@@ -0,0 +1,234 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @defgroup MLERROR
+ *  @brief  Definition of the error codes used within the MPL and
+ *          returned to the user.
+ *          Every function tries to return a meaningful error code basing
+ *          on the occuring error condition. The error code is numeric.
+ *
+ *          The available error codes and their associated values are:
+ *          - (0)               INV_SUCCESS
+ *          - (32)              INV_ERROR
+ *          - (22 / EINVAL)     INV_ERROR_INVALID_PARAMETER
+ *          - (1  / EPERM)      INV_ERROR_FEATURE_NOT_ENABLED
+ *          - (36)              INV_ERROR_FEATURE_NOT_IMPLEMENTED
+ *          - (38)              INV_ERROR_DMP_NOT_STARTED
+ *          - (39)              INV_ERROR_DMP_STARTED
+ *          - (40)              INV_ERROR_NOT_OPENED
+ *          - (41)              INV_ERROR_OPENED
+ *          - (19 / ENODEV)     INV_ERROR_INVALID_MODULE
+ *          - (12 / ENOMEM)     INV_ERROR_MEMORY_EXAUSTED
+ *          - (44)              INV_ERROR_DIVIDE_BY_ZERO
+ *          - (45)              INV_ERROR_ASSERTION_FAILURE
+ *          - (46)              INV_ERROR_FILE_OPEN
+ *          - (47)              INV_ERROR_FILE_READ
+ *          - (48)              INV_ERROR_FILE_WRITE
+ *          - (49)              INV_ERROR_INVALID_CONFIGURATION
+ *          - (52)              INV_ERROR_SERIAL_CLOSED
+ *          - (53)              INV_ERROR_SERIAL_OPEN_ERROR
+ *          - (54)              INV_ERROR_SERIAL_READ
+ *          - (55)              INV_ERROR_SERIAL_WRITE
+ *          - (56)              INV_ERROR_SERIAL_DEVICE_NOT_RECOGNIZED
+ *          - (57)              INV_ERROR_SM_TRANSITION
+ *          - (58)              INV_ERROR_SM_IMPROPER_STATE
+ *          - (62)              INV_ERROR_FIFO_OVERFLOW
+ *          - (63)              INV_ERROR_FIFO_FOOTER
+ *          - (64)              INV_ERROR_FIFO_READ_COUNT
+ *          - (65)              INV_ERROR_FIFO_READ_DATA
+ *          - (72)              INV_ERROR_MEMORY_SET
+ *          - (82)              INV_ERROR_LOG_MEMORY_ERROR
+ *          - (83)              INV_ERROR_LOG_OUTPUT_ERROR
+ *          - (92)              INV_ERROR_OS_BAD_PTR
+ *          - (93)              INV_ERROR_OS_BAD_HANDLE
+ *          - (94)              INV_ERROR_OS_CREATE_FAILED
+ *          - (95)              INV_ERROR_OS_LOCK_FAILED
+ *          - (102)             INV_ERROR_COMPASS_DATA_OVERFLOW
+ *          - (103)             INV_ERROR_COMPASS_DATA_UNDERFLOW
+ *          - (104)             INV_ERROR_COMPASS_DATA_NOT_READY
+ *          - (105)             INV_ERROR_COMPASS_DATA_ERROR
+ *          - (107)             INV_ERROR_CALIBRATION_LOAD
+ *          - (108)             INV_ERROR_CALIBRATION_STORE
+ *          - (109)             INV_ERROR_CALIBRATION_LEN
+ *          - (110)             INV_ERROR_CALIBRATION_CHECKSUM
+ *          - (111)             INV_ERROR_ACCEL_DATA_OVERFLOW
+ *          - (112)             INV_ERROR_ACCEL_DATA_UNDERFLOW
+ *          - (113)             INV_ERROR_ACCEL_DATA_NOT_READY
+ *          - (114)             INV_ERROR_ACCEL_DATA_ERROR
+ *
+ *          The available warning codes and their associated values are:
+ *          - (115)             INV_WARNING_MOTION_RACE
+ *          - (116)             INV_WARNING_QUAT_TRASHED
+ *
+ *  @{
+ *      @file mltypes.h
+ *  @}
+ */
+
+#ifndef MLTYPES_H
+#define MLTYPES_H
+
+#include <linux/types.h>
+#include <asm-generic/errno-base.h>
+
+
+
+
+/*---------------------------
+ *    ML Defines
+ *--------------------------*/
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+/* - ML Errors. - */
+#define ERROR_NAME(x)   (#x)
+#define ERROR_CHECK_FIRST(first, x) \
+	{ if (INV_SUCCESS == first) first = x; }
+
+#define INV_SUCCESS                       (0)
+/* Generic Error code.  Proprietary Error Codes only */
+#define INV_ERROR_BASE                    (0x20)
+#define INV_ERROR                         (INV_ERROR_BASE)
+
+/* Compatibility and other generic error codes */
+#define INV_ERROR_INVALID_PARAMETER             (EINVAL)
+#define INV_ERROR_FEATURE_NOT_ENABLED           (EPERM)
+#define INV_ERROR_FEATURE_NOT_IMPLEMENTED       (INV_ERROR_BASE + 4)
+#define INV_ERROR_DMP_NOT_STARTED               (INV_ERROR_BASE + 6)
+#define INV_ERROR_DMP_STARTED                   (INV_ERROR_BASE + 7)
+#define INV_ERROR_NOT_OPENED                    (INV_ERROR_BASE + 8)
+#define INV_ERROR_OPENED                        (INV_ERROR_BASE + 9)
+#define INV_ERROR_INVALID_MODULE                (ENODEV)
+#define INV_ERROR_MEMORY_EXAUSTED               (ENOMEM)
+#define INV_ERROR_DIVIDE_BY_ZERO                (INV_ERROR_BASE + 12)
+#define INV_ERROR_ASSERTION_FAILURE             (INV_ERROR_BASE + 13)
+#define INV_ERROR_FILE_OPEN                     (INV_ERROR_BASE + 14)
+#define INV_ERROR_FILE_READ                     (INV_ERROR_BASE + 15)
+#define INV_ERROR_FILE_WRITE                    (INV_ERROR_BASE + 16)
+#define INV_ERROR_INVALID_CONFIGURATION         (INV_ERROR_BASE + 17)
+
+/* Serial Communication */
+#define INV_ERROR_SERIAL_CLOSED                 (INV_ERROR_BASE + 20)
+#define INV_ERROR_SERIAL_OPEN_ERROR             (INV_ERROR_BASE + 21)
+#define INV_ERROR_SERIAL_READ                   (INV_ERROR_BASE + 22)
+#define INV_ERROR_SERIAL_WRITE                  (INV_ERROR_BASE + 23)
+#define INV_ERROR_SERIAL_DEVICE_NOT_RECOGNIZED  (INV_ERROR_BASE + 24)
+
+/* SM = State Machine */
+#define INV_ERROR_SM_TRANSITION                 (INV_ERROR_BASE + 25)
+#define INV_ERROR_SM_IMPROPER_STATE             (INV_ERROR_BASE + 26)
+
+/* Fifo */
+#define INV_ERROR_FIFO_OVERFLOW                 (INV_ERROR_BASE + 30)
+#define INV_ERROR_FIFO_FOOTER                   (INV_ERROR_BASE + 31)
+#define INV_ERROR_FIFO_READ_COUNT               (INV_ERROR_BASE + 32)
+#define INV_ERROR_FIFO_READ_DATA                (INV_ERROR_BASE + 33)
+
+/* Memory & Registers, Set & Get */
+#define INV_ERROR_MEMORY_SET                    (INV_ERROR_BASE + 40)
+
+#define INV_ERROR_LOG_MEMORY_ERROR              (INV_ERROR_BASE + 50)
+#define INV_ERROR_LOG_OUTPUT_ERROR              (INV_ERROR_BASE + 51)
+
+/* OS interface errors */
+#define INV_ERROR_OS_BAD_PTR                    (INV_ERROR_BASE + 60)
+#define INV_ERROR_OS_BAD_HANDLE                 (INV_ERROR_BASE + 61)
+#define INV_ERROR_OS_CREATE_FAILED              (INV_ERROR_BASE + 62)
+#define INV_ERROR_OS_LOCK_FAILED                (INV_ERROR_BASE + 63)
+
+/* Compass errors */
+#define INV_ERROR_COMPASS_DATA_OVERFLOW         (INV_ERROR_BASE + 70)
+#define INV_ERROR_COMPASS_DATA_UNDERFLOW        (INV_ERROR_BASE + 71)
+#define INV_ERROR_COMPASS_DATA_NOT_READY        (INV_ERROR_BASE + 72)
+#define INV_ERROR_COMPASS_DATA_ERROR            (INV_ERROR_BASE + 73)
+
+/* Load/Store calibration */
+#define INV_ERROR_CALIBRATION_LOAD              (INV_ERROR_BASE + 75)
+#define INV_ERROR_CALIBRATION_STORE             (INV_ERROR_BASE + 76)
+#define INV_ERROR_CALIBRATION_LEN               (INV_ERROR_BASE + 77)
+#define INV_ERROR_CALIBRATION_CHECKSUM          (INV_ERROR_BASE + 78)
+
+/* Accel errors */
+#define INV_ERROR_ACCEL_DATA_OVERFLOW           (INV_ERROR_BASE + 79)
+#define INV_ERROR_ACCEL_DATA_UNDERFLOW          (INV_ERROR_BASE + 80)
+#define INV_ERROR_ACCEL_DATA_NOT_READY          (INV_ERROR_BASE + 81)
+#define INV_ERROR_ACCEL_DATA_ERROR              (INV_ERROR_BASE + 82)
+
+/* No Motion Warning States */
+#define INV_WARNING_MOTION_RACE                 (INV_ERROR_BASE + 83)
+#define INV_WARNING_QUAT_TRASHED                (INV_ERROR_BASE + 84)
+#define INV_WARNING_GYRO_MAG                    (INV_ERROR_BASE + 85)
+
+#ifdef INV_USE_LEGACY_NAMES
+#define ML_SUCCESS                        INV_SUCCESS
+#define ML_ERROR                          INV_ERROR
+#define ML_ERROR_INVALID_PARAMETER        INV_ERROR_INVALID_PARAMETER
+#define ML_ERROR_FEATURE_NOT_ENABLED      INV_ERROR_FEATURE_NOT_ENABLED
+#define ML_ERROR_FEATURE_NOT_IMPLEMENTED  INV_ERROR_FEATURE_NOT_IMPLEMENTED
+#define ML_ERROR_DMP_NOT_STARTED          INV_ERROR_DMP_NOT_STARTED
+#define ML_ERROR_DMP_STARTED              INV_ERROR_DMP_STARTED
+#define ML_ERROR_NOT_OPENED               INV_ERROR_NOT_OPENED
+#define ML_ERROR_OPENED                   INV_ERROR_OPENED
+#define ML_ERROR_INVALID_MODULE           INV_ERROR_INVALID_MODULE
+#define ML_ERROR_MEMORY_EXAUSTED          INV_ERROR_MEMORY_EXAUSTED
+#define ML_ERROR_DIVIDE_BY_ZERO           INV_ERROR_DIVIDE_BY_ZERO
+#define ML_ERROR_ASSERTION_FAILURE        INV_ERROR_ASSERTION_FAILURE
+#define ML_ERROR_FILE_OPEN                INV_ERROR_FILE_OPEN
+#define ML_ERROR_FILE_READ                INV_ERROR_FILE_READ
+#define ML_ERROR_FILE_WRITE               INV_ERROR_FILE_WRITE
+#define ML_ERROR_INVALID_CONFIGURATION    INV_ERROR_INVALID_CONFIGURATION
+#define ML_ERROR_SERIAL_CLOSED            INV_ERROR_SERIAL_CLOSED
+#define ML_ERROR_SERIAL_OPEN_ERROR        INV_ERROR_SERIAL_OPEN_ERROR
+#define ML_ERROR_SERIAL_READ              INV_ERROR_SERIAL_READ
+#define ML_ERROR_SERIAL_WRITE             INV_ERROR_SERIAL_WRITE
+#define ML_ERROR_SERIAL_DEVICE_NOT_RECOGNIZED  \
+	INV_ERROR_SERIAL_DEVICE_NOT_RECOGNIZED
+#define ML_ERROR_SM_TRANSITION            INV_ERROR_SM_TRANSITION
+#define ML_ERROR_SM_IMPROPER_STATE        INV_ERROR_SM_IMPROPER_STATE
+#define ML_ERROR_FIFO_OVERFLOW            INV_ERROR_FIFO_OVERFLOW
+#define ML_ERROR_FIFO_FOOTER              INV_ERROR_FIFO_FOOTER
+#define ML_ERROR_FIFO_READ_COUNT          INV_ERROR_FIFO_READ_COUNT
+#define ML_ERROR_FIFO_READ_DATA           INV_ERROR_FIFO_READ_DATA
+#define ML_ERROR_MEMORY_SET               INV_ERROR_MEMORY_SET
+#define ML_ERROR_LOG_MEMORY_ERROR         INV_ERROR_LOG_MEMORY_ERROR
+#define ML_ERROR_LOG_OUTPUT_ERROR         INV_ERROR_LOG_OUTPUT_ERROR
+#define ML_ERROR_OS_BAD_PTR               INV_ERROR_OS_BAD_PTR
+#define ML_ERROR_OS_BAD_HANDLE            INV_ERROR_OS_BAD_HANDLE
+#define ML_ERROR_OS_CREATE_FAILED         INV_ERROR_OS_CREATE_FAILED
+#define ML_ERROR_OS_LOCK_FAILED           INV_ERROR_OS_LOCK_FAILED
+#define ML_ERROR_COMPASS_DATA_OVERFLOW    INV_ERROR_COMPASS_DATA_OVERFLOW
+#define ML_ERROR_COMPASS_DATA_UNDERFLOW   INV_ERROR_COMPASS_DATA_UNDERFLOW
+#define ML_ERROR_COMPASS_DATA_NOT_READY   INV_ERROR_COMPASS_DATA_NOT_READY
+#define ML_ERROR_COMPASS_DATA_ERROR       INV_ERROR_COMPASS_DATA_ERROR
+#define ML_ERROR_CALIBRATION_LOAD         INV_ERROR_CALIBRATION_LOAD
+#define ML_ERROR_CALIBRATION_STORE        INV_ERROR_CALIBRATION_STORE
+#define ML_ERROR_CALIBRATION_LEN          INV_ERROR_CALIBRATION_LEN
+#define ML_ERROR_CALIBRATION_CHECKSUM     INV_ERROR_CALIBRATION_CHECKSUM
+#define ML_ERROR_ACCEL_DATA_OVERFLOW      INV_ERROR_ACCEL_DATA_OVERFLOW
+#define ML_ERROR_ACCEL_DATA_UNDERFLOW     INV_ERROR_ACCEL_DATA_UNDERFLOW
+#define ML_ERROR_ACCEL_DATA_NOT_READY     INV_ERROR_ACCEL_DATA_NOT_READY
+#define ML_ERROR_ACCEL_DATA_ERROR         INV_ERROR_ACCEL_DATA_ERROR
+#endif
+
+/* For Linux coding compliance */
+
+#endif				/* MLTYPES_H */
diff --git a/drivers/misc/inv_mpu/mpu-dev.c b/drivers/misc/inv_mpu/mpu-dev.c
new file mode 100644
index 0000000..5407827
--- /dev/null
+++ b/drivers/misc/inv_mpu/mpu-dev.c
@@ -0,0 +1,1512 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/stat.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/signal.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/pm.h>
+#include <linux/mutex.h>
+#include <linux/suspend.h>
+#include <linux/poll.h>
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+
+#include "mpuirq.h"
+#include "slaveirq.h"
+#include "mlsl.h"
+#include "mldl_cfg.h"
+#include <linux/mpu.h>
+
+#include "accel/mpu6050.h"
+#include <mach/sys_config.h>//20130411nick++++++
+#include <linux/gpio.h>
+
+/* Platform data for the MPU */
+struct mpu_private_data {
+	struct miscdevice dev;
+	struct i2c_client *client;
+
+	/* mldl_cfg data */
+	struct mldl_cfg mldl_cfg;
+	struct mpu_ram		mpu_ram;
+	struct mpu_gyro_cfg	mpu_gyro_cfg;
+	struct mpu_offsets	mpu_offsets;
+	struct mpu_chip_info	mpu_chip_info;
+	struct inv_mpu_cfg	inv_mpu_cfg;
+	struct inv_mpu_state	inv_mpu_state;
+
+	struct mutex mutex;
+	wait_queue_head_t mpu_event_wait;
+	struct completion completion;
+	struct timer_list timeout;
+	struct notifier_block nb;
+	struct mpuirq_data mpu_pm_event;
+	int response_timeout;	/* In seconds */
+	unsigned long event;
+	int pid;
+	struct module *slave_modules[EXT_SLAVE_NUM_TYPES];
+};
+
+struct mpu_private_data *mpu_private_data;
+
+struct mpu_platform_data gyrodata ={//20130411++++++nick
+		.int_config = 0x10,//mpu6050c_int_config,
+		.level_shifter = 0,//mpu6050c_level_shifter,
+		.orientation = { 0,  1,  0, 
+				1,  0,  0 , 
+				0,  0, -1 },
+		};//20130411------nick
+
+static void mpu_pm_timeout(u_long data)
+{
+	struct mpu_private_data *mpu = (struct mpu_private_data *)data;
+	struct i2c_client *client = mpu->client;
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+	complete(&mpu->completion);
+}
+
+
+static int mpu_pm_notifier_callback(struct notifier_block *nb,
+				    unsigned long event, void *unused)
+{
+	struct mpu_private_data *mpu =
+	    container_of(nb, struct mpu_private_data, nb);
+	struct i2c_client *client = mpu->client;
+	struct timeval event_time;
+	dev_dbg(&client->adapter->dev, "%s: %ld\n", __func__, event);
+
+	/* Prevent the file handle from being closed before we initialize
+	   the completion event */
+	mutex_lock(&mpu->mutex);
+	if (!(mpu->pid) ||
+	    (event != PM_SUSPEND_PREPARE && event != PM_POST_SUSPEND)) {
+		mutex_unlock(&mpu->mutex);
+		return NOTIFY_OK;
+	}
+
+	if (event == PM_SUSPEND_PREPARE)
+		mpu->event = MPU_PM_EVENT_SUSPEND_PREPARE;
+	if (event == PM_POST_SUSPEND)
+		mpu->event = MPU_PM_EVENT_POST_SUSPEND;
+
+	do_gettimeofday(&event_time);
+	mpu->mpu_pm_event.interruptcount++;
+	mpu->mpu_pm_event.irqtime =
+	    (((long long)event_time.tv_sec) << 32) + event_time.tv_usec;
+	mpu->mpu_pm_event.data_type = MPUIRQ_DATA_TYPE_PM_EVENT;
+	mpu->mpu_pm_event.data = mpu->event;
+
+	if (mpu->response_timeout > 0) {
+		mpu->timeout.expires = jiffies + mpu->response_timeout * HZ;
+		add_timer(&mpu->timeout);
+	}
+	INIT_COMPLETION(mpu->completion);
+	mutex_unlock(&mpu->mutex);
+
+	wake_up_interruptible(&mpu->mpu_event_wait);
+	wait_for_completion(&mpu->completion);
+	del_timer_sync(&mpu->timeout);
+	dev_dbg(&client->adapter->dev, "%s: %ld DONE\n", __func__, event);
+	return NOTIFY_OK;
+}
+
+static int mpu_dev_open(struct inode *inode, struct file *file)
+{
+	struct mpu_private_data *mpu =
+	    container_of(file->private_data, struct mpu_private_data, dev);
+	struct i2c_client *client = mpu->client;
+	int result;
+	int ii;
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+	dev_dbg(&client->adapter->dev, "current->pid %d\n", current->pid);
+
+	result = mutex_lock_interruptible(&mpu->mutex);
+	//if (mpu->pid) {fix polldmp-static runs after stop zygote command
+	if (result) {
+		mutex_unlock(&mpu->mutex);
+		return -EBUSY;
+	}
+	mpu->pid = current->pid;
+
+	/* Reset the sensors to the default */
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"%s: mutex_lock_interruptible returned %d\n",
+			__func__, result);
+		return result;
+	}
+
+	for (ii = 0; ii < EXT_SLAVE_NUM_TYPES; ii++)
+		__module_get(mpu->slave_modules[ii]);
+
+	mutex_unlock(&mpu->mutex);
+	return 0;
+}
+
+/* close function - called when the "file" /dev/mpu is closed in userspace   */
+static int mpu_release(struct inode *inode, struct file *file)
+{
+	struct mpu_private_data *mpu =
+	    container_of(file->private_data, struct mpu_private_data, dev);
+	struct i2c_client *client = mpu->client;
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	int result = 0;
+	int ii;
+	struct i2c_adapter *slave_adapter[EXT_SLAVE_NUM_TYPES];
+	struct ext_slave_platform_data **pdata_slave = mldl_cfg->pdata_slave;
+
+	for (ii = 0; ii < EXT_SLAVE_NUM_TYPES; ii++) {
+		if (!pdata_slave[ii])
+			slave_adapter[ii] = NULL;
+		else
+			slave_adapter[ii] =
+				i2c_get_adapter(pdata_slave[ii]->adapt_num);
+	}
+	slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE] = client->adapter;
+
+	mutex_lock(&mpu->mutex);
+	mldl_cfg->inv_mpu_cfg->requested_sensors = 0;
+	result = inv_mpu_suspend(mldl_cfg,
+				slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+				slave_adapter[EXT_SLAVE_TYPE_ACCEL],
+				slave_adapter[EXT_SLAVE_TYPE_COMPASS],
+				slave_adapter[EXT_SLAVE_TYPE_PRESSURE],
+				INV_ALL_SENSORS);
+	mpu->pid = 0;
+	for (ii = 0; ii < EXT_SLAVE_NUM_TYPES; ii++)
+		module_put(mpu->slave_modules[ii]);
+
+	mutex_unlock(&mpu->mutex);
+	complete(&mpu->completion);
+	dev_dbg(&client->adapter->dev, "mpu_release\n");
+
+	return result;
+}
+
+/* read function called when from /dev/mpu is read.  Read from the FIFO */
+static ssize_t mpu_read(struct file *file,
+			char __user *buf, size_t count, loff_t *offset)
+{
+	struct mpu_private_data *mpu =
+	    container_of(file->private_data, struct mpu_private_data, dev);
+	struct i2c_client *client = mpu->client;
+	size_t len = sizeof(mpu->mpu_pm_event) + sizeof(unsigned long);
+	int err;
+
+	if (!mpu->event && (!(file->f_flags & O_NONBLOCK)))
+		wait_event_interruptible(mpu->mpu_event_wait, mpu->event);
+
+	if (!mpu->event || !buf
+	    || count < sizeof(mpu->mpu_pm_event))
+		return 0;
+
+	err = copy_to_user(buf, &mpu->mpu_pm_event, sizeof(mpu->mpu_pm_event));
+	if (err) {
+		dev_err(&client->adapter->dev,
+			"Copy to user returned %d\n", err);
+		return -EFAULT;
+	}
+	mpu->event = 0;
+	return len;
+}
+
+static unsigned int mpu_poll(struct file *file, struct poll_table_struct *poll)
+{
+	struct mpu_private_data *mpu =
+	    container_of(file->private_data, struct mpu_private_data, dev);
+	int mask = 0;
+
+	poll_wait(file, &mpu->mpu_event_wait, poll);
+	if (mpu->event)
+		mask |= POLLIN | POLLRDNORM;
+	return mask;
+}
+
+static int mpu_dev_ioctl_get_ext_slave_platform_data(
+	struct i2c_client *client,
+	struct ext_slave_platform_data __user *arg)
+{
+	struct mpu_private_data *mpu =
+	    (struct mpu_private_data *)i2c_get_clientdata(client);
+	struct ext_slave_platform_data *pdata_slave;
+	struct ext_slave_platform_data local_pdata_slave;
+
+	if (copy_from_user(&local_pdata_slave, arg, sizeof(local_pdata_slave)))
+		return -EFAULT;
+
+	if (local_pdata_slave.type >= EXT_SLAVE_NUM_TYPES)
+		return -EINVAL;
+
+	pdata_slave = mpu->mldl_cfg.pdata_slave[local_pdata_slave.type];
+	/* All but private data and irq_data */
+	if (!pdata_slave)
+		return -ENODEV;
+	if (copy_to_user(arg, pdata_slave, sizeof(*pdata_slave)))
+		return -EFAULT;
+	return 0;
+}
+
+static int mpu_dev_ioctl_get_mpu_platform_data(
+	struct i2c_client *client,
+	struct mpu_platform_data __user *arg)
+{
+	struct mpu_private_data *mpu =
+	    (struct mpu_private_data *)i2c_get_clientdata(client);
+	struct mpu_platform_data *pdata = mpu->mldl_cfg.pdata;
+
+	if (copy_to_user(arg, pdata, sizeof(*pdata)))
+		return -EFAULT;
+	return 0;
+}
+
+static int mpu_dev_ioctl_get_ext_slave_descr(
+	struct i2c_client *client,
+	struct ext_slave_descr __user *arg)
+{
+	struct mpu_private_data *mpu =
+	    (struct mpu_private_data *)i2c_get_clientdata(client);
+	struct ext_slave_descr *slave;
+	struct ext_slave_descr local_slave;
+
+	if (copy_from_user(&local_slave, arg, sizeof(local_slave)))
+		return -EFAULT;
+
+	if (local_slave.type >= EXT_SLAVE_NUM_TYPES)
+		return -EINVAL;
+
+	slave = mpu->mldl_cfg.slave[local_slave.type];
+	/* All but private data and irq_data */
+	if (!slave)
+		return -ENODEV;
+	if (copy_to_user(arg, slave, sizeof(*slave)))
+		return -EFAULT;
+	return 0;
+}
+
+
+/**
+ * slave_config() - Pass a requested slave configuration to the slave sensor
+ *
+ * @adapter the adaptor to use to communicate with the slave
+ * @mldl_cfg the mldl configuration structuer
+ * @slave pointer to the slave descriptor
+ * @usr_config The configuration to pass to the slave sensor
+ *
+ * returns 0 or non-zero error code
+ */
+static int inv_mpu_config(struct mldl_cfg *mldl_cfg,
+			void *gyro_adapter,
+			struct ext_slave_config __user *usr_config)
+{
+	int retval = 0;
+	struct ext_slave_config config;
+
+	retval = copy_from_user(&config, usr_config, sizeof(config));
+	if (retval)
+		return -EFAULT;
+
+	if (config.len && config.data) {
+		void *data;
+		data = kmalloc(config.len, GFP_KERNEL);
+		if (!data)
+			return -ENOMEM;
+
+		retval = copy_from_user(data,
+					(void __user *)config.data, config.len);
+		if (retval) {
+			retval = -EFAULT;
+			kfree(data);
+			return retval;
+		}
+		config.data = data;
+	}
+	retval = gyro_config(gyro_adapter, mldl_cfg, &config);
+	kfree(config.data);
+	return retval;
+}
+
+static int inv_mpu_get_config(struct mldl_cfg *mldl_cfg,
+			    void *gyro_adapter,
+			    struct ext_slave_config __user *usr_config)
+{
+	int retval = 0;
+	struct ext_slave_config config;
+	void *user_data;
+
+	retval = copy_from_user(&config, usr_config, sizeof(config));
+	if (retval)
+		return -EFAULT;
+
+	user_data = config.data;
+	if (config.len && config.data) {
+		void *data;
+		data = kmalloc(config.len, GFP_KERNEL);
+		if (!data)
+			return -ENOMEM;
+
+		retval = copy_from_user(data,
+					(void __user *)config.data, config.len);
+		if (retval) {
+			retval = -EFAULT;
+			kfree(data);
+			return retval;
+		}
+		config.data = data;
+	}
+	retval = gyro_get_config(gyro_adapter, mldl_cfg, &config);
+	if (!retval)
+		retval = copy_to_user((unsigned char __user *)user_data,
+				config.data, config.len);
+	kfree(config.data);
+	return retval;
+}
+
+static int slave_config(struct mldl_cfg *mldl_cfg,
+			void *gyro_adapter,
+			void *slave_adapter,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata,
+			struct ext_slave_config __user *usr_config)
+{
+	int retval = 0;
+	struct ext_slave_config config;
+	if ((!slave) || (!slave->config))
+		return -ENODEV;
+
+	retval = copy_from_user(&config, usr_config, sizeof(config));
+	if (retval)
+		return -EFAULT;
+
+	if (config.len && config.data) {
+		void *data;
+		data = kmalloc(config.len, GFP_KERNEL);
+		if (!data)
+			return -ENOMEM;
+
+		retval = copy_from_user(data,
+					(void __user *)config.data, config.len);
+		if (retval) {
+			retval = -EFAULT;
+			kfree(data);
+			return retval;
+		}
+		config.data = data;
+	}
+	retval = inv_mpu_slave_config(mldl_cfg, gyro_adapter, slave_adapter,
+				      &config, slave, pdata);
+	kfree(config.data);
+	return retval;
+}
+
+static int slave_get_config(struct mldl_cfg *mldl_cfg,
+			    void *gyro_adapter,
+			    void *slave_adapter,
+			    struct ext_slave_descr *slave,
+			    struct ext_slave_platform_data *pdata,
+			    struct ext_slave_config __user *usr_config)
+{
+	int retval = 0;
+	struct ext_slave_config config;
+	void *user_data;
+	if (!(slave) || !(slave->get_config))
+		return -ENODEV;
+
+	retval = copy_from_user(&config, usr_config, sizeof(config));
+	if (retval)
+		return -EFAULT;
+
+	user_data = config.data;
+	if (config.len && config.data) {
+		void *data;
+		data = kmalloc(config.len, GFP_KERNEL);
+		if (!data)
+			return -ENOMEM;
+
+		retval = copy_from_user(data,
+					(void __user *)config.data, config.len);
+		if (retval) {
+			retval = -EFAULT;
+			kfree(data);
+			return retval;
+		}
+		config.data = data;
+	}
+	retval = inv_mpu_get_slave_config(mldl_cfg, gyro_adapter,
+					  slave_adapter, &config, slave, pdata);
+	if (retval) {
+		kfree(config.data);
+		return retval;
+	}
+	retval = copy_to_user((unsigned char __user *)user_data,
+			      config.data, config.len);
+	kfree(config.data);
+	return retval;
+}
+
+static int inv_slave_read(struct mldl_cfg *mldl_cfg,
+			  void *gyro_adapter,
+			  void *slave_adapter,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata,
+			  void __user *usr_data)
+{
+	int retval;
+	unsigned char *data;
+	data = kzalloc(slave->read_len, GFP_KERNEL);
+	if (!data)
+		return -EFAULT;
+
+	retval = inv_mpu_slave_read(mldl_cfg, gyro_adapter, slave_adapter,
+				    slave, pdata, data);
+
+	if ((!retval) &&
+	    (copy_to_user((unsigned char __user *)usr_data,
+			  data, slave->read_len)))
+		retval = -EFAULT;
+
+	kfree(data);
+	return retval;
+}
+
+static int mpu_handle_mlsl(void *sl_handle,
+			   unsigned char addr,
+			   unsigned int cmd,
+			   struct mpu_read_write __user *usr_msg)
+{
+	int retval = 0;
+	struct mpu_read_write msg;
+	unsigned char *user_data;
+	retval = copy_from_user(&msg, usr_msg, sizeof(msg));
+	if (retval)
+		return -EFAULT;
+
+	user_data = msg.data;
+	if (msg.length && msg.data) {
+		unsigned char *data;
+		data = kmalloc(msg.length, GFP_KERNEL);
+		if (!data)
+			return -ENOMEM;
+
+		retval = copy_from_user(data,
+					(void __user *)msg.data, msg.length);
+		if (retval) {
+			retval = -EFAULT;
+			kfree(data);
+			return retval;
+		}
+		msg.data = data;
+	} else {
+		return -EPERM;
+	}
+
+	switch (cmd) {
+	case MPU_READ:
+		retval = inv_serial_read(sl_handle, addr,
+					 msg.address, msg.length, msg.data);
+		//printk("msg.address= %x,msg.length=%d\n" ,msg.address,msg.length);
+		//for(i=1;i<=msg.length;i++)
+		//printk("msg.data=%12.4f\n",msg.data);
+		break;
+	case MPU_WRITE:
+		retval = inv_serial_write(sl_handle, addr,
+					  msg.length, msg.data);
+		break;
+	case MPU_READ_MEM:
+		retval = inv_serial_read_mem(sl_handle, addr,
+					     msg.address, msg.length, msg.data);
+		break;
+	case MPU_WRITE_MEM:
+		retval = inv_serial_write_mem(sl_handle, addr,
+					      msg.address, msg.length,
+					      msg.data);
+		break;
+	case MPU_READ_FIFO:
+		retval = inv_serial_read_fifo(sl_handle, addr,
+					      msg.length, msg.data);
+		break;
+	case MPU_WRITE_FIFO:
+		retval = inv_serial_write_fifo(sl_handle, addr,
+					       msg.length, msg.data);
+		break;
+
+	};
+	if (retval) {
+		dev_err(&((struct i2c_adapter *)sl_handle)->dev,
+			"%s: i2c %d error %d\n",
+			__func__, cmd, retval);
+		kfree(msg.data);
+		return retval;
+	}
+	retval = copy_to_user((unsigned char __user *)user_data,
+			      msg.data, msg.length);
+	kfree(msg.data);
+	return retval;
+}
+
+/* ioctl - I/O control */
+static long mpu_dev_ioctl(struct file *file,
+			  unsigned int cmd, unsigned long arg)
+{
+	struct mpu_private_data *mpu =
+	    container_of(file->private_data, struct mpu_private_data, dev);
+	struct i2c_client *client = mpu->client;
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	int retval = 0;
+	struct i2c_adapter *slave_adapter[EXT_SLAVE_NUM_TYPES];
+	struct ext_slave_descr **slave = mldl_cfg->slave;
+	struct ext_slave_platform_data **pdata_slave = mldl_cfg->pdata_slave;
+	int ii;
+
+	for (ii = 0; ii < EXT_SLAVE_NUM_TYPES; ii++) {
+		if (!pdata_slave[ii])
+			slave_adapter[ii] = NULL;
+		else
+			slave_adapter[ii] =
+				i2c_get_adapter(pdata_slave[ii]->adapt_num);
+	}
+	slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE] = client->adapter;
+
+	retval = mutex_lock_interruptible(&mpu->mutex);
+	if (retval) {
+		dev_err(&client->adapter->dev,
+			"%s: mutex_lock_interruptible returned %d\n",
+			__func__, retval);
+		return retval;
+	}
+
+	switch (cmd) {
+	case MPU_GET_EXT_SLAVE_PLATFORM_DATA:
+		retval = mpu_dev_ioctl_get_ext_slave_platform_data(
+			client,
+			(struct ext_slave_platform_data __user *)arg);
+		break;
+	case MPU_GET_MPU_PLATFORM_DATA:
+		retval = mpu_dev_ioctl_get_mpu_platform_data(
+			client,
+			(struct mpu_platform_data __user *)arg);
+		break;
+	case MPU_GET_EXT_SLAVE_DESCR:
+		retval = mpu_dev_ioctl_get_ext_slave_descr(
+			client,
+			(struct ext_slave_descr __user *)arg);
+		break;
+	case MPU_READ:
+	case MPU_WRITE:
+	case MPU_READ_MEM:
+	case MPU_WRITE_MEM:
+	case MPU_READ_FIFO:
+	case MPU_WRITE_FIFO:
+		retval = mpu_handle_mlsl(
+			slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+			mldl_cfg->mpu_chip_info->addr, cmd,
+			(struct mpu_read_write __user *)arg);
+		break;
+	case MPU_CONFIG_GYRO:
+		retval = inv_mpu_config(
+			mldl_cfg,
+			slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+			(struct ext_slave_config __user *)arg);
+		break;
+	case MPU_CONFIG_ACCEL:
+		retval = slave_config(
+			mldl_cfg,
+			slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+			slave_adapter[EXT_SLAVE_TYPE_ACCEL],
+			slave[EXT_SLAVE_TYPE_ACCEL],
+			pdata_slave[EXT_SLAVE_TYPE_ACCEL],
+			(struct ext_slave_config __user *)arg);
+		break;
+	case MPU_CONFIG_COMPASS:
+		retval = slave_config(
+			mldl_cfg,
+			slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+			slave_adapter[EXT_SLAVE_TYPE_COMPASS],
+			slave[EXT_SLAVE_TYPE_COMPASS],
+			pdata_slave[EXT_SLAVE_TYPE_COMPASS],
+			(struct ext_slave_config __user *)arg);
+		break;
+	case MPU_CONFIG_PRESSURE:
+		retval = slave_config(
+			mldl_cfg,
+			slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+			slave_adapter[EXT_SLAVE_TYPE_PRESSURE],
+			slave[EXT_SLAVE_TYPE_PRESSURE],
+			pdata_slave[EXT_SLAVE_TYPE_PRESSURE],
+			(struct ext_slave_config __user *)arg);
+		break;
+	case MPU_GET_CONFIG_GYRO:
+		retval = inv_mpu_get_config(
+			mldl_cfg,
+			slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+			(struct ext_slave_config __user *)arg);
+		break;
+	case MPU_GET_CONFIG_ACCEL:
+		retval = slave_get_config(
+			mldl_cfg,
+			slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+			slave_adapter[EXT_SLAVE_TYPE_ACCEL],
+			slave[EXT_SLAVE_TYPE_ACCEL],
+			pdata_slave[EXT_SLAVE_TYPE_ACCEL],
+			(struct ext_slave_config __user *)arg);
+		break;
+	case MPU_GET_CONFIG_COMPASS:
+		retval = slave_get_config(
+			mldl_cfg,
+			slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+			slave_adapter[EXT_SLAVE_TYPE_COMPASS],
+			slave[EXT_SLAVE_TYPE_COMPASS],
+			pdata_slave[EXT_SLAVE_TYPE_COMPASS],
+			(struct ext_slave_config __user *)arg);
+		break;
+	case MPU_GET_CONFIG_PRESSURE:
+		retval = slave_get_config(
+			mldl_cfg,
+			slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+			slave_adapter[EXT_SLAVE_TYPE_PRESSURE],
+			slave[EXT_SLAVE_TYPE_PRESSURE],
+			pdata_slave[EXT_SLAVE_TYPE_PRESSURE],
+			(struct ext_slave_config __user *)arg);
+		break;
+	case MPU_SUSPEND:
+		retval = inv_mpu_suspend(
+			mldl_cfg,
+			slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+			slave_adapter[EXT_SLAVE_TYPE_ACCEL],
+			slave_adapter[EXT_SLAVE_TYPE_COMPASS],
+			slave_adapter[EXT_SLAVE_TYPE_PRESSURE],
+			arg);
+		break;
+	case MPU_RESUME:
+		retval = inv_mpu_resume(
+			mldl_cfg,
+			slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+			slave_adapter[EXT_SLAVE_TYPE_ACCEL],
+			slave_adapter[EXT_SLAVE_TYPE_COMPASS],
+			slave_adapter[EXT_SLAVE_TYPE_PRESSURE],
+			arg);
+		break;
+	case MPU_PM_EVENT_HANDLED:
+		dev_dbg(&client->adapter->dev, "%s: %d\n", __func__, cmd);
+		complete(&mpu->completion);
+		break;
+	case MPU_READ_ACCEL:
+		retval = inv_slave_read(
+			mldl_cfg,
+			slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+			slave_adapter[EXT_SLAVE_TYPE_ACCEL],
+			slave[EXT_SLAVE_TYPE_ACCEL],
+			pdata_slave[EXT_SLAVE_TYPE_ACCEL],
+			(unsigned char __user *)arg);
+		break;
+	case MPU_READ_COMPASS:
+		retval = inv_slave_read(
+			mldl_cfg,
+			slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+			slave_adapter[EXT_SLAVE_TYPE_COMPASS],
+			slave[EXT_SLAVE_TYPE_COMPASS],
+			pdata_slave[EXT_SLAVE_TYPE_COMPASS],
+			(unsigned char __user *)arg);
+		break;
+	case MPU_READ_PRESSURE:
+		retval = inv_slave_read(
+			mldl_cfg,
+			slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+			slave_adapter[EXT_SLAVE_TYPE_PRESSURE],
+			slave[EXT_SLAVE_TYPE_PRESSURE],
+			pdata_slave[EXT_SLAVE_TYPE_PRESSURE],
+			(unsigned char __user *)arg);
+		break;
+	case MPU_GET_REQUESTED_SENSORS:
+		if (copy_to_user(
+			   (__u32 __user *)arg,
+			   &mldl_cfg->inv_mpu_cfg->requested_sensors,
+			   sizeof(mldl_cfg->inv_mpu_cfg->requested_sensors)))
+			retval = -EFAULT;
+		break;
+	case MPU_SET_REQUESTED_SENSORS:
+		mldl_cfg->inv_mpu_cfg->requested_sensors = arg;
+		break;
+	case MPU_GET_IGNORE_SYSTEM_SUSPEND:
+		if (copy_to_user(
+			(unsigned char __user *)arg,
+			&mldl_cfg->inv_mpu_cfg->ignore_system_suspend,
+			sizeof(mldl_cfg->inv_mpu_cfg->ignore_system_suspend)))
+			retval = -EFAULT;
+		break;
+	case MPU_SET_IGNORE_SYSTEM_SUSPEND:
+		mldl_cfg->inv_mpu_cfg->ignore_system_suspend = arg;
+		break;
+	case MPU_GET_MLDL_STATUS:
+		if (copy_to_user(
+			(unsigned char __user *)arg,
+			&mldl_cfg->inv_mpu_state->status,
+			sizeof(mldl_cfg->inv_mpu_state->status)))
+			retval = -EFAULT;
+		break;
+	case MPU_GET_I2C_SLAVES_ENABLED:
+		if (copy_to_user(
+			(unsigned char __user *)arg,
+			&mldl_cfg->inv_mpu_state->i2c_slaves_enabled,
+			sizeof(mldl_cfg->inv_mpu_state->i2c_slaves_enabled)))
+			retval = -EFAULT;
+		break;
+	default:
+		dev_err(&client->adapter->dev,
+			"%s: Unknown cmd %x, arg %lu\n",
+			__func__, cmd, arg);
+		retval = -EINVAL;
+	};
+
+	mutex_unlock(&mpu->mutex);
+	dev_dbg(&client->adapter->dev, "%s: %08x, %08lx, %d\n",
+		__func__, cmd, arg, retval);
+
+	if (retval > 0)
+		retval = -retval;
+
+	return retval;
+}
+
+void mpu_shutdown(struct i2c_client *client)
+{
+	struct mpu_private_data *mpu =
+	    (struct mpu_private_data *)i2c_get_clientdata(client);
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	struct i2c_adapter *slave_adapter[EXT_SLAVE_NUM_TYPES];
+	struct ext_slave_platform_data **pdata_slave = mldl_cfg->pdata_slave;
+	int ii;
+
+	for (ii = 0; ii < EXT_SLAVE_NUM_TYPES; ii++) {
+		if (!pdata_slave[ii])
+			slave_adapter[ii] = NULL;
+		else
+			slave_adapter[ii] =
+				i2c_get_adapter(pdata_slave[ii]->adapt_num);
+	}
+	slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE] = client->adapter;
+
+	mutex_lock(&mpu->mutex);
+	(void)inv_mpu_suspend(mldl_cfg,
+			slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+			slave_adapter[EXT_SLAVE_TYPE_ACCEL],
+			slave_adapter[EXT_SLAVE_TYPE_COMPASS],
+			slave_adapter[EXT_SLAVE_TYPE_PRESSURE],
+			INV_ALL_SENSORS);
+	mutex_unlock(&mpu->mutex);
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+}
+
+int mpu_dev_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct mpu_private_data *mpu =
+	    (struct mpu_private_data *)i2c_get_clientdata(client);
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	struct i2c_adapter *slave_adapter[EXT_SLAVE_NUM_TYPES];
+	struct ext_slave_platform_data **pdata_slave = mldl_cfg->pdata_slave;
+	int ii;
+
+	for (ii = 0; ii < EXT_SLAVE_NUM_TYPES; ii++) {
+		if (!pdata_slave[ii])
+			slave_adapter[ii] = NULL;
+		else
+			slave_adapter[ii] =
+				i2c_get_adapter(pdata_slave[ii]->adapt_num);
+	}
+	slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE] = client->adapter;
+
+	mutex_lock(&mpu->mutex);
+	if (!mldl_cfg->inv_mpu_cfg->ignore_system_suspend) {
+		dev_dbg(&client->adapter->dev,
+			"%s: suspending on event %d\n", __func__, mesg.event);
+		(void)inv_mpu_suspend(mldl_cfg,
+				slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+				slave_adapter[EXT_SLAVE_TYPE_ACCEL],
+				slave_adapter[EXT_SLAVE_TYPE_COMPASS],
+				slave_adapter[EXT_SLAVE_TYPE_PRESSURE],
+				INV_ALL_SENSORS);
+	} else {
+		dev_dbg(&client->adapter->dev,
+			"%s: Already suspended %d\n", __func__, mesg.event);
+	}
+	mutex_unlock(&mpu->mutex);
+	return 0;
+}
+
+int mpu_dev_resume(struct i2c_client *client)
+{
+	struct mpu_private_data *mpu =
+	    (struct mpu_private_data *)i2c_get_clientdata(client);
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	struct i2c_adapter *slave_adapter[EXT_SLAVE_NUM_TYPES];
+	struct ext_slave_platform_data **pdata_slave = mldl_cfg->pdata_slave;
+	int ii;
+
+	for (ii = 0; ii < EXT_SLAVE_NUM_TYPES; ii++) {
+		if (!pdata_slave[ii])
+			slave_adapter[ii] = NULL;
+		else
+			slave_adapter[ii] =
+				i2c_get_adapter(pdata_slave[ii]->adapt_num);
+	}
+	slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE] = client->adapter;
+
+	mutex_lock(&mpu->mutex);
+	if (mpu->pid && !mldl_cfg->inv_mpu_cfg->ignore_system_suspend) {
+		(void)inv_mpu_resume(mldl_cfg,
+				slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+				slave_adapter[EXT_SLAVE_TYPE_ACCEL],
+				slave_adapter[EXT_SLAVE_TYPE_COMPASS],
+				slave_adapter[EXT_SLAVE_TYPE_PRESSURE],
+				mldl_cfg->inv_mpu_cfg->requested_sensors);
+		dev_dbg(&client->adapter->dev,
+			"%s for pid %d\n", __func__, mpu->pid);
+	}
+	mutex_unlock(&mpu->mutex);
+	return 0;
+}
+//20130411nick++++++
+enum {
+	DEBUG_INIT = 1U << 0,
+	DEBUG_CONTROL_INFO = 1U << 1,
+	DEBUG_REPORT_DATA = 1U << 2,
+	DEBUG_SUSPEND = 1U << 3,
+	DEBUG_INT = 1U << 4,
+};
+//static const unsigned short i2c_address[] = {0x68,0x69};
+static u32 debug_mask = 0;
+
+#define dprintk(level_mask,fmt,arg...)    if(unlikely(debug_mask & level_mask)) \
+        printk("***CTP***"fmt, ## arg)
+static __u32 mpu6050c_twi_id = -1;
+__u8 mpu6050c_level_shifter , mpu6050c_int_config;
+u32 mpu6050c_gy_int1;
+static int mpu6050c_fetch_sysconfig_para(void)
+{
+	int ret = -1;
+	int device_used = -1;
+	script_item_u	val;
+	script_item_value_type_e  type;
+	
+		
+	dprintk(DEBUG_INIT,"========%s===================\n", __func__);
+
+	
+	type = script_get_item("mpu6050c_para", "mpu6050c_used", &val);
+ 
+	if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+		pr_err("%s: type err  device_used = %d. \n", __func__, val.val);
+		goto script_get_err;
+	}
+	device_used = val.val;
+	
+	if (1 == device_used) {
+		type = script_get_item("mpu6050c_para", "mpu6050c_twi_id", &val);	
+		if(SCIRPT_ITEM_VALUE_TYPE_INT != type){
+			pr_err("%s: type err twi_id = %d. \n", __func__, val.val);
+			goto script_get_err;
+		}
+		mpu6050c_twi_id = val.val;
+		
+		dprintk(DEBUG_INIT,"%s: mpu6050c_twi_id is %d. \n", __func__, mpu6050c_twi_id);
+		
+		type = script_get_item("mpu6050c_para", "mpu6050c_level_shifter", &val);	
+		if(SCIRPT_ITEM_VALUE_TYPE_INT != type){
+			pr_err("%s: type err mpu6050c_level_shifter = %d. \n", __func__, val.val);
+			goto script_get_err;
+		}
+		mpu6050c_level_shifter = val.val;
+
+		dprintk(DEBUG_INIT,"%s: level_shifter is %d. \n", __func__, mpu6050c_level_shifter);
+
+		type = script_get_item("mpu6050c_para", "mpu6050c_int_config", &val);	
+		if(SCIRPT_ITEM_VALUE_TYPE_INT != type){
+			pr_err("%s: type err mpu6050c_int_config = %d. \n", __func__, val.val);
+			goto script_get_err;
+		}
+		mpu6050c_int_config = val.val;
+
+		dprintk(DEBUG_INIT,"%s: mpu6050c_int_config is %d. \n", __func__, mpu6050c_int_config);
+
+		ret = 0;
+		
+	} else {
+		pr_err("%s: mpu6050c_unused. \n",  __func__);
+		ret = -1;
+	}
+
+	return ret;
+
+script_get_err:
+	pr_notice("=========script_get_err============\n");
+	return ret;
+
+}
+
+/**
+ * mpu6050c_init_platform_resource - initialize platform related resource
+ * return value: 0 : success
+ *               -EIO :  i/o err.
+ *
+ */
+int mpu6050c_init_platform_resource(void)
+{	
+
+	script_item_u   item;
+	script_item_value_type_e   type;
+
+        
+	type = script_get_item("mpu6050c_para", "mpu6050c_int1", &item);
+	if(SCIRPT_ITEM_VALUE_TYPE_PIO != type) {
+		pr_err("script_get_item mpu6050c_int_port type err\n");
+		return -1;
+	}
+        mpu6050c_gy_int1 = item.gpio.gpio;
+	return 0;
+}
+EXPORT_SYMBOL(mpu6050c_init_platform_resource);
+
+
+/**
+ * MPU6050C_detect - Device detection callback for automatic device creation
+ * return value:  
+ *                    = 0; success;
+ *                    < 0; err
+ */
+static int MPU6050C_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	int ret;
+	int err = -1;
+	u8 buf[1];
+	u8 cmd;
+	
+	printk("enter func %s. \n", __func__);
+	
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+		return -ENODEV;
+
+	if(mpu6050c_twi_id == adapter->nr){
+		//for(i2c_num = 0; i2c_num < (sizeof(i2c_address)/sizeof(i2c_address[0]));i2c_num++){	    
+			client->addr = 0x69;//i2c_address[i2c_num];
+
+			dprintk(DEBUG_INIT,"check i2c addr: %x .\n", client->addr);
+			buf[0] = 0x75;//20130411++++++nick,WHO_AM_I address
+			cmd = buf[0];
+
+			
+			ret = i2c_master_send(client, &cmd, sizeof(cmd));
+			if (ret != sizeof(cmd))
+				return ret;
+
+			dprintk(DEBUG_INIT,"check i2c addr: %x after send cmd.\n", client->addr);
+
+			err = i2c_master_recv(client, buf, 1);
+
+			dprintk(DEBUG_INIT,"check i2c addr: %x after recv cmd.\n", client->addr);			
+
+			if (err < 0) {
+				dev_warn(&client->dev, "Error reading WHO_AM_I: is device"
+					" available/working?\n");
+				
+			}else	if (buf[0] != 0x68 && buf[0] != 0x69) {//20130411++++++nick,WHO_AM_I address default value is 0x68
+				dev_err(&client->dev,
+					"device unknown. Expected: 0x%02x,"
+					" Replies: 0x%02x\n", 0x68, buf[0]);
+			}else {
+				pr_info("%s:addr= 0x%x\n",__func__,client->addr);
+				strlcpy(info->type, MPU_NAME, I2C_NAME_SIZE);
+				return 0;
+			}
+
+		//}
+	
+		pr_info("%s:mpu6050c Device not found, \
+			 maybe the other e_compass equipment! \n",__func__);
+		return -ENODEV;
+	}else{
+		return -ENODEV;
+	}
+
+}
+//20130411nick------
+
+/* define which file operations are supported */
+static const struct file_operations mpu_fops = {
+	.owner = THIS_MODULE,
+	.read = mpu_read,
+	.poll = mpu_poll,
+	.unlocked_ioctl = mpu_dev_ioctl,
+	.open = mpu_dev_open,
+	.release = mpu_release,
+};
+
+int inv_mpu_register_slave(struct module *slave_module,
+			struct i2c_client *slave_client,
+			struct ext_slave_platform_data *slave_pdata,
+			struct ext_slave_descr *(*get_slave_descr)(void))
+{
+	struct mpu_private_data *mpu = mpu_private_data;
+	struct mldl_cfg *mldl_cfg;
+	struct ext_slave_descr *slave_descr;
+	struct ext_slave_platform_data **pdata_slave;
+	char *irq_name = NULL;
+	int result = 0;
+
+	if (!slave_client || !slave_pdata || !get_slave_descr)
+		return -EINVAL;
+
+	if (!mpu) {
+		dev_err(&slave_client->adapter->dev,
+			"%s: Null mpu_private_data\n", __func__);
+		return -EINVAL;
+	}
+	mldl_cfg    = &mpu->mldl_cfg;
+	pdata_slave = mldl_cfg->pdata_slave;
+	slave_descr = get_slave_descr();
+
+	if (!slave_descr) {
+		dev_err(&slave_client->adapter->dev,
+			"%s: Null ext_slave_descr\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&mpu->mutex);
+	if (mpu->pid) {
+		mutex_unlock(&mpu->mutex);
+		return -EBUSY;
+	}
+
+	if (pdata_slave[slave_descr->type]) {
+		result = -EBUSY;
+		goto out_unlock_mutex;
+	}
+
+	slave_pdata->address	= slave_client->addr;
+	slave_pdata->irq	= slave_client->irq;
+	slave_pdata->adapt_num	= i2c_adapter_id(slave_client->adapter);
+
+	dev_info(&slave_client->adapter->dev,
+		"%s: +%s Type %d: Addr: %2x IRQ: %2d, Adapt: %2d\n",
+		__func__,
+		slave_descr->name,
+		slave_descr->type,
+		slave_pdata->address,
+		slave_pdata->irq,
+		slave_pdata->adapt_num);
+
+	switch (slave_descr->type) {
+	case EXT_SLAVE_TYPE_ACCEL:
+		irq_name = "accelirq";
+		break;
+	case EXT_SLAVE_TYPE_COMPASS:
+		irq_name = "compassirq";
+		break;
+	case EXT_SLAVE_TYPE_PRESSURE:
+		irq_name = "pressureirq";
+		break;
+	default:
+		irq_name = "none";
+	};
+	if (slave_descr->init) {
+		result = slave_descr->init(slave_client->adapter,
+					slave_descr,
+					slave_pdata);
+		if (result) {
+			dev_err(&slave_client->adapter->dev,
+				"%s init failed %d\n",
+				slave_descr->name, result);
+			goto out_unlock_mutex;
+		}
+	}
+
+	if (slave_descr->type == EXT_SLAVE_TYPE_ACCEL &&
+	    slave_descr->id == ACCEL_ID_MPU6050 &&
+	    slave_descr->config) {
+		/* pass a reference to the mldl_cfg data
+		   structure to the mpu6050 accel "class" */
+		struct ext_slave_config config;
+		config.key = MPU_SLAVE_CONFIG_INTERNAL_REFERENCE;
+		config.len = sizeof(struct mldl_cfg *);
+		config.apply = true;
+		config.data = mldl_cfg;
+		result = slave_descr->config(
+			slave_client->adapter, slave_descr,
+			slave_pdata, &config);
+		if (result) {
+			LOG_RESULT_LOCATION(result);
+			goto out_slavedescr_exit;
+		}
+	}
+	pdata_slave[slave_descr->type] = slave_pdata;
+	mpu->slave_modules[slave_descr->type] = slave_module;
+	mldl_cfg->slave[slave_descr->type] = slave_descr;
+
+	goto out_unlock_mutex;
+
+out_slavedescr_exit:
+
+	if (slave_descr->exit)
+		slave_descr->exit(slave_client->adapter,
+				  slave_descr, slave_pdata);
+out_unlock_mutex:
+	mutex_unlock(&mpu->mutex);
+
+	if (!result && irq_name && (slave_pdata->irq > 0)) {
+		int warn_result;
+		dev_info(&slave_client->adapter->dev,
+			"Installing %s irq using %d\n",
+			irq_name,
+			slave_pdata->irq);
+		warn_result = slaveirq_init(slave_client->adapter,
+					slave_pdata, irq_name);
+		if (result)
+			dev_WARN(&slave_client->adapter->dev,
+				"%s irq assigned error: %d\n",
+				slave_descr->name, warn_result);
+	} else {
+		dev_WARN(&slave_client->adapter->dev,
+			"%s irq not assigned: %d %d %d\n",
+			slave_descr->name,
+			result, (int)irq_name, slave_pdata->irq);
+	}
+
+	return result;
+}
+EXPORT_SYMBOL(inv_mpu_register_slave);
+
+void inv_mpu_unregister_slave(struct i2c_client *slave_client,
+			struct ext_slave_platform_data *slave_pdata,
+			struct ext_slave_descr *(*get_slave_descr)(void))
+{
+	struct mpu_private_data *mpu = mpu_private_data;
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	struct ext_slave_descr *slave_descr;
+	int result;
+
+	dev_info(&slave_client->adapter->dev, "%s\n", __func__);
+
+	if (!slave_client || !slave_pdata || !get_slave_descr)
+		return;
+
+	if (slave_pdata->irq)
+		slaveirq_exit(slave_pdata);
+
+	slave_descr = get_slave_descr();
+	if (!slave_descr)
+		return;
+
+	mutex_lock(&mpu->mutex);
+
+	if (slave_descr->exit) {
+		result = slave_descr->exit(slave_client->adapter,
+					slave_descr,
+					slave_pdata);
+		if (result)
+			dev_err(&slave_client->adapter->dev,
+				"Accel exit failed %d\n", result);
+	}
+	mldl_cfg->slave[slave_descr->type] = NULL;
+	mldl_cfg->pdata_slave[slave_descr->type] = NULL;
+	mpu->slave_modules[slave_descr->type] = NULL;
+
+	mutex_unlock(&mpu->mutex);
+
+}
+EXPORT_SYMBOL(inv_mpu_unregister_slave);
+
+static unsigned short normal_i2c[] = { 0x69,I2C_CLIENT_END };
+
+static const struct i2c_device_id mpu_id[] = {
+	{"mpu3050", 0},
+	{"mpu6050B1", 0},
+	{"mpu6050_no_accel", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, mpu_id);
+
+int mpu_probe(struct i2c_client *client, const struct i2c_device_id *devid)
+{
+	//struct mpu_platform_data pdata ={//20130411++++++nick
+		//.int_config = 0x10,//mpu6050c_int_config,
+		//.level_shifter = 0,//mpu6050c_level_shifter,
+		//.orientation = { 0,  1,  0, 
+		//		1,  0,  0 , 
+		//		0,  0, -1 },
+		//};//20130411------nick
+	struct mpu_private_data *mpu;
+	struct mldl_cfg *mldl_cfg;
+	int res = 0;
+	int ii = 0;
+
+	dev_info(&client->adapter->dev, "%s: %d\n", __func__, ii++);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		res = -ENODEV;
+		goto out_check_functionality_failed;
+	}
+
+	mpu = kzalloc(sizeof(struct mpu_private_data), GFP_KERNEL);
+	if (!mpu) {
+		res = -ENOMEM;
+		goto out_alloc_data_failed;
+	}
+	mldl_cfg = &mpu->mldl_cfg;
+	mldl_cfg->mpu_ram	= &mpu->mpu_ram;
+	mldl_cfg->mpu_gyro_cfg	= &mpu->mpu_gyro_cfg;
+	mldl_cfg->mpu_offsets	= &mpu->mpu_offsets;
+	mldl_cfg->mpu_chip_info	= &mpu->mpu_chip_info;
+	mldl_cfg->inv_mpu_cfg	= &mpu->inv_mpu_cfg;
+	mldl_cfg->inv_mpu_state	= &mpu->inv_mpu_state;
+
+	mldl_cfg->mpu_ram->length = MPU_MEM_NUM_RAM_BANKS * MPU_MEM_BANK_SIZE;
+	mldl_cfg->mpu_ram->ram = kzalloc(mldl_cfg->mpu_ram->length, GFP_KERNEL);
+	if (!mldl_cfg->mpu_ram->ram) {
+		res = -ENOMEM;
+		goto out_alloc_ram_failed;
+	}
+	mpu_private_data = mpu;
+	i2c_set_clientdata(client, mpu);
+	mpu->client = client;
+
+	init_waitqueue_head(&mpu->mpu_event_wait);
+	mutex_init(&mpu->mutex);
+	init_completion(&mpu->completion);
+
+	mpu->response_timeout = 60;	/* Seconds */
+	mpu->timeout.function = mpu_pm_timeout;
+	mpu->timeout.data = (u_long) mpu;
+	init_timer(&mpu->timeout);
+
+	mpu->nb.notifier_call = mpu_pm_notifier_callback;
+	mpu->nb.priority = 0;
+	res = register_pm_notifier(&mpu->nb);
+	if (res) {
+		dev_err(&client->adapter->dev,
+			"Unable to register pm_notifier %d\n", res);
+		goto out_register_pm_notifier_failed;
+	}
+//20130411++++++nick
+	//pdata = (struct mpu_platform_data *)client->dev.platform_data;
+	//pdata->int_config = mpu6050c_int_config;
+	//pdata->level_shifter = mpu6050c_level_shifter;
+	//pdata->orientation[9] = { 0,  -1,  0, -1,  0,  0 , 0,  0, -1 };
+
+	//if (!pdata) {
+	//	printk(&client->adapter->dev,
+	//		 "Missing platform data for mpu\n");
+	//}
+//20130411------nick
+
+	mldl_cfg->pdata = &gyrodata;//20130511++++++nick
+
+	mldl_cfg->mpu_chip_info->addr = client->addr;
+	res = inv_mpu_open(&mpu->mldl_cfg, client->adapter, NULL, NULL, NULL);
+
+	if (res) {
+		dev_err(&client->adapter->dev,
+			"Unable to open %s %d\n", MPU_NAME, res);
+		res = -ENODEV;
+		goto out_whoami_failed;
+	}
+
+	mpu->dev.minor = MISC_DYNAMIC_MINOR;
+	mpu->dev.name = "mpu";
+	mpu->dev.fops = &mpu_fops;
+	res = misc_register(&mpu->dev);
+	if (res < 0) {
+		dev_err(&client->adapter->dev,
+			"ERROR: misc_register returned %d\n", res);
+		goto out_misc_register_failed;
+	}
+	
+	client->irq = mpu6050c_gy_int1;//20130411++++++nick 
+	if (client->irq) {
+		dev_info(&client->adapter->dev,
+			 "Installing irq using %d\n", client->irq);
+		res = mpuirq_init(client, mldl_cfg);
+		if (res)
+			goto out_mpuirq_failed;
+	} else {
+		dev_WARN(&client->adapter->dev,
+			 "Missing %s IRQ\n", MPU_NAME);
+	}
+	if (!strcmp(mpu_id[1].name, devid->name)) {
+		/* Special case to re-use the inv_mpu_register_slave */
+		struct ext_slave_platform_data *slave_pdata;
+		slave_pdata = kzalloc(sizeof(*slave_pdata), GFP_KERNEL);
+		if (!slave_pdata) {
+			res = -ENOMEM;
+			goto out_slave_pdata_kzalloc_failed;
+		}
+		slave_pdata->bus = EXT_SLAVE_BUS_PRIMARY;
+		for (ii = 0; ii < 9; ii++)
+			slave_pdata->orientation[ii] = mldl_cfg->pdata->orientation[ii];//20130411++++++nick
+		res = inv_mpu_register_slave(
+			NULL, client,
+			slave_pdata,
+			mpu6050_get_slave_descr);
+		if (res) {
+			/* if inv_mpu_register_slave fails there are no pointer
+			   references to the memory allocated to slave_pdata */
+			kfree(slave_pdata);
+			goto out_slave_pdata_kzalloc_failed;
+		}
+	}
+	return res;
+
+out_slave_pdata_kzalloc_failed:
+	if (client->irq)
+		mpuirq_exit();
+out_mpuirq_failed:
+	misc_deregister(&mpu->dev);
+out_misc_register_failed:
+	inv_mpu_close(&mpu->mldl_cfg, client->adapter, NULL, NULL, NULL);
+out_whoami_failed:
+	unregister_pm_notifier(&mpu->nb);
+out_register_pm_notifier_failed:
+	kfree(mldl_cfg->mpu_ram->ram);
+	mpu_private_data = NULL;
+out_alloc_ram_failed:
+	kfree(mpu);
+out_alloc_data_failed:
+out_check_functionality_failed:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, res);
+	return res;
+
+}
+
+static int mpu_remove(struct i2c_client *client)
+{
+	struct mpu_private_data *mpu = i2c_get_clientdata(client);
+	struct i2c_adapter *slave_adapter[EXT_SLAVE_NUM_TYPES];
+	struct mldl_cfg *mldl_cfg = &mpu->mldl_cfg;
+	struct ext_slave_platform_data **pdata_slave = mldl_cfg->pdata_slave;
+	int ii;
+
+	for (ii = 0; ii < EXT_SLAVE_NUM_TYPES; ii++) {
+		if (!pdata_slave[ii])
+			slave_adapter[ii] = NULL;
+		else
+			slave_adapter[ii] =
+				i2c_get_adapter(pdata_slave[ii]->adapt_num);
+	}
+
+	slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE] = client->adapter;
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_close(mldl_cfg,
+		slave_adapter[EXT_SLAVE_TYPE_GYROSCOPE],
+		slave_adapter[EXT_SLAVE_TYPE_ACCEL],
+		slave_adapter[EXT_SLAVE_TYPE_COMPASS],
+		slave_adapter[EXT_SLAVE_TYPE_PRESSURE]);
+
+	if (mldl_cfg->slave[EXT_SLAVE_TYPE_ACCEL] &&
+		(mldl_cfg->slave[EXT_SLAVE_TYPE_ACCEL]->id ==
+			ACCEL_ID_MPU6050)) {
+		struct ext_slave_platform_data *slave_pdata =
+			mldl_cfg->pdata_slave[EXT_SLAVE_TYPE_ACCEL];
+		inv_mpu_unregister_slave(
+			client,
+			mldl_cfg->pdata_slave[EXT_SLAVE_TYPE_ACCEL],
+			mpu6050_get_slave_descr);
+		kfree(slave_pdata);
+	}
+
+	if (client->irq)
+		mpuirq_exit();
+
+	misc_deregister(&mpu->dev);
+
+	unregister_pm_notifier(&mpu->nb);
+
+	kfree(mpu->mldl_cfg.mpu_ram->ram);
+	kfree(mpu);
+
+	return 0;
+}
+
+static struct i2c_driver mpu_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = mpu_probe,
+	.remove = mpu_remove,
+	.id_table = mpu_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = MPU_NAME,
+		   },
+	.address_list = normal_i2c,
+	.shutdown = mpu_shutdown,	/* optional */
+	.suspend = mpu_dev_suspend,	/* optional */
+	.resume = mpu_dev_resume,	/* optional */
+
+};
+
+static int __init mpu_init(void)
+{
+	//20130411++++++nick
+	int err = -1 , res;
+	if (mpu6050c_fetch_sysconfig_para()) {
+		printk("%s: err.\n", __func__);
+		return -1;
+	}
+	else{
+		err = mpu6050c_init_platform_resource();
+		if(0 != err){
+        		printk("%s:mpu6050c init_platform_resource err. \n", __func__);    
+        	}
+	}
+	mpu_driver.detect = MPU6050C_detect;
+	//20130411------nick
+	res = i2c_add_driver(&mpu_driver);
+	pr_info("%s: Probe name %s\n", __func__, MPU_NAME);
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit mpu_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&mpu_driver);
+	//gpio_free(mpu6050c_gy_int1);
+}
+
+module_init(mpu_init);
+module_exit(mpu_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("User space character device interface for MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS(MPU_NAME);
diff --git a/drivers/misc/inv_mpu/mpu-dev.h b/drivers/misc/inv_mpu/mpu-dev.h
new file mode 100644
index 0000000..b6a4fcf
--- /dev/null
+++ b/drivers/misc/inv_mpu/mpu-dev.h
@@ -0,0 +1,36 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+
+#ifndef __MPU_DEV_H__
+#define __MPU_DEV_H__
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/mpu.h>
+
+int inv_mpu_register_slave(struct module *slave_module,
+			struct i2c_client *client,
+			struct ext_slave_platform_data *pdata,
+			struct ext_slave_descr *(*slave_descr)(void));
+
+void inv_mpu_unregister_slave(struct i2c_client *client,
+			struct ext_slave_platform_data *pdata,
+			struct ext_slave_descr *(*slave_descr)(void));
+#endif
diff --git a/drivers/misc/inv_mpu/mpu6050b1.h b/drivers/misc/inv_mpu/mpu6050b1.h
new file mode 100644
index 0000000..c1b0f46
--- /dev/null
+++ b/drivers/misc/inv_mpu/mpu6050b1.h
@@ -0,0 +1,435 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ * @defgroup
+ * @brief
+ *
+ * @{
+ *      @file     mpu6050.h
+ *      @brief
+ */
+
+#ifndef __MPU_H_
+#error Do not include this file directly.  Include mpu.h instead.
+#endif
+
+#ifndef __MPU6050B1_H_
+#define __MPU6050B1_H_
+
+
+#define MPU_NAME "mpu6050B1"
+#define DEFAULT_MPU_SLAVEADDR		0x69//nick++++++20130419
+
+/*==== MPU6050B1 REGISTER SET ====*/
+enum {
+	MPUREG_XG_OFFS_TC = 0,			/* 0x00,   0 */
+	MPUREG_YG_OFFS_TC,			/* 0x01,   1 */
+	MPUREG_ZG_OFFS_TC,			/* 0x02,   2 */
+	MPUREG_X_FINE_GAIN,			/* 0x03,   3 */
+	MPUREG_Y_FINE_GAIN,			/* 0x04,   4 */
+	MPUREG_Z_FINE_GAIN,			/* 0x05,   5 */
+	MPUREG_XA_OFFS_H,			/* 0x06,   6 */
+	MPUREG_XA_OFFS_L,			/* 0x07,   7 */
+	MPUREG_YA_OFFS_H,			/* 0x08,   8 */
+	MPUREG_YA_OFFS_L,			/* 0x09,   9 */
+	MPUREG_ZA_OFFS_H,			/* 0x0a,  10 */
+	MPUREG_ZA_OFFS_L,			/* 0x0B,  11 */
+	MPUREG_PRODUCT_ID,			/* 0x0c,  12 */
+	MPUREG_0D_RSVD,				/* 0x0d,  13 */
+	MPUREG_0E_RSVD,				/* 0x0e,  14 */
+	MPUREG_0F_RSVD,				/* 0x0f,  15 */
+	MPUREG_10_RSVD,				/* 0x00,  16 */
+	MPUREG_11_RSVD,				/* 0x11,  17 */
+	MPUREG_12_RSVD,				/* 0x12,  18 */
+	MPUREG_XG_OFFS_USRH,			/* 0x13,  19 */
+	MPUREG_XG_OFFS_USRL,			/* 0x14,  20 */
+	MPUREG_YG_OFFS_USRH,			/* 0x15,  21 */
+	MPUREG_YG_OFFS_USRL,			/* 0x16,  22 */
+	MPUREG_ZG_OFFS_USRH,			/* 0x17,  23 */
+	MPUREG_ZG_OFFS_USRL,			/* 0x18,  24 */
+	MPUREG_SMPLRT_DIV,			/* 0x19,  25 */
+	MPUREG_CONFIG,				/* 0x1A,  26 */
+	MPUREG_GYRO_CONFIG,			/* 0x1b,  27 */
+	MPUREG_ACCEL_CONFIG,			/* 0x1c,  28 */
+	MPUREG_ACCEL_FF_THR,			/* 0x1d,  29 */
+	MPUREG_ACCEL_FF_DUR,			/* 0x1e,  30 */
+	MPUREG_ACCEL_MOT_THR,			/* 0x1f,  31 */
+	MPUREG_ACCEL_MOT_DUR,			/* 0x20,  32 */
+	MPUREG_ACCEL_ZRMOT_THR,			/* 0x21,  33 */
+	MPUREG_ACCEL_ZRMOT_DUR,			/* 0x22,  34 */
+	MPUREG_FIFO_EN,				/* 0x23,  35 */
+	MPUREG_I2C_MST_CTRL,			/* 0x24,  36 */
+	MPUREG_I2C_SLV0_ADDR,			/* 0x25,  37 */
+	MPUREG_I2C_SLV0_REG,			/* 0x26,  38 */
+	MPUREG_I2C_SLV0_CTRL,			/* 0x27,  39 */
+	MPUREG_I2C_SLV1_ADDR,			/* 0x28,  40 */
+	MPUREG_I2C_SLV1_REG,			/* 0x29,  41 */
+	MPUREG_I2C_SLV1_CTRL,			/* 0x2a,  42 */
+	MPUREG_I2C_SLV2_ADDR,			/* 0x2B,  43 */
+	MPUREG_I2C_SLV2_REG,			/* 0x2c,  44 */
+	MPUREG_I2C_SLV2_CTRL,			/* 0x2d,  45 */
+	MPUREG_I2C_SLV3_ADDR,			/* 0x2E,  46 */
+	MPUREG_I2C_SLV3_REG,			/* 0x2f,  47 */
+	MPUREG_I2C_SLV3_CTRL,			/* 0x30,  48 */
+	MPUREG_I2C_SLV4_ADDR,			/* 0x31,  49 */
+	MPUREG_I2C_SLV4_REG,			/* 0x32,  50 */
+	MPUREG_I2C_SLV4_DO,			/* 0x33,  51 */
+	MPUREG_I2C_SLV4_CTRL,			/* 0x34,  52 */
+	MPUREG_I2C_SLV4_DI,			/* 0x35,  53 */
+	MPUREG_I2C_MST_STATUS,			/* 0x36,  54 */
+	MPUREG_INT_PIN_CFG,			/* 0x37,  55 */
+	MPUREG_INT_ENABLE,			/* 0x38,  56 */
+	MPUREG_DMP_INT_STATUS,			/* 0x39,  57 */
+	MPUREG_INT_STATUS,			/* 0x3A,  58 */
+	MPUREG_ACCEL_XOUT_H,			/* 0x3B,  59 */
+	MPUREG_ACCEL_XOUT_L,			/* 0x3c,  60 */
+	MPUREG_ACCEL_YOUT_H,			/* 0x3d,  61 */
+	MPUREG_ACCEL_YOUT_L,			/* 0x3e,  62 */
+	MPUREG_ACCEL_ZOUT_H,			/* 0x3f,  63 */
+	MPUREG_ACCEL_ZOUT_L,			/* 0x40,  64 */
+	MPUREG_TEMP_OUT_H,			/* 0x41,  65 */
+	MPUREG_TEMP_OUT_L,			/* 0x42,  66 */
+	MPUREG_GYRO_XOUT_H,			/* 0x43,  67 */
+	MPUREG_GYRO_XOUT_L,			/* 0x44,  68 */
+	MPUREG_GYRO_YOUT_H,			/* 0x45,  69 */
+	MPUREG_GYRO_YOUT_L,			/* 0x46,  70 */
+	MPUREG_GYRO_ZOUT_H,			/* 0x47,  71 */
+	MPUREG_GYRO_ZOUT_L,			/* 0x48,  72 */
+	MPUREG_EXT_SLV_SENS_DATA_00,		/* 0x49,  73 */
+	MPUREG_EXT_SLV_SENS_DATA_01,		/* 0x4a,  74 */
+	MPUREG_EXT_SLV_SENS_DATA_02,		/* 0x4b,  75 */
+	MPUREG_EXT_SLV_SENS_DATA_03,		/* 0x4c,  76 */
+	MPUREG_EXT_SLV_SENS_DATA_04,		/* 0x4d,  77 */
+	MPUREG_EXT_SLV_SENS_DATA_05,		/* 0x4e,  78 */
+	MPUREG_EXT_SLV_SENS_DATA_06,		/* 0x4F,  79 */
+	MPUREG_EXT_SLV_SENS_DATA_07,		/* 0x50,  80 */
+	MPUREG_EXT_SLV_SENS_DATA_08,		/* 0x51,  81 */
+	MPUREG_EXT_SLV_SENS_DATA_09,		/* 0x52,  82 */
+	MPUREG_EXT_SLV_SENS_DATA_10,		/* 0x53,  83 */
+	MPUREG_EXT_SLV_SENS_DATA_11,		/* 0x54,  84 */
+	MPUREG_EXT_SLV_SENS_DATA_12,		/* 0x55,  85 */
+	MPUREG_EXT_SLV_SENS_DATA_13,		/* 0x56,  86 */
+	MPUREG_EXT_SLV_SENS_DATA_14,		/* 0x57,  87 */
+	MPUREG_EXT_SLV_SENS_DATA_15,		/* 0x58,  88 */
+	MPUREG_EXT_SLV_SENS_DATA_16,		/* 0x59,  89 */
+	MPUREG_EXT_SLV_SENS_DATA_17,		/* 0x5a,  90 */
+	MPUREG_EXT_SLV_SENS_DATA_18,		/* 0x5B,  91 */
+	MPUREG_EXT_SLV_SENS_DATA_19,		/* 0x5c,  92 */
+	MPUREG_EXT_SLV_SENS_DATA_20,		/* 0x5d,  93 */
+	MPUREG_EXT_SLV_SENS_DATA_21,		/* 0x5e,  94 */
+	MPUREG_EXT_SLV_SENS_DATA_22,		/* 0x5f,  95 */
+	MPUREG_EXT_SLV_SENS_DATA_23,		/* 0x60,  96 */
+	MPUREG_ACCEL_INTEL_STATUS,		/* 0x61,  97 */
+	MPUREG_62_RSVD,				/* 0x62,  98 */
+	MPUREG_I2C_SLV0_DO,			/* 0x63,  99 */
+	MPUREG_I2C_SLV1_DO,			/* 0x64, 100 */
+	MPUREG_I2C_SLV2_DO,			/* 0x65, 101 */
+	MPUREG_I2C_SLV3_DO,			/* 0x66, 102 */
+	MPUREG_I2C_MST_DELAY_CTRL,		/* 0x67, 103 */
+	MPUREG_SIGNAL_PATH_RESET,		/* 0x68, 104 */
+	MPUREG_ACCEL_INTEL_CTRL,		/* 0x69, 105 */
+	MPUREG_USER_CTRL,			/* 0x6A, 106 */
+	MPUREG_PWR_MGMT_1,			/* 0x6B, 107 */
+	MPUREG_PWR_MGMT_2,			/* 0x6C, 108 */
+	MPUREG_BANK_SEL,			/* 0x6D, 109 */
+	MPUREG_MEM_START_ADDR,			/* 0x6E, 100 */
+	MPUREG_MEM_R_W,				/* 0x6F, 111 */
+	MPUREG_DMP_CFG_1,			/* 0x70, 112 */
+	MPUREG_DMP_CFG_2,			/* 0x71, 113 */
+	MPUREG_FIFO_COUNTH,			/* 0x72, 114 */
+	MPUREG_FIFO_COUNTL,			/* 0x73, 115 */
+	MPUREG_FIFO_R_W,			/* 0x74, 116 */
+	MPUREG_WHOAMI,				/* 0x75, 117 */
+
+	NUM_OF_MPU_REGISTERS			/* = 0x76, 118 */
+};
+
+/*==== MPU6050B1 MEMORY ====*/
+enum MPU_MEMORY_BANKS {
+	MEM_RAM_BANK_0 = 0,
+	MEM_RAM_BANK_1,
+	MEM_RAM_BANK_2,
+	MEM_RAM_BANK_3,
+	MEM_RAM_BANK_4,
+	MEM_RAM_BANK_5,
+	MEM_RAM_BANK_6,
+	MEM_RAM_BANK_7,
+	MEM_RAM_BANK_8,
+	MEM_RAM_BANK_9,
+	MEM_RAM_BANK_10,
+	MEM_RAM_BANK_11,
+	MPU_MEM_NUM_RAM_BANKS,
+	MPU_MEM_OTP_BANK_0 = 16
+};
+
+
+/*==== MPU6050B1 parameters ====*/
+
+#define NUM_REGS		(NUM_OF_MPU_REGISTERS)
+#define START_SENS_REGS		(0x3B)
+#define NUM_SENS_REGS		(0x60 - START_SENS_REGS + 1)
+
+/*---- MPU Memory ----*/
+#define NUM_BANKS		(MPU_MEM_NUM_RAM_BANKS)
+#define BANK_SIZE		(256)
+#define MEM_SIZE		(NUM_BANKS * BANK_SIZE)
+#define MPU_MEM_BANK_SIZE	(BANK_SIZE)	/*alternative name */
+
+#define FIFO_HW_SIZE		(1024)
+
+#define NUM_EXT_SLAVES		(4)
+
+
+/*==== BITS FOR MPU6050B1 ====*/
+/*---- MPU6050B1 'XG_OFFS_TC' register (0, 1, 2) ----*/
+#define BIT_PU_SLEEP_MODE			0x80
+#define BITS_XG_OFFS_TC				0x7E
+#define BIT_OTP_BNK_VLD				0x01
+
+#define BIT_I2C_MST_VDDIO			0x80
+#define BITS_YG_OFFS_TC				0x7E
+#define BITS_ZG_OFFS_TC				0x7E
+/*---- MPU6050B1 'FIFO_EN' register (23) ----*/
+#define	BIT_TEMP_OUT				0x80
+#define	BIT_GYRO_XOUT				0x40
+#define	BIT_GYRO_YOUT				0x20
+#define	BIT_GYRO_ZOUT				0x10
+#define	BIT_ACCEL				0x08
+#define	BIT_SLV_2				0x04
+#define	BIT_SLV_1				0x02
+#define	BIT_SLV_0				0x01
+/*---- MPU6050B1 'CONFIG' register (1A) ----*/
+/*NONE						0xC0 */
+#define	BITS_EXT_SYNC_SET			0x38
+#define	BITS_DLPF_CFG				0x07
+/*---- MPU6050B1 'GYRO_CONFIG' register (1B) ----*/
+/* voluntarily modified label from BITS_FS_SEL to
+ * BITS_GYRO_FS_SEL to avoid confusion with MPU
+ */
+#define BITS_GYRO_FS_SEL			0x18
+/*NONE						0x07 */
+/*---- MPU6050B1 'ACCEL_CONFIG' register (1C) ----*/
+#define BITS_ACCEL_FS_SEL			0x18
+#define BITS_ACCEL_HPF				0x07
+/*---- MPU6050B1 'I2C_MST_CTRL' register (24) ----*/
+#define BIT_MULT_MST_EN				0x80
+#define BIT_WAIT_FOR_ES				0x40
+#define BIT_SLV_3_FIFO_EN			0x20
+#define BIT_I2C_MST_PSR				0x10
+#define BITS_I2C_MST_CLK			0x0F
+/*---- MPU6050B1 'I2C_SLV?_ADDR' register (27,2A,2D,30) ----*/
+#define BIT_I2C_READ				0x80
+#define BIT_I2C_WRITE				0x00
+#define BITS_I2C_ADDR				0x7F
+/*---- MPU6050B1 'I2C_SLV?_CTRL' register (27,2A,2D,30) ----*/
+#define BIT_SLV_ENABLE				0x80
+#define BIT_SLV_BYTE_SW				0x40
+#define BIT_SLV_REG_DIS				0x20
+#define BIT_SLV_GRP				0x10
+#define BITS_SLV_LENG				0x0F
+/*---- MPU6050B1 'I2C_SLV4_ADDR' register (31) ----*/
+#define BIT_I2C_SLV4_RNW			0x80
+/*---- MPU6050B1 'I2C_SLV4_CTRL' register (34) ----*/
+#define BIT_I2C_SLV4_EN				0x80
+#define BIT_SLV4_DONE_INT_EN			0x40
+#define BIT_SLV4_REG_DIS			0x20
+#define MASK_I2C_MST_DLY			0x1F
+/*---- MPU6050B1 'I2C_MST_STATUS' register (36) ----*/
+#define BIT_PASS_THROUGH			0x80
+#define BIT_I2C_SLV4_DONE			0x40
+#define BIT_I2C_LOST_ARB			0x20
+#define BIT_I2C_SLV4_NACK			0x10
+#define BIT_I2C_SLV3_NACK			0x08
+#define BIT_I2C_SLV2_NACK			0x04
+#define BIT_I2C_SLV1_NACK			0x02
+#define BIT_I2C_SLV0_NACK			0x01
+/*---- MPU6050B1 'INT_PIN_CFG' register (37) ----*/
+#define	BIT_ACTL				0x80
+#define BIT_ACTL_LOW				0x80
+#define BIT_ACTL_HIGH				0x00
+#define	BIT_OPEN				0x40
+#define	BIT_LATCH_INT_EN			0x20
+#define	BIT_INT_ANYRD_2CLEAR			0x10
+#define	BIT_ACTL_FSYNC				0x08
+#define	BIT_FSYNC_INT_EN			0x04
+#define	BIT_BYPASS_EN				0x02
+#define	BIT_CLKOUT_EN				0x01
+/*---- MPU6050B1 'INT_ENABLE' register (38) ----*/
+#define	BIT_FF_EN				0x80
+#define	BIT_MOT_EN				0x40
+#define	BIT_ZMOT_EN				0x20
+#define	BIT_FIFO_OVERFLOW_EN			0x10
+#define BIT_I2C_MST_INT_EN			0x08
+#define	BIT_PLL_RDY_EN				0x04
+#define BIT_DMP_INT_EN				0x02
+#define	BIT_RAW_RDY_EN				0x01
+/*---- MPU6050B1 'DMP_INT_STATUS' register (39) ----*/
+/*NONE						0x80 */
+/*NONE						0x40 */
+#define	BIT_DMP_INT_5				0x20
+#define	BIT_DMP_INT_4				0x10
+#define	BIT_DMP_INT_3				0x08
+#define	BIT_DMP_INT_2				0x04
+#define	BIT_DMP_INT_1				0x02
+#define	BIT_DMP_INT_0				0x01
+/*---- MPU6050B1 'INT_STATUS' register (3A) ----*/
+#define	BIT_FF_INT				0x80
+#define	BIT_MOT_INT				0x40
+#define	BIT_ZMOT_INT				0x20
+#define	BIT_FIFO_OVERFLOW_INT			0x10
+#define	BIT_I2C_MST_INT				0x08
+#define	BIT_PLL_RDY_INT				0x04
+#define BIT_DMP_INT				0x02
+#define	BIT_RAW_DATA_RDY_INT			0x01
+/*---- MPU6050B1 'MPUREG_I2C_MST_DELAY_CTRL' register (0x67) ----*/
+#define	BIT_DELAY_ES_SHADOW			0x80
+#define	BIT_SLV4_DLY_EN				0x10
+#define	BIT_SLV3_DLY_EN				0x08
+#define	BIT_SLV2_DLY_EN				0x04
+#define	BIT_SLV1_DLY_EN				0x02
+#define	BIT_SLV0_DLY_EN				0x01
+/*---- MPU6050B1 'BANK_SEL' register (6D) ----*/
+#define	BIT_PRFTCH_EN				0x40
+#define	BIT_CFG_USER_BANK			0x20
+#define	BITS_MEM_SEL				0x1f
+/*---- MPU6050B1 'USER_CTRL' register (6A) ----*/
+#define	BIT_DMP_EN				0x80
+#define	BIT_FIFO_EN				0x40
+#define	BIT_I2C_MST_EN				0x20
+#define	BIT_I2C_IF_DIS				0x10
+#define	BIT_DMP_RST				0x08
+#define	BIT_FIFO_RST				0x04
+#define	BIT_I2C_MST_RST				0x02
+#define	BIT_SIG_COND_RST			0x01
+/*---- MPU6050B1 'PWR_MGMT_1' register (6B) ----*/
+#define	BIT_H_RESET				0x80
+#define	BIT_SLEEP				0x40
+#define	BIT_CYCLE				0x20
+#define BIT_PD_PTAT				0x08
+#define BITS_CLKSEL				0x07
+/*---- MPU6050B1 'PWR_MGMT_2' register (6C) ----*/
+#define	BITS_LPA_WAKE_CTRL			0xC0
+#define	BITS_LPA_WAKE_1HZ			0x00
+#define	BITS_LPA_WAKE_2HZ			0x40
+#define	BITS_LPA_WAKE_10HZ			0x80
+#define	BITS_LPA_WAKE_40HZ			0xC0
+#define	BIT_STBY_XA				0x20
+#define	BIT_STBY_YA				0x10
+#define	BIT_STBY_ZA				0x08
+#define	BIT_STBY_XG				0x04
+#define	BIT_STBY_YG				0x02
+#define	BIT_STBY_ZG				0x01
+
+#define ACCEL_MOT_THR_LSB (32) /* mg */
+#define ACCEL_MOT_DUR_LSB (1)
+#define ACCEL_ZRMOT_THR_LSB_CONVERSION(mg) ((mg * 1000) / 255)
+#define ACCEL_ZRMOT_DUR_LSB (64)
+
+/*----------------------------------------------------------------------------*/
+/*---- Alternative names to take care of conflicts with current mpu3050.h ----*/
+/*----------------------------------------------------------------------------*/
+
+/*-- registers --*/
+#define MPUREG_DLPF_FS_SYNC	MPUREG_CONFIG			/* 0x1A */
+
+#define MPUREG_PWR_MGM		MPUREG_PWR_MGMT_1		/* 0x6B */
+#define MPUREG_FIFO_EN1		MPUREG_FIFO_EN			/* 0x23 */
+#define MPUREG_INT_CFG		MPUREG_INT_ENABLE		/* 0x38 */
+#define MPUREG_X_OFFS_USRH	MPUREG_XG_OFFS_USRH		/* 0x13 */
+#define MPUREG_WHO_AM_I		MPUREG_WHOAMI			/* 0x75 */
+#define MPUREG_23_RSVD		MPUREG_EXT_SLV_SENS_DATA_00	/* 0x49 */
+
+/*-- bits --*/
+/* 'USER_CTRL' register */
+#define BIT_AUX_IF_EN		BIT_I2C_MST_EN
+#define BIT_AUX_RD_LENG		BIT_I2C_MST_EN
+#define BIT_IME_IF_RST		BIT_I2C_MST_RST
+#define BIT_GYRO_RST		BIT_SIG_COND_RST
+/* 'INT_ENABLE' register */
+#define BIT_RAW_RDY		BIT_RAW_DATA_RDY_INT
+#define BIT_MPU_RDY_EN		BIT_PLL_RDY_EN
+/* 'INT_STATUS' register */
+#define BIT_INT_STATUS_FIFO_OVERLOW BIT_FIFO_OVERFLOW_INT
+
+/*---- MPU6050 Silicon Revisions ----*/
+#define MPU_SILICON_REV_A2		1	/* MPU6050A2 Device */
+#define MPU_SILICON_REV_B1		2	/* MPU6050B1 Device */
+
+/*---- MPU6050 notable product revisions ----*/
+#define MPU_PRODUCT_KEY_B1_E1_5		105
+#define MPU_PRODUCT_KEY_B2_F1		431
+
+/*---- structure containing control variables used by MLDL ----*/
+/*---- MPU clock source settings ----*/
+/*---- MPU filter selections ----*/
+enum mpu_filter {
+	MPU_FILTER_256HZ_NOLPF2 = 0,
+	MPU_FILTER_188HZ,
+	MPU_FILTER_98HZ,
+	MPU_FILTER_42HZ,
+	MPU_FILTER_20HZ,
+	MPU_FILTER_10HZ,
+	MPU_FILTER_5HZ,
+	MPU_FILTER_2100HZ_NOLPF,
+	NUM_MPU_FILTER
+};
+
+enum mpu_fullscale {
+	MPU_FS_250DPS = 0,
+	MPU_FS_500DPS,
+	MPU_FS_1000DPS,
+	MPU_FS_2000DPS,
+	NUM_MPU_FS
+};
+
+enum mpu_clock_sel {
+	MPU_CLK_SEL_INTERNAL = 0,
+	MPU_CLK_SEL_PLLGYROX,
+	MPU_CLK_SEL_PLLGYROY,
+	MPU_CLK_SEL_PLLGYROZ,
+	MPU_CLK_SEL_PLLEXT32K,
+	MPU_CLK_SEL_PLLEXT19M,
+	MPU_CLK_SEL_RESERVED,
+	MPU_CLK_SEL_STOP,
+	NUM_CLK_SEL
+};
+
+enum mpu_ext_sync {
+	MPU_EXT_SYNC_NONE = 0,
+	MPU_EXT_SYNC_TEMP,
+	MPU_EXT_SYNC_GYROX,
+	MPU_EXT_SYNC_GYROY,
+	MPU_EXT_SYNC_GYROZ,
+	MPU_EXT_SYNC_ACCELX,
+	MPU_EXT_SYNC_ACCELY,
+	MPU_EXT_SYNC_ACCELZ,
+	NUM_MPU_EXT_SYNC
+};
+
+#define MPUREG_CONFIG_VALUE(ext_sync, lpf) \
+	((ext_sync << 3) | lpf)
+
+#define MPUREG_GYRO_CONFIG_VALUE(x_st, y_st, z_st, full_scale)	\
+	((x_st ? 0x80 : 0) |				\
+	 (y_st ? 0x70 : 0) |				\
+	 (z_st ? 0x60 : 0) |				\
+	 (full_scale << 3))
+
+#endif				/* __MPU6050_H_ */
diff --git a/drivers/misc/inv_mpu/mpuirq.c b/drivers/misc/inv_mpu/mpuirq.c
new file mode 100644
index 0000000..39bb80a
--- /dev/null
+++ b/drivers/misc/inv_mpu/mpuirq.c
@@ -0,0 +1,257 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/stat.h>
+#include <linux/irq.h>
+#include <linux/signal.h>
+#include <linux/miscdevice.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/poll.h>
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+
+#include <linux/mpu.h>
+#include "mpuirq.h"
+#include "mldl_cfg.h"
+#include <mach/gpio.h>
+#define MPUIRQ_NAME "mpuirq"
+
+/* function which gets accel data and sends it to MPU */
+
+DECLARE_WAIT_QUEUE_HEAD(mpuirq_wait);
+
+struct mpuirq_dev_data {
+	struct i2c_client *mpu_client;
+	struct miscdevice *dev;
+	int irq;
+	int pid;
+	int accel_divider;
+	int data_ready;
+	int timeout;
+};
+
+static struct mpuirq_dev_data mpuirq_dev_data;
+static struct mpuirq_data mpuirq_data;
+static char *interface = MPUIRQ_NAME;
+static u32 gy_handle = 0;
+static int mpuirq_open(struct inode *inode, struct file *file)
+{
+	dev_dbg(mpuirq_dev_data.dev->this_device,
+		"%s current->pid %d\n", __func__, current->pid);
+	mpuirq_dev_data.pid = current->pid;
+	file->private_data = &mpuirq_dev_data;
+	return 0;
+}
+
+/* close function - called when the "file" /dev/mpuirq is closed in userspace */
+static int mpuirq_release(struct inode *inode, struct file *file)
+{
+	dev_dbg(mpuirq_dev_data.dev->this_device, "mpuirq_release\n");
+	return 0;
+}
+
+/* read function called when from /dev/mpuirq is read */
+static ssize_t mpuirq_read(struct file *file,
+			   char *buf, size_t count, loff_t *ppos)
+{
+	int len, err;
+	struct mpuirq_dev_data *p_mpuirq_dev_data = file->private_data;
+
+	if (!mpuirq_dev_data.data_ready &&
+	    mpuirq_dev_data.timeout && (!(file->f_flags & O_NONBLOCK))) {
+		wait_event_interruptible_timeout(mpuirq_wait,
+						 mpuirq_dev_data.data_ready,
+						 mpuirq_dev_data.timeout);
+	}
+
+	if (mpuirq_dev_data.data_ready && NULL != buf
+	    && count >= sizeof(mpuirq_data)) {
+		err = copy_to_user(buf, &mpuirq_data, sizeof(mpuirq_data));
+		mpuirq_data.data_type = 0;
+	} else {
+		return 0;
+	}
+	if (err != 0) {
+		dev_err(p_mpuirq_dev_data->dev->this_device,
+			"Copy to user returned %d\n", err);
+		return -EFAULT;
+	}
+	mpuirq_dev_data.data_ready = 0;
+	len = sizeof(mpuirq_data);
+	return len;
+}
+
+unsigned int mpuirq_poll(struct file *file, struct poll_table_struct *poll)
+{
+	int mask = 0;
+
+	poll_wait(file, &mpuirq_wait, poll);
+	if (mpuirq_dev_data.data_ready)
+		mask |= POLLIN | POLLRDNORM;
+	return mask;
+}
+
+/* ioctl - I/O control */
+static long mpuirq_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+	int data;
+
+	switch (cmd) {
+	case MPUIRQ_SET_TIMEOUT:
+		mpuirq_dev_data.timeout = arg;
+		break;
+
+	case MPUIRQ_GET_INTERRUPT_CNT:
+		data = mpuirq_data.interruptcount - 1;
+		if (mpuirq_data.interruptcount > 1)
+			mpuirq_data.interruptcount = 1;
+
+		if (copy_to_user((int *)arg, &data, sizeof(int)))
+			return -EFAULT;
+		break;
+	case MPUIRQ_GET_IRQ_TIME:
+		if (copy_to_user((int *)arg, &mpuirq_data.irqtime,
+				 sizeof(mpuirq_data.irqtime)))
+			return -EFAULT;
+		mpuirq_data.irqtime = 0;
+		break;
+	case MPUIRQ_SET_FREQUENCY_DIVIDER:
+		mpuirq_dev_data.accel_divider = arg;
+		break;
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+static irqreturn_t mpuirq_handler(int irq, void *dev_id)
+{
+	static int mycount;
+	struct timeval irqtime;
+	mycount++;
+
+	mpuirq_data.interruptcount++;
+
+	/* wake up (unblock) for reading data from userspace */
+	/* and ignore first interrupt generated in module init */
+	mpuirq_dev_data.data_ready = 1;
+
+	do_gettimeofday(&irqtime);
+	mpuirq_data.irqtime = (((long long)irqtime.tv_sec) << 32);
+	mpuirq_data.irqtime += irqtime.tv_usec;
+	mpuirq_data.data_type = MPUIRQ_DATA_TYPE_MPU_IRQ;
+	mpuirq_data.data = 0;
+
+	wake_up_interruptible(&mpuirq_wait);
+
+	return 0;
+
+}
+
+/* define which file operations are supported */
+const struct file_operations mpuirq_fops = {
+	.owner = THIS_MODULE,
+	.read = mpuirq_read,
+	.poll = mpuirq_poll,
+
+	.unlocked_ioctl = mpuirq_ioctl,
+	.open = mpuirq_open,
+	.release = mpuirq_release,
+};
+
+static struct miscdevice mpuirq_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = MPUIRQ_NAME,
+	.fops = &mpuirq_fops,
+};
+
+int mpuirq_init(struct i2c_client *mpu_client, struct mldl_cfg *mldl_cfg)
+{
+	int res=0;
+
+	mpuirq_dev_data.mpu_client = mpu_client;
+
+	dev_info(&mpu_client->adapter->dev,
+		 "Module Param interface = %s\n", interface);
+
+	mpuirq_dev_data.irq = mpu_client->irq;
+	mpuirq_dev_data.pid = 0;
+	mpuirq_dev_data.accel_divider = -1;
+	mpuirq_dev_data.data_ready = 0;
+	mpuirq_dev_data.timeout = 0;
+	mpuirq_dev_data.dev = &mpuirq_device;
+
+	if (mpuirq_dev_data.irq) {
+		unsigned long flags;
+		if (BIT_ACTL_LOW == ((mldl_cfg->pdata->int_config) & BIT_ACTL))
+			flags = TRIG_LEVL_LOW;//IRQF_TRIGGER_FALLING;
+		else
+			flags = TRIG_EDGE_NEGATIVE;//TRIG_LEVL_HIGH;//IRQF_TRIGGER_RISING;
+
+		//flags |= IRQF_SHARED;
+		gy_handle =//request_irq(mpuirq_dev_data.irq, mpuirq_handler, flags,
+				//interface, &mpuirq_dev_data.irq);
+sw_gpio_irq_request(mpuirq_dev_data.irq, flags, (peint_handle)mpuirq_handler,
+				&mpuirq_dev_data.irq);
+		if (!gy_handle) {
+			dev_err(&mpu_client->adapter->dev,
+				"myirqtest: cannot register IRQ %d\n",
+				mpuirq_dev_data.irq);
+		} else {
+			res = misc_register(&mpuirq_device);
+			if (res < 0) {
+				dev_err(&mpu_client->adapter->dev,
+					"misc_register returned %d\n", res);
+				sw_gpio_irq_free(gy_handle);
+				//free_irq(mpuirq_dev_data.irq,
+					 //&mpuirq_dev_data.irq);
+			}
+		}
+	} else {
+		res = 0;
+	}
+
+	return res;
+}
+
+void mpuirq_exit(void)
+{
+	if (mpuirq_dev_data.irq > 0)
+		//free_irq(mpuirq_dev_data.irq, &mpuirq_dev_data.irq);
+		sw_gpio_irq_free(gy_handle);
+	dev_info(mpuirq_device.this_device, "Unregistering %s\n", MPUIRQ_NAME);
+	misc_deregister(&mpuirq_device);
+
+	return;
+}
+
+module_param(interface, charp, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(interface, "The Interface name");
diff --git a/drivers/misc/inv_mpu/mpuirq.h b/drivers/misc/inv_mpu/mpuirq.h
new file mode 100644
index 0000000..3348071
--- /dev/null
+++ b/drivers/misc/inv_mpu/mpuirq.h
@@ -0,0 +1,36 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+#ifndef __MPUIRQ__
+#define __MPUIRQ__
+
+#include <linux/i2c-dev.h>
+#include <linux/time.h>
+#include <linux/ioctl.h>
+#include "mldl_cfg.h"
+
+#define MPUIRQ_SET_TIMEOUT           _IOW(MPU_IOCTL, 0x40, unsigned long)
+#define MPUIRQ_GET_INTERRUPT_CNT     _IOR(MPU_IOCTL, 0x41, unsigned long)
+#define MPUIRQ_GET_IRQ_TIME          _IOR(MPU_IOCTL, 0x42, struct timeval)
+#define MPUIRQ_SET_FREQUENCY_DIVIDER _IOW(MPU_IOCTL, 0x43, unsigned long)
+
+void mpuirq_exit(void);
+int mpuirq_init(struct i2c_client *mpu_client, struct mldl_cfg *mldl_cfg);
+
+#endif
diff --git a/drivers/misc/inv_mpu/pressure/Kconfig b/drivers/misc/inv_mpu/pressure/Kconfig
new file mode 100644
index 0000000..f1c021e
--- /dev/null
+++ b/drivers/misc/inv_mpu/pressure/Kconfig
@@ -0,0 +1,20 @@
+menuconfig: INV_SENSORS_PRESSURE
+	bool "Pressure Sensor Slaves"
+	depends on INV_SENSORS
+	default y
+	help
+	  Select y to see a list of supported pressure sensors that can be
+	  integrated with the MPUxxxx set of motion processors.
+
+if INV_SENSORS_PRESSURE
+
+config MPU_SENSORS_BMA085
+	tristate "Bosch BMA085"
+	help
+	  This enables support for the Bosch bma085 pressure sensor
+	  This support is for integration with the MPU3050 or MPU6050 gyroscope
+          device driver.  Only one accelerometer can be registered at a time.
+	  Specifying more that one accelerometer in the board file will result
+	  in runtime errors.
+
+endif
diff --git a/drivers/misc/inv_mpu/pressure/Makefile b/drivers/misc/inv_mpu/pressure/Makefile
new file mode 100644
index 0000000..595923d
--- /dev/null
+++ b/drivers/misc/inv_mpu/pressure/Makefile
@@ -0,0 +1,8 @@
+#
+# Pressure Slaves to MPUxxxx
+#
+obj-$(CONFIG_MPU_SENSORS_BMA085) += inv_mpu_bma085.o
+inv_mpu_bma085-objs +=	bma085.o
+
+EXTRA_CFLAGS += -Idrivers/misc/inv_mpu
+EXTRA_CFLAGS += -D__C99_DESIGNATED_INITIALIZER
diff --git a/drivers/misc/inv_mpu/pressure/bma085.c b/drivers/misc/inv_mpu/pressure/bma085.c
new file mode 100644
index 0000000..696d2b6
--- /dev/null
+++ b/drivers/misc/inv_mpu/pressure/bma085.c
@@ -0,0 +1,367 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+/**
+ *  @defgroup   ACCELDL (Motion Library - Pressure Driver Layer)
+ *  @brief      Provides the interface to setup and handle a pressure
+ *              connected to the secondary I2C interface of the gyroscope.
+ *
+ *  @{
+ *      @file   bma085.c
+ *      @brief  Pressure setup and handling methods.
+ */
+
+/* ------------------ */
+/* - Include Files. - */
+/* ------------------ */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include "mpu-dev.h"
+
+#include <linux/mpu.h>
+#include "mlsl.h"
+#include "log.h"
+
+/*
+ * this structure holds all device specific calibration parameters
+ */
+struct bmp085_calibration_param_t {
+	short ac1;
+	short ac2;
+	short ac3;
+	unsigned short ac4;
+	unsigned short ac5;
+	unsigned short ac6;
+	short b1;
+	short b2;
+	short mb;
+	short mc;
+	short md;
+	long param_b5;
+};
+
+struct bmp085_calibration_param_t cal_param;
+
+#define PRESSURE_BMA085_PARAM_MG      3038        /* calibration parameter */
+#define PRESSURE_BMA085_PARAM_MH     -7357        /* calibration parameter */
+#define PRESSURE_BMA085_PARAM_MI      3791        /* calibration parameter */
+
+/*********************************************
+ *    Pressure Initialization Functions
+ *********************************************/
+
+static int bma085_suspend(void *mlsl_handle,
+			  struct ext_slave_descr *slave,
+			  struct ext_slave_platform_data *pdata)
+{
+	int result = INV_SUCCESS;
+	return result;
+}
+
+#define PRESSURE_BMA085_PROM_START_ADDR  (0xAA)
+#define PRESSURE_BMA085_PROM_DATA_LEN    (22)
+#define PRESSURE_BMP085_CTRL_MEAS_REG    (0xF4)
+/* temperature measurent */
+#define PRESSURE_BMP085_T_MEAS           (0x2E)
+/* pressure measurement; oversampling_setting */
+#define PRESSURE_BMP085_P_MEAS_OSS_0     (0x34)
+#define PRESSURE_BMP085_P_MEAS_OSS_1     (0x74)
+#define PRESSURE_BMP085_P_MEAS_OSS_2     (0xB4)
+#define PRESSURE_BMP085_P_MEAS_OSS_3     (0xF4)
+#define PRESSURE_BMP085_ADC_OUT_MSB_REG  (0xF6)
+#define PRESSURE_BMP085_ADC_OUT_LSB_REG  (0xF7)
+
+static int bma085_resume(void *mlsl_handle,
+			 struct ext_slave_descr *slave,
+			 struct ext_slave_platform_data *pdata)
+{
+	int result;
+	unsigned char data[PRESSURE_BMA085_PROM_DATA_LEN];
+
+	result =
+	    inv_serial_read(mlsl_handle, pdata->address,
+			   PRESSURE_BMA085_PROM_START_ADDR,
+			   PRESSURE_BMA085_PROM_DATA_LEN, data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+
+	/* parameters AC1-AC6 */
+	cal_param.ac1 = (data[0] << 8) | data[1];
+	cal_param.ac2 = (data[2] << 8) | data[3];
+	cal_param.ac3 = (data[4] << 8) | data[5];
+	cal_param.ac4 = (data[6] << 8) | data[7];
+	cal_param.ac5 = (data[8] << 8) | data[9];
+	cal_param.ac6 = (data[10] << 8) | data[11];
+
+	/* parameters B1,B2 */
+	cal_param.b1 = (data[12] << 8) | data[13];
+	cal_param.b2 = (data[14] << 8) | data[15];
+
+	/* parameters MB,MC,MD */
+	cal_param.mb = (data[16] << 8) | data[17];
+	cal_param.mc = (data[18] << 8) | data[19];
+	cal_param.md = (data[20] << 8) | data[21];
+
+	return result;
+}
+
+static int bma085_read(void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata,
+		       unsigned char *data)
+{
+	int result;
+	long pressure, x1, x2, x3, b3, b6;
+	unsigned long b4, b7;
+	unsigned long up;
+	unsigned short ut;
+	short oversampling_setting = 0;
+	short temperature;
+	long divisor;
+
+	/* get temprature */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       PRESSURE_BMP085_CTRL_MEAS_REG,
+				       PRESSURE_BMP085_T_MEAS);
+	msleep(5);
+	result =
+	    inv_serial_read(mlsl_handle, pdata->address,
+			   PRESSURE_BMP085_ADC_OUT_MSB_REG, 2,
+			   (unsigned char *)data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	ut = (data[0] << 8) | data[1];
+
+	x1 = (((long) ut - (long)cal_param.ac6) * (long)cal_param.ac5) >> 15;
+	divisor = x1 + cal_param.md;
+	if (!divisor)
+		return INV_ERROR_DIVIDE_BY_ZERO;
+
+	x2 = ((long)cal_param.mc << 11) / (x1 + cal_param.md);
+	cal_param.param_b5 = x1 + x2;
+	/* temperature in 0.1 degree C */
+	temperature = (short)((cal_param.param_b5 + 8) >> 4);
+
+	/* get pressure */
+	result = inv_serial_single_write(mlsl_handle, pdata->address,
+				       PRESSURE_BMP085_CTRL_MEAS_REG,
+				       PRESSURE_BMP085_P_MEAS_OSS_0);
+	msleep(5);
+	result =
+	    inv_serial_read(mlsl_handle, pdata->address,
+			   PRESSURE_BMP085_ADC_OUT_MSB_REG, 2,
+			   (unsigned char *)data);
+	if (result) {
+		LOG_RESULT_LOCATION(result);
+		return result;
+	}
+	up = (((unsigned long) data[0] << 8) | ((unsigned long) data[1]));
+
+	b6 = cal_param.param_b5 - 4000;
+	/* calculate B3 */
+	x1 = (b6*b6) >> 12;
+	x1 *= cal_param.b2;
+	x1 >>= 11;
+
+	x2 = (cal_param.ac2*b6);
+	x2 >>= 11;
+
+	x3 = x1 + x2;
+
+	b3 = (((((long)cal_param.ac1) * 4 + x3)
+	    << oversampling_setting) + 2) >> 2;
+
+	/* calculate B4 */
+	x1 = (cal_param.ac3 * b6) >> 13;
+	x2 = (cal_param.b1 * ((b6*b6) >> 12)) >> 16;
+	x3 = ((x1 + x2) + 2) >> 2;
+	b4 = (cal_param.ac4 * (unsigned long) (x3 + 32768)) >> 15;
+	if (!b4)
+		return INV_ERROR;
+
+	b7 = ((unsigned long)(up - b3) * (50000>>oversampling_setting));
+	if (b7 < 0x80000000)
+		pressure = (b7 << 1) / b4;
+	else
+		pressure = (b7 / b4) << 1;
+
+	x1 = pressure >> 8;
+	x1 *= x1;
+	x1 = (x1 * PRESSURE_BMA085_PARAM_MG) >> 16;
+	x2 = (pressure * PRESSURE_BMA085_PARAM_MH) >> 16;
+	/* pressure in Pa */
+	pressure += (x1 + x2 + PRESSURE_BMA085_PARAM_MI) >> 4;
+
+	data[0] = (unsigned char)(pressure >> 16);
+	data[1] = (unsigned char)(pressure >> 8);
+	data[2] = (unsigned char)(pressure & 0xFF);
+
+	return result;
+}
+
+static struct ext_slave_descr bma085_descr = {
+	.init             = NULL,
+	.exit             = NULL,
+	.suspend          = bma085_suspend,
+	.resume           = bma085_resume,
+	.read             = bma085_read,
+	.config           = NULL,
+	.get_config       = NULL,
+	.name             = "bma085",
+	.type             = EXT_SLAVE_TYPE_PRESSURE,
+	.id               = PRESSURE_ID_BMA085,
+	.read_reg         = 0xF6,
+	.read_len         = 3,
+	.endian           = EXT_SLAVE_BIG_ENDIAN,
+	.range            = {0, 0},
+};
+
+static
+struct ext_slave_descr *bma085_get_slave_descr(void)
+{
+	return &bma085_descr;
+}
+
+/* Platform data for the MPU */
+struct bma085_mod_private_data {
+	struct i2c_client *client;
+	struct ext_slave_platform_data *pdata;
+};
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+static int bma085_mod_probe(struct i2c_client *client,
+			   const struct i2c_device_id *devid)
+{
+	struct ext_slave_platform_data *pdata;
+	struct bma085_mod_private_data *private_data;
+	int result = 0;
+
+	dev_info(&client->adapter->dev, "%s: %s\n", __func__, devid->name);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		result = -ENODEV;
+		goto out_no_free;
+	}
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->adapter->dev,
+			"Missing platform data for slave %s\n", devid->name);
+		result = -EFAULT;
+		goto out_no_free;
+	}
+
+	private_data = kzalloc(sizeof(*private_data), GFP_KERNEL);
+	if (!private_data) {
+		result = -ENOMEM;
+		goto out_no_free;
+	}
+
+	i2c_set_clientdata(client, private_data);
+	private_data->client = client;
+	private_data->pdata = pdata;
+
+	result = inv_mpu_register_slave(THIS_MODULE, client, pdata,
+					bma085_get_slave_descr);
+	if (result) {
+		dev_err(&client->adapter->dev,
+			"Slave registration failed: %s, %d\n",
+			devid->name, result);
+		goto out_free_memory;
+	}
+
+	return result;
+
+out_free_memory:
+	kfree(private_data);
+out_no_free:
+	dev_err(&client->adapter->dev, "%s failed %d\n", __func__, result);
+	return result;
+
+}
+
+static int bma085_mod_remove(struct i2c_client *client)
+{
+	struct bma085_mod_private_data *private_data =
+		i2c_get_clientdata(client);
+
+	dev_dbg(&client->adapter->dev, "%s\n", __func__);
+
+	inv_mpu_unregister_slave(client, private_data->pdata,
+				bma085_get_slave_descr);
+
+	kfree(private_data);
+	return 0;
+}
+
+static const struct i2c_device_id bma085_mod_id[] = {
+	{ "bma085", PRESSURE_ID_BMA085 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, bma085_mod_id);
+
+static struct i2c_driver bma085_mod_driver = {
+	.class = I2C_CLASS_HWMON,
+	.probe = bma085_mod_probe,
+	.remove = bma085_mod_remove,
+	.id_table = bma085_mod_id,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "bma085_mod",
+		   },
+	.address_list = normal_i2c,
+};
+
+static int __init bma085_mod_init(void)
+{
+	int res = i2c_add_driver(&bma085_mod_driver);
+	pr_info("%s: Probe name %s\n", __func__, "bma085_mod");
+	if (res)
+		pr_err("%s failed\n", __func__);
+	return res;
+}
+
+static void __exit bma085_mod_exit(void)
+{
+	pr_info("%s\n", __func__);
+	i2c_del_driver(&bma085_mod_driver);
+}
+
+module_init(bma085_mod_init);
+module_exit(bma085_mod_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Driver to integrate BMA085 sensor with the MPU");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("bma085_mod");
+/**
+ *  @}
+**/
diff --git a/drivers/misc/inv_mpu/slaveirq.c b/drivers/misc/inv_mpu/slaveirq.c
new file mode 100644
index 0000000..4e7d2a2
--- /dev/null
+++ b/drivers/misc/inv_mpu/slaveirq.c
@@ -0,0 +1,266 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/stat.h>
+#include <linux/irq.h>
+#include <linux/signal.h>
+#include <linux/miscdevice.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/poll.h>
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+
+#include <linux/mpu.h>
+#include "slaveirq.h"
+#include "mldl_cfg.h"
+
+/* function which gets slave data and sends it to SLAVE */
+
+struct slaveirq_dev_data {
+	struct miscdevice dev;
+	struct i2c_client *slave_client;
+	struct mpuirq_data data;
+	wait_queue_head_t slaveirq_wait;
+	int irq;
+	int pid;
+	int data_ready;
+	int timeout;
+};
+
+/* The following depends on patch fa1f68db6ca7ebb6fc4487ac215bffba06c01c28
+ * drivers: misc: pass miscdevice pointer via file private data
+ */
+static int slaveirq_open(struct inode *inode, struct file *file)
+{
+	/* Device node is availabe in the file->private_data, this is
+	 * exactly what we want so we leave it there */
+	struct slaveirq_dev_data *data =
+	    container_of(file->private_data, struct slaveirq_dev_data, dev);
+
+	dev_dbg(data->dev.this_device,
+		"%s current->pid %d\n", __func__, current->pid);
+	data->pid = current->pid;
+	return 0;
+}
+
+static int slaveirq_release(struct inode *inode, struct file *file)
+{
+	struct slaveirq_dev_data *data =
+	    container_of(file->private_data, struct slaveirq_dev_data, dev);
+	dev_dbg(data->dev.this_device, "slaveirq_release\n");
+	return 0;
+}
+
+/* read function called when from /dev/slaveirq is read */
+static ssize_t slaveirq_read(struct file *file,
+			     char *buf, size_t count, loff_t *ppos)
+{
+	int len, err;
+	struct slaveirq_dev_data *data =
+	    container_of(file->private_data, struct slaveirq_dev_data, dev);
+
+	if (!data->data_ready && data->timeout &&
+	    !(file->f_flags & O_NONBLOCK)) {
+		wait_event_interruptible_timeout(data->slaveirq_wait,
+						 data->data_ready,
+						 data->timeout);
+	}
+
+	if (data->data_ready && NULL != buf && count >= sizeof(data->data)) {
+		err = copy_to_user(buf, &data->data, sizeof(data->data));
+		data->data.data_type = 0;
+	} else {
+		return 0;
+	}
+	if (err != 0) {
+		dev_err(data->dev.this_device,
+			"Copy to user returned %d\n", err);
+		return -EFAULT;
+	}
+	data->data_ready = 0;
+	len = sizeof(data->data);
+	return len;
+}
+
+static unsigned int slaveirq_poll(struct file *file,
+				  struct poll_table_struct *poll)
+{
+	int mask = 0;
+	struct slaveirq_dev_data *data =
+	    container_of(file->private_data, struct slaveirq_dev_data, dev);
+
+	poll_wait(file, &data->slaveirq_wait, poll);
+	if (data->data_ready)
+		mask |= POLLIN | POLLRDNORM;
+	return mask;
+}
+
+/* ioctl - I/O control */
+static long slaveirq_ioctl(struct file *file,
+			   unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+	int tmp;
+	struct slaveirq_dev_data *data =
+	    container_of(file->private_data, struct slaveirq_dev_data, dev);
+
+	switch (cmd) {
+	case SLAVEIRQ_SET_TIMEOUT:
+		data->timeout = arg;
+		break;
+
+	case SLAVEIRQ_GET_INTERRUPT_CNT:
+		tmp = data->data.interruptcount - 1;
+		if (data->data.interruptcount > 1)
+			data->data.interruptcount = 1;
+
+		if (copy_to_user((int *)arg, &tmp, sizeof(int)))
+			return -EFAULT;
+		break;
+	case SLAVEIRQ_GET_IRQ_TIME:
+		if (copy_to_user((int *)arg, &data->data.irqtime,
+				 sizeof(data->data.irqtime)))
+			return -EFAULT;
+		data->data.irqtime = 0;
+		break;
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+/*static irqreturn_t slaveirq_handler(int irq, void *dev_id)
+{
+	struct slaveirq_dev_data *data = (struct slaveirq_dev_data *)dev_id;
+	static int mycount;
+	struct timeval irqtime;
+	mycount++;
+
+	data->data.interruptcount++;
+
+	// wake up (unblock) for reading data from userspace 
+	data->data_ready = 1;
+
+	do_gettimeofday(&irqtime);
+	data->data.irqtime = (((long long)irqtime.tv_sec) << 32);
+	data->data.irqtime += irqtime.tv_usec;
+	data->data.data_type |= 1;
+
+	wake_up_interruptible(&data->slaveirq_wait);
+
+	return IRQ_HANDLED;
+
+}*/
+
+/* define which file operations are supported */
+static const struct file_operations slaveirq_fops = {
+	.owner = THIS_MODULE,
+	.read = slaveirq_read,
+	.poll = slaveirq_poll,
+
+#if HAVE_COMPAT_IOCTL
+	.compat_ioctl = slaveirq_ioctl,
+#endif
+#if HAVE_UNLOCKED_IOCTL
+	.unlocked_ioctl = slaveirq_ioctl,
+#endif
+	.open = slaveirq_open,
+	.release = slaveirq_release,
+};
+
+int slaveirq_init(struct i2c_adapter *slave_adapter,
+		  struct ext_slave_platform_data *pdata, char *name)
+{
+	return 0;
+	/*int res;
+	struct slaveirq_dev_data *data;
+
+	if (!pdata->irq)
+		return -EINVAL;
+
+	pdata->irq_data = kzalloc(sizeof(*data), GFP_KERNEL);
+	data = (struct slaveirq_dev_data *)pdata->irq_data;
+	if (!data)
+		return -ENOMEM;
+
+	data->dev.minor = MISC_DYNAMIC_MINOR;
+	data->dev.name = name;
+	data->dev.fops = &slaveirq_fops;
+	data->irq = pdata->irq;
+	data->pid = 0;
+	data->data_ready = 0;
+	data->timeout = 0;
+
+	init_waitqueue_head(&data->slaveirq_wait);
+
+	res = request_irq(data->irq, slaveirq_handler,
+			IRQF_TRIGGER_RISING | IRQF_SHARED,
+			  data->dev.name, data);
+
+	if (res) {
+		dev_err(&slave_adapter->dev,
+			"myirqtest: cannot register IRQ %d\n", data->irq);
+		goto out_request_irq;
+	}
+
+	res = misc_register(&data->dev);
+	if (res < 0) {
+		dev_err(&slave_adapter->dev,
+			"misc_register returned %d\n", res);
+		goto out_misc_register;
+	}
+
+	return res;
+
+out_misc_register:
+	free_irq(data->irq, data);
+out_request_irq:
+	kfree(pdata->irq_data);
+	pdata->irq_data = NULL;
+
+	return res;*/
+}
+
+void slaveirq_exit(struct ext_slave_platform_data *pdata)
+{
+	struct slaveirq_dev_data *data = pdata->irq_data;
+
+	if (!pdata->irq_data || data->irq <= 0)
+		return;
+
+	dev_info(data->dev.this_device, "Unregistering %s\n", data->dev.name);
+
+	free_irq(data->irq, data);
+	misc_deregister(&data->dev);
+	kfree(pdata->irq_data);
+	pdata->irq_data = NULL;
+}
diff --git a/drivers/misc/inv_mpu/slaveirq.h b/drivers/misc/inv_mpu/slaveirq.h
new file mode 100644
index 0000000..6926634
--- /dev/null
+++ b/drivers/misc/inv_mpu/slaveirq.h
@@ -0,0 +1,36 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+#ifndef __SLAVEIRQ__
+#define __SLAVEIRQ__
+
+#include <linux/i2c-dev.h>
+
+#include <linux/mpu.h>
+#include "mpuirq.h"
+
+#define SLAVEIRQ_SET_TIMEOUT           _IOW(MPU_IOCTL, 0x50, unsigned long)
+#define SLAVEIRQ_GET_INTERRUPT_CNT     _IOR(MPU_IOCTL, 0x51, unsigned long)
+#define SLAVEIRQ_GET_IRQ_TIME          _IOR(MPU_IOCTL, 0x52, unsigned long)
+
+void slaveirq_exit(struct ext_slave_platform_data *pdata);
+int slaveirq_init(struct i2c_adapter *slave_adapter,
+		  struct ext_slave_platform_data *pdata, char *name);
+
+#endif
diff --git a/drivers/misc/inv_mpu/timerirq.c b/drivers/misc/inv_mpu/timerirq.c
new file mode 100644
index 0000000..601858f
--- /dev/null
+++ b/drivers/misc/inv_mpu/timerirq.c
@@ -0,0 +1,296 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/stat.h>
+#include <linux/signal.h>
+#include <linux/miscdevice.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/poll.h>
+
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/timer.h>
+#include <linux/slab.h>
+
+#include <linux/mpu.h>
+#include "mltypes.h"
+#include "timerirq.h"
+
+/* function which gets timer data and sends it to TIMER */
+struct timerirq_data {
+	int pid;
+	int data_ready;
+	int run;
+	int timeout;
+	unsigned long period;
+	struct mpuirq_data data;
+	struct completion timer_done;
+	wait_queue_head_t timerirq_wait;
+	struct timer_list timer;
+	struct miscdevice *dev;
+};
+
+static struct miscdevice *timerirq_dev_data;
+
+static void timerirq_handler(unsigned long arg)
+{
+	struct timerirq_data *data = (struct timerirq_data *)arg;
+	struct timeval irqtime;
+
+	data->data.interruptcount++;
+
+	data->data_ready = 1;
+
+	do_gettimeofday(&irqtime);
+	data->data.irqtime = (((long long)irqtime.tv_sec) << 32);
+	data->data.irqtime += irqtime.tv_usec;
+	data->data.data_type |= 1;
+
+	dev_dbg(data->dev->this_device,
+		"%s, %lld, %ld\n", __func__, data->data.irqtime,
+		(unsigned long)data);
+
+	wake_up_interruptible(&data->timerirq_wait);
+
+	if (data->run)
+		mod_timer(&data->timer,
+			  jiffies + msecs_to_jiffies(data->period));
+	else
+		complete(&data->timer_done);
+}
+
+static int start_timerirq(struct timerirq_data *data)
+{
+	dev_dbg(data->dev->this_device,
+		"%s current->pid %d\n", __func__, current->pid);
+
+	/* Timer already running... success */
+	if (data->run)
+		return 0;
+
+	/* Don't allow a period of 0 since this would fire constantly */
+	if (!data->period)
+		return -EINVAL;
+
+	data->run = true;
+	data->data_ready = false;
+
+	init_completion(&data->timer_done);
+	setup_timer(&data->timer, timerirq_handler, (unsigned long)data);
+
+	return mod_timer(&data->timer,
+			 jiffies + msecs_to_jiffies(data->period));
+}
+
+static int stop_timerirq(struct timerirq_data *data)
+{
+	dev_dbg(data->dev->this_device,
+		"%s current->pid %lx\n", __func__, (unsigned long)data);
+
+	if (data->run) {
+		data->run = false;
+		mod_timer(&data->timer, jiffies + 1);
+		wait_for_completion(&data->timer_done);
+	}
+	return 0;
+}
+
+/* The following depends on patch fa1f68db6ca7ebb6fc4487ac215bffba06c01c28
+ * drivers: misc: pass miscdevice pointer via file private data
+ */
+static int timerirq_open(struct inode *inode, struct file *file)
+{
+	/* Device node is availabe in the file->private_data, this is
+	 * exactly what we want so we leave it there */
+	struct miscdevice *dev_data = file->private_data;
+	struct timerirq_data *data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->dev = dev_data;
+	file->private_data = data;
+	data->pid = current->pid;
+	init_waitqueue_head(&data->timerirq_wait);
+
+	dev_dbg(data->dev->this_device,
+		"%s current->pid %d\n", __func__, current->pid);
+	return 0;
+}
+
+static int timerirq_release(struct inode *inode, struct file *file)
+{
+	struct timerirq_data *data = file->private_data;
+	dev_dbg(data->dev->this_device, "timerirq_release\n");
+	if (data->run)
+		stop_timerirq(data);
+	kfree(data);
+	return 0;
+}
+
+/* read function called when from /dev/timerirq is read */
+static ssize_t timerirq_read(struct file *file,
+			     char *buf, size_t count, loff_t *ppos)
+{
+	int len, err;
+	struct timerirq_data *data = file->private_data;
+
+	if (!data->data_ready && data->timeout &&
+	    !(file->f_flags & O_NONBLOCK)) {
+		wait_event_interruptible_timeout(data->timerirq_wait,
+						 data->data_ready,
+						 data->timeout);
+	}
+
+	if (data->data_ready && NULL != buf && count >= sizeof(data->data)) {
+		err = copy_to_user(buf, &data->data, sizeof(data->data));
+		data->data.data_type = 0;
+	} else {
+		return 0;
+	}
+	if (err != 0) {
+		dev_err(data->dev->this_device,
+			"Copy to user returned %d\n", err);
+		return -EFAULT;
+	}
+	data->data_ready = 0;
+	len = sizeof(data->data);
+	return len;
+}
+
+static unsigned int timerirq_poll(struct file *file,
+				  struct poll_table_struct *poll)
+{
+	int mask = 0;
+	struct timerirq_data *data = file->private_data;
+
+	poll_wait(file, &data->timerirq_wait, poll);
+	if (data->data_ready)
+		mask |= POLLIN | POLLRDNORM;
+	return mask;
+}
+
+/* ioctl - I/O control */
+static long timerirq_ioctl(struct file *file,
+			   unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+	int tmp;
+	struct timerirq_data *data = file->private_data;
+
+	dev_dbg(data->dev->this_device,
+		"%s current->pid %d, %d, %ld\n",
+		__func__, current->pid, cmd, arg);
+
+	if (!data)
+		return -EFAULT;
+
+	switch (cmd) {
+	case TIMERIRQ_SET_TIMEOUT:
+		data->timeout = arg;
+		break;
+	case TIMERIRQ_GET_INTERRUPT_CNT:
+		tmp = data->data.interruptcount - 1;
+		if (data->data.interruptcount > 1)
+			data->data.interruptcount = 1;
+
+		if (copy_to_user((int *)arg, &tmp, sizeof(int)))
+			return -EFAULT;
+		break;
+	case TIMERIRQ_START:
+		data->period = arg;
+		retval = start_timerirq(data);
+		break;
+	case TIMERIRQ_STOP:
+		retval = stop_timerirq(data);
+		break;
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+/* define which file operations are supported */
+static const struct file_operations timerirq_fops = {
+	.owner = THIS_MODULE,
+	.read = timerirq_read,
+	.poll = timerirq_poll,
+
+#if HAVE_COMPAT_IOCTL
+	.compat_ioctl = timerirq_ioctl,
+#endif
+#if HAVE_UNLOCKED_IOCTL
+	.unlocked_ioctl = timerirq_ioctl,
+#endif
+	.open = timerirq_open,
+	.release = timerirq_release,
+};
+
+static int __init timerirq_init(void)
+{
+
+	int res;
+	static struct miscdevice *data;
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+	timerirq_dev_data = data;
+	data->minor = MISC_DYNAMIC_MINOR;
+	data->name = "timerirq";
+	data->fops = &timerirq_fops;
+
+	res = misc_register(data);
+	if (res < 0) {
+		dev_err(data->this_device, "misc_register returned %d\n", res);
+		return res;
+	}
+
+	return res;
+}
+
+module_init(timerirq_init);
+
+static void __exit timerirq_exit(void)
+{
+	struct miscdevice *data = timerirq_dev_data;
+
+	dev_info(data->this_device, "Unregistering %s\n", data->name);
+
+	misc_deregister(data);
+	kfree(data);
+
+	timerirq_dev_data = NULL;
+}
+
+module_exit(timerirq_exit);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Timer IRQ device driver.");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("timerirq");
diff --git a/drivers/misc/inv_mpu/timerirq.h b/drivers/misc/inv_mpu/timerirq.h
new file mode 100644
index 0000000..f69f07a
--- /dev/null
+++ b/drivers/misc/inv_mpu/timerirq.h
@@ -0,0 +1,30 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+#ifndef __TIMERIRQ__
+#define __TIMERIRQ__
+
+#include <linux/mpu.h>
+
+#define TIMERIRQ_SET_TIMEOUT           _IOW(MPU_IOCTL, 0x60, unsigned long)
+#define TIMERIRQ_GET_INTERRUPT_CNT     _IOW(MPU_IOCTL, 0x61, unsigned long)
+#define TIMERIRQ_START                 _IOW(MPU_IOCTL, 0x62, unsigned long)
+#define TIMERIRQ_STOP                  _IO(MPU_IOCTL, 0x63)
+
+#endif
diff --git a/drivers/net/wireless/bcmdhd/bcmsdh_linux.c b/drivers/net/wireless/bcmdhd/bcmsdh_linux.c
index 14e49e5..b17276f 100755
--- a/drivers/net/wireless/bcmdhd/bcmsdh_linux.c
+++ b/drivers/net/wireless/bcmdhd/bcmsdh_linux.c
@@ -640,7 +640,8 @@ static irqreturn_t wlan_oob_irq(int irq, void *dev_id)
 }
 
 #if 1
-u32 irq_hand = NULL;
+//u32 irq_hand = NULL;
+u32 irq_hand = 0;//modify to fix the compile warning "initialization makes integer from pointer without a cast"
 u32 eint_handle(void *para)
 {
 	unsigned int penable = 0;
diff --git a/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c b/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c
index 88ffdf2..e456063 100755
--- a/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c
+++ b/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c
@@ -875,7 +875,8 @@ sdioh_request_byte(sdioh_info_t *sd, uint rw, uint func, uint regaddr, uint8 *by
 	//AW judge sdio read write timeout, 1s
 	ret = sw_mci_check_r1_ready(gInstance->func[func]->card->host, 1000);
 	if (ret != 0)
-		printk(("%s data timeout.\n", __FUNCTION__));	
+		//printk(("%s data timeout.\n", __FUNCTION__));	
+		printk("%s data timeout.\n", __FUNCTION__);	//modify to fix compile warning
 
 	if (err_ret) {
 		sd_err(("bcmsdh_sdmmc: Failed to %s byte F%d:@0x%05x=%02x, Err: %d\n",
@@ -929,7 +930,8 @@ sdioh_request_word(sdioh_info_t *sd, uint cmd_type, uint rw, uint func, uint add
 	//AW judge sdio read write timeout, 1s
 	ret = sw_mci_check_r1_ready(gInstance->func[func]->card->host, 1000);
 	if (ret != 0)
-		printk(("%s data timeout.\n", __FUNCTION__));
+		//printk(("%s data timeout.\n", __FUNCTION__));	
+		printk("%s data timeout.\n", __FUNCTION__);//modify to fix compile warning
 
 	/* Release host controller */
 	sdio_release_host(gInstance->func[func]);
@@ -1123,7 +1125,8 @@ sdioh_request_packet(sdioh_info_t *sd, uint fix_inc, uint write, uint func,
 			//AW judge sdio read write timeout, 1s
 			ret = sw_mci_check_r1_ready(gInstance->func[func]->card->host, 1000);
 			if (ret != 0)
-				printk(("%s data timeout.\n", __FUNCTION__));
+				//printk(("%s data timeout.\n", __FUNCTION__));
+				printk("%s data timeout.\n", __FUNCTION__);	//modify to fix the compile warning
 			
 			if (err_ret)
 				sd_err(("%s: %s FAILED %p[%d], addr=0x%05x, pkt_len=%d, ERR=%d\n",
diff --git a/drivers/net/wireless/bcmdhd/dhd.h b/drivers/net/wireless/bcmdhd/dhd.h
index 14d04ab..0cc45ab 100755
--- a/drivers/net/wireless/bcmdhd/dhd.h
+++ b/drivers/net/wireless/bcmdhd/dhd.h
@@ -472,7 +472,8 @@ extern void dhd_os_sdunlock_txq(dhd_pub_t * pub);
 extern void dhd_os_sdlock_rxq(dhd_pub_t * pub);
 extern void dhd_os_sdunlock_rxq(dhd_pub_t * pub);
 extern void dhd_os_sdlock_sndup_rxq(dhd_pub_t * pub);
-extern void dhd_customer_gpio_wlan_ctrl(int onoff);
+//extern void dhd_customer_gpio_wlan_ctrl(int onoff);
+extern int dhd_customer_gpio_wlan_ctrl(int onoff);//modify to fix the compile warning: 'return' with a value, in function returning void
 extern int dhd_custom_get_mac_address(unsigned char *buf);
 extern void dhd_os_sdunlock_sndup_rxq(dhd_pub_t * pub);
 extern void dhd_os_sdlock_eventq(dhd_pub_t * pub);
diff --git a/drivers/net/wireless/bcmdhd/dhd_common.c b/drivers/net/wireless/bcmdhd/dhd_common.c
index d7ba7b3..d0380f2 100755
--- a/drivers/net/wireless/bcmdhd/dhd_common.c
+++ b/drivers/net/wireless/bcmdhd/dhd_common.c
@@ -195,14 +195,13 @@ dhd_common_init(osl_t *osh)
 	select_type = wifi_pm_get_mod_type();
 	
 #ifdef CONFIG_BCMDHD_FW_PATH
-	//select ap6181 or ap6210
-	if (select_type == 1 || select_type == 2) {
+	//select ap6181 or ap6210 or gb9662
+	if (select_type == 1 || select_type == 2 || select_type == 9) {
 		bcm_strncpy_s(fw_path, sizeof(fw_path), "/system/vendor/modules/fw_bcm40181a2.bin", MOD_PARAM_PATHLEN-1);
 	}
-
-	//select ap6330
-	if (select_type == 9) {
-		bcm_strncpy_s(fw_path, sizeof(fw_path), "/system/vendor/modules/fw_bcm40183b2_ag.bin", MOD_PARAM_PATHLEN-1);
+	//select gb9663
+	if (select_type == 10) {
+		bcm_strncpy_s(fw_path, sizeof(fw_path), "/system/vendor/modules/fw_bcm40183b2.bin", MOD_PARAM_PATHLEN-1);
 	}
 #else /* CONFIG_BCMDHD_FW_PATH */
 	fw_path[0] = '\0';
@@ -218,10 +217,16 @@ dhd_common_init(osl_t *osh)
 		bcm_strncpy_s(nv_path, sizeof(nv_path), "/system/vendor/modules/nvram_ap6210.txt", MOD_PARAM_PATHLEN-1);
 	}
 
-	//select ap6330
+	//select gb9662
 	if (select_type == 9) {
-		bcm_strncpy_s(nv_path, sizeof(nv_path), "/system/vendor/modules/nvram_ap6330.txt", MOD_PARAM_PATHLEN-1);
+		bcm_strncpy_s(nv_path, sizeof(nv_path), "/system/vendor/modules/nvram_gb9662.txt", MOD_PARAM_PATHLEN-1);
 	}
+
+	//select gb9663
+	if (select_type == 10) {
+		bcm_strncpy_s(nv_path, sizeof(nv_path), "/system/vendor/modules/nvram_gb9663.txt", MOD_PARAM_PATHLEN-1);
+	}
+	
 #else /* CONFIG_BCMDHD_NVRAM_PATH */
 	nv_path[0] = '\0';
 #endif /* CONFIG_BCMDHD_NVRAM_PATH */
diff --git a/drivers/net/wireless/bcmdhd/dhd_custom_gpio.c b/drivers/net/wireless/bcmdhd/dhd_custom_gpio.c
index 983ab60..4cb6487 100755
--- a/drivers/net/wireless/bcmdhd/dhd_custom_gpio.c
+++ b/drivers/net/wireless/bcmdhd/dhd_custom_gpio.c
@@ -131,7 +131,8 @@ int dhd_customer_oob_irq_map(unsigned long *irq_flags_ptr)
 #endif 
 
 /* Customer function to control hw specific wlan gpios */
-void
+//void
+int  //modify to fix the compile warning: 'return' with a value, in function returning void
 dhd_customer_gpio_wlan_ctrl(int onoff)
 {
 	static int first = 1;
@@ -144,7 +145,7 @@ dhd_customer_gpio_wlan_ctrl(int onoff)
 		type = script_get_item("wifi_para", "wifi_sdc_id", &val);
 		if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
 			WL_ERROR(("failed to fetch sdio card's sdcid\n"));
-			return ;
+			return -1;
 		}
 		sdc_id = val.val;
 		first = 0;
@@ -160,6 +161,7 @@ dhd_customer_gpio_wlan_ctrl(int onoff)
 #if defined(CUSTOMER_HW2)
 			wifi_set_power(0, 0);
 #endif
+			mdelay(100);
 			WL_ERROR(("=========== WLAN placed in RESET ========\n"));
 		break;
 
@@ -172,6 +174,7 @@ dhd_customer_gpio_wlan_ctrl(int onoff)
 #if defined(CUSTOMER_HW2)
 			wifi_set_power(1, 0);
 #endif
+			mdelay(100);
 			WL_ERROR(("=========== WLAN going back to live  ========\n"));
 		break;
 
@@ -197,6 +200,7 @@ dhd_customer_gpio_wlan_ctrl(int onoff)
 			WL_ERROR(("=========== WLAN placed in POWER ON ========\n"));
 		break;
 	}
+	return 0;//modify to fix the compile warning: 'return' with a value, in function returning void
 }
 
 #ifdef GET_CUSTOM_MAC_ENABLE
diff --git a/drivers/net/wireless/bcmdhd/include/wlioctl.h b/drivers/net/wireless/bcmdhd/include/wlioctl.h
index a3e7003..ef952e6 100755
--- a/drivers/net/wireless/bcmdhd/include/wlioctl.h
+++ b/drivers/net/wireless/bcmdhd/include/wlioctl.h
@@ -1715,12 +1715,12 @@ typedef struct {
 /* WLC_GET_AUTH, WLC_SET_AUTH values */
 #define WL_AUTH_OPEN_SYSTEM		0	/* d11 open authentication */
 #define WL_AUTH_SHARED_KEY		1	/* d11 shared authentication */
-#ifdef BCM4330_CHIP
+//#ifdef BCM4330_CHIP
 #define WL_AUTH_OPEN_SHARED		2	/* try open, then shared if open failed w/rc 13 */
-#else
+//#else
 /* BCM4334(Phoenex branch) value changed to 3 */
-#define WL_AUTH_OPEN_SHARED		3	/* try open, then shared if open failed w/rc 13 */
-#endif
+//#define WL_AUTH_OPEN_SHARED		3	/* try open, then shared if open failed w/rc 13 */
+//#endif
 #endif /* LINUX_POSTMOGRIFY_REMOVAL */
 
 /* Bit masks for radio disabled status - returned by WL_GET_RADIO */
diff --git a/drivers/net/wireless/bcmdhd/wl_android.c b/drivers/net/wireless/bcmdhd/wl_android.c
index ed81f92..41801a3 100755
--- a/drivers/net/wireless/bcmdhd/wl_android.c
+++ b/drivers/net/wireless/bcmdhd/wl_android.c
@@ -159,7 +159,8 @@ typedef struct android_wifi_priv_cmd {
 /**
  * Extern function declarations (TODO: move them to dhd_linux.h)
  */
-void dhd_customer_gpio_wlan_ctrl(int onoff);
+//void dhd_customer_gpio_wlan_ctrl(int onoff);
+int dhd_customer_gpio_wlan_ctrl(int onoff);//modify to fix the compile warning: 'return' with a value, in function returning void
 int dhd_dev_reset(struct net_device *dev, uint8 flag);
 int dhd_dev_init_ioctl(struct net_device *dev);
 #ifdef WL_CFG80211
diff --git a/drivers/power/axp_power/axp-sply.h b/drivers/power/axp_power/axp-sply.h
index 5d6226a..c1406c7 100755
--- a/drivers/power/axp_power/axp-sply.h
+++ b/drivers/power/axp_power/axp-sply.h
@@ -81,11 +81,13 @@ static 	struct input_dev * powerkeydev;
 #define AXP22_DATA_BUFFERB					AXP22_BUFFERC
 
 const uint64_t AXP22_NOTIFIER_ON = (AXP22_IRQ_USBIN | AXP22_IRQ_USBRE |
-                                    AXP22_IRQ_ACIN  | AXP22_IRQ_ACRE |
-                                    AXP22_IRQ_BATIN | AXP22_IRQ_BATRE |
-				       				AXP22_IRQ_CHAST |  AXP22_IRQ_CHAOV | 
-				       				(uint64_t)AXP22_IRQ_PEKFE |
-				       				(uint64_t)AXP22_IRQ_PEKRE);
+					AXP22_IRQ_ACIN  | AXP22_IRQ_ACRE |
+					AXP22_IRQ_TEMOV | AXP22_IRQ_TEMLO |
+					AXP22_IRQ_BATIN | AXP22_IRQ_BATRE |
+					AXP22_IRQ_CHAST | AXP22_IRQ_CHAOV | 
+					AXP22_IRQ_EXTLOWARN1 | AXP22_IRQ_EXTLOWARN2 | // enable low power alert 1,2
+					(uint64_t)AXP22_IRQ_PEKFE |
+					(uint64_t)AXP22_IRQ_PEKRE);
 
 
 #define AXP_CHG_ATTR(_name)					\
diff --git a/drivers/power/axp_power/axp22-sply.c b/drivers/power/axp_power/axp22-sply.c
index 7623917..a182b03 100755
--- a/drivers/power/axp_power/axp22-sply.c
+++ b/drivers/power/axp_power/axp22-sply.c
@@ -48,6 +48,9 @@
 #define DBG_PSY_MSG(format,args...)   do {} while (0)
 #endif
 
+#define DELAYTIME 60	// delay=60*10=600s=10min
+static int device_state = 0;	// record device's state for lowpower, 0 for on, 1 for sleep
+
 static int axp_debug = 0;
 static int vbus_curr_limit_debug = 1;
 static int long_key_power_off = 1;
@@ -439,20 +442,35 @@ static enum power_supply_property axp_usb_props[] = {
   POWER_SUPPLY_PROP_CURRENT_NOW,
 };
 
+static int axp_battery_check_status_counter=0;
 static void axp_battery_check_status(struct axp_charger *charger,
             union power_supply_propval *val)
 {
   if (charger->bat_det) {
     if (charger->ext_valid){
-    	if( charger->rest_vol == 100)
-        val->intval = POWER_SUPPLY_STATUS_FULL;
-    	else if(charger->charge_on)
-    		val->intval = POWER_SUPPLY_STATUS_CHARGING;
-    	else
+    	if( charger->rest_vol == 100){
+	       	val->intval = POWER_SUPPLY_STATUS_FULL;
+		axp_battery_check_status_counter|=0x4;
+	}
+    	else if((charger->charge_on) && (charger->bat_current_direction == 1)){
+		if( (axp_battery_check_status_counter&0x3) == 0x3 ) {
+    			val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		}
+		else{
+	    		val->intval = POWER_SUPPLY_STATUS_CHARGING;
+			axp_battery_check_status_counter|=0x1;
+		}
+	}
+    	else{
     		val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		if( (axp_battery_check_status_counter&0x1) != 0 )
+			axp_battery_check_status_counter|=0x2;
+	}
     }
-    else
+    else{
       val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+      axp_battery_check_status_counter=0;
+    }
   }
   else
     val->intval = POWER_SUPPLY_STATUS_FULL;
@@ -570,10 +588,19 @@ static int axp_ac_get_property(struct power_supply *psy,
   case POWER_SUPPLY_PROP_MODEL_NAME:
     val->strval = charger->ac.name;break;
   case POWER_SUPPLY_PROP_PRESENT:
-    val->intval = charger->ac_det;
+//    val->intval = charger->ac_det;
+	if((1 == charger->ac_det) && (0 == axp_usbcurflag))
+		val->intval = 1;
+	else
+		val->intval = 0;
     break;
   case POWER_SUPPLY_PROP_ONLINE:
-    val->intval = charger->ac_valid;break;
+//    val->intval = charger->ac_valid;break;
+  	if((1 == charger->ac_valid) && (0 == axp_usbcurflag))
+		val->intval = 1;
+	else
+		val->intval = 0;
+	break;
   case POWER_SUPPLY_PROP_VOLTAGE_NOW:
     val->intval = charger->vac * 1000;
     break;
@@ -599,11 +626,19 @@ static int axp_usb_get_property(struct power_supply *psy,
   case POWER_SUPPLY_PROP_MODEL_NAME:
     val->strval = charger->usb.name;break;
   case POWER_SUPPLY_PROP_PRESENT:
-    val->intval = charger->usb_det;
-    break;
+//    val->intval = charger->usb_det;
+  	if(1 == axp_usbcurflag)
+		val->intval = 1;
+	else
+		val->intval = 0;
+	break;
   case POWER_SUPPLY_PROP_ONLINE:
-    val->intval = charger->usb_valid;
-    break;
+//    val->intval = charger->usb_valid;
+  	if(1 == axp_usbcurflag)
+		val->intval = 1;
+	else
+		val->intval = 0;
+	break;
   case POWER_SUPPLY_PROP_VOLTAGE_NOW:
     val->intval = charger->vusb * 1000;
     break;
@@ -760,11 +795,21 @@ static int axp_battery_event(struct notifier_block *nb, unsigned long event,
 				axp_capchange(charger);
 			}
 	
-			if(event & (AXP22_IRQ_ACIN|AXP22_IRQ_USBIN|AXP22_IRQ_ACOV|AXP22_IRQ_USBOV|AXP22_IRQ_CHAOV
-						|AXP22_IRQ_CHAST|AXP22_IRQ_TEMOV|AXP22_IRQ_TEMLO)) {
+//			if(event & (AXP22_IRQ_ACIN|AXP22_IRQ_USBIN|AXP22_IRQ_ACOV|AXP22_IRQ_USBOV|AXP22_IRQ_CHAOV
+//						|AXP22_IRQ_CHAST|AXP22_IRQ_TEMOV|AXP22_IRQ_TEMLO)) {
+
+			if(event & (AXP22_IRQ_ACIN|AXP22_IRQ_USBIN)){
+				printk("!!!!!!!!!!!!!!ac in or usb in\n");
+			}
+
+			if(event & (AXP22_IRQ_ACOV|AXP22_IRQ_USBOV|AXP22_IRQ_CHAOV|AXP22_IRQ_TEMOV|AXP22_IRQ_TEMLO)){
 				axp_change(charger);
 			}
 	
+			if(event & AXP22_IRQ_CHAST){
+				axp_change(charger);
+			}
+
 			if(event & (AXP22_IRQ_ACRE|AXP22_IRQ_USBRE)) {
 				axp_change(charger);
 			}
@@ -776,6 +821,11 @@ static int axp_battery_event(struct notifier_block *nb, unsigned long event,
 			if(event & AXP22_IRQ_POKSH) {
 				axp_pressshort(charger);
 			}
+
+			/* imitate a powerkey event to wake up the device in low power */
+			if((event & (AXP22_IRQ_EXTLOWARN1 | AXP22_IRQ_EXTLOWARN2 )) && device_state) {
+				axp_pressshort(charger);
+			}
 			w[0] = (uint8_t) ((event) & 0xFF);
     		w[1] = AXP22_INTSTS2;
     		w[2] = (uint8_t) ((event >> 8) & 0xFF);
@@ -881,6 +931,14 @@ static int axp_battery_adc_set(struct axp_charger *charger)
   if (ret)
     return ret;
 
+   //set the TS output current to 40uA
+   axp_clr_bits(charger->master, AXP22_ADC_CONTROL3, 0x20);
+   axp_set_bits(charger->master, AXP22_ADC_CONTROL3, 0x10);
+   //set reg_84h to d1
+   axp_clr_bits(charger->master, AXP22_ADC_CONTROL3, 0x02);
+   axp_set_bits(charger->master, AXP22_ADC_CONTROL3, 0x01);
+   // axp_read(charger->master, AXP22_ADC_CONTROL3, &val);
+  // printk("val = %d\n", val);
   return 0;
 }
 #else
@@ -894,11 +952,44 @@ static int axp_battery_first_init(struct axp_charger *charger)
 {
    int ret;
    uint8_t val;
+
+   script_item_u chg_high_temp, chg_low_temp;                                                              
+   script_item_u dischg_high_temp, dischg_low_temp;           
+   script_item_value_type_e type;
+
    axp_set_charge(charger);
    ret = axp_battery_adc_set(charger);
    if(ret)
     return ret;
 
+   type = script_get_item("battery_para", "chg_high_temp", &chg_high_temp);              
+   if(SCIRPT_ITEM_VALUE_TYPE_INT != type){                         
+        printk("type error!\n");
+		chg_high_temp.val = 0x12;
+   }
+   axp_write(charger->master, 0x39, chg_high_temp.val);  //charge 40      
+		                    
+   type = script_get_item("battery_para", "chg_low_temp", &chg_low_temp);       
+   if(SCIRPT_ITEM_VALUE_TYPE_INT != type){      
+        printk("type error!\n");     
+		chg_low_temp.val = 0x57;
+   }
+   axp_write(charger->master, 0x38, chg_low_temp.val);   //charge 0        
+					          
+   type = script_get_item("battery_para", "dischg_high_temp", &dischg_high_temp);         
+   if(SCIRPT_ITEM_VALUE_TYPE_INT != type){
+        printk("type error!\n");     
+		dischg_high_temp.val = 0x0D;
+   }
+   axp_write(charger->master, 0x3D, dischg_high_temp.val);  //discharge 50    
+								                    
+   type = script_get_item("battery_para", "dischg_low_temp", &dischg_low_temp);       
+   if(SCIRPT_ITEM_VALUE_TYPE_INT != type){        
+       printk("type error!\n");           
+	   dischg_low_temp.val = 0x8B;
+   }
+   axp_write(charger->master, 0x3C, dischg_low_temp.val);  //discharge -10 
+
    ret = axp_read(charger->master, AXP22_ADC_CONTROL3, &val);
    switch ((val >> 6) & 0x03){
   case 0: charger->sample_time = 100;break;
@@ -1252,7 +1343,8 @@ static void axp_earlysuspend(struct early_suspend *h)
 	uint8_t tmp;
 	if(axp_debug)
 		DBG_PSY_MSG("======early suspend=======\n");
-
+	
+	device_state = 1;
 #if defined (CONFIG_AXP_CHGCHANGE)
   	early_suspend_flag = 1;
   	if(pmu_earlysuspend_chgcur == 0)
@@ -1273,6 +1365,7 @@ static void axp_lateresume(struct early_suspend *h)
 	if(axp_debug)
 		DBG_PSY_MSG("======late resume=======\n");
 
+	device_state = 0;
 #if defined (CONFIG_AXP_CHGCHANGE)
 	early_suspend_flag = 0;
 	if(pmu_runtime_chgcur == 0)
@@ -1319,6 +1412,8 @@ static void axp_charging_monitor(struct work_struct *work)
 	struct axp_charger *charger;
 	uint8_t	val,temp_val[4];
 	int	pre_rest_vol,pre_bat_curr_dir;
+	static int state = 0;	// add to record if we have revised the volume
+	static int count = 0;	// record the count after the volume reach to 99%
 //	uint16_t tmp;
 	charger = container_of(work, struct axp_charger, work.work);
 	pre_rest_vol = charger->rest_vol;
@@ -1328,6 +1423,51 @@ static void axp_charging_monitor(struct work_struct *work)
 
 	axp_read(charger->master, AXP22_CAP,&val);
 	charger->rest_vol	= (int)	(val & 0x7F);
+	
+	/* When the volume reach to 99% and keep charging DELAYTIME*10 second,
+	 * we revise the voluem to 100% manualy.
+	 */
+	if (charger->rest_vol == 99) {
+		if (charger->bat_current_direction == 1) {
+			if (count == DELAYTIME)
+				count = DELAYTIME;
+			else
+				count++;
+		} else {
+			if (count == 0)
+				count = 0;
+			else
+				count--;
+		}
+
+		if (count == DELAYTIME && charger->bat_current_direction == 1) {
+			charger->rest_vol = 100;
+			state = 1;
+		}
+
+		/* After we have modified the volume to 100% and the user stop charging, 
+		 * we remain the volume of 100% DELAYTIME*10 second.
+		 */
+		if (count >= 0 && charger->bat_current_direction == 0 && state == 1)
+			charger->rest_vol = 100;
+
+		if (count == 0 && charger->bat_current_direction == 0 && state == 1)
+			state =0;
+	}
+
+	if (charger->rest_vol < 99)
+		count = 0;
+#if 0
+	/* Modify alert threshold in low power dynamically */
+	if (charger->rest_vol > 10) 
+		axp_write(charger->master, AXP22_WARNING_LEVEL, 0x50);	// set the 1st alert to 10
+	if (charger->rest_vol < 10 && charger->rest_vol > 5) 
+		axp_write(charger->master, AXP22_WARNING_LEVEL, 0x00);	// set the 1st alert to 5
+	if (charger->rest_vol < 5) {
+		/* volume is to low, poweroff the device */
+	}
+#endif
+
 #if 0	
 #if defined (CONFIG_AXP_CHGCHANGE)	
 #if defined CONFIG_HAS_EARLYSUSPEND
@@ -1440,7 +1580,7 @@ static void axp_usb(struct work_struct *work)
 			printk("set usbcur_pc %d mA\n",pmu_usbcur_pc);
 		}
 		if(pmu_usbcur_pc){
-			msleep(20*1000);
+			//msleep(20*1000);
 			axp_clr_bits(charger->master, AXP22_CHARGE_VBUS, 0x01);
 			var = pmu_usbcur_pc * 1000;
 			if(var >= 900000)
@@ -1610,14 +1750,14 @@ static int axp_battery_probe(struct platform_device *pdev)
   if (ret)
     goto err_ps_register;
 
-	axp_read(charger->master,AXP22_CHARGE_STATUS,&val);
-	if(!((val >> 1) & 0x01)){
+//	axp_read(charger->master,AXP22_CHARGE_STATUS,&val);
+//	if(!((val >> 1) & 0x01)){
   	ret = power_supply_register(&pdev->dev, &charger->ac);
   	if (ret){
     	power_supply_unregister(&charger->batt);
     	goto err_ps_register;
   	}
-  }
+//  }
 
   ret = power_supply_register(&pdev->dev, &charger->usb);
   if (ret){
diff --git a/drivers/rtc/alarm.c b/drivers/rtc/alarm.c
index 511acdc..1b82040 100755
--- a/drivers/rtc/alarm.c
+++ b/drivers/rtc/alarm.c
@@ -389,7 +389,7 @@ static int alarm_suspend(struct platform_device *pdev, pm_message_t state)
 	spin_unlock_irqrestore(&alarm_slock, flags);
 
 	hrtimer_cancel(&alarms[ANDROID_ALARM_RTC_SHUTDOWN_WAKEUP].timer);
-#ifndef CONFIG_RTC_ALARM_CLOCK_WAKEUP
+#ifdef CONFIG_RTC_ALARM_CLOCK_WAKEUP
 	hrtimer_cancel(&alarms[ANDROID_ALARM_RTC_WAKEUP].timer);
 	hrtimer_cancel(&alarms[
 			ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP].timer);
@@ -399,7 +399,7 @@ static int alarm_suspend(struct platform_device *pdev, pm_message_t state)
 	if (tmp_queue->first) {
 		wakeup_queue = tmp_queue;
 	}
-#ifndef CONFIG_RTC_ALARM_CLOCK_WAKEUP
+#ifdef CONFIG_RTC_ALARM_CLOCK_WAKEUP
 	tmp_queue = &alarms[ANDROID_ALARM_RTC_WAKEUP];
 	if (tmp_queue->first && (!wakeup_queue ||
 		hrtimer_get_expires(&tmp_queue->timer).tv64 <
@@ -445,7 +445,7 @@ static int alarm_suspend(struct platform_device *pdev, pm_message_t state)
 			spin_lock_irqsave(&alarm_slock, flags);
 			suspended = false;
 			wake_lock_timeout(&alarm_rtc_wake_lock, 2 * HZ);
-#ifndef CONFIG_RTC_ALARM_CLOCK_WAKEUP
+#ifdef CONFIG_RTC_ALARM_CLOCK_WAKEUP
 			update_timer_locked(&alarms[ANDROID_ALARM_RTC_WAKEUP],
 									false);
 			update_timer_locked(&alarms[
@@ -474,7 +474,7 @@ static int alarm_resume(struct platform_device *pdev)
 
 	spin_lock_irqsave(&alarm_slock, flags);
 	suspended = false;
-#ifndef CONFIG_RTC_ALARM_CLOCK_WAKEUP
+#ifdef CONFIG_RTC_ALARM_CLOCK_WAKEUP
 	update_timer_locked(&alarms[ANDROID_ALARM_RTC_WAKEUP], false);
 	update_timer_locked(&alarms[ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP],
 									false);
diff --git a/drivers/staging/android/switch/switch_headset.c b/drivers/staging/android/switch/switch_headset.c
index 842b81b..336b709 100755
--- a/drivers/staging/android/switch/switch_headset.c
+++ b/drivers/staging/android/switch/switch_headset.c
@@ -136,7 +136,7 @@ struct gpio_switch_data {
 	int check_four_count;
 
 	enum headphone_mode_u mode;		/* mode for three/four sector headphone */
-	struct work_struct work;
+	struct delayed_work work;
 	struct semaphore sem;
 	struct timer_list timer;
 
@@ -236,7 +236,7 @@ static void earphone_switch_timer_poll(unsigned long data)
 	}
 }
 
-static void earphone_switch_work(struct work_struct *work)
+static void earphone_switch_work(struct delayed_work *work)
 {
 	struct gpio_switch_data	*switch_data =
 		container_of(work, struct gpio_switch_data, work);
@@ -271,10 +271,14 @@ static irqreturn_t audio_hmic_irq(int irq, void *dev_id)
 	tmp = hmic_rdreg(SUN6I_HMIC_DATA);
 	tmp &= 0x1f;
 SWITCH_DBG("%s,line:%d,tmp:%x\n", __func__, __LINE__, tmp);
-
+	del_timer(&switch_data->work.timer);
 	if (((&switch_data->timer) != NULL)) {
 		del_timer(&switch_data->timer);
 	}
+
+	work_clear_pending(&switch_data->work.work);
+
+//	printk("tmp=%x\n",tmp);
 	if (tmp) {
 		SWITCH_DBG("%s,line:%d,tmp:%x\n", __func__, __LINE__, tmp);
 		if (!headphone_direct_used) {
@@ -300,7 +304,8 @@ SWITCH_DBG("%s,line:%d,tmp:%x\n", __func__, __LINE__, tmp);
 		headphone_state = 0;
 		switch_data->state = 0;
 	}
-	schedule_work(&switch_data->work);
+
+	schedule_delayed_work(&switch_data->work,HZ);
 	return IRQ_HANDLED;
 }
 
@@ -455,11 +460,11 @@ static int gpio_switch_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, (void *)switch_data);
 
 	switch_data->sdev.state 		= 0;
-	switch_data->state				= -1;
+	switch_data->state				= 0;
 	switch_data->sdev.name 			= pdata->name;
 	switch_data->sdev.print_name 	= print_headset_name;
 	switch_data->sdev.print_state 	= switch_gpio_print_state;
-	INIT_WORK(&switch_data->work, earphone_switch_work);
+	INIT_DELAYED_WORK(&switch_data->work, earphone_switch_work);
 	INIT_WORK(&switch_data->resume_work, switch_resume_events);
  	/* create input device */
     switch_data->key = input_allocate_device();
diff --git a/drivers/tty/serial/sw_uart.c b/drivers/tty/serial/sw_uart.c
index ee37233..355c50d 100755
--- a/drivers/tty/serial/sw_uart.c
+++ b/drivers/tty/serial/sw_uart.c
@@ -1186,6 +1186,10 @@ void sw_uart_procfs_remove(struct sw_uart_port *sw_uport)
 }
 #endif
 
+#ifdef CONFIG_BT_LPM
+extern void bluesleep_setup_uart_port(struct platform_device *uart_dev);
+#endif
+
 static int __devinit sw_uart_probe(struct platform_device *pdev)
 {
 	u32 id = pdev->id;
@@ -1236,6 +1240,20 @@ static int __devinit sw_uart_probe(struct platform_device *pdev)
 #ifdef CONFIG_PROC_FS
 	sw_uart_procfs_attach(sw_uport);
 #endif
+
+#ifdef CONFIG_BT_LPM
+	script_item_value_type_e type;
+	script_item_u val;
+	type = script_get_item("bt_para", "bt_uart_id", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+	SERIAL_MSG("failed to fetch bt uart configuration.");
+	return -1;
+	}
+	if (val.val != 0 && val.val == sw_uport->id) {
+	bluesleep_setup_uart_port(pdev);
+	}
+#endif
+
 	SERIAL_DBG("add uart%d port, port_type %d, uartclk %d\n",
 			id, port->type, port->uartclk);
 	return uart_add_one_port(&sw_uart_driver, port);
diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index 815b0f6..94d7b88 100755
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -309,15 +309,15 @@ static const char fsg_string_interface[] = "Mass Storage";
 #define FSG_NO_OTG               1
 #define FSG_NO_INTR_EP           1
 
-#define DO_VFS_STAT              1
-#define DO_VFS_END               2
-
-#include "storage_common.c"
+#define DO_VFS_STAT              1
+#define DO_VFS_END               2
 
-extern atomic_t vfs_read_flag;
-extern atomic_t vfs_write_flag;
-extern int g_msc_write_debug;
+#include "storage_common.c"
 
+extern atomic_t vfs_read_flag;
+extern atomic_t vfs_write_flag;
+extern unsigned int vfs_amount;
+extern loff_t vfs_file_offset;
 
 /*-------------------------------------------------------------------------*/
 
@@ -832,13 +832,13 @@ static int do_read(struct fsg_common *common)
                 nread = amount;
             }
         }else{
-			if(g_msc_write_debug)
-				atomic_set(&vfs_read_flag, DO_VFS_STAT);
+			vfs_amount = amount;
+			vfs_file_offset = file_offset_tmp;
+			atomic_set(&vfs_read_flag, DO_VFS_STAT);
             nread = vfs_read(curlun->filp,
                      (char __user *)bh->buf,
                      amount, &file_offset_tmp);
-			if(g_msc_write_debug)
-				atomic_set(&vfs_read_flag, DO_VFS_END);
+			atomic_set(&vfs_read_flag, DO_VFS_END);
         }
 #else
         nread = vfs_read(curlun->filp,
@@ -1043,13 +1043,13 @@ static int do_write(struct fsg_common *common)
 								if(amount <= 512){
 									msleep(1);
 								}
-				if(g_msc_write_debug)
-					atomic_set(&vfs_write_flag, DO_VFS_STAT);
+				vfs_amount = amount;
+				vfs_file_offset = file_offset_tmp;
+				atomic_set(&vfs_write_flag, DO_VFS_STAT);
                 nwritten = vfs_write(curlun->filp,
                              (char __user *)bh->buf,
                              amount, &file_offset_tmp);
-				if(g_msc_write_debug)
-					atomic_set(&vfs_write_flag, DO_VFS_END);
+				atomic_set(&vfs_write_flag, DO_VFS_END);
             }
 #else
             nwritten = vfs_write(curlun->filp,
diff --git a/drivers/usb/gadget/f_rndis.c b/drivers/usb/gadget/f_rndis.c
index fff81df..0ffbc2e 100644
--- a/drivers/usb/gadget/f_rndis.c
+++ b/drivers/usb/gadget/f_rndis.c
@@ -545,11 +545,12 @@ static int rndis_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 			VDBG(cdev, "reset rndis control %d\n", intf);
 			usb_ep_disable(rndis->notify);
 		}
-		if (!rndis->notify->desc) {
+		//if (!rndis->notify->desc) {
+			rndis->notify->desc = NULL;
 			VDBG(cdev, "init rndis ctrl %d\n", intf);
 			if (config_ep_by_speed(cdev->gadget, f, rndis->notify))
 				goto fail;
-		}
+		//}
 		usb_ep_enable(rndis->notify);
 		rndis->notify->driver_data = rndis;
 
@@ -559,10 +560,13 @@ static int rndis_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 		if (rndis->port.in_ep->driver_data) {
 			DBG(cdev, "reset rndis\n");
 			gether_disconnect(&rndis->port);
+
 		}
 
-		if (!rndis->port.in_ep->desc || !rndis->port.out_ep->desc) {
+		//if (!rndis->port.in_ep->desc || !rndis->port.out_ep->desc) {
 			DBG(cdev, "init rndis\n");
+			rndis->port.in_ep->desc = NULL;
+			rndis->port.out_ep->desc = NULL;
 			if (config_ep_by_speed(cdev->gadget, f,
 					       rndis->port.in_ep) ||
 			    config_ep_by_speed(cdev->gadget, f,
@@ -571,7 +575,7 @@ static int rndis_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 				rndis->port.out_ep->desc = NULL;
 				goto fail;
 			}
-		}
+		//}
 
 		/* Avoid ZLPs; they can be troublesome. */
 		rndis->port.is_zlp_ok = false;
diff --git a/drivers/usb/host/sw_hci_sun6i.c b/drivers/usb/host/sw_hci_sun6i.c
index 1fe0e33..2b37b3c 100755
--- a/drivers/usb/host/sw_hci_sun6i.c
+++ b/drivers/usb/host/sw_hci_sun6i.c
@@ -1044,7 +1044,7 @@ static void sw_set_vbus(struct sw_hci_hcd *sw_hci, int is_on)
         }else{
             usb1_set_vbus_cnt--;
         }
-    }if(sw_hci->usbc_no == 2){
+    }else if(sw_hci->usbc_no == 2){
         if(is_on && usb2_set_vbus_cnt == 0){
             __sw_set_vbus(sw_hci, is_on);  /* power on */
         }else if(!is_on && usb2_set_vbus_cnt == 1){
diff --git a/drivers/usb/sun6i_usb/hcd/hcd0/sw_hcd0.c b/drivers/usb/sun6i_usb/hcd/hcd0/sw_hcd0.c
index c12ecfd..3e549ac 100755
--- a/drivers/usb/sun6i_usb/hcd/hcd0/sw_hcd0.c
+++ b/drivers/usb/sun6i_usb/hcd/hcd0/sw_hcd0.c
@@ -94,7 +94,7 @@ static __u32 usbc_no = 0;
 
 #ifdef  CONFIG_USB_SW_SUN6I_USB0_OTG
 static struct platform_device *g_hcd0_pdev = NULL;
-extern atomic_t thread_suspend_flag;
+extern atomic_t thread_suspend_flag;
 #endif
 
 static struct sw_hcd_context_registers sw_hcd_context;
@@ -929,57 +929,14 @@ static int sw_hcd_core_init(u16 sw_hcd_type, struct sw_hcd *sw_hcd)
 {
 	u8              reg         = 0;
 	char            *type       = NULL;
-	char            aInfo[78];
-	char            aRevision[32];
-	char            aDate[12];
 	void __iomem    *usbc_base  = sw_hcd->mregs;
 	int             status      = 0;
 	int             i           = 0;
 
-    memset(aInfo, 0, sizeof(aInfo));
-    memset(aRevision, 0, sizeof(aRevision));
-    memset(aDate, 0, sizeof(aDate));
-
 	/* log core options (read using indexed model) */
 	sw_hcd_ep_select(usbc_base, 0);
 	reg = sw_hcd_read_configdata(usbc_base);
 
-    strcpy(aInfo, (reg & (1 << USBC_BP_CONFIGDATA_UTMI_DATAWIDTH)) ? "UTMI-16" : "UTMI-8");
-
-	if (reg & (1 << USBC_BP_CONFIGDATA_DYNFIFO_SIZING)){
-		strcat(aInfo, ", dyn FIFOs");
-	}
-
-	if (reg & (1 << USBC_BP_CONFIGDATA_MPRXE)) {
-		strcat(aInfo, ", bulk combine");
-
-		sw_hcd->bulk_combine = true;
-	}
-
-	if (reg & (1 << USBC_BP_CONFIGDATA_MPTXE)) {
-		strcat(aInfo, ", bulk split");
-
-		sw_hcd->bulk_split = true;
-	}
-
-	if (reg & (1 << USBC_BP_CONFIGDATA_HBRXE)) {
-		strcat(aInfo, ", HB-ISO Rx");
-		strcat(aInfo, " (X)");		/* no driver support */
-	}
-
-	if (reg & (1 << USBC_BP_CONFIGDATA_HBTXE)) {
-		strcat(aInfo, ", HB-ISO Tx");
-		strcat(aInfo, " (X)");		/* no driver support */
-	}
-
-	if (reg & (1 << USBC_BP_CONFIGDATA_SOFTCONE)){
-		strcat(aInfo, ", SoftConn");
-	}
-
-//	DMSG_INFO_HCD0("%s: ConfigData=0x%02x (%s)\n", sw_hcd_driver_name, reg, aInfo);
-
-	aDate[0] = 0;
-
 	if (SW_HCD_CONTROLLER_MHDRC == sw_hcd_type) {
 		sw_hcd->is_multipoint = 1;
 		type = "M";
@@ -2256,7 +2213,7 @@ static int sw_hcd_suspend(struct device *dev)
 
 	DMSG_INFO_HCD0("sw_hcd_suspend start\n");
 
-	atomic_set(&thread_suspend_flag, 1);
+	atomic_set(&thread_suspend_flag, 1);
 
 	if(!sw_hcd->enable){
 		DMSG_INFO("wrn: hcd is disable, need not enter to suspend\n");
@@ -2308,7 +2265,7 @@ static int sw_hcd_resume(struct device *dev)
 
 	DMSG_INFO_HCD0("sw_hcd_resume start\n");
 
-	atomic_set(&thread_suspend_flag, 0);
+	atomic_set(&thread_suspend_flag, 0);
 
 	if(!sw_hcd->enable){
 		DMSG_INFO("wrn: hcd is disable, need not resume\n");
diff --git a/drivers/usb/sun6i_usb/manager/usb_hw_scan.c b/drivers/usb/sun6i_usb/manager/usb_hw_scan.c
index 68c9b67..a654a07 100755
--- a/drivers/usb/sun6i_usb/manager/usb_hw_scan.c
+++ b/drivers/usb/sun6i_usb/manager/usb_hw_scan.c
@@ -493,10 +493,10 @@ static void do_vbus1_id1(struct usb_scan_info *info)
 					break;
 				}
     			/* delay for vbus is stably */
-    			if(device_insmod_delay < USB_SCAN_INSMOD_DEVICE_DRIVER_DELAY){
+/*    			if(device_insmod_delay < USB_SCAN_INSMOD_DEVICE_DRIVER_DELAY){
     				device_insmod_delay++;
     				break;
-    			}
+     			}*/  /*delete for usb_pc charge*/
 
     			device_insmod_delay = 0;
 			    hw_insmod_usb_device();
diff --git a/drivers/usb/sun6i_usb/udc/sw_udc.c b/drivers/usb/sun6i_usb/udc/sw_udc.c
index 9481259..47ff42d 100755
--- a/drivers/usb/sun6i_usb/udc/sw_udc.c
+++ b/drivers/usb/sun6i_usb/udc/sw_udc.c
@@ -36,6 +36,7 @@
 
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
+#include <linux/wakelock.h>
 
 #include <asm/byteorder.h>
 #include <asm/io.h>
@@ -64,6 +65,7 @@ static const char		gadget_name[] = "sw_usb_udc";
 static const char		driver_desc[] = DRIVER_DESC;
 
 static struct sw_udc	*the_controller = NULL;
+static struct wake_lock udc_wakelock;
 static u32              usbd_port_no = 0;
 static sw_udc_io_t      g_sw_udc_io;
 static u32 usb_connect = 0;
@@ -75,14 +77,16 @@ extern int axp_usbcur(void);
 
 #ifdef CONFIG_USB_SW_SUN6I_USB0_OTG
 static struct platform_device *g_udc_pdev = NULL;
-extern atomic_t thread_suspend_flag;
+extern atomic_t thread_suspend_flag;
 #endif
 
-__u32 dma_working = 0;
-
-atomic_t vfs_read_flag;
-atomic_t vfs_write_flag;
-
+__u32 dma_working = 0;
+
+atomic_t vfs_read_flag;
+atomic_t vfs_write_flag;
+unsigned int vfs_amount = 0;
+loff_t vfs_file_offset = 0;
+
 #define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
 
 static u8 crq_bRequest = 0;
@@ -639,7 +643,7 @@ static int dma_write_fifo(struct sw_udc_ep *ep, struct sw_udc_request *req)
     left_len = left_len - (left_len % ep->ep.maxpacket);
 
 	ep->dma_working	= 1;
-	dma_working = 1;
+	dma_working = 1;
 	ep->dma_transfer_len = left_len;
 
     if(g_dma_debug){
@@ -890,7 +894,7 @@ static int dma_read_fifo(struct sw_udc_ep *ep, struct sw_udc_request *req)
     }
 
 	ep->dma_working	= 1;
-	dma_working = 1;
+	dma_working = 1;
 	ep->dma_transfer_len = left_len;
 
 	spin_unlock(&ep->dev->lock);
@@ -1672,7 +1676,7 @@ void sw_udc_clean_dma_status(struct sw_udc_ep *ep)
 	}
 
     ep->dma_working = 0;
-	dma_working = 0;
+	dma_working = 0;
 
 	return;
 }
@@ -1785,16 +1789,17 @@ static irqreturn_t sw_udc_irq(int dummy, void *_dev)
 	/* RESET */
 	if (usb_irq & USBC_INTUSB_RESET) {
 		DMSG_INFO_UDC("IRQ: reset\n");
-		if(g_msc_write_debug){
-			printk("flag(1:star,2:end) vfs_read_flag:%d, vfs_write_flag:%d,dma_working:%d\n",
-				atomic_read(&vfs_read_flag), atomic_read(&vfs_write_flag), dma_working);
-		}
+		printk("(1:star,2:end): vfs_read:%d, vfs_write:%d,dma_working:%d,amount:%u,file_offset:%llu\n",
+				atomic_read(&vfs_read_flag), atomic_read(&vfs_write_flag), dma_working, vfs_amount, (unsigned long long)vfs_file_offset);
 
         USBC_INT_ClearMiscPending(g_sw_udc_io.usb_bsp_hdle, USBC_INTUSB_RESET);
         clear_all_irq();
 
 		usb_connect = 1;
 
+		if( wake_lock_active(&udc_wakelock) == 0 )
+			wake_lock(&udc_wakelock);
+
 		USBC_SelectActiveEp(g_sw_udc_io.usb_bsp_hdle, 0);
 		USBC_Dev_SetAddress_default(g_sw_udc_io.usb_bsp_hdle);
 
@@ -1841,6 +1846,9 @@ static irqreturn_t sw_udc_irq(int dummy, void *_dev)
 
 		if(dev->gadget.speed != USB_SPEED_UNKNOWN){
 			usb_connect = 0;
+
+			if( wake_lock_active(&udc_wakelock) )
+				wake_unlock(&udc_wakelock);
 		}else{
 			DMSG_INFO_UDC("ERR: usb speed is unkown\n");
 		}
@@ -1866,6 +1874,9 @@ static irqreturn_t sw_udc_irq(int dummy, void *_dev)
         dev->ep0state = EP0_IDLE;
 
 		usb_connect = 0;
+
+		if( wake_lock_active(&udc_wakelock) )
+			wake_unlock(&udc_wakelock);
 	}
 
 	/* EP */
@@ -3351,6 +3362,9 @@ int sw_usb_device_enable(void)
 	crq_bRequest 	= 0;
 	is_controller_alive = 1;
 
+	if( wake_lock_active(&udc_wakelock) )
+		wake_unlock(&udc_wakelock);
+
     memset(&g_sw_udc_io, 0, sizeof(sw_udc_io_t));
 
     retval = sw_udc_io_init(usbd_port_no, pdev, &g_sw_udc_io);
@@ -3440,17 +3454,20 @@ __acquires(sw_udc.lock)
 
 	free_irq(udc->irq_no, udc);
 
+	usbd_port_no   = 0;
+	usb_connect    = 0;
+	crq_bRequest   = 0;
+	is_controller_alive = 0;
+
+	if( wake_lock_active(&udc_wakelock) )
+		wake_unlock(&udc_wakelock);
+
 	sw_udc_io_exit(usbd_port_no, pdev, &g_sw_udc_io);
 
     spin_lock_irqsave(&udc->lock, flags);
 
     memset(&g_sw_udc_io, 0, sizeof(sw_udc_io_t));
 
-	usbd_port_no   = 0;
-	usb_connect    = 0;
-	crq_bRequest   = 0;
-	is_controller_alive = 0;
-
     spin_unlock_irqrestore(&udc->lock, flags);
 
 	DMSG_INFO_UDC("sw_usb_device_disable end\n");
@@ -3760,7 +3777,7 @@ static int sw_udc_suspend(struct platform_device *pdev, pm_message_t message)
     DMSG_INFO_UDC("sw_udc_suspend start\n");
 	device_insmod_delay = 0;
 
-	atomic_set(&thread_suspend_flag, 1);
+	atomic_set(&thread_suspend_flag, 1);
 
 	if(!is_peripheral_active()){
 		DMSG_INFO_UDC("udc is disable, need not enter to suspend\n");
@@ -3818,7 +3835,7 @@ static int sw_udc_resume(struct platform_device *pdev)
     DMSG_INFO_UDC("sw_udc_resume start\n");
 	device_insmod_delay = 0;
 
-	atomic_set(&thread_suspend_flag, 0);
+	atomic_set(&thread_suspend_flag, 0);
 
 	if(!is_peripheral_active()){
 		DMSG_INFO_UDC("udc is disable, need not enter to resume\n");
@@ -3923,9 +3940,9 @@ static int __init udc_init(void)
 
     usb_connect = 0;
 
-	atomic_set(&vfs_read_flag, 0);
-	atomic_set(&vfs_write_flag, 0);
-
+	atomic_set(&vfs_read_flag, 0);
+	atomic_set(&vfs_write_flag, 0);
+
     /* driver register */
 	retval = platform_driver_probe(&sw_udc_driver, sw_udc_probe);
 	if(retval){
@@ -3934,6 +3951,9 @@ static int __init udc_init(void)
 		goto err;
     }
 
+	wake_lock_init(&udc_wakelock, WAKE_LOCK_SUSPEND,
+		       "udc_wake");
+
 	return 0;
 
 err:
@@ -3962,6 +3982,8 @@ static void __exit udc_exit(void)
 {
 	DMSG_INFO_UDC("udc_exit: version %s\n", DRIVER_VERSION);
 
+	wake_lock_destroy(&udc_wakelock);
+
 	platform_driver_unregister(&sw_udc_driver);
 
 	return ;
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index ec3ef38..40e5a58 100755
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -29,7 +29,7 @@ obj-$(CONFIG_FB_DEFERRED_IO)   += fb_defio.o
 obj-$(CONFIG_FB_WMT_GE_ROPS)   += wmt_ge_rops.o
 obj-$(CONFIG_LYCHEE_FB_SUN6I)     += sun6i/disp/
 obj-$(CONFIG_LYCHEE_LCD_SUN6I)    += sun6i/lcd/
-obj-$(CONFIG_LYCHEE_HDMI_SUN6I)   += sun6i/hdmi/
+#obj-$(CONFIG_LYCHEE_HDMI_SUN6I)   += sun6i/hdmi/
 
 # Hardware specific drivers go first
 obj-$(CONFIG_FB_AMIGA)            += amifb.o c2p_planar.o
diff --git a/drivers/video/sun6i/disp/de_bsp/de/disp_lcd.c b/drivers/video/sun6i/disp/de_bsp/de/disp_lcd.c
index c7a61aa..75cf246 100755
--- a/drivers/video/sun6i/disp/de_bsp/de/disp_lcd.c
+++ b/drivers/video/sun6i/disp/de_bsp/de/disp_lcd.c
@@ -987,7 +987,10 @@ __s32 LCD_PWM_EN(__u32 sel, __bool b_en)
         }
         else
         {            
-            gpio_info->mul_sel = 7;
+            //gpio_info->mul_sel = 7;
+			//Force to make pwm pin output low
+            gpio_info->mul_sel = 1;//0:input 1:output
+			gpio_info->data = 0;//0:low 1:high,only vaild when mul_sel set to 0/1
             hdl = OSAL_GPIO_Request(gpio_info, 1);
             OSAL_GPIO_Release(hdl, 2);
         }
@@ -2193,8 +2196,9 @@ __s32 BSP_disp_lcd_set_bright(__u32 sel, __u32  bright, __u32 from_iep)
         backlight_bright = bright;
         backlight_dimming = gdisp.screen[sel].lcd_cfg.backlight_dimming;
         period_ns = gdisp.pwm[gdisp.screen[sel].lcd_cfg.lcd_pwm_ch].period_ns;
-        duty_ns = (backlight_bright * backlight_dimming *  period_ns/256 + 128) / 256;
-
+        //duty_ns = (backlight_bright * backlight_dimming *  period_ns/256 + 128) / 256;
+        //Change for duty_ns overflow 32 bit add by caitilin
+        duty_ns = (bright * gdisp.pwm[gdisp.screen[sel].lcd_cfg.lcd_pwm_ch].period_ns) / 256;
         DE_DBG("[PWM]bright=%d,backlight_dimming=%d, period_ns=%d, duty_ns=%d\n",
             bright,gdisp.screen[sel].lcd_cfg.backlight_dimming,  gdisp.pwm[gdisp.screen[sel].lcd_cfg.lcd_pwm_ch].period_ns,duty_ns);
         pwm_set_duty_ns(gdisp.screen[sel].lcd_cfg.lcd_pwm_ch, duty_ns);
diff --git a/drivers/video/sun6i/disp/dev_disp.c b/drivers/video/sun6i/disp/dev_disp.c
index 857d169..4e00d2b 100755
--- a/drivers/video/sun6i/disp/dev_disp.c
+++ b/drivers/video/sun6i/disp/dev_disp.c
@@ -696,7 +696,7 @@ void backlight_early_suspend(struct early_suspend *h)
             BSP_disp_hdmi_close(i);
         }
     }
-    BSP_disp_hdmi_early_suspend();
+    //BSP_disp_hdmi_early_suspend();
 
     BSP_disp_clk_off(2);
 
@@ -714,7 +714,7 @@ void backlight_late_resume(struct early_suspend *h)
     {
         BSP_disp_clk_on(2);
     }
-    BSP_disp_hdmi_late_resume();
+    //BSP_disp_hdmi_late_resume();
     for(i=0; i<2; i++)
     {
         if(suspend_output_type[i] == DISP_OUTPUT_TYPE_LCD)
@@ -1889,6 +1889,7 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
             break;
 
     //----hdmi----
+#if 0
     	case DISP_CMD_HDMI_ON:
     		ret = BSP_disp_hdmi_open(ubuffer[0]);
             if(suspend_status != 0)
@@ -1929,6 +1930,7 @@ long disp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
     	case DISP_CMD_HDMI_SET_SRC:
     		ret = BSP_disp_hdmi_set_src(ubuffer[0], (__disp_lcdc_src_t)ubuffer[1]);
     		break;
+#endif
 
     //----vga----
     	case DISP_CMD_VGA_ON:
diff --git a/drivers/video/sun6i/disp/dev_disp_attrnode.c b/drivers/video/sun6i/disp/dev_disp_attrnode.c
index d40cdbe..ab78f67 100755
--- a/drivers/video/sun6i/disp/dev_disp_attrnode.c
+++ b/drivers/video/sun6i/disp/dev_disp_attrnode.c
@@ -1672,11 +1672,11 @@ static struct attribute *disp_attributes[] = {
     &dev_attr_vsync_event_enable.attr,
     &dev_attr_lcd.attr,
     &dev_attr_lcd_bl.attr,
-    &dev_attr_hdmi.attr,
+//	&dev_attr_hdmi.attr,
     &dev_attr_script_dump.attr,
     &dev_attr_colorbar.attr,
     &dev_attr_layer_para.attr,
-    &dev_attr_hdmi_hpd.attr,
+//	&dev_attr_hdmi_hpd.attr,
     &dev_attr_print_cmd_level.attr,
     &dev_attr_cmd_print.attr,
     &dev_attr_gamma_test.attr,
@@ -1685,8 +1685,8 @@ static struct attribute *disp_attributes[] = {
     &dev_attr_video_info.attr,
     &dev_attr_video_fps.attr,
     &dev_attr_lcd_src.attr,
-    &dev_attr_hdmi_cts.attr,
-    &dev_attr_hdmi_test_mode.attr,
+//	&dev_attr_hdmi_cts.attr,
+//	&dev_attr_hdmi_test_mode.attr,
     &dev_attr_cfg_cnt.attr,
     &dev_attr_cache.attr,
 	NULL
diff --git a/drivers/video/sun6i/lcd/Makefile b/drivers/video/sun6i/lcd/Makefile
index 56129d2..db1eec9 100755
--- a/drivers/video/sun6i/lcd/Makefile
+++ b/drivers/video/sun6i/lcd/Makefile
@@ -1,3 +1,4 @@
 obj-$(CONFIG_LYCHEE_LCD_SUN6I) += lcd.o
 
-lcd-objs := dev_lcd.o lcd0_panel_cfg.o lcd1_panel_cfg.o lcd_bak/lcd_edp_anx9804.o lcd_bak/lcd_edp_anx6345.o lcd_bak/lcd_B079XAN01.o
+#lcd-objs := dev_lcd.o lcd0_panel_cfg.o lcd1_panel_cfg.o lcd_bak/lcd_edp_anx9804.o lcd_bak/lcd_edp_anx6345.o lcd_bak/lcd_B079XAN01.o
+lcd-objs := dev_lcd.o lcd0_panel_cfg-hv800x480.o
diff --git a/drivers/video/sun6i/lcd/dev_lcd.c b/drivers/video/sun6i/lcd/dev_lcd.c
index 1691544..6362d6c 100755
--- a/drivers/video/sun6i/lcd/dev_lcd.c
+++ b/drivers/video/sun6i/lcd/dev_lcd.c
@@ -56,7 +56,7 @@ int lcd_init(void)
 	memset(&lcd1_cfg, 0, sizeof(__lcd_panel_fun_t));
     
     LCD_get_panel_funs_0(&lcd0_cfg);
-	LCD_get_panel_funs_1(&lcd1_cfg);
+	//LCD_get_panel_funs_1(&lcd1_cfg);
 	LCD_set_panel_funs(&lcd0_cfg, &lcd1_cfg);
 
     DRV_DISP_Init();
diff --git a/drivers/video/sun6i/lcd/lcd0_panel_cfg-hv800x480.c b/drivers/video/sun6i/lcd/lcd0_panel_cfg-hv800x480.c
index ee7c6be..50656ca 100755
--- a/drivers/video/sun6i/lcd/lcd0_panel_cfg-hv800x480.c
+++ b/drivers/video/sun6i/lcd/lcd0_panel_cfg-hv800x480.c
@@ -1,9 +1,12 @@
 
 #include "lcd_panel_cfg.h"
-
+#include "linux/delay.h"
 //delete this line if you want to use the lcd para define in sys_config1.fex
-#define LCD_PARA_USE_CONFIG
-
+//#define LCD_PARA_USE_CONFIG
+static void LCD_power_on(__u32 sel);
+static void LCD_power_off(__u32 sel);
+static void LCD_bl_open(__u32 sel);
+static void LCD_bl_close(__u32 sel);
 #ifdef LCD_PARA_USE_CONFIG
 static __u8 g_gamma_tbl[][2] = 
 {
@@ -85,19 +88,18 @@ static void LCD_cfg_panel_info(__panel_para_t * info)
 
 static __s32 LCD_open_flow(__u32 sel)
 {
-	LCD_OPEN_FUNC(sel, LCD_power_on, 50);   //open lcd power, and delay 50ms
-	LCD_OPEN_FUNC(sel, TCON_open, 500);     //open lcd controller, and delay 500ms
-	LCD_OPEN_FUNC(sel, LCD_bl_open, 0);     //open lcd backlight, and delay 0ms
-
+	LCD_PWM_EN(sel,0);                      //first make pwm signal output low,not effect with dldo1 
+	LCD_OPEN_FUNC(sel, TCON_open, 250);     //open lcd controller, and delay more than 200ms
+	LCD_OPEN_FUNC(sel, LCD_power_on, 10);   //open lcd tcon power, and delay 10ms
+	LCD_OPEN_FUNC(sel, LCD_bl_open, 10);    //open lcd backlight, and delay 10ms
 	return 0;
 }
 
 static __s32 LCD_close_flow(__u32 sel)
 {	
-	LCD_CLOSE_FUNC(sel, LCD_bl_close, 0);       //close lcd backlight, and delay 0ms
-	LCD_CLOSE_FUNC(sel, TCON_close, 0);         //close lcd controller, and delay 0ms
-	LCD_CLOSE_FUNC(sel, LCD_power_off, 1000);   //close lcd power, and delay 1000ms
-
+	LCD_CLOSE_FUNC(sel, LCD_bl_close, 200);   //close lcd backlight, and delay more than 200ms
+	LCD_CLOSE_FUNC(sel, LCD_power_off, 10);   //close lcd power, and delay 10ms
+	LCD_CLOSE_FUNC(sel, TCON_close, 10);      //close lcd controller, and delay 10ms
 	return 0;
 }
 
@@ -113,14 +115,16 @@ static void LCD_power_off(__u32 sel)
 
 static void LCD_bl_open(__u32 sel)
 {
-    LCD_PWM_EN(sel, 1);//open pwm module
     LCD_BL_EN(sel, 1);//config lcd_bl_en pin to open lcd backlight
+ 	LCD_delay_ms(15);
+	LCD_PWM_EN(sel, 1);//open pwm module
 }
 
 static void LCD_bl_close(__u32 sel)
 {
+    LCD_PWM_EN(sel, 0);//close pwm module 
+    LCD_delay_ms(15);
     LCD_BL_EN(sel, 0);//config lcd_bl_en pin to close lcd backlight
-    LCD_PWM_EN(sel, 0);//close pwm module
 }
 
 //sel: 0:lcd0; 1:lcd1
diff --git a/fs/notify/fanotify/Kconfig b/fs/notify/fanotify/Kconfig
index 7dceff0..1ddf171 100644
--- a/fs/notify/fanotify/Kconfig
+++ b/fs/notify/fanotify/Kconfig
@@ -2,7 +2,7 @@ config FANOTIFY
 	bool "Filesystem wide access notification"
 	select FSNOTIFY
 	select ANON_INODES
-	default n
+	default y
 	---help---
 	   Say Y here to enable fanotify suport.  fanotify is a file access
 	   notification system which differs from inotify in that it sends
@@ -15,7 +15,7 @@ config FANOTIFY_ACCESS_PERMISSIONS
 	bool "fanotify permissions checking"
 	depends on FANOTIFY
 	depends on SECURITY
-	default n
+	default y
 	---help---
 	   Say Y here is you want fanotify listeners to be able to make permissions
 	   decisions concerning filesystem events.  This is used by some fanotify
diff --git a/include/linux/ctp.h b/include/linux/ctp.h
index b9cbd10..07d1cbd 100755
--- a/include/linux/ctp.h
+++ b/include/linux/ctp.h
@@ -4,6 +4,7 @@
 struct ctp_config_info{
         int ctp_used;
         __u32 twi_id;
+		int enable_fwupdate;   //add by ethan 13/06/24
         int screen_max_x;
         int screen_max_y;
         int revert_x_flag;
diff --git a/include/linux/mpu.h b/include/linux/mpu.h
new file mode 100644
index 0000000..fd66ba0
--- /dev/null
+++ b/include/linux/mpu.h
@@ -0,0 +1,366 @@
+/*
+	$License:
+	Copyright (C) 2011 InvenSense Corporation, All Rights Reserved.
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	$
+ */
+
+#ifndef __MPU_H_
+#define __MPU_H_
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+/* Number of axes on each sensor */
+#define GYRO_NUM_AXES               (3)
+#define ACCEL_NUM_AXES              (3)
+#define COMPASS_NUM_AXES            (3)
+
+struct mpu_read_write {
+	/* Memory address or register address depending on ioctl */
+	__u16 address;
+	__u16 length;
+	__u8 *data;
+};
+
+enum mpuirq_data_type {
+	MPUIRQ_DATA_TYPE_MPU_IRQ,
+	MPUIRQ_DATA_TYPE_SLAVE_IRQ,
+	MPUIRQ_DATA_TYPE_PM_EVENT,
+	MPUIRQ_DATA_TYPE_NUM_TYPES,
+};
+
+/* User space PM event notification */
+#define MPU_PM_EVENT_SUSPEND_PREPARE (3)
+#define MPU_PM_EVENT_POST_SUSPEND    (4)
+
+struct mpuirq_data {
+	__u32 interruptcount;
+	__u64 irqtime;
+	__u32 data_type;
+	__s32 data;
+};
+
+enum ext_slave_config_key {
+	MPU_SLAVE_CONFIG_ODR_SUSPEND,
+	MPU_SLAVE_CONFIG_ODR_RESUME,
+	MPU_SLAVE_CONFIG_FSR_SUSPEND,
+	MPU_SLAVE_CONFIG_FSR_RESUME,
+	MPU_SLAVE_CONFIG_MOT_THS,
+	MPU_SLAVE_CONFIG_NMOT_THS,
+	MPU_SLAVE_CONFIG_MOT_DUR,
+	MPU_SLAVE_CONFIG_NMOT_DUR,
+	MPU_SLAVE_CONFIG_IRQ_SUSPEND,
+	MPU_SLAVE_CONFIG_IRQ_RESUME,
+	MPU_SLAVE_WRITE_REGISTERS,
+	MPU_SLAVE_READ_REGISTERS,
+	MPU_SLAVE_CONFIG_INTERNAL_REFERENCE,
+	/* AMI 306 specific config keys */
+	MPU_SLAVE_PARAM,
+	MPU_SLAVE_WINDOW,
+	MPU_SLAVE_READWINPARAMS,
+	MPU_SLAVE_SEARCHOFFSET,
+	/* AKM specific config keys */
+	MPU_SLAVE_READ_SCALE,
+	/* MPU3050 and MPU6050 Keys */
+	MPU_SLAVE_INT_CONFIG,
+	MPU_SLAVE_EXT_SYNC,
+	MPU_SLAVE_FULL_SCALE,
+	MPU_SLAVE_LPF,
+	MPU_SLAVE_CLK_SRC,
+	MPU_SLAVE_DIVIDER,
+	MPU_SLAVE_DMP_ENABLE,
+	MPU_SLAVE_FIFO_ENABLE,
+	MPU_SLAVE_DMP_CFG1,
+	MPU_SLAVE_DMP_CFG2,
+	MPU_SLAVE_TC,
+	MPU_SLAVE_GYRO,
+	MPU_SLAVE_ADDR,
+	MPU_SLAVE_PRODUCT_REVISION,
+	MPU_SLAVE_SILICON_REVISION,
+	MPU_SLAVE_PRODUCT_ID,
+	MPU_SLAVE_GYRO_SENS_TRIM,
+	MPU_SLAVE_ACCEL_SENS_TRIM,
+	MPU_SLAVE_RAM,
+	/* -------------------------- */
+	MPU_SLAVE_CONFIG_NUM_CONFIG_KEYS
+};
+
+/* For the MPU_SLAVE_CONFIG_IRQ_SUSPEND and MPU_SLAVE_CONFIG_IRQ_RESUME */
+enum ext_slave_config_irq_type {
+	MPU_SLAVE_IRQ_TYPE_NONE,
+	MPU_SLAVE_IRQ_TYPE_MOTION,
+	MPU_SLAVE_IRQ_TYPE_DATA_READY,
+};
+
+/* Structure for the following IOCTS's
+ * MPU_CONFIG_GYRO
+ * MPU_CONFIG_ACCEL
+ * MPU_CONFIG_COMPASS
+ * MPU_CONFIG_PRESSURE
+ * MPU_GET_CONFIG_GYRO
+ * MPU_GET_CONFIG_ACCEL
+ * MPU_GET_CONFIG_COMPASS
+ * MPU_GET_CONFIG_PRESSURE
+ *
+ * @key one of enum ext_slave_config_key
+ * @len length of data pointed to by data
+ * @apply zero if communication with the chip is not necessary, false otherwise
+ *        This flag can be used to select cached data or to refresh cashed data
+ *        cache data to be pushed later or push immediately.  If true and the
+ *        slave is on the secondary bus the MPU will first enger bypass mode
+ *        before calling the slaves .config or .get_config funcion
+ * @data pointer to the data to confgure or get
+ */
+struct ext_slave_config {
+	__u8 key;
+	__u16 len;
+	__u8 apply;
+	void *data;
+};
+
+enum ext_slave_type {
+	EXT_SLAVE_TYPE_GYROSCOPE,
+	EXT_SLAVE_TYPE_ACCEL,
+	EXT_SLAVE_TYPE_COMPASS,
+	EXT_SLAVE_TYPE_PRESSURE,
+	/*EXT_SLAVE_TYPE_TEMPERATURE */
+
+	EXT_SLAVE_NUM_TYPES
+};
+
+enum ext_slave_id {
+	ID_INVALID = 0,
+
+	ACCEL_ID_LIS331,
+	ACCEL_ID_LSM303DLX,
+	ACCEL_ID_LIS3DH,
+	ACCEL_ID_KXSD9,
+	ACCEL_ID_KXTF9,
+	ACCEL_ID_BMA150,
+	ACCEL_ID_BMA222,
+	ACCEL_ID_BMA250,
+	ACCEL_ID_ADXL34X,
+	ACCEL_ID_MMA8450,
+	ACCEL_ID_MMA845X,
+	ACCEL_ID_MPU6050,
+
+	COMPASS_ID_AK8975,
+	COMPASS_ID_AK8972,
+	COMPASS_ID_AMI30X,
+	COMPASS_ID_AMI306,
+	COMPASS_ID_YAS529,
+	COMPASS_ID_YAS530,
+	COMPASS_ID_HMC5883,
+	COMPASS_ID_LSM303DLH,
+	COMPASS_ID_LSM303DLM,
+	COMPASS_ID_MMC314X,
+	COMPASS_ID_HSCDTD002B,
+	COMPASS_ID_HSCDTD004A,
+
+	PRESSURE_ID_BMA085,
+};
+
+enum ext_slave_endian {
+	EXT_SLAVE_BIG_ENDIAN,
+	EXT_SLAVE_LITTLE_ENDIAN,
+	EXT_SLAVE_FS8_BIG_ENDIAN,
+	EXT_SLAVE_FS16_BIG_ENDIAN,
+};
+
+enum ext_slave_bus {
+	EXT_SLAVE_BUS_INVALID = -1,
+	EXT_SLAVE_BUS_PRIMARY = 0,
+	EXT_SLAVE_BUS_SECONDARY = 1
+};
+
+
+/**
+ *  struct ext_slave_platform_data - Platform data for mpu3050 and mpu6050
+ *  slave devices
+ *
+ *  @type: the type of slave device based on the enum ext_slave_type
+ *         definitions.
+ *  @irq: the irq number attached to the slave if any.
+ *  @adapt_num: the I2C adapter number.
+ *  @bus: the bus the slave is attached to: enum ext_slave_bus
+ *  @address: the I2C slave address of the slave device.
+ *  @orientation: the mounting matrix of the device relative to MPU.
+ *  @irq_data: private data for the slave irq handler
+ *  @private_data: additional data, user customizable.  Not touched by the MPU
+ *                 driver.
+ *
+ * The orientation matricies are 3x3 rotation matricies
+ * that are applied to the data to rotate from the mounting orientation to the
+ * platform orientation.  The values must be one of 0, 1, or -1 and each row and
+ * column should have exactly 1 non-zero value.
+ */
+struct ext_slave_platform_data {
+	__u8 type;
+	__u32 irq;
+	__u32 adapt_num;
+	__u32 bus;
+	__u8 address;
+	__s8 orientation[9];
+	void *irq_data;
+	void *private_data;
+};
+
+struct fix_pnt_range {
+	__s32 mantissa;
+	__s32 fraction;
+};
+
+static inline long range_fixedpoint_to_long_mg(struct fix_pnt_range rng)
+{
+	return (long)(rng.mantissa * 1000 + rng.fraction / 10);
+}
+
+struct ext_slave_read_trigger {
+	__u8 reg;
+	__u8 value;
+};
+
+/**
+ *  struct ext_slave_descr - Description of the slave device for programming.
+ *
+ *  @suspend:	function pointer to put the device in suspended state
+ *  @resume:	function pointer to put the device in running state
+ *  @read:	function that reads the device data
+ *  @init:	function used to preallocate memory used by the driver
+ *  @exit:	function used to free memory allocated for the driver
+ *  @config:	function used to configure the device
+ *  @get_config:function used to get the device's configuration
+ *
+ *  @name:	text name of the device
+ *  @type:	device type. enum ext_slave_type
+ *  @id:	enum ext_slave_id
+ *  @read_reg:	starting register address to retrieve data.
+ *  @read_len:	length in bytes of the sensor data.  Typically  6.
+ *  @endian:	byte order of the data. enum ext_slave_endian
+ *  @range:	full scale range of the slave ouput: struct fix_pnt_range
+ *  @trigger:	If reading data first requires writing a register this is the
+ *		data to write.
+ *
+ *  Defines the functions and information about the slave the mpu3050 and
+ *  mpu6050 needs to use the slave device.
+ */
+struct ext_slave_descr {
+	int (*init) (void *mlsl_handle,
+		     struct ext_slave_descr *slave,
+		     struct ext_slave_platform_data *pdata);
+	int (*exit) (void *mlsl_handle,
+		     struct ext_slave_descr *slave,
+		     struct ext_slave_platform_data *pdata);
+	int (*suspend) (void *mlsl_handle,
+			struct ext_slave_descr *slave,
+			struct ext_slave_platform_data *pdata);
+	int (*resume) (void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata);
+	int (*read) (void *mlsl_handle,
+		     struct ext_slave_descr *slave,
+		     struct ext_slave_platform_data *pdata,
+		     __u8 *data);
+	int (*config) (void *mlsl_handle,
+		       struct ext_slave_descr *slave,
+		       struct ext_slave_platform_data *pdata,
+		       struct ext_slave_config *config);
+	int (*get_config) (void *mlsl_handle,
+			   struct ext_slave_descr *slave,
+			   struct ext_slave_platform_data *pdata,
+			   struct ext_slave_config *config);
+
+	char *name;
+	__u8 type;
+	__u8 id;
+	__u8 read_reg;
+	__u8 read_len;
+	__u8 endian;
+	struct fix_pnt_range range;
+	struct ext_slave_read_trigger *trigger;
+};
+
+/**
+ * struct mpu_platform_data - Platform data for the mpu driver
+ * @int_config:		Bits [7:3] of the int config register.
+ * @level_shifter:	0: VLogic, 1: VDD
+ * @orientation:	Orientation matrix of the gyroscope
+ *
+ * Contains platform specific information on how to configure the MPU3050 to
+ * work on this platform.  The orientation matricies are 3x3 rotation matricies
+ * that are applied to the data to rotate from the mounting orientation to the
+ * platform orientation.  The values must be one of 0, 1, or -1 and each row and
+ * column should have exactly 1 non-zero value.
+ */
+struct mpu_platform_data {
+	__u8 int_config;
+	__u8 level_shifter;
+	__s8 orientation[GYRO_NUM_AXES * GYRO_NUM_AXES];
+};
+
+#define MPU_IOCTL (0x81) /* Magic number for MPU Iocts */
+/* IOCTL commands for /dev/mpu */
+
+/*--------------------------------------------------------------------------
+ * Deprecated, debugging only
+ */
+#define MPU_SET_MPU_PLATFORM_DATA	\
+	_IOWR(MPU_IOCTL, 0x01, struct mpu_platform_data)
+#define MPU_SET_EXT_SLAVE_PLATFORM_DATA	\
+	_IOWR(MPU_IOCTL, 0x01, struct ext_slave_platform_data)
+/*--------------------------------------------------------------------------*/
+#define MPU_GET_EXT_SLAVE_PLATFORM_DATA	\
+	_IOWR(MPU_IOCTL, 0x02, struct ext_slave_platform_data)
+#define MPU_GET_MPU_PLATFORM_DATA	\
+	_IOWR(MPU_IOCTL, 0x02, struct mpu_platform_data)
+#define MPU_GET_EXT_SLAVE_DESCR	\
+	_IOWR(MPU_IOCTL, 0x02, struct ext_slave_descr)
+
+#define MPU_READ		_IOWR(MPU_IOCTL, 0x10, struct mpu_read_write)
+#define MPU_WRITE		_IOW(MPU_IOCTL,  0x10, struct mpu_read_write)
+#define MPU_READ_MEM		_IOWR(MPU_IOCTL, 0x11, struct mpu_read_write)
+#define MPU_WRITE_MEM		_IOW(MPU_IOCTL,  0x11, struct mpu_read_write)
+#define MPU_READ_FIFO		_IOWR(MPU_IOCTL, 0x12, struct mpu_read_write)
+#define MPU_WRITE_FIFO		_IOW(MPU_IOCTL,  0x12, struct mpu_read_write)
+
+#define MPU_READ_COMPASS	_IOR(MPU_IOCTL, 0x12, __u8)
+#define MPU_READ_ACCEL		_IOR(MPU_IOCTL, 0x13, __u8)
+#define MPU_READ_PRESSURE	_IOR(MPU_IOCTL, 0x14, __u8)
+
+#define MPU_CONFIG_GYRO		_IOW(MPU_IOCTL, 0x20, struct ext_slave_config)
+#define MPU_CONFIG_ACCEL	_IOW(MPU_IOCTL, 0x21, struct ext_slave_config)
+#define MPU_CONFIG_COMPASS	_IOW(MPU_IOCTL, 0x22, struct ext_slave_config)
+#define MPU_CONFIG_PRESSURE	_IOW(MPU_IOCTL, 0x23, struct ext_slave_config)
+
+#define MPU_GET_CONFIG_GYRO	_IOWR(MPU_IOCTL, 0x20, struct ext_slave_config)
+#define MPU_GET_CONFIG_ACCEL	_IOWR(MPU_IOCTL, 0x21, struct ext_slave_config)
+#define MPU_GET_CONFIG_COMPASS	_IOWR(MPU_IOCTL, 0x22, struct ext_slave_config)
+#define MPU_GET_CONFIG_PRESSURE	_IOWR(MPU_IOCTL, 0x23, struct ext_slave_config)
+
+#define MPU_SUSPEND		_IOW(MPU_IOCTL, 0x30, __u32)
+#define MPU_RESUME		_IOW(MPU_IOCTL, 0x31, __u32)
+/* Userspace PM Event response */
+#define MPU_PM_EVENT_HANDLED	_IO(MPU_IOCTL, 0x32)
+
+#define MPU_GET_REQUESTED_SENSORS	_IOR(MPU_IOCTL, 0x40, __u8)
+#define MPU_SET_REQUESTED_SENSORS	_IOW(MPU_IOCTL, 0x40, __u8)
+#define MPU_GET_IGNORE_SYSTEM_SUSPEND	_IOR(MPU_IOCTL, 0x41, __u8)
+#define MPU_SET_IGNORE_SYSTEM_SUSPEND	_IOW(MPU_IOCTL, 0x41, __u8)
+#define MPU_GET_MLDL_STATUS		_IOR(MPU_IOCTL, 0x42, __u8)
+#define MPU_GET_I2C_SLAVES_ENABLED	_IOR(MPU_IOCTL, 0x43, __u8)
+
+
+#endif				/* __MPU_H_ */
diff --git a/include/net/bluetooth/amp.h b/include/net/bluetooth/amp.h
new file mode 100644
index 0000000..15d1817
--- /dev/null
+++ b/include/net/bluetooth/amp.h
@@ -0,0 +1,293 @@
+/*
+   Copyright (c) 2010-2012 The Linux Foundation.  All rights reserved.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 and
+   only version 2 as published by the Free Software Foundation.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+*/
+
+#ifndef __AMP_H
+#define __AMP_H
+
+/* AMP defaults */
+
+#define A2MP_RSP_TIMEOUT        (8000)  /*  8 seconds */
+
+/* A2MP Protocol */
+
+/* A2MP command codes */
+#define A2MP_COMMAND_REJ         0x01
+#define A2MP_DISCOVER_REQ        0x02
+#define A2MP_DISCOVER_RSP        0x03
+#define A2MP_CHANGE_NOTIFY       0x04
+#define A2MP_CHANGE_RSP          0x05
+#define A2MP_GETINFO_REQ         0x06
+#define A2MP_GETINFO_RSP         0x07
+#define A2MP_GETAMPASSOC_REQ     0x08
+#define A2MP_GETAMPASSOC_RSP     0x09
+#define A2MP_CREATEPHYSLINK_REQ  0x0A
+#define A2MP_CREATEPHYSLINK_RSP  0x0B
+#define A2MP_DISCONNPHYSLINK_REQ 0x0C
+#define A2MP_DISCONNPHYSLINK_RSP 0x0D
+
+struct a2mp_cmd_hdr {
+	__u8       code;
+	__u8       ident;
+	__le16     len;
+} __packed;
+
+struct a2mp_cmd_rej {
+	__le16     reason;
+} __packed;
+
+struct a2mp_discover_req {
+	__le16     mtu;
+	__le16     ext_feat;
+} __packed;
+
+struct a2mp_cl {
+	__u8       id;
+	__u8       type;
+	__u8       status;
+} __packed;
+
+struct a2mp_discover_rsp {
+	__le16     mtu;
+	__le16     ext_feat;
+	struct a2mp_cl cl[0];
+} __packed;
+
+struct a2mp_getinfo_req {
+	__u8       id;
+} __packed;
+
+struct a2mp_getinfo_rsp {
+	__u8       id;
+	__u8       status;
+	__le32     total_bw;
+	__le32     max_bw;
+	__le32     min_latency;
+	__le16     pal_cap;
+	__le16     assoc_size;
+} __packed;
+
+struct a2mp_getampassoc_req {
+	__u8       id;
+} __packed;
+
+struct a2mp_getampassoc_rsp {
+	__u8       id;
+	__u8       status;
+	__u8       amp_assoc[0];
+} __packed;
+
+struct a2mp_createphyslink_req {
+	__u8       local_id;
+	__u8       remote_id;
+	__u8       amp_assoc[0];
+} __packed;
+
+struct a2mp_createphyslink_rsp {
+	__u8       local_id;
+	__u8       remote_id;
+	__u8       status;
+} __packed;
+
+struct a2mp_disconnphyslink_req {
+	__u8       local_id;
+	__u8       remote_id;
+} __packed;
+
+struct a2mp_disconnphyslink_rsp {
+	__u8       local_id;
+	__u8       remote_id;
+	__u8       status;
+} __packed;
+
+
+/* L2CAP-AMP module interface */
+int amp_init(void);
+void amp_exit(void);
+
+/* L2CAP-AMP fixed channel interface */
+void amp_conn_ind(struct hci_conn *hcon, struct sk_buff *skb);
+
+/* L2CAP-AMP link interface */
+void amp_create_physical(struct l2cap_conn *conn, struct sock *sk);
+void amp_accept_physical(struct l2cap_conn *conn, u8 id, struct sock *sk);
+
+/* AMP manager internals */
+struct amp_ctrl {
+	struct  amp_mgr *mgr;
+	__u8    id;
+	__u8    type;
+	__u8    status;
+	__u32   total_bw;
+	__u32   max_bw;
+	__u32   min_latency;
+	__u16   pal_cap;
+	__u16   max_assoc_size;
+};
+
+struct amp_mgr {
+	struct list_head list;
+	__u8    discovered;
+	__u8    next_ident;
+	struct l2cap_conn *l2cap_conn;
+	struct socket *a2mp_sock;
+	struct list_head  ctx_list;
+	rwlock_t       ctx_list_lock;
+	struct amp_ctrl *ctrls;          /* @@ TODO s.b. list of controllers */
+	struct sk_buff *skb;
+	__u8   connected;
+};
+
+/* AMP Manager signalling contexts */
+#define AMP_GETAMPASSOC       1
+#define AMP_CREATEPHYSLINK    2
+#define AMP_ACCEPTPHYSLINK    3
+#define AMP_CREATELOGLINK     4
+#define AMP_ACCEPTLOGLINK     5
+
+/* Get AMP Assoc sequence */
+#define AMP_GAA_INIT           0
+#define AMP_GAA_RLAA_COMPLETE  1
+struct amp_gaa_state {
+	__u8       req_ident;
+	__u16      len_so_far;
+	__u8      *assoc;
+};
+
+/* Create Physical Link sequence */
+#define AMP_CPL_INIT           0
+#define AMP_CPL_DISC_RSP       1
+#define AMP_CPL_GETINFO_RSP    2
+#define AMP_CPL_GAA_RSP        3
+#define AMP_CPL_CPL_STATUS     4
+#define AMP_CPL_WRA_COMPLETE   5
+#define AMP_CPL_CHANNEL_SELECT 6
+#define AMP_CPL_RLA_COMPLETE   7
+#define AMP_CPL_PL_COMPLETE    8
+#define AMP_CPL_PL_CANCEL      9
+struct amp_cpl_state {
+	__u8       remote_id;
+	__u16      max_len;
+	__u8      *remote_assoc;
+	__u8      *local_assoc;
+	__u16      len_so_far;
+	__u16      rem_len;
+	__u8       phy_handle;
+};
+
+/* Accept Physical Link sequence */
+#define AMP_APL_INIT           0
+#define AMP_APL_APL_STATUS     1
+#define AMP_APL_WRA_COMPLETE   2
+#define AMP_APL_PL_COMPLETE    3
+struct amp_apl_state {
+	__u8       remote_id;
+	__u8       req_ident;
+	__u8      *remote_assoc;
+	__u16      len_so_far;
+	__u16      rem_len;
+	__u8       phy_handle;
+};
+
+/* Create/Accept Logical Link sequence */
+#define AMP_LOG_INIT         0
+#define AMP_LOG_LL_STATUS    1
+#define AMP_LOG_LL_COMPLETE  2
+struct amp_log_state {
+	__u8       remote_id;
+};
+
+/* Possible event types a context may wait for */
+#define AMP_INIT            0x01
+#define AMP_HCI_EVENT       0x02
+#define AMP_HCI_CMD_CMPLT   0x04
+#define AMP_HCI_CMD_STATUS  0x08
+#define AMP_A2MP_RSP        0x10
+#define AMP_KILLED          0x20
+#define AMP_CANCEL          0x40
+struct amp_ctx {
+	struct list_head list;
+	struct amp_mgr *mgr;
+	struct hci_dev *hdev;
+	__u8       type;
+	__u8       state;
+	union {
+		struct amp_gaa_state gaa;
+		struct amp_cpl_state cpl;
+		struct amp_apl_state apl;
+	} d;
+	__u8 evt_type;
+	__u8 evt_code;
+	__u16 opcode;
+	__u8 id;
+	__u8 rsp_ident;
+
+	struct sock *sk;
+	struct amp_ctx *deferred;
+	struct timer_list timer;
+};
+
+/* AMP work */
+struct amp_work_pl_timeout {
+	struct work_struct work;
+	struct amp_ctrl *ctrl;
+};
+struct amp_work_ctx_timeout {
+	struct work_struct work;
+	struct amp_ctx *ctx;
+};
+struct amp_work_data_ready {
+	struct work_struct work;
+	struct sock *sk;
+	int bytes;
+};
+struct amp_work_state_change {
+	struct work_struct work;
+	struct sock *sk;
+};
+struct amp_work_conn_ind {
+	struct work_struct work;
+	struct hci_conn *hcon;
+	struct sk_buff *skb;
+};
+struct amp_work_create_physical {
+	struct work_struct work;
+	struct l2cap_conn *conn;
+	u8 id;
+	struct sock *sk;
+};
+struct amp_work_accept_physical {
+	struct work_struct work;
+	struct l2cap_conn *conn;
+	u8 id;
+	struct sock *sk;
+};
+struct amp_work_cmd_cmplt {
+	struct work_struct work;
+	struct hci_dev *hdev;
+	u16 opcode;
+	struct sk_buff *skb;
+};
+struct amp_work_cmd_status {
+	struct work_struct work;
+	struct hci_dev *hdev;
+	u16 opcode;
+	u8 status;
+};
+struct amp_work_event {
+	struct work_struct work;
+	struct hci_dev *hdev;
+	u8 event;
+	struct sk_buff *skb;
+};
+
+#endif /* __AMP_H */
diff --git a/include/net/bluetooth/bluetooth.h b/include/net/bluetooth/bluetooth.h
index 4a82ca0..b78a570 100644
--- a/include/net/bluetooth/bluetooth.h
+++ b/include/net/bluetooth/bluetooth.h
@@ -36,13 +36,9 @@
 #define PF_BLUETOOTH	AF_BLUETOOTH
 #endif
 
-/* Bluetooth versions */
-#define BLUETOOTH_VER_1_1	1
-#define BLUETOOTH_VER_1_2	2
-#define BLUETOOTH_VER_2_0	3
-
 /* Reserv for core and drivers use */
 #define BT_SKB_RESERVE	8
+#define BT_SKB_RESERVE_80211	32
 
 #define BTPROTO_L2CAP	0
 #define BTPROTO_HCI	1
@@ -67,54 +63,68 @@ struct bt_security {
 #define BT_SECURITY_LOW		1
 #define BT_SECURITY_MEDIUM	2
 #define BT_SECURITY_HIGH	3
+#define BT_SECURITY_VERY_HIGH	4
 
 #define BT_DEFER_SETUP	7
-
 #define BT_FLUSHABLE	8
 
-#define BT_FLUSHABLE_OFF	0
-#define BT_FLUSHABLE_ON		1
-
 #define BT_POWER	9
 struct bt_power {
 	__u8 force_active;
 };
-#define BT_POWER_FORCE_ACTIVE_OFF 0
-#define BT_POWER_FORCE_ACTIVE_ON  1
 
-#define BT_CHANNEL_POLICY	10
+#define BT_AMP_POLICY          10
 
-/* BR/EDR only (default policy)
- *   AMP controllers cannot be used.
- *   Channel move requests from the remote device are denied.
- *   If the L2CAP channel is currently using AMP, move the channel to BR/EDR.
+/* Require BR/EDR (default policy)
+ *   AMP controllers cannot be used
+ *   Channel move requests from the remote device are denied
+ *   If the L2CAP channel is currently using AMP, move the channel to BR/EDR
  */
-#define BT_CHANNEL_POLICY_BREDR_ONLY		0
+#define BT_AMP_POLICY_REQUIRE_BR_EDR   0
 
-/* BR/EDR Preferred
- *   Allow use of AMP controllers.
- *   If the L2CAP channel is currently on AMP, move it to BR/EDR.
- *   Channel move requests from the remote device are allowed.
+/* Prefer BR/EDR
+ *   Allow use of AMP controllers
+ *   If the L2CAP channel is currently on AMP, move it to BR/EDR
+ *   Channel move requests from the remote device are allowed
  */
-#define BT_CHANNEL_POLICY_BREDR_PREFERRED	1
+#define BT_AMP_POLICY_PREFER_BR_EDR    1
 
-/* AMP Preferred
+/* Prefer AMP
  *   Allow use of AMP controllers
  *   If the L2CAP channel is currently on BR/EDR and AMP controller
- *     resources are available, initiate a channel move to AMP.
- *   Channel move requests from the remote device are allowed.
+ *     resources are available, initiate a channel move to AMP
+ *   Channel move requests from the remote device are allowed
  *   If the L2CAP socket has not been connected yet, try to create
  *     and configure the channel directly on an AMP controller rather
- *     than BR/EDR.
+ *     than BR/EDR
  */
-#define BT_CHANNEL_POLICY_AMP_PREFERRED		2
+#define BT_AMP_POLICY_PREFER_AMP       2
+
+#define BT_LE_PARAMS	100
+
+#define BT_LE_SCAN_WINDOW_MIN		0x0004
+#define BT_LE_SCAN_WINDOW_MAX		0x4000
+#define BT_LE_SCAN_WINDOW_DEF		0x0004
+
+#define BT_LE_SCAN_INTERVAL_MIN		0x0004
+#define BT_LE_SCAN_INTERVAL_MAX		0x4000
+#define BT_LE_SCAN_INTERVAL_DEF		0x0008
+
+#define BT_LE_CONN_INTERVAL_MIN		0x0006
+#define BT_LE_CONN_INTERVAL_MAX		0x0C80
+#define BT_LE_CONN_INTERVAL_MIN_DEF	0x0008
+#define BT_LE_CONN_INTERVAL_MAX_DEF	0x0100
 
-__printf(2, 3)
-int bt_printk(const char *level, const char *fmt, ...);
+#define BT_LE_LATENCY_MAX		0x01F4
+#define BT_LE_LATENCY_DEF		0x0000
 
-#define BT_INFO(fmt, arg...)   bt_printk(KERN_INFO, pr_fmt(fmt), ##arg)
-#define BT_ERR(fmt, arg...)    bt_printk(KERN_ERR, pr_fmt(fmt), ##arg)
-#define BT_DBG(fmt, arg...)    pr_debug(fmt "\n", ##arg)
+#define BT_LE_SUP_TO_MIN		0x000A
+#define BT_LE_SUP_TO_MAX		0x0C80
+#define BT_LE_SUP_TO_DEFAULT		0X03E8
+
+#define BT_INFO(fmt, arg...) printk(KERN_INFO "Bluetooth: " fmt "\n" , ## arg)
+#define BT_ERR(fmt, arg...)  printk(KERN_ERR "%s: " fmt "\n" , __func__ , ## arg)
+#define BT_DBG(fmt, arg...)  pr_debug("%s: " fmt "\n" , __func__ , ## arg)
 
 /* Connection and socket states */
 enum {
@@ -155,6 +165,20 @@ bdaddr_t *strtoba(char *str);
 
 #define bt_sk(__sk) ((struct bt_sock *) __sk)
 
+struct bt_le_params {
+	__u8  prohibit_remote_chg;
+	__u8  filter_policy;
+	__u16 scan_interval;
+	__u16 scan_window;
+	__u16 interval_min;
+	__u16 interval_max;
+	__u16 latency;
+	__u16 supervision_timeout;
+	__u16 min_ce_len;
+	__u16 max_ce_len;
+	__u16 conn_timeout;
+};
+
 struct bt_sock {
 	struct sock sk;
 	bdaddr_t    src;
@@ -162,6 +186,7 @@ struct bt_sock {
 	struct list_head accept_q;
 	struct sock *parent;
 	u32 defer_setup;
+	struct bt_le_params le_params;
 };
 
 struct bt_sock_list {
@@ -177,7 +202,7 @@ int  bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
 				struct msghdr *msg, size_t len, int flags);
 int  bt_sock_stream_recvmsg(struct kiocb *iocb, struct socket *sock,
 			struct msghdr *msg, size_t len, int flags);
-uint bt_sock_poll(struct file * file, struct socket *sock, poll_table *wait);
+uint bt_sock_poll(struct file *file, struct socket *sock, poll_table *wait);
 int  bt_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
 int  bt_sock_wait_state(struct sock *sk, int state, unsigned long timeo);
 
@@ -186,15 +211,25 @@ void bt_accept_unlink(struct sock *sk);
 struct sock *bt_accept_dequeue(struct sock *parent, struct socket *newsock);
 
 /* Skb helpers */
+struct bt_l2cap_control {
+	__u8  frame_type;
+	__u8  final;
+	__u8  sar;
+	__u8  super;
+	__u16 reqseq;
+	__u16 txseq;
+	__u8  poll;
+	__u8  fcs;
+};
+
 struct bt_skb_cb {
 	__u8 pkt_type;
 	__u8 incoming;
 	__u16 expect;
-	__u16 tx_seq;
 	__u8 retries;
-	__u8 sar;
-	unsigned short channel;
 	__u8 force_active;
+	unsigned short channel;
+	struct bt_l2cap_control control;
 };
 #define bt_cb(skb) ((struct bt_skb_cb *)((skb)->cb))
 
@@ -202,7 +237,8 @@ static inline struct sk_buff *bt_skb_alloc(unsigned int len, gfp_t how)
 {
 	struct sk_buff *skb;
 
-	if ((skb = alloc_skb(len + BT_SKB_RESERVE, how))) {
+	skb = alloc_skb(len + BT_SKB_RESERVE, how);
+	if (skb) {
 		skb_reserve(skb, BT_SKB_RESERVE);
 		bt_cb(skb)->incoming  = 0;
 	}
@@ -215,7 +251,8 @@ static inline struct sk_buff *bt_skb_send_alloc(struct sock *sk,
 	struct sk_buff *skb;
 
 	release_sock(sk);
-	if ((skb = sock_alloc_send_skb(sk, len + BT_SKB_RESERVE, nb, err))) {
+	skb = sock_alloc_send_skb(sk, len + BT_SKB_RESERVE, nb, err);
+	if (skb) {
 		skb_reserve(skb, BT_SKB_RESERVE);
 		bt_cb(skb)->incoming  = 0;
 	}
@@ -240,7 +277,7 @@ out:
 	return NULL;
 }
 
-int bt_to_errno(__u16 code);
+int bt_err(__u16 code);
 
 extern int hci_sock_init(void);
 extern void hci_sock_cleanup(void);
@@ -256,6 +293,4 @@ void l2cap_exit(void);
 int sco_init(void);
 void sco_exit(void);
 
-void bt_sock_reclassify_lock(struct sock *sk, int proto);
-
 #endif /* __BLUETOOTH_H */
diff --git a/include/net/bluetooth/hci.h b/include/net/bluetooth/hci.h
old mode 100755
new mode 100644
index f47293c..35c57c0
--- a/include/net/bluetooth/hci.h
+++ b/include/net/bluetooth/hci.h
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (C) 2000-2001 Qualcomm Incorporated
+   Copyright (c) 2000-2001, 2010-2013 The Linux Foundation. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -25,7 +25,7 @@
 #ifndef __HCI_H
 #define __HCI_H
 
-#define HCI_MAX_ACL_SIZE	1024
+#define HCI_MAX_ACL_SIZE	1500
 #define HCI_MAX_SCO_SIZE	255
 #define HCI_MAX_EVENT_SIZE	260
 #define HCI_MAX_FRAME_SIZE	(HCI_MAX_ACL_SIZE + 4)
@@ -37,9 +37,7 @@
 #define HCI_DEV_DOWN			4
 #define HCI_DEV_SUSPEND			5
 #define HCI_DEV_RESUME			6
-#ifdef CONFIG_BT_BLUESLEEP
 #define HCI_DEV_WRITE			7
-#endif
 
 /* HCI notify events */
 #define HCI_NOTIFY_CONN_ADD		1
@@ -54,6 +52,7 @@
 #define HCI_RS232	4
 #define HCI_PCI		5
 #define HCI_SDIO	6
+#define HCI_SMD		7
 
 /* HCI controller types */
 #define HCI_BREDR	0x00
@@ -91,14 +90,6 @@ enum {
 	HCI_RESET,
 };
 
-/*
- * BR/EDR and/or LE controller flags: the flags defined here should represent
- * states from the controller.
- */
-enum {
-	HCI_LE_SCAN,
-};
-
 /* HCI ioctl defines */
 #define HCIDEVUP	_IOW('H', 201, int)
 #define HCIDEVDOWN	_IOW('H', 202, int)
@@ -110,6 +101,7 @@ enum {
 #define HCIGETCONNLIST	_IOR('H', 212, int)
 #define HCIGETCONNINFO	_IOR('H', 213, int)
 #define HCIGETAUTHINFO	_IOR('H', 215, int)
+#define HCISETAUTHINFO  _IOR('H', 216, int)
 
 #define HCISETRAW	_IOW('H', 220, int)
 #define HCISETSCAN	_IOW('H', 221, int)
@@ -132,7 +124,7 @@ enum {
 #define HCI_PAIRING_TIMEOUT	(60000)	/* 60 seconds */
 #define HCI_IDLE_TIMEOUT	(6000)	/* 6 seconds */
 #define HCI_INIT_TIMEOUT	(10000)	/* 10 seconds */
-#define HCI_CMD_TIMEOUT		(1000)	/* 1 seconds */
+#define HCI_CMD_TIMEOUT		(5000)	/* 5 seconds */
 
 /* HCI data types */
 #define HCI_COMMAND_PKT		0x01
@@ -168,18 +160,35 @@ enum {
 #define ESCO_2EV5	0x0100
 #define ESCO_3EV5	0x0200
 
+#define ESCO_WBS	(ESCO_EV3 | (EDR_ESCO_MASK ^ ESCO_2EV3))
+
 #define SCO_ESCO_MASK	(ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
 #define EDR_ESCO_MASK	(ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
 #define ALL_ESCO_MASK	(SCO_ESCO_MASK | ESCO_EV3 | ESCO_EV4 | ESCO_EV5 | \
 			EDR_ESCO_MASK)
 
+/* Air Coding Format */
+#define ACF_CVSD	0x0000;
+#define ACF_ULAW	0x0001;
+#define ACF_ALAW	0x0002;
+#define ACF_TRANS	0x0003;
+
+/* Retransmission Effort */
+#define RE_NO_RETRANS		0x00;
+#define RE_POWER_CONSUMP	0x01;
+#define RE_LINK_QUALITY		0x02;
+#define RE_DONT_CARE		0xFF;
+
 /* ACL flags */
 #define ACL_START_NO_FLUSH	0x00
 #define ACL_CONT		0x01
 #define ACL_START		0x02
+#define ACL_COMPLETE		0x03
 #define ACL_ACTIVE_BCAST	0x04
 #define ACL_PICO_BCAST		0x08
 
+#define ACL_PB_MASK	(ACL_CONT | ACL_START)
+
 /* Baseband links */
 #define SCO_LINK	0x00
 #define ACL_LINK	0x01
@@ -215,7 +224,6 @@ enum {
 
 #define LMP_EV4		0x01
 #define LMP_EV5		0x02
-#define LMP_NO_BREDR	0x20
 #define LMP_LE		0x40
 
 #define LMP_SNIFF_SUBR	0x02
@@ -225,16 +233,11 @@ enum {
 #define LMP_EDR_3S_ESCO	0x80
 
 #define LMP_EXT_INQ	0x01
-#define LMP_SIMUL_LE_BR	0x02
 #define LMP_SIMPLE_PAIR	0x08
 #define LMP_NO_FLUSH	0x40
 
 #define LMP_LSTO	0x01
 #define LMP_INQ_TX_PWR	0x02
-#define LMP_EXTFEATURES	0x80
-
-/* Extended LMP features */
-#define LMP_HOST_LE	0x02
 
 /* Connection modes */
 #define HCI_CM_ACTIVE	0x0000
@@ -265,29 +268,9 @@ enum {
 #define HCI_AT_GENERAL_BONDING		0x04
 #define HCI_AT_GENERAL_BONDING_MITM	0x05
 
-/* Link Key types */
-#define HCI_LK_COMBINATION		0x00
-#define HCI_LK_LOCAL_UNIT		0x01
-#define HCI_LK_REMOTE_UNIT		0x02
-#define HCI_LK_DEBUG_COMBINATION	0x03
-#define HCI_LK_UNAUTH_COMBINATION	0x04
-#define HCI_LK_AUTH_COMBINATION		0x05
-#define HCI_LK_CHANGED_COMBINATION	0x06
-/* The spec doesn't define types for SMP keys */
-#define HCI_LK_SMP_LTK			0x81
-#define HCI_LK_SMP_IRK			0x82
-#define HCI_LK_SMP_CSRK			0x83
-
-/* ---- HCI Error Codes ---- */
-#define HCI_ERROR_AUTH_FAILURE		0x05
-#define HCI_ERROR_REJ_BAD_ADDR		0x0f
-#define HCI_ERROR_REMOTE_USER_TERM	0x13
-#define HCI_ERROR_LOCAL_HOST_TERM	0x16
-#define HCI_ERROR_PAIRING_NOT_ALLOWED	0x18
-
 /* Flow control modes */
-#define HCI_FLOW_CTL_MODE_PACKET_BASED	0x00
-#define HCI_FLOW_CTL_MODE_BLOCK_BASED	0x01
+#define HCI_PACKET_BASED_FLOW_CTL_MODE	0x00
+#define HCI_BLOCK_BASED_FLOW_CTL_MODE	0x01
 
 /* -----  HCI Commands ---- */
 #define HCI_OP_NOP			0x0000
@@ -348,6 +331,11 @@ struct hci_cp_link_key_reply {
 	__u8     link_key[16];
 } __packed;
 
+struct hci_rp_link_key_reply {
+	__u8     status;
+	bdaddr_t bdaddr;
+} __packed;
+
 #define HCI_OP_LINK_KEY_NEG_REPLY	0x040c
 struct hci_cp_link_key_neg_reply {
 	bdaddr_t bdaddr;
@@ -424,6 +412,11 @@ struct hci_cp_read_remote_version {
 	__le16   handle;
 } __packed;
 
+#define HCI_OP_READ_CLOCK_OFFSET	0x041f
+struct hci_cp_read_clock_offset {
+	__le16   handle;
+} __packed;
+
 #define HCI_OP_SETUP_SYNC_CONN		0x0428
 struct hci_cp_setup_sync_conn {
 	__le16   handle;
@@ -471,14 +464,6 @@ struct hci_rp_user_confirm_reply {
 
 #define HCI_OP_USER_CONFIRM_NEG_REPLY	0x042d
 
-#define HCI_OP_USER_PASSKEY_REPLY		0x042e
-struct hci_cp_user_passkey_reply {
-	bdaddr_t bdaddr;
-	__le32	passkey;
-} __packed;
-
-#define HCI_OP_USER_PASSKEY_NEG_REPLY	0x042f
-
 #define HCI_OP_REMOTE_OOB_DATA_REPLY	0x0430
 struct hci_cp_remote_oob_data_reply {
 	bdaddr_t bdaddr;
@@ -497,6 +482,69 @@ struct hci_cp_io_capability_neg_reply {
 	__u8     reason;
 } __packed;
 
+#define HCI_OP_CREATE_PHYS_LINK		0x0435
+struct hci_cp_create_phys_link {
+	__u8     phy_handle;
+	__u8     key_len;
+	__u8     type;
+	__u8     data[32];
+} __packed;
+
+#define HCI_OP_ACCEPT_PHYS_LINK		0x0436
+struct hci_cp_accept_phys_link {
+	__u8     phy_handle;
+	__u8     key_len;
+	__u8     type;
+	__u8     data[32];
+} __packed;
+
+#define HCI_OP_DISCONN_PHYS_LINK	0x0437
+struct hci_cp_disconn_phys_link {
+	__u8     phy_handle;
+	__u8     reason;
+} __packed;
+
+struct hci_ext_fs {
+	__u8       id;
+	__u8       type;
+	__le16     max_sdu;
+	__le32     sdu_arr_time;
+	__le32     acc_latency;
+	__le32     flush_to;
+} __packed;
+
+#define HCI_OP_CREATE_LOGICAL_LINK	0x0438
+#define HCI_OP_ACCEPT_LOGICAL_LINK	0x0439
+struct hci_cp_create_logical_link {
+	__u8               phy_handle;
+	struct hci_ext_fs  tx_fs;
+	struct hci_ext_fs  rx_fs;
+} __packed;
+
+#define HCI_OP_DISCONN_LOGICAL_LINK	0x043a
+struct hci_cp_disconn_logical_link {
+	__le16   log_handle;
+} __packed;
+
+#define HCI_OP_LOGICAL_LINK_CANCEL	0x043b
+struct hci_cp_logical_link_cancel {
+	__u8     phy_handle;
+	__u8     flow_spec_id;
+} __packed;
+
+struct hci_rp_logical_link_cancel {
+	__u8     status;
+	__u8     phy_handle;
+	__u8     flow_spec_id;
+} __packed;
+
+#define HCI_OP_FLOW_SPEC_MODIFY		0x043c
+struct hci_cp_flow_spec_modify {
+	__le16             log_handle;
+	struct hci_ext_fs  tx_fs;
+	struct hci_ext_fs  rx_fs;
+} __packed;
+
 #define HCI_OP_SNIFF_MODE		0x0803
 struct hci_cp_sniff_mode {
 	__le16   handle;
@@ -657,6 +705,12 @@ struct hci_cp_write_voice_setting {
 	__le16   voice_setting;
 } __packed;
 
+#define HCI_OP_WRITE_AUTOMATIC_FLUSH_TIMEOUT	0x0c28
+struct hci_cp_write_automatic_flush_timeout {
+	__le16   handle;
+	__le16   timeout;
+} __packed;
+
 #define HCI_OP_HOST_BUFFER_SIZE		0x0c33
 struct hci_cp_host_buffer_size {
 	__le16   acl_mtu;
@@ -665,6 +719,12 @@ struct hci_cp_host_buffer_size {
 	__le16   sco_max_pkt;
 } __packed;
 
+#define HCI_OP_WRITE_CURRENT_IAC_LAP	0x0c3a
+struct hci_cp_write_current_iac_lap {
+	__u8     num_current_iac;
+	__u8     lap[6];
+} __packed;
+
 #define HCI_OP_WRITE_INQUIRY_MODE	0x0c45
 
 #define HCI_MAX_EIR_LENGTH		240
@@ -695,16 +755,70 @@ struct hci_rp_read_local_oob_data {
 
 #define HCI_OP_READ_INQ_RSP_TX_POWER	0x0c58
 
+#define HCI_OP_READ_LL_TIMEOUT		0x0c61
+struct hci_rp_read_ll_timeout {
+	__u8     status;
+	__le16   timeout;
+} __packed;
+
+#define HCI_OP_WRITE_LL_TIMEOUT		0x0c62
+struct hci_cp_write_ll_timeout {
+	__le16   timeout;
+} __packed;
+
+#define HCI_OP_SET_EVENT_MASK_PAGE2	0x0c63
+struct hci_cp_set_event_mask_page2 {
+	__u8     mask[8];
+} __packed;
+
+#define HCI_OP_READ_LOCATION_DATA	0x0c64
+struct hci_rp_read_location_data {
+	__u8     status;
+	__u8     loc_dom_aware;
+	__u8     loc_dom;
+	__u8     loc_dom_opts;
+	__u8     loc_opts;
+} __packed;
+
+#define HCI_OP_WRITE_LOCATION_DATA	0x0c65
+struct hci_cp_write_location_data {
+	__u8     loc_dom_aware;
+	__u8     loc_dom;
+	__u8     loc_dom_opts;
+	__u8     loc_opts;
+} __packed;
+
 #define HCI_OP_READ_FLOW_CONTROL_MODE	0x0c66
 struct hci_rp_read_flow_control_mode {
 	__u8     status;
 	__u8     mode;
 } __packed;
 
-#define HCI_OP_WRITE_LE_HOST_SUPPORTED	0x0c6d
-struct hci_cp_write_le_host_supported {
-	__u8 le;
-	__u8 simul;
+#define HCI_OP_WRITE_FLOW_CONTROL_MODE	0x0c67
+struct hci_cp_write_flow_control_mode {
+	__u8     mode;
+} __packed;
+
+#define HCI_OP_READ_BE_FLUSH_TIMEOUT	0x0c69
+struct hci_cp_read_be_flush_timeout {
+	__le16   log_handle;
+} __packed;
+
+struct hci_rp_read_be_flush_timeout {
+	__u8     status;
+	__le32   timeout;
+} __packed;
+
+#define HCI_OP_WRITE_BE_FLUSH_TIMEOUT	0x0c6a
+struct hci_cp_write_be_flush_timeout {
+	__le16   log_handle;
+	__le32   timeout;
+} __packed;
+
+#define HCI_OP_SHORT_RANGE_MODE		0x0c6b
+struct hci_cp_short_range_mode {
+	__u8     phy_handle;
+	__u8     mode;
 } __packed;
 
 #define HCI_OP_READ_LOCAL_VERSION	0x1001
@@ -730,9 +844,6 @@ struct hci_rp_read_local_features {
 } __packed;
 
 #define HCI_OP_READ_LOCAL_EXT_FEATURES	0x1004
-struct hci_cp_read_local_ext_features {
-	__u8     page;
-} __packed;
 struct hci_rp_read_local_ext_features {
 	__u8     status;
 	__u8     page;
@@ -759,19 +870,20 @@ struct hci_rp_read_bd_addr {
 struct hci_rp_read_data_block_size {
 	__u8     status;
 	__le16   max_acl_len;
-	__le16   block_len;
+	__le16   data_block_len;
 	__le16   num_blocks;
 } __packed;
 
-#define HCI_OP_WRITE_PAGE_SCAN_ACTIVITY	0x0c1c
-struct hci_cp_write_page_scan_activity {
-	__le16   interval;
-	__le16   window;
+#define HCI_OP_READ_RSSI	0x1405
+struct hci_cp_read_rssi {
+	__le16   handle;
 } __packed;
 
-#define HCI_OP_WRITE_PAGE_SCAN_TYPE	0x0c47
-	#define PAGE_SCAN_TYPE_STANDARD		0x00
-	#define PAGE_SCAN_TYPE_INTERLACED	0x01
+struct hci_rp_read_rssi {
+	__u8     status;
+	__le16   handle;
+	__s8     rssi;
+} __packed;
 
 #define HCI_OP_READ_LOCAL_AMP_INFO	0x1409
 struct hci_rp_read_local_amp_info {
@@ -788,6 +900,33 @@ struct hci_rp_read_local_amp_info {
 	__le32   be_flush_to;
 } __packed;
 
+#define HCI_OP_READ_LOCAL_AMP_ASSOC	0x140a
+struct hci_cp_read_local_amp_assoc {
+	__u8     phy_handle;
+	__le16   len_so_far;
+	__le16   max_len;
+} __packed;
+
+struct hci_rp_read_local_amp_assoc {
+	__u8     status;
+	__u8     phy_handle;
+	__le16   rem_len;
+	__u8     frag[248];
+} __packed;
+
+#define HCI_OP_WRITE_REMOTE_AMP_ASSOC	0x140b
+struct hci_cp_write_remote_amp_assoc {
+	__u8     phy_handle;
+	__le16   len_so_far;
+	__le16   rem_len;
+	__u8     frag[248];
+} __packed;
+
+struct hci_rp_write_remote_amp_assoc {
+	__u8     status;
+	__u8     phy_handle;
+} __packed;
+
 #define HCI_OP_LE_SET_EVENT_MASK	0x2001
 struct hci_cp_le_set_event_mask {
 	__u8     mask[8];
@@ -800,22 +939,19 @@ struct hci_rp_le_read_buffer_size {
 	__u8     le_max_pkt;
 } __packed;
 
-#define HCI_OP_LE_SET_SCAN_PARAM	0x200b
-struct hci_cp_le_set_scan_param {
-	__u8    type;
-	__le16  interval;
-	__le16  window;
-	__u8    own_address_type;
-	__u8    filter_policy;
+#define HCI_OP_LE_SET_SCAN_PARAMETERS	0x200b
+struct hci_cp_le_set_scan_parameters {
+	__u8	type;
+	__le16	interval;
+	__le16	window;
+	__u8	own_bdaddr_type;
+	__u8	filter;
 } __packed;
 
-#define LE_SCANNING_DISABLED		0x00
-#define LE_SCANNING_ENABLED		0x01
-
 #define HCI_OP_LE_SET_SCAN_ENABLE	0x200c
 struct hci_cp_le_set_scan_enable {
-	__u8     enable;
-	__u8     filter_dup;
+	__u8	enable;
+	__u8	filter_dup;
 } __packed;
 
 #define HCI_OP_LE_CREATE_CONN		0x200d
@@ -836,6 +972,26 @@ struct hci_cp_le_create_conn {
 
 #define HCI_OP_LE_CREATE_CONN_CANCEL	0x200e
 
+#define HCI_OP_LE_READ_WHITE_LIST_SIZE	0x200F
+struct hci_rp_le_read_white_list_size {
+	__u8     status;
+	__u8     size;
+} __packed;
+
+#define HCI_OP_LE_CLEAR_WHITE_LIST	0x2010
+
+#define HCI_OP_LE_ADD_DEV_WHITE_LIST	0x2011
+struct hci_cp_le_add_dev_white_list {
+	__u8     addr_type;
+	bdaddr_t addr;
+} __packed;
+
+#define HCI_OP_LE_REMOVE_DEV_WHITE_LIST 0x2012
+struct hci_cp_le_remove_dev_white_list {
+	__u8     addr_type;
+	bdaddr_t addr;
+} __packed;
+
 #define HCI_OP_LE_CONN_UPDATE		0x2013
 struct hci_cp_le_conn_update {
 	__le16   handle;
@@ -847,6 +1003,16 @@ struct hci_cp_le_conn_update {
 	__le16   max_ce_len;
 } __packed;
 
+#define HCI_OP_LE_ENCRYPT		0x2017
+struct hci_cp_le_encrypt {
+	__u8	key[16];
+	__u8	data[16];
+} __packed;
+struct hci_cp_le_encrypt_reply {
+	__u8     status;
+	__u8     encrypted[16];
+} __packed;
+
 #define HCI_OP_LE_START_ENC		0x2019
 struct hci_cp_le_start_enc {
 	__le16	handle;
@@ -979,6 +1145,11 @@ struct hci_ev_cmd_status {
 	__le16   opcode;
 } __packed;
 
+#define HCI_EV_HARDWARE_ERROR		0x10
+struct hci_ev_hardware_error {
+	__u8   hw_err_code;
+} __packed;
+
 #define HCI_EV_ROLE_CHANGE		0x12
 struct hci_ev_role_change {
 	__u8     status;
@@ -987,14 +1158,9 @@ struct hci_ev_role_change {
 } __packed;
 
 #define HCI_EV_NUM_COMP_PKTS		0x13
-struct hci_comp_pkts_info {
-	__le16   handle;
-	__le16   count;
-} __packed;
-
 struct hci_ev_num_comp_pkts {
 	__u8     num_hndl;
-	struct hci_comp_pkts_info handles[0];
+	/* variable length part */
 } __packed;
 
 #define HCI_EV_MODE_CHANGE		0x14
@@ -1134,8 +1300,8 @@ struct hci_ev_user_confirm_req {
 } __packed;
 
 #define HCI_EV_USER_PASSKEY_REQUEST	0x34
-struct hci_ev_user_passkey_req {
-	bdaddr_t	bdaddr;
+struct hci_ev_user_passkey_request {
+	bdaddr_t bdaddr;
 } __packed;
 
 #define HCI_EV_REMOTE_OOB_DATA_REQUEST	0x35
@@ -1149,6 +1315,12 @@ struct hci_ev_simple_pair_complete {
 	bdaddr_t bdaddr;
 } __packed;
 
+#define HCI_EV_USER_PASSKEY_NOTIFICATION	0x3b
+struct hci_ev_user_passkey_notification {
+	bdaddr_t	bdaddr;
+	__le32		passkey;
+} __packed;
+
 #define HCI_EV_REMOTE_HOST_FEATURES	0x3d
 struct hci_ev_remote_host_features {
 	bdaddr_t bdaddr;
@@ -1174,14 +1346,6 @@ struct hci_ev_le_conn_complete {
 	__u8     clk_accurancy;
 } __packed;
 
-#define HCI_EV_LE_LTK_REQ		0x05
-struct hci_ev_le_ltk_req {
-	__le16	handle;
-	__u8	random[8];
-	__le16	ediv;
-} __packed;
-
-/* Advertising report event types */
 #define ADV_IND		0x00
 #define ADV_DIRECT_IND	0x01
 #define ADV_SCAN_IND	0x02
@@ -1200,6 +1364,81 @@ struct hci_ev_le_advertising_info {
 	__u8	 data[0];
 } __packed;
 
+#define HCI_EV_LE_CONN_UPDATE_COMPLETE	0x03
+struct hci_ev_le_conn_update_complete {
+	__u8     status;
+	__le16   handle;
+	__le16   interval;
+	__le16   latency;
+	__le16   supervision_timeout;
+} __packed;
+
+#define HCI_EV_LE_LTK_REQ		0x05
+struct hci_ev_le_ltk_req {
+	__le16	handle;
+	__u8	random[8];
+	__le16	ediv;
+} __packed;
+
+#define HCI_EV_PHYS_LINK_COMPLETE	0x40
+struct hci_ev_phys_link_complete {
+	__u8     status;
+	__u8     phy_handle;
+} __packed;
+
+#define HCI_EV_CHANNEL_SELECTED		0x41
+struct hci_ev_channel_selected {
+	__u8     phy_handle;
+} __packed;
+
+#define HCI_EV_DISCONN_PHYS_LINK_COMPLETE	0x42
+struct hci_ev_disconn_phys_link_complete {
+	__u8     status;
+	__u8     phy_handle;
+	__u8     reason;
+} __packed;
+
+#define HCI_EV_LOG_LINK_COMPLETE	0x45
+struct hci_ev_log_link_complete {
+	__u8     status;
+	__le16   log_handle;
+	__u8     phy_handle;
+	__u8     flow_spec_id;
+} __packed;
+
+#define HCI_EV_DISCONN_LOG_LINK_COMPLETE	0x46
+struct hci_ev_disconn_log_link_complete {
+	__u8     status;
+	__le16   log_handle;
+	__u8     reason;
+} __packed;
+
+#define HCI_EV_FLOW_SPEC_MODIFY_COMPLETE	0x47
+struct hci_ev_flow_spec_modify_complete {
+	__u8     status;
+	__le16   log_handle;
+} __packed;
+
+#define HCI_EV_NUM_COMP_BLOCKS		0x48
+struct hci_ev_num_comp_blocks {
+	__le16   total_num_blocks;
+	__u8     num_hndl;
+	/* variable length part */
+} __packed;
+
+#define HCI_EV_SHORT_RANGE_MODE_COMPLETE	0x4c
+struct hci_ev_short_range_mode_complete {
+	__u8     status;
+	__u8     phy_handle;
+	__u8     mode;
+} __packed;
+
+#define HCI_EV_AMP_STATUS_CHANGE	0x4d
+struct hci_ev_amp_status_change {
+	__u8     status;
+	__u8     amp_status;
+} __packed;
+
 /* Internal events generated by Bluetooth stack */
 #define HCI_EV_STACK_INTERNAL	0xfd
 struct hci_ev_stack_internal {
@@ -1247,6 +1486,7 @@ struct hci_sco_hdr {
 	__u8	dlen;
 } __packed;
 
+#ifdef __KERNEL__
 #include <linux/skbuff.h>
 static inline struct hci_event_hdr *hci_event_hdr(const struct sk_buff *skb)
 {
@@ -1262,6 +1502,7 @@ static inline struct hci_sco_hdr *hci_sco_hdr(const struct sk_buff *skb)
 {
 	return (struct hci_sco_hdr *) skb->data;
 }
+#endif
 
 /* Command opcode pack/unpack */
 #define hci_opcode_pack(ogf, ocf)	(__u16) ((ocf & 0x03ff)|(ogf << 10))
@@ -1358,6 +1599,8 @@ struct hci_conn_info {
 	__u32    mtu;
 	__u32    cnt;
 	__u32    pkts;
+	__u8     pending_sec_level;
+	__u8     ssp_mode;
 };
 
 struct hci_dev_req {
@@ -1396,6 +1639,4 @@ struct hci_inquiry_req {
 };
 #define IREQ_CACHE_FLUSH 0x0001
 
-extern bool enable_hs;
-
 #endif /* __HCI_H */
diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 34becdd..60845de 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1,6 +1,7 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
+   Copyright (c) 2000-2001, The Linux Foundation. All rights reserved.
+   Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -25,11 +26,10 @@
 #ifndef __HCI_CORE_H
 #define __HCI_CORE_H
 
-#include <linux/interrupt.h>
 #include <net/bluetooth/hci.h>
-
-/* HCI priority */
-#define HCI_PRIO_MAX	7
+/* HCI upper protocols */
+#define HCI_PROTO_L2CAP	0
+#define HCI_PROTO_SCO	1
 
 /* HCI Core structures */
 struct inquiry_data {
@@ -50,17 +50,24 @@ struct inquiry_entry {
 };
 
 struct inquiry_cache {
+	spinlock_t		lock;
 	__u32			timestamp;
 	struct inquiry_entry	*list;
 };
 
 struct hci_conn_hash {
 	struct list_head list;
+	spinlock_t       lock;
 	unsigned int     acl_num;
 	unsigned int     sco_num;
 	unsigned int     le_num;
 };
 
+struct hci_chan_list {
+	struct list_head list;
+	spinlock_t       lock;
+};
+
 struct bdaddr_list {
 	struct list_head list;
 	bdaddr_t bdaddr;
@@ -77,11 +84,18 @@ struct key_master_id {
 	u8 rand[8];
 } __packed;
 
+#define KEY_TYPE_LE_BASE	0x11
+#define KEY_TYPE_LTK		0x11
+#define KEY_TYPE_IRK		0x12
+#define KEY_TYPE_CSRK		0x13
+
 struct link_key_data {
 	bdaddr_t bdaddr;
-	u8 type;
+	u8 addr_type;
+	u8 key_type;
 	u8 val[16];
 	u8 pin_len;
+	u8 auth;
 	u8 dlen;
 	u8 data[0];
 } __packed;
@@ -89,9 +103,11 @@ struct link_key_data {
 struct link_key {
 	struct list_head list;
 	bdaddr_t bdaddr;
-	u8 type;
+	u8 addr_type;
+	u8 key_type;
 	u8 val[16];
 	u8 pin_len;
+	u8 auth;
 	u8 dlen;
 	u8 data[0];
 };
@@ -107,12 +123,13 @@ struct adv_entry {
 	struct list_head list;
 	bdaddr_t bdaddr;
 	u8 bdaddr_type;
+	u8 flags;
 };
 
 #define NUM_REASSEMBLY 4
 struct hci_dev {
 	struct list_head list;
-	struct mutex	lock;
+	spinlock_t	lock;
 	atomic_t	refcnt;
 
 	char		name[8];
@@ -127,7 +144,6 @@ struct hci_dev {
 	__u8		major_class;
 	__u8		minor_class;
 	__u8		features[8];
-	__u8		host_features[8];
 	__u8		commands[64];
 	__u8		ssp_mode;
 	__u8		hci_ver;
@@ -158,9 +174,7 @@ struct hci_dev {
 	__u32		amp_max_flush_to;
 	__u32		amp_be_flush_to;
 
-	__u8		flow_ctl_mode;
-
-	unsigned int	auto_accept_delay;
+	__s8		is_wbs;
 
 	unsigned long	quirks;
 
@@ -169,17 +183,17 @@ struct hci_dev {
 	unsigned int	sco_cnt;
 	unsigned int	le_cnt;
 
+	__u8	flow_ctl_mode;
+
 	unsigned int	acl_mtu;
 	unsigned int	sco_mtu;
 	unsigned int	le_mtu;
 	unsigned int	acl_pkts;
 	unsigned int	sco_pkts;
 	unsigned int	le_pkts;
+	unsigned int	le_white_list_size;
 
-	__u16		block_len;
-	__u16		block_mtu;
-	__u16		num_blocks;
-	__u16		block_cnt;
+	unsigned int	data_block_len;
 
 	unsigned long	acl_last_tx;
 	unsigned long	sco_last_tx;
@@ -188,18 +202,13 @@ struct hci_dev {
 	struct workqueue_struct	*workqueue;
 
 	struct work_struct	power_on;
-	struct delayed_work	power_off;
-
-	__u16			discov_timeout;
-	struct delayed_work	discov_off;
-
-	struct delayed_work	service_cache;
+	struct work_struct	power_off;
+	struct timer_list	off_timer;
 
 	struct timer_list	cmd_timer;
-
-	struct work_struct	rx_work;
-	struct work_struct	cmd_work;
-	struct work_struct	tx_work;
+	struct tasklet_struct	cmd_task;
+	struct tasklet_struct	rx_task;
+	struct tasklet_struct	tx_task;
 
 	struct sk_buff_head	rx_q;
 	struct sk_buff_head	raw_q;
@@ -215,10 +224,11 @@ struct hci_dev {
 
 	__u16			init_last_cmd;
 
-	struct list_head	mgmt_pending;
+	struct crypto_blkcipher	*tfm;
 
 	struct inquiry_cache	inq_cache;
 	struct hci_conn_hash	conn_hash;
+	struct hci_chan_list	chan_list;
 	struct list_head	blacklist;
 
 	struct list_head	uuids;
@@ -228,7 +238,14 @@ struct hci_dev {
 	struct list_head	remote_oob_data;
 
 	struct list_head	adv_entries;
-	struct delayed_work	adv_work;
+	rwlock_t		adv_entries_lock;
+	struct timer_list	adv_timer;
+
+	struct timer_list	disco_timer;
+	struct timer_list	disco_le_timer;
+	__u8			disco_state;
+	int			disco_int_phase;
+	int			disco_int_count;
 
 	struct hci_dev_stats	stat;
 
@@ -248,8 +265,6 @@ struct hci_dev {
 
 	struct module		*owner;
 
-	unsigned long		dev_flags;
-
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);
 	int (*flush)(struct hci_dev *hdev);
@@ -263,9 +278,11 @@ struct hci_conn {
 	struct list_head list;
 
 	atomic_t	refcnt;
+	spinlock_t	lock;
 
 	bdaddr_t	dst;
-	__u8		dst_type;
+	__u8		 dst_id;
+	__u8            dst_type;
 	__u16		handle;
 	__u16		state;
 	__u8		mode;
@@ -279,40 +296,68 @@ struct hci_conn {
 	__u16		pkt_type;
 	__u16		link_policy;
 	__u32		link_mode;
-	__u8		key_type;
 	__u8		auth_type;
 	__u8		sec_level;
 	__u8		pending_sec_level;
 	__u8		pin_length;
 	__u8		enc_key_size;
 	__u8		io_capability;
+	__u8		auth_initiator;
 	__u8		power_save;
 	__u16		disc_timeout;
+	__u16		conn_timeout;
 	unsigned long	pend;
 
 	__u8		remote_cap;
 	__u8		remote_oob;
 	__u8		remote_auth;
 
+	__s8	rssi_threshold;
+	__u16	rssi_update_interval;
+	__u8	rssi_update_thresh_exceed;
+
 	unsigned int	sent;
 
 	struct sk_buff_head data_q;
-	struct list_head chan_list;
 
-	struct delayed_work disc_work;
+	struct timer_list disc_timer;
 	struct timer_list idle_timer;
-	struct timer_list auto_accept_timer;
+	struct delayed_work	rssi_update_work;
+	struct timer_list encrypt_pause_timer;
 
+	struct work_struct work_add;
+	struct work_struct work_del;
 	struct device	dev;
 	atomic_t	devref;
 
 	struct hci_dev	*hdev;
 	void		*l2cap_data;
 	void		*sco_data;
-	void		*smp_conn;
+	void		*priv;
+
+	__u8             link_key[16];
+	__u8             key_type;
 
 	struct hci_conn	*link;
 
+	/* Low Energy SMP pairing data */
+	__u8		oob; /* OOB pairing supported */
+	__u8		tk_valid; /* TK value is valid */
+	__u8		cfm_pending; /* CONFIRM cmd may be sent */
+	__u8		preq[7]; /* Pairing Request */
+	__u8		prsp[7]; /* Pairing Response */
+	__u8		prnd[16]; /* Pairing Random */
+	__u8		pcnf[16]; /* Pairing Confirm */
+	__u8		tk[16]; /* Temporary Key */
+	__u8		smp_key_size;
+	__u8		sec_req;
+	__u8		auth;
+	void		*smp_conn;
+	struct timer_list smp_timer;
+	__u8		conn_valid;
+	__u8		hidp_session_valid;
+
+
 	void (*connect_cfm_cb)	(struct hci_conn *conn, u8 status);
 	void (*security_cfm_cb)	(struct hci_conn *conn, u8 status);
 	void (*disconn_cfm_cb)	(struct hci_conn *conn, u8 reason);
@@ -320,37 +365,35 @@ struct hci_conn {
 
 struct hci_chan {
 	struct list_head list;
-
-	struct hci_conn *conn;
-	struct sk_buff_head data_q;
-	unsigned int	sent;
+	struct hci_dev	*hdev;
+	__u16		state;
+	atomic_t	refcnt;
+	__u16		ll_handle;
+	struct hci_ext_fs	tx_fs;
+	struct hci_ext_fs	rx_fs;
+	struct hci_conn	*conn;
+	void		*l2cap_sk;
 };
 
+extern struct hci_proto *hci_proto[];
 extern struct list_head hci_dev_list;
 extern struct list_head hci_cb_list;
 extern rwlock_t hci_dev_list_lock;
 extern rwlock_t hci_cb_list_lock;
 
-/* ----- HCI interface to upper protocols ----- */
-extern int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
-extern int l2cap_connect_cfm(struct hci_conn *hcon, u8 status);
-extern int l2cap_disconn_ind(struct hci_conn *hcon);
-extern int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason);
-extern int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt);
-extern int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags);
-
-extern int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
-extern int sco_connect_cfm(struct hci_conn *hcon, __u8 status);
-extern int sco_disconn_cfm(struct hci_conn *hcon, __u8 reason);
-extern int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
-
 /* ----- Inquiry cache ----- */
 #define INQUIRY_CACHE_AGE_MAX   (HZ*30)   /* 30 seconds */
-#define INQUIRY_ENTRY_AGE_MAX   (HZ*60)   /* 60 seconds */
+#define INQUIRY_ENTRY_AGE_MAX   (HZ*60*60)   /* 1 Hour */
+
+#define inquiry_cache_lock(c)		spin_lock(&c->lock)
+#define inquiry_cache_unlock(c)		spin_unlock(&c->lock)
+#define inquiry_cache_lock_bh(c)	spin_lock_bh(&c->lock)
+#define inquiry_cache_unlock_bh(c)	spin_unlock_bh(&c->lock)
 
 static inline void inquiry_cache_init(struct hci_dev *hdev)
 {
 	struct inquiry_cache *c = &hdev->inq_cache;
+	spin_lock_init(&c->lock);
 	c->list = NULL;
 }
 
@@ -371,34 +414,31 @@ static inline long inquiry_entry_age(struct inquiry_entry *e)
 	return jiffies - e->timestamp;
 }
 
-struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev,
-							bdaddr_t *bdaddr);
+struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
 void hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data);
 
 /* ----- HCI Connections ----- */
 enum {
 	HCI_CONN_AUTH_PEND,
-	HCI_CONN_REAUTH_PEND,
 	HCI_CONN_ENCRYPT_PEND,
 	HCI_CONN_RSWITCH_PEND,
 	HCI_CONN_MODE_CHANGE_PEND,
 	HCI_CONN_SCO_SETUP_PEND,
-	HCI_CONN_LE_SMP_PEND,
 };
 
 static inline void hci_conn_hash_init(struct hci_dev *hdev)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
 	INIT_LIST_HEAD(&h->list);
+	spin_lock_init(&h->lock);
 	h->acl_num = 0;
 	h->sco_num = 0;
-	h->le_num = 0;
 }
 
 static inline void hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	list_add_rcu(&c->list, &h->list);
+	list_add(&c->list, &h->list);
 	switch (c->type) {
 	case ACL_LINK:
 		h->acl_num++;
@@ -416,10 +456,7 @@ static inline void hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)
 static inline void hci_conn_hash_del(struct hci_dev *hdev, struct hci_conn *c)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-
-	list_del_rcu(&c->list);
-	synchronize_rcu();
-
+	list_del(&c->list);
 	switch (c->type) {
 	case ACL_LINK:
 		h->acl_num--;
@@ -434,58 +471,55 @@ static inline void hci_conn_hash_del(struct hci_dev *hdev, struct hci_conn *c)
 	}
 }
 
-static inline unsigned int hci_conn_num(struct hci_dev *hdev, __u8 type)
-{
-	struct hci_conn_hash *h = &hdev->conn_hash;
-	switch (type) {
-	case ACL_LINK:
-		return h->acl_num;
-	case LE_LINK:
-		return h->le_num;
-	case SCO_LINK:
-	case ESCO_LINK:
-		return h->sco_num;
-	default:
-		return 0;
-	}
-}
-
 static inline struct hci_conn *hci_conn_hash_lookup_handle(struct hci_dev *hdev,
 								__u16 handle)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct list_head *p;
 	struct hci_conn  *c;
 
-	rcu_read_lock();
-
-	list_for_each_entry_rcu(c, &h->list, list) {
-		if (c->handle == handle) {
-			rcu_read_unlock();
+	list_for_each(p, &h->list) {
+		c = list_entry(p, struct hci_conn, list);
+		if (c->handle == handle)
 			return c;
-		}
 	}
-	rcu_read_unlock();
-
 	return NULL;
 }
 
+static inline void hci_chan_list_init(struct hci_dev *hdev)
+{
+	struct hci_chan_list *h = &hdev->chan_list;
+	INIT_LIST_HEAD(&h->list);
+	spin_lock_init(&h->lock);
+}
+
 static inline struct hci_conn *hci_conn_hash_lookup_ba(struct hci_dev *hdev,
 							__u8 type, bdaddr_t *ba)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct list_head *p;
 	struct hci_conn  *c;
 
-	rcu_read_lock();
-
-	list_for_each_entry_rcu(c, &h->list, list) {
-		if (c->type == type && !bacmp(&c->dst, ba)) {
-			rcu_read_unlock();
+	list_for_each(p, &h->list) {
+		c = list_entry(p, struct hci_conn, list);
+		if (c->type == type && !bacmp(&c->dst, ba))
 			return c;
-		}
 	}
+	return NULL;
+}
 
-	rcu_read_unlock();
+static inline struct hci_conn *hci_conn_hash_lookup_id(struct hci_dev *hdev,
+					bdaddr_t *ba, __u8 id)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct list_head *p;
+	struct hci_conn  *c;
 
+	list_for_each(p, &h->list) {
+		c = list_entry(p, struct hci_conn, list);
+		if (!bacmp(&c->dst, ba) && (c->dst_id == id))
+			return c;
+	}
 	return NULL;
 }
 
@@ -493,19 +527,44 @@ static inline struct hci_conn *hci_conn_hash_lookup_state(struct hci_dev *hdev,
 							__u8 type, __u16 state)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct list_head *p;
 	struct hci_conn  *c;
 
-	rcu_read_lock();
+	list_for_each(p, &h->list) {
+		c = list_entry(p, struct hci_conn, list);
+		if (c->type == type && c->state == state)
+			return c;
+	}
+	return NULL;
+}
+
+static inline struct hci_chan *hci_chan_list_lookup_handle(struct hci_dev *hdev,
+					__u16 handle)
+{
+	struct hci_chan_list *l = &hdev->chan_list;
+	struct list_head *p;
+	struct hci_chan  *c;
 
-	list_for_each_entry_rcu(c, &h->list, list) {
-		if (c->type == type && c->state == state) {
-			rcu_read_unlock();
+	list_for_each(p, &l->list) {
+		c = list_entry(p, struct hci_chan, list);
+		if (c->ll_handle == handle)
 			return c;
-		}
 	}
+	return NULL;
+}
 
-	rcu_read_unlock();
+static inline struct hci_chan *hci_chan_list_lookup_id(struct hci_dev *hdev,
+					__u8 handle)
+{
+	struct hci_chan_list *l = &hdev->chan_list;
+	struct list_head *p;
+	struct hci_chan  *c;
 
+	list_for_each(p, &l->list) {
+		c = list_entry(p, struct hci_chan, list);
+		if (c->conn->handle == handle)
+			return c;
+	}
 	return NULL;
 }
 
@@ -517,32 +576,58 @@ void hci_sco_setup(struct hci_conn *conn, __u8 status);
 
 struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
 					__u16 pkt_type, bdaddr_t *dst);
+struct hci_conn *hci_le_conn_add(struct hci_dev *hdev, bdaddr_t *dst,
+							__u8 addr_type);
 int hci_conn_del(struct hci_conn *conn);
-void hci_conn_hash_flush(struct hci_dev *hdev);
+void hci_conn_hash_flush(struct hci_dev *hdev, u8 is_process);
 void hci_conn_check_pending(struct hci_dev *hdev);
 
-struct hci_chan *hci_chan_create(struct hci_conn *conn);
+struct hci_chan *hci_chan_add(struct hci_dev *hdev);
 int hci_chan_del(struct hci_chan *chan);
-void hci_chan_list_flush(struct hci_conn *conn);
+static inline void hci_chan_hold(struct hci_chan *chan)
+{
+	atomic_inc(&chan->refcnt);
+}
+int hci_chan_put(struct hci_chan *chan);
+
+struct hci_chan *hci_chan_create(struct hci_chan *chan,
+				struct hci_ext_fs *tx_fs,
+				struct hci_ext_fs *rx_fs);
+void hci_chan_modify(struct hci_chan *chan,
+				struct hci_ext_fs *tx_fs,
+				struct hci_ext_fs *rx_fs);
 
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
 					__u16 pkt_type, bdaddr_t *dst,
 					__u8 sec_level, __u8 auth_type);
+struct hci_conn *hci_le_connect(struct hci_dev *hdev, __u16 pkt_type,
+					bdaddr_t *dst, __u8 sec_level,
+					__u8 auth_type,
+					struct bt_le_params *le_params);
+void hci_le_add_dev_white_list(struct hci_dev *hdev, bdaddr_t *dst);
+void hci_le_remove_dev_white_list(struct hci_dev *hdev, bdaddr_t *dst);
+void hci_le_cancel_create_connect(struct hci_dev *hdev, bdaddr_t *dst);
 int hci_conn_check_link_mode(struct hci_conn *conn);
-int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);
 int hci_conn_change_link_key(struct hci_conn *conn);
 int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
+void hci_disconnect(struct hci_conn *conn, __u8 reason);
+void hci_disconnect_amp(struct hci_conn *conn, __u8 reason);
 
 void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active);
+void hci_conn_enter_sniff_mode(struct hci_conn *conn);
 
 void hci_conn_hold_device(struct hci_conn *conn);
 void hci_conn_put_device(struct hci_conn *conn);
 
+void hci_conn_set_rssi_reporter(struct hci_conn *conn,
+		s8 rssi_threshold, u16 interval, u8 updateOnThreshExceed);
+void hci_conn_unset_rssi_reporter(struct hci_conn *conn);
+
 static inline void hci_conn_hold(struct hci_conn *conn)
 {
 	atomic_inc(&conn->refcnt);
-	cancel_delayed_work(&conn->disc_work);
+	del_timer(&conn->disc_timer);
 }
 
 static inline void hci_conn_put(struct hci_conn *conn)
@@ -554,16 +639,12 @@ static inline void hci_conn_put(struct hci_conn *conn)
 			if (conn->state == BT_CONNECTED) {
 				timeo = msecs_to_jiffies(conn->disc_timeout);
 				if (!conn->out)
-					timeo *= 20;
-			} else {
+					timeo *= 4;
+			} else
 				timeo = msecs_to_jiffies(10);
-			}
-		} else {
+		} else
 			timeo = msecs_to_jiffies(10);
-		}
-		cancel_delayed_work(&conn->disc_work);
-		queue_delayed_work(conn->hdev->workqueue,
-					&conn->disc_work, timeo);
+		mod_timer(&conn->disc_timer, jiffies + timeo);
 	}
 }
 
@@ -574,15 +655,11 @@ static inline void __hci_dev_put(struct hci_dev *d)
 		d->destruct(d);
 }
 
-/*
- * hci_dev_put and hci_dev_hold are macros to avoid dragging all the
- * overhead of all the modular infrastructure into this header.
- */
-#define hci_dev_put(d)		\
-do {				\
-	__hci_dev_put(d);	\
-	module_put(d->owner);	\
-} while (0)
+static inline void hci_dev_put(struct hci_dev *d)
+{
+	__hci_dev_put(d);
+	module_put(d->owner);
+}
 
 static inline struct hci_dev *__hci_dev_hold(struct hci_dev *d)
 {
@@ -590,21 +667,26 @@ static inline struct hci_dev *__hci_dev_hold(struct hci_dev *d)
 	return d;
 }
 
-#define hci_dev_hold(d)						\
-({								\
-	try_module_get(d->owner) ? __hci_dev_hold(d) : NULL;	\
-})
+static inline struct hci_dev *hci_dev_hold(struct hci_dev *d)
+{
+	if (try_module_get(d->owner))
+		return __hci_dev_hold(d);
+	return NULL;
+}
 
-#define hci_dev_lock(d)		mutex_lock(&d->lock)
-#define hci_dev_unlock(d)	mutex_unlock(&d->lock)
+#define hci_dev_lock(d)		spin_lock(&d->lock)
+#define hci_dev_unlock(d)	spin_unlock(&d->lock)
+#define hci_dev_lock_bh(d)	spin_lock_bh(&d->lock)
+#define hci_dev_unlock_bh(d)	spin_unlock_bh(&d->lock)
 
 struct hci_dev *hci_dev_get(int index);
 struct hci_dev *hci_get_route(bdaddr_t *src, bdaddr_t *dst);
+struct hci_dev *hci_dev_get_type(__u8 amp_type);
 
 struct hci_dev *hci_alloc_dev(void);
 void hci_free_dev(struct hci_dev *hdev);
 int hci_register_dev(struct hci_dev *hdev);
-void hci_unregister_dev(struct hci_dev *hdev);
+int hci_unregister_dev(struct hci_dev *hdev);
 int hci_suspend_dev(struct hci_dev *hdev);
 int hci_resume_dev(struct hci_dev *hdev);
 int hci_dev_open(__u16 dev);
@@ -617,24 +699,23 @@ int hci_get_dev_info(void __user *arg);
 int hci_get_conn_list(void __user *arg);
 int hci_get_conn_info(struct hci_dev *hdev, void __user *arg);
 int hci_get_auth_info(struct hci_dev *hdev, void __user *arg);
+int hci_set_auth_info(struct hci_dev *hdev, void __user *arg);
 int hci_inquiry(void __user *arg);
 
 struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_blacklist_clear(struct hci_dev *hdev);
-int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr);
-int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 int hci_uuids_clear(struct hci_dev *hdev);
 
 int hci_link_keys_clear(struct hci_dev *hdev);
 struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
-int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
-			bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len);
+int hci_add_link_key(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
+						u8 *key, u8 type, u8 pin_len);
 struct link_key *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8]);
 struct link_key *hci_find_link_key_type(struct hci_dev *hdev,
 					bdaddr_t *bdaddr, u8 type);
-int hci_add_ltk(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
-			u8 key_size, __le16 ediv, u8 rand[8], u8 ltk[16]);
+int hci_add_ltk(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr, u8 type,
+		u8 auth, u8 key_size, __le16 ediv, u8 rand[8], u8 ltk[16]);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 int hci_remote_oob_data_clear(struct hci_dev *hdev);
@@ -658,9 +739,8 @@ int hci_recv_frame(struct sk_buff *skb);
 int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count);
 int hci_recv_stream_fragment(struct hci_dev *hdev, void *data, int count);
 
-void hci_init_sysfs(struct hci_dev *hdev);
-int hci_add_sysfs(struct hci_dev *hdev);
-void hci_del_sysfs(struct hci_dev *hdev);
+int hci_register_sysfs(struct hci_dev *hdev);
+void hci_unregister_sysfs(struct hci_dev *hdev);
 void hci_conn_init_sysfs(struct hci_conn *conn);
 void hci_conn_add_sysfs(struct hci_conn *conn);
 void hci_conn_del_sysfs(struct hci_conn *conn);
@@ -677,44 +757,54 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_no_flush_capable(dev)  ((dev)->features[6] & LMP_NO_FLUSH)
 #define lmp_le_capable(dev)        ((dev)->features[4] & LMP_LE)
 
-/* ----- Extended LMP capabilities ----- */
-#define lmp_host_le_capable(dev)   ((dev)->host_features[0] & LMP_HOST_LE)
-
 /* ----- HCI protocols ----- */
-static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								__u8 type)
+struct hci_proto {
+	char		*name;
+	unsigned int	id;
+	unsigned long	flags;
+
+	void		*priv;
+
+	int (*connect_ind)	(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type);
+	int (*connect_cfm)	(struct hci_conn *conn, __u8 status);
+	int (*disconn_ind)	(struct hci_conn *conn);
+	int (*disconn_cfm)	(struct hci_conn *conn, __u8 reason,
+							__u8 is_process);
+	int (*recv_acldata)	(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
+	int (*recv_scodata)	(struct hci_conn *conn, struct sk_buff *skb);
+	int (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
+	int (*create_cfm)	(struct hci_chan *chan, __u8 status);
+	int (*modify_cfm)	(struct hci_chan *chan, __u8 status);
+	int (*destroy_cfm)	(struct hci_chan *chan, __u8 status);
+};
+
+static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)
 {
-	switch (type) {
-	case ACL_LINK:
-		return l2cap_connect_ind(hdev, bdaddr);
+	register struct hci_proto *hp;
+	int mask = 0;
 
-	case SCO_LINK:
-	case ESCO_LINK:
-		return sco_connect_ind(hdev, bdaddr);
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->connect_ind)
+		mask |= hp->connect_ind(hdev, bdaddr, type);
 
-	default:
-		BT_ERR("unknown link type %d", type);
-		return -EINVAL;
-	}
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->connect_ind)
+		mask |= hp->connect_ind(hdev, bdaddr, type);
+
+	return mask;
 }
 
 static inline void hci_proto_connect_cfm(struct hci_conn *conn, __u8 status)
 {
-	switch (conn->type) {
-	case ACL_LINK:
-	case LE_LINK:
-		l2cap_connect_cfm(conn, status);
-		break;
+	register struct hci_proto *hp;
 
-	case SCO_LINK:
-	case ESCO_LINK:
-		sco_connect_cfm(conn, status);
-		break;
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->connect_cfm)
+		hp->connect_cfm(conn, status);
 
-	default:
-		BT_ERR("unknown link type %d", conn->type);
-		break;
-	}
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->connect_cfm)
+		hp->connect_cfm(conn, status);
 
 	if (conn->connect_cfm_cb)
 		conn->connect_cfm_cb(conn, status);
@@ -722,29 +812,32 @@ static inline void hci_proto_connect_cfm(struct hci_conn *conn, __u8 status)
 
 static inline int hci_proto_disconn_ind(struct hci_conn *conn)
 {
-	if (conn->type != ACL_LINK && conn->type != LE_LINK)
-		return HCI_ERROR_REMOTE_USER_TERM;
+	register struct hci_proto *hp;
+	int reason = 0x13;
 
-	return l2cap_disconn_ind(conn);
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->disconn_ind)
+		reason = hp->disconn_ind(conn);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->disconn_ind)
+		reason = hp->disconn_ind(conn);
+
+	return reason;
 }
 
-static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason)
+static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason,
+							__u8 is_process)
 {
-	switch (conn->type) {
-	case ACL_LINK:
-	case LE_LINK:
-		l2cap_disconn_cfm(conn, reason);
-		break;
+	register struct hci_proto *hp;
 
-	case SCO_LINK:
-	case ESCO_LINK:
-		sco_disconn_cfm(conn, reason);
-		break;
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->disconn_cfm)
+		hp->disconn_cfm(conn, reason, is_process);
 
-	default:
-		BT_ERR("unknown link type %d", conn->type);
-		break;
-	}
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->disconn_cfm)
+		hp->disconn_cfm(conn, reason, is_process);
 
 	if (conn->disconn_cfm_cb)
 		conn->disconn_cfm_cb(conn, reason);
@@ -752,41 +845,79 @@ static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason)
 
 static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
 {
+	register struct hci_proto *hp;
 	__u8 encrypt;
 
-	if (conn->type != ACL_LINK && conn->type != LE_LINK)
-		return;
-
 	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
 		return;
 
 	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
-	l2cap_security_cfm(conn, status, encrypt);
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->security_cfm)
+		hp->security_cfm(conn, status, encrypt);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->security_cfm)
+		hp->security_cfm(conn, status, encrypt);
 
 	if (conn->security_cfm_cb)
 		conn->security_cfm_cb(conn, status);
 }
 
-static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status,
-								__u8 encrypt)
+static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
 {
-	if (conn->type != ACL_LINK && conn->type != LE_LINK)
-		return;
+	register struct hci_proto *hp;
 
-	l2cap_security_cfm(conn, status, encrypt);
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->security_cfm)
+		hp->security_cfm(conn, status, encrypt);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->security_cfm)
+		hp->security_cfm(conn, status, encrypt);
 
 	if (conn->security_cfm_cb)
 		conn->security_cfm_cb(conn, status);
 }
 
+static inline void hci_proto_create_cfm(struct hci_chan *chan, __u8 status)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->create_cfm)
+		hp->create_cfm(chan, status);
+}
+
+static inline void hci_proto_modify_cfm(struct hci_chan *chan, __u8 status)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->modify_cfm)
+		hp->modify_cfm(chan, status);
+}
+
+static inline void hci_proto_destroy_cfm(struct hci_chan *chan, __u8 status)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->destroy_cfm)
+		hp->destroy_cfm(chan, status);
+}
+
+int hci_register_proto(struct hci_proto *hproto);
+int hci_unregister_proto(struct hci_proto *hproto);
+
 /* ----- HCI callbacks ----- */
 struct hci_cb {
 	struct list_head list;
 
 	char *name;
 
-	void (*security_cfm)	(struct hci_conn *conn, __u8 status,
-								__u8 encrypt);
+	void (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
 	void (*key_change_cfm)	(struct hci_conn *conn, __u8 status);
 	void (*role_switch_cfm)	(struct hci_conn *conn, __u8 status, __u8 role);
 };
@@ -803,62 +934,60 @@ static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 
 	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
 
-	read_lock(&hci_cb_list_lock);
+	read_lock_bh(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->security_cfm)
 			cb->security_cfm(conn, status, encrypt);
 	}
-	read_unlock(&hci_cb_list_lock);
+	read_unlock_bh(&hci_cb_list_lock);
 }
 
-static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
-								__u8 encrypt)
+static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
 {
 	struct list_head *p;
 
 	if (conn->sec_level == BT_SECURITY_SDP)
 		conn->sec_level = BT_SECURITY_LOW;
 
-	if (conn->pending_sec_level > conn->sec_level)
+	if (!status && encrypt && conn->pending_sec_level > conn->sec_level)
 		conn->sec_level = conn->pending_sec_level;
 
 	hci_proto_encrypt_cfm(conn, status, encrypt);
 
-	read_lock(&hci_cb_list_lock);
+	read_lock_bh(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->security_cfm)
 			cb->security_cfm(conn, status, encrypt);
 	}
-	read_unlock(&hci_cb_list_lock);
+	read_unlock_bh(&hci_cb_list_lock);
 }
 
 static inline void hci_key_change_cfm(struct hci_conn *conn, __u8 status)
 {
 	struct list_head *p;
 
-	read_lock(&hci_cb_list_lock);
+	read_lock_bh(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->key_change_cfm)
 			cb->key_change_cfm(conn, status);
 	}
-	read_unlock(&hci_cb_list_lock);
+	read_unlock_bh(&hci_cb_list_lock);
 }
 
-static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,
-								__u8 role)
+static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status, __u8 role)
 {
 	struct list_head *p;
 
-	read_lock(&hci_cb_list_lock);
+	read_lock_bh(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->role_switch_cfm)
 			cb->role_switch_cfm(conn, status, role);
 	}
-	read_unlock(&hci_cb_list_lock);
+	read_unlock_bh(&hci_cb_list_lock);
 }
 
 int hci_register_cb(struct hci_cb *hcb);
@@ -867,8 +996,29 @@ int hci_unregister_cb(struct hci_cb *hcb);
 int hci_register_notifier(struct notifier_block *nb);
 int hci_unregister_notifier(struct notifier_block *nb);
 
+/* AMP Manager event callbacks */
+struct amp_mgr_cb {
+	struct list_head list;
+	void (*amp_cmd_complete_event) (struct hci_dev *hdev, __u16 opcode,
+					struct sk_buff *skb);
+	void (*amp_cmd_status_event) (struct hci_dev *hdev, __u16 opcode,
+					__u8 status);
+	void (*amp_event) (struct hci_dev *hdev, __u8 ev_code,
+					struct sk_buff *skb);
+};
+
+void hci_amp_cmd_complete(struct hci_dev *hdev, __u16 opcode,
+			struct sk_buff *skb);
+void hci_amp_cmd_status(struct hci_dev *hdev, __u16 opcode, __u8 status);
+void hci_amp_event_packet(struct hci_dev *hdev, __u8 ev_code,
+			struct sk_buff *skb);
+
+int hci_register_amp(struct amp_mgr_cb *acb);
+int hci_unregister_amp(struct amp_mgr_cb *acb);
+
 int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
-void hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags);
+void hci_send_acl(struct hci_conn *conn, struct hci_chan *chan,
+		struct sk_buff *skb, __u16 flags);
 void hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);
 
 void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
@@ -881,63 +1031,58 @@ void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb,
 
 /* Management interface */
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
-int mgmt_index_added(struct hci_dev *hdev);
-int mgmt_index_removed(struct hci_dev *hdev);
-int mgmt_powered(struct hci_dev *hdev, u8 powered);
-int mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
-int mgmt_connectable(struct hci_dev *hdev, u8 connectable);
-int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
-int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
-								u8 persistent);
-int mgmt_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-								u8 addr_type);
-int mgmt_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-								u8 addr_type);
-int mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 status);
-int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-						u8 addr_type, u8 status);
-int mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure);
-int mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								u8 status);
-int mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+int mgmt_index_added(u16 index);
+int mgmt_index_removed(u16 index);
+int mgmt_powered(u16 index, u8 powered);
+int mgmt_discoverable(u16 index, u8 discoverable);
+int mgmt_connectable(u16 index, u8 connectable);
+int mgmt_new_key(u16 index, struct link_key *key, u8 bonded);
+int mgmt_connected(u16 index, bdaddr_t *bdaddr, u8 le);
+int mgmt_le_conn_params(u16 index, bdaddr_t *bdaddr, u16 interval,
+						u16 latency, u16 timeout);
+int mgmt_disconnected(u16 index, bdaddr_t *bdaddr, u8 reason);
+int mgmt_disconnect_failed(u16 index);
+int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 status);
+int mgmt_pin_code_request(u16 index, bdaddr_t *bdaddr);
+int mgmt_pin_code_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
+int mgmt_pin_code_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
+int mgmt_user_confirm_request(u16 index, u8 event, bdaddr_t *bdaddr,
+							__le32 value);
+int mgmt_user_oob_request(u16 index, bdaddr_t *bdaddr);
+int mgmt_user_confirm_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
+int mgmt_user_confirm_neg_reply_complete(u16 index, bdaddr_t *bdaddr,
 								u8 status);
-int mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
-						__le32 value, u8 confirm_hint);
-int mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+int mgmt_auth_failed(u16 index, bdaddr_t *bdaddr, u8 status);
+int mgmt_set_local_name_complete(u16 index, u8 *name, u8 status);
+int mgmt_read_local_oob_data_reply_complete(u16 index, u8 *hash, u8 *randomizer,
 								u8 status);
-int mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev,
-						bdaddr_t *bdaddr, u8 status);
-int mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr);
-int mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								u8 status);
-int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev,
-						bdaddr_t *bdaddr, u8 status);
-int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 status);
-int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
-int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
-						u8 *randomizer, u8 status);
-int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-				u8 addr_type, u8 *dev_class, s8 rssi, u8 *eir);
-int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *name);
-int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status);
-int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status);
-int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
-int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr);
-int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr);
+int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 type, u8 le,
+				u8 *dev_class, s8 rssi, u8 eir_len, u8 *eir);
+void mgmt_read_rssi_complete(u16 index, s8 rssi, bdaddr_t *bdaddr,
+				u16 handle, u8 status);
+int mgmt_remote_name(u16 index, bdaddr_t *bdaddr, u8 status, u8 *name);
+void mgmt_inquiry_started(u16 index);
+void mgmt_inquiry_complete_evt(u16 index, u8 status);
+void mgmt_disco_timeout(unsigned long data);
+void mgmt_disco_le_timeout(unsigned long data);
+int mgmt_encrypt_change(u16 index, bdaddr_t *bdaddr, u8 status);
+
+/* LE SMP Management interface */
+int le_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, void *cp);
+int mgmt_remote_class(u16 index, bdaddr_t *bdaddr, u8 dev_class[3]);
+int mgmt_remote_version(u16 index, bdaddr_t *bdaddr, u8 ver, u16 mnf,
+							u16 sub_ver);
+int mgmt_remote_features(u16 index, bdaddr_t *bdaddr, u8 features[8]);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)
 
-/* HCI socket flags */
-#define HCI_PI_MGMT_INIT	0
-
 struct hci_pinfo {
 	struct bt_sock    bt;
 	struct hci_dev    *hdev;
 	struct hci_filter filter;
 	__u32             cmsg_mask;
 	unsigned short   channel;
-	unsigned long     flags;
 };
 
 /* HCI security filter */
@@ -966,7 +1111,6 @@ void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16]);
 void hci_le_ltk_neg_reply(struct hci_conn *conn);
 
-int hci_do_inquiry(struct hci_dev *hdev, u8 length);
-int hci_cancel_inquiry(struct hci_dev *hdev);
+void hci_read_rssi(struct hci_conn *conn);
 
 #endif /* __HCI_CORE_H */
diff --git a/include/net/bluetooth/l2cap.h b/include/net/bluetooth/l2cap.h
old mode 100755
new mode 100644
index 554acce..9c2b735
--- a/include/net/bluetooth/l2cap.h
+++ b/include/net/bluetooth/l2cap.h
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (C) 2000-2001 Qualcomm Incorporated
+   Copyright (c) 2000-2001, 2010-2012 The Linux Foundation.  All rights reserved.
    Copyright (C) 2009-2010 Gustavo F. Padovan <gustavo@padovan.org>
    Copyright (C) 2010 Google Inc.
 
@@ -27,29 +27,32 @@
 #ifndef __L2CAP_H
 #define __L2CAP_H
 
-#include <asm/unaligned.h>
-
 /* L2CAP defaults */
 #define L2CAP_DEFAULT_MTU		672
 #define L2CAP_DEFAULT_MIN_MTU		48
+#define L2CAP_DEFAULT_MAX_SDU_SIZE	0xffff
 #define L2CAP_DEFAULT_FLUSH_TO		0xffff
+#define L2CAP_MAX_FLUSH_TO		0x7ff
 #define L2CAP_DEFAULT_TX_WINDOW		63
-#define L2CAP_DEFAULT_EXT_WINDOW	0x3FFF
 #define L2CAP_DEFAULT_MAX_TX		3
 #define L2CAP_DEFAULT_RETRANS_TO	2000    /* 2 seconds */
 #define L2CAP_DEFAULT_MONITOR_TO	12000   /* 12 seconds */
-#define L2CAP_DEFAULT_MAX_PDU_SIZE	1009    /* Sized for 3-DH5 packet */
+#define L2CAP_DEFAULT_MAX_PDU_SIZE	1482    /* Sized for AMP or BR/EDR */
 #define L2CAP_DEFAULT_ACK_TO		200
+#define L2CAP_BREDR_MAX_PAYLOAD		1019    /* 3-DH5 packet */
+#define L2CAP_MAX_ERTM_QUEUED		5
+#define L2CAP_MIN_ERTM_QUEUED		2
+
+#define L2CAP_A2MP_DEFAULT_MTU		670
+
+#define L2CAP_TX_WIN_MAX_ENHANCED	0x3f
+#define L2CAP_TX_WIN_MAX_EXTENDED	0x3fff
 #define L2CAP_LE_DEFAULT_MTU		23
-#define L2CAP_DEFAULT_MAX_SDU_SIZE	0xFFFF
-#define L2CAP_DEFAULT_SDU_ITIME		0xFFFFFFFF
-#define L2CAP_DEFAULT_ACC_LAT		0xFFFFFFFF
 
-#define L2CAP_DISC_TIMEOUT             (100)
-#define L2CAP_DISC_REJ_TIMEOUT         (5000)  /*  5 seconds */
-#define L2CAP_ENC_TIMEOUT              (5000)  /*  5 seconds */
-#define L2CAP_CONN_TIMEOUT             (40000) /* 40 seconds */
-#define L2CAP_INFO_TIMEOUT             (4000)  /*  4 seconds */
+#define L2CAP_CONN_TIMEOUT	(40000) /* 40 seconds */
+#define L2CAP_INFO_TIMEOUT	(4000)  /*  4 seconds */
+#define L2CAP_MOVE_TIMEOUT		(4*HZ)  /*  4 seconds */
+#define L2CAP_MOVE_ERTX_TIMEOUT		(60*HZ) /* 60 seconds */
 
 /* L2CAP socket address */
 struct sockaddr_l2 {
@@ -84,36 +87,35 @@ struct l2cap_conninfo {
 #define L2CAP_LM_TRUSTED	0x0008
 #define L2CAP_LM_RELIABLE	0x0010
 #define L2CAP_LM_SECURE		0x0020
+#define L2CAP_LM_FLUSHABLE	0x0040
 
 /* L2CAP command codes */
-#define L2CAP_COMMAND_REJ	0x01
-#define L2CAP_CONN_REQ		0x02
-#define L2CAP_CONN_RSP		0x03
-#define L2CAP_CONF_REQ		0x04
-#define L2CAP_CONF_RSP		0x05
-#define L2CAP_DISCONN_REQ	0x06
-#define L2CAP_DISCONN_RSP	0x07
-#define L2CAP_ECHO_REQ		0x08
-#define L2CAP_ECHO_RSP		0x09
-#define L2CAP_INFO_REQ		0x0a
-#define L2CAP_INFO_RSP		0x0b
+#define L2CAP_COMMAND_REJ		0x01
+#define L2CAP_CONN_REQ			0x02
+#define L2CAP_CONN_RSP			0x03
+#define L2CAP_CONF_REQ			0x04
+#define L2CAP_CONF_RSP			0x05
+#define L2CAP_DISCONN_REQ		0x06
+#define L2CAP_DISCONN_RSP		0x07
+#define L2CAP_ECHO_REQ			0x08
+#define L2CAP_ECHO_RSP			0x09
+#define L2CAP_INFO_REQ			0x0a
+#define L2CAP_INFO_RSP			0x0b
 #define L2CAP_CREATE_CHAN_REQ	0x0c
 #define L2CAP_CREATE_CHAN_RSP	0x0d
-#define L2CAP_MOVE_CHAN_REQ	0x0e
-#define L2CAP_MOVE_CHAN_RSP	0x0f
-#define L2CAP_MOVE_CHAN_CFM	0x10
+#define L2CAP_MOVE_CHAN_REQ		0x0e
+#define L2CAP_MOVE_CHAN_RSP		0x0f
+#define L2CAP_MOVE_CHAN_CFM		0x10
 #define L2CAP_MOVE_CHAN_CFM_RSP	0x11
 #define L2CAP_CONN_PARAM_UPDATE_REQ	0x12
 #define L2CAP_CONN_PARAM_UPDATE_RSP	0x13
 
-/* L2CAP extended feature mask */
+/* L2CAP feature mask */
 #define L2CAP_FEAT_FLOWCTL	0x00000001
 #define L2CAP_FEAT_RETRANS	0x00000002
-#define L2CAP_FEAT_BIDIR_QOS	0x00000004
 #define L2CAP_FEAT_ERTM		0x00000008
 #define L2CAP_FEAT_STREAMING	0x00000010
 #define L2CAP_FEAT_FCS		0x00000020
-#define L2CAP_FEAT_EXT_FLOW	0x00000040
 #define L2CAP_FEAT_FIXED_CHAN	0x00000080
 #define L2CAP_FEAT_EXT_WINDOW	0x00000100
 #define L2CAP_FEAT_UCD		0x00000200
@@ -126,53 +128,52 @@ struct l2cap_conninfo {
 #define L2CAP_FC_L2CAP		0x02
 #define L2CAP_FC_A2MP		0x08
 
-/* L2CAP Control Field bit masks */
-#define L2CAP_CTRL_SAR			0xC000
-#define L2CAP_CTRL_REQSEQ		0x3F00
-#define L2CAP_CTRL_TXSEQ		0x007E
-#define L2CAP_CTRL_SUPERVISE		0x000C
-
-#define L2CAP_CTRL_RETRANS		0x0080
-#define L2CAP_CTRL_FINAL		0x0080
-#define L2CAP_CTRL_POLL			0x0010
-#define L2CAP_CTRL_FRAME_TYPE		0x0001 /* I- or S-Frame */
-
-#define L2CAP_CTRL_TXSEQ_SHIFT		1
-#define L2CAP_CTRL_SUPER_SHIFT		2
-#define L2CAP_CTRL_REQSEQ_SHIFT		8
-#define L2CAP_CTRL_SAR_SHIFT		14
-
-/* L2CAP Extended Control Field bit mask */
-#define L2CAP_EXT_CTRL_TXSEQ		0xFFFC0000
-#define L2CAP_EXT_CTRL_SAR		0x00030000
-#define L2CAP_EXT_CTRL_SUPERVISE	0x00030000
-#define L2CAP_EXT_CTRL_REQSEQ		0x0000FFFC
-
-#define L2CAP_EXT_CTRL_POLL		0x00040000
-#define L2CAP_EXT_CTRL_FINAL		0x00000002
-#define L2CAP_EXT_CTRL_FRAME_TYPE	0x00000001 /* I- or S-Frame */
-
-#define L2CAP_EXT_CTRL_REQSEQ_SHIFT	2
-#define L2CAP_EXT_CTRL_SAR_SHIFT	16
-#define L2CAP_EXT_CTRL_SUPER_SHIFT	16
-#define L2CAP_EXT_CTRL_TXSEQ_SHIFT	18
-
-/* L2CAP Supervisory Function */
-#define L2CAP_SUPER_RR		0x00
-#define L2CAP_SUPER_REJ		0x01
-#define L2CAP_SUPER_RNR		0x02
-#define L2CAP_SUPER_SREJ	0x03
+/* L2CAP Control Field */
+#define L2CAP_CTRL_SAR               0xC000
+#define L2CAP_CTRL_REQSEQ            0x3F00
+#define L2CAP_CTRL_TXSEQ             0x007E
+#define L2CAP_CTRL_FINAL             0x0080
+#define L2CAP_CTRL_POLL              0x0010
+#define L2CAP_CTRL_SUPERVISE         0x000C
+#define L2CAP_CTRL_FRAME_TYPE        0x0001 /* I- or S-Frame */
+
+#define L2CAP_CTRL_TXSEQ_SHIFT      1
+#define L2CAP_CTRL_SUPERVISE_SHIFT  2
+#define L2CAP_CTRL_POLL_SHIFT       4
+#define L2CAP_CTRL_FINAL_SHIFT      7
+#define L2CAP_CTRL_REQSEQ_SHIFT     8
+#define L2CAP_CTRL_SAR_SHIFT       14
+
+#define L2CAP_EXT_CTRL_SAR           0x00030000
+#define L2CAP_EXT_CTRL_REQSEQ        0x0000FFFC
+#define L2CAP_EXT_CTRL_TXSEQ         0xFFFC0000
+#define L2CAP_EXT_CTRL_FINAL         0x00000002
+#define L2CAP_EXT_CTRL_POLL          0x00040000
+#define L2CAP_EXT_CTRL_SUPERVISE     0x00030000
+#define L2CAP_EXT_CTRL_FRAME_TYPE    0x00000001 /* I- or S-Frame */
+
+#define L2CAP_EXT_CTRL_FINAL_SHIFT      1
+#define L2CAP_EXT_CTRL_REQSEQ_SHIFT     2
+#define L2CAP_EXT_CTRL_SAR_SHIFT       16
+#define L2CAP_EXT_CTRL_SUPERVISE_SHIFT 16
+#define L2CAP_EXT_CTRL_POLL_SHIFT      18
+#define L2CAP_EXT_CTRL_TXSEQ_SHIFT     18
+
+/* L2CAP Supervisory Frame Types */
+#define L2CAP_SFRAME_RR            0x00
+#define L2CAP_SFRAME_REJ           0x01
+#define L2CAP_SFRAME_RNR           0x02
+#define L2CAP_SFRAME_SREJ          0x03
 
 /* L2CAP Segmentation and Reassembly */
-#define L2CAP_SAR_UNSEGMENTED	0x00
-#define L2CAP_SAR_START		0x01
-#define L2CAP_SAR_END		0x02
-#define L2CAP_SAR_CONTINUE	0x03
+#define L2CAP_SAR_UNSEGMENTED      0x00
+#define L2CAP_SAR_START            0x01
+#define L2CAP_SAR_END              0x02
+#define L2CAP_SAR_CONTINUE         0x03
 
-/* L2CAP Command rej. reasons */
-#define L2CAP_REJ_NOT_UNDERSTOOD	0x0000
-#define L2CAP_REJ_MTU_EXCEEDED		0x0001
-#define L2CAP_REJ_INVALID_CID		0x0002
+/* L2CAP ERTM / Streaming extra field lengths */
+#define L2CAP_SDULEN_SIZE       2
+#define L2CAP_FCS_SIZE          2
 
 /* L2CAP structures */
 struct l2cap_hdr {
@@ -180,12 +181,8 @@ struct l2cap_hdr {
 	__le16     cid;
 } __packed;
 #define L2CAP_HDR_SIZE		4
-#define L2CAP_ENH_HDR_SIZE	6
-#define L2CAP_EXT_HDR_SIZE	8
-
-#define L2CAP_FCS_SIZE		2
-#define L2CAP_SDULEN_SIZE	2
-#define L2CAP_PSMLEN_SIZE	2
+#define L2CAP_ENHANCED_HDR_SIZE	6
+#define L2CAP_EXTENDED_HDR_SIZE	8
 
 struct l2cap_cmd_hdr {
 	__u8       code;
@@ -194,19 +191,8 @@ struct l2cap_cmd_hdr {
 } __packed;
 #define L2CAP_CMD_HDR_SIZE	4
 
-struct l2cap_cmd_rej_unk {
-	__le16     reason;
-} __packed;
-
-struct l2cap_cmd_rej_mtu {
+struct l2cap_cmd_rej {
 	__le16     reason;
-	__le16     max_mtu;
-} __packed;
-
-struct l2cap_cmd_rej_cid {
-	__le16     reason;
-	__le16     scid;
-	__le16     dcid;
 } __packed;
 
 struct l2cap_conn_req {
@@ -224,21 +210,21 @@ struct l2cap_conn_rsp {
 /* channel indentifier */
 #define L2CAP_CID_SIGNALING	0x0001
 #define L2CAP_CID_CONN_LESS	0x0002
+#define L2CAP_CID_A2MP		0x0003
 #define L2CAP_CID_LE_DATA	0x0004
 #define L2CAP_CID_LE_SIGNALING	0x0005
 #define L2CAP_CID_SMP		0x0006
 #define L2CAP_CID_DYN_START	0x0040
 #define L2CAP_CID_DYN_END	0xffff
 
-/* connect/create channel results */
+/* connect result */
 #define L2CAP_CR_SUCCESS	0x0000
 #define L2CAP_CR_PEND		0x0001
 #define L2CAP_CR_BAD_PSM	0x0002
 #define L2CAP_CR_SEC_BLOCK	0x0003
 #define L2CAP_CR_NO_MEM		0x0004
-#define L2CAP_CR_BAD_AMP	0x0005
 
-/* connect/create channel status */
+/* connect status */
 #define L2CAP_CS_NO_INFO	0x0000
 #define L2CAP_CS_AUTHEN_PEND	0x0001
 #define L2CAP_CS_AUTHOR_PEND	0x0002
@@ -261,7 +247,7 @@ struct l2cap_conf_rsp {
 #define L2CAP_CONF_REJECT	0x0002
 #define L2CAP_CONF_UNKNOWN	0x0003
 #define L2CAP_CONF_PENDING	0x0004
-#define L2CAP_CONF_EFS_REJECT	0x0005
+#define L2CAP_CONF_FLOW_SPEC_REJECT	0x0005
 
 struct l2cap_conf_opt {
 	__u8       type;
@@ -278,8 +264,13 @@ struct l2cap_conf_opt {
 #define L2CAP_CONF_QOS		0x03
 #define L2CAP_CONF_RFC		0x04
 #define L2CAP_CONF_FCS		0x05
-#define L2CAP_CONF_EFS		0x06
-#define L2CAP_CONF_EWS		0x07
+#define L2CAP_CONF_EXT_FS	0x06
+#define L2CAP_CONF_EXT_WINDOW	0x07
+
+/* QOS Service type */
+#define L2CAP_SERVICE_NO_TRAFFIC		0x00
+#define L2CAP_SERVICE_BEST_EFFORT		0x01
+#define L2CAP_SERVICE_GUARANTEED		0x02
 
 #define L2CAP_CONF_MAX_SIZE	22
 
@@ -292,27 +283,26 @@ struct l2cap_conf_rfc {
 	__le16     max_pdu_size;
 } __packed;
 
+struct l2cap_conf_ext_fs {
+	__u8       id;
+	__u8       type;
+	__le16     max_sdu;
+	__le32     sdu_arr_time;
+	__le32     acc_latency;
+	__le32     flush_to;
+} __packed;
+
+struct l2cap_conf_prm {
+	__u8       fcs;
+	__le32     flush_to;
+};
+
 #define L2CAP_MODE_BASIC	0x00
 #define L2CAP_MODE_RETRANS	0x01
 #define L2CAP_MODE_FLOWCTL	0x02
 #define L2CAP_MODE_ERTM		0x03
 #define L2CAP_MODE_STREAMING	0x04
 
-struct l2cap_conf_efs {
-	__u8	id;
-	__u8	stype;
-	__le16	msdu;
-	__le32	sdu_itime;
-	__le32	acc_lat;
-	__le32	flush_to;
-} __packed;
-
-#define L2CAP_SERV_NOTRAFIC	0x00
-#define L2CAP_SERV_BESTEFFORT	0x01
-#define L2CAP_SERV_GUARANTEED	0x02
-
-#define L2CAP_BESTEFFORT_ID	0x01
-
 struct l2cap_disconn_req {
 	__le16     dcid;
 	__le16     scid;
@@ -337,53 +327,83 @@ struct l2cap_create_chan_req {
 	__le16      psm;
 	__le16      scid;
 	__u8        amp_id;
-} __packed;
+} __attribute__ ((packed));
 
 struct l2cap_create_chan_rsp {
 	__le16      dcid;
 	__le16      scid;
 	__le16      result;
 	__le16      status;
-} __packed;
+} __attribute__ ((packed));
+
+#define L2CAP_CREATE_CHAN_SUCCESS				(0x0000)
+#define L2CAP_CREATE_CHAN_PENDING				(0x0001)
+#define L2CAP_CREATE_CHAN_REFUSED_PSM			(0x0002)
+#define L2CAP_CREATE_CHAN_REFUSED_SECURITY		(0x0003)
+#define L2CAP_CREATE_CHAN_REFUSED_RESOURCES		(0x0004)
+#define L2CAP_CREATE_CHAN_REFUSED_CONTROLLER	(0x0005)
+
+#define L2CAP_CREATE_CHAN_STATUS_NONE			(0x0000)
+#define L2CAP_CREATE_CHAN_STATUS_AUTHENTICATION	(0x0001)
+#define L2CAP_CREATE_CHAN_STATUS_AUTHORIZATION	(0x0002)
 
 struct l2cap_move_chan_req {
 	__le16      icid;
 	__u8        dest_amp_id;
-} __packed;
+} __attribute__ ((packed));
 
 struct l2cap_move_chan_rsp {
 	__le16      icid;
 	__le16      result;
-} __packed;
+} __attribute__ ((packed));
 
-#define L2CAP_MR_SUCCESS	0x0000
-#define L2CAP_MR_PEND		0x0001
-#define L2CAP_MR_BAD_ID		0x0002
-#define L2CAP_MR_SAME_ID	0x0003
-#define L2CAP_MR_NOT_SUPP	0x0004
-#define L2CAP_MR_COLLISION	0x0005
-#define L2CAP_MR_NOT_ALLOWED	0x0006
+#define L2CAP_MOVE_CHAN_SUCCESS				(0x0000)
+#define L2CAP_MOVE_CHAN_PENDING				(0x0001)
+#define L2CAP_MOVE_CHAN_REFUSED_CONTROLLER	(0x0002)
+#define L2CAP_MOVE_CHAN_REFUSED_SAME_ID		(0x0003)
+#define L2CAP_MOVE_CHAN_REFUSED_CONFIG		(0x0004)
+#define L2CAP_MOVE_CHAN_REFUSED_COLLISION	(0x0005)
+#define L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED	(0x0006)
 
 struct l2cap_move_chan_cfm {
 	__le16      icid;
 	__le16      result;
-} __packed;
+} __attribute__ ((packed));
 
-#define L2CAP_MC_CONFIRMED	0x0000
-#define L2CAP_MC_UNCONFIRMED	0x0001
+#define L2CAP_MOVE_CHAN_CONFIRMED	(0x0000)
+#define L2CAP_MOVE_CHAN_UNCONFIRMED	(0x0001)
 
 struct l2cap_move_chan_cfm_rsp {
 	__le16      icid;
-} __packed;
+} __attribute__ ((packed));
+
+struct l2cap_amp_signal_work {
+	struct work_struct work;
+	struct l2cap_cmd_hdr cmd;
+	struct l2cap_conn *conn;
+	struct sk_buff *skb;
+	u8 *data;
+};
+
+struct l2cap_resegment_work {
+	struct work_struct work;
+	struct sock *sk;
+};
+
+struct l2cap_logical_link_work {
+	struct work_struct work;
+	struct hci_chan *chan;
+	u8 status;
+};
 
 /* info type */
-#define L2CAP_IT_CL_MTU		0x0001
-#define L2CAP_IT_FEAT_MASK	0x0002
-#define L2CAP_IT_FIXED_CHAN	0x0003
+#define L2CAP_IT_CL_MTU     0x0001
+#define L2CAP_IT_FEAT_MASK  0x0002
+#define L2CAP_IT_FIXED_CHAN 0x0003
 
 /* info result */
-#define L2CAP_IR_SUCCESS	0x0000
-#define L2CAP_IR_NOTSUPP	0x0001
+#define L2CAP_IR_SUCCESS    0x0000
+#define L2CAP_IR_NOTSUPP    0x0001
 
 struct l2cap_conn_param_update_req {
 	__le16      min;
@@ -400,21 +420,64 @@ struct l2cap_conn_param_update_rsp {
 #define L2CAP_CONN_PARAM_ACCEPTED	0x0000
 #define L2CAP_CONN_PARAM_REJECTED	0x0001
 
-/* ----- L2CAP channels and connections ----- */
-struct srej_list {
-	__u16	tx_seq;
-	struct list_head list;
+/* ----- L2CAP connections ----- */
+struct l2cap_chan_list {
+	struct sock	*head;
+	rwlock_t	lock;
 };
 
-struct l2cap_chan {
-	struct sock *sk;
+struct l2cap_conn {
+	struct hci_conn	*hcon;
 
-	struct l2cap_conn	*conn;
+	bdaddr_t	*dst;
+	bdaddr_t	*src;
 
-	__u8		state;
+	unsigned int	mtu;
 
-	atomic_t	refcnt;
+	__u32		feat_mask;
+	__u8		fc_mask;
+	struct amp_mgr *mgr;
 
+	__u8		info_state;
+	__u8		info_ident;
+
+	struct timer_list info_timer;
+
+	spinlock_t	lock;
+
+	struct sk_buff *rx_skb;
+	__u32		rx_len;
+	__u8		tx_ident;
+
+	__u8		disc_reason;
+
+	struct l2cap_chan_list chan_list;
+};
+
+struct sock_del_list {
+	struct sock *sk;
+	struct list_head list;
+};
+
+#define L2CAP_INFO_CL_MTU_REQ_SENT	0x01
+#define L2CAP_INFO_FEAT_MASK_REQ_SENT	0x04
+#define L2CAP_INFO_FEAT_MASK_REQ_DONE	0x08
+
+/* ----- L2CAP channel and socket info ----- */
+#define l2cap_pi(sk) ((struct l2cap_pinfo *) sk)
+#define TX_QUEUE(sk) (&l2cap_pi(sk)->tx_queue)
+#define SREJ_QUEUE(sk) (&l2cap_pi(sk)->srej_queue)
+
+struct l2cap_seq_list {
+	__u16 head;
+	__u16 tail;
+	__u16 size;
+	__u16 mask;
+	__u16 *list;
+};
+
+struct l2cap_pinfo {
+	struct bt_sock	bt;
 	__le16		psm;
 	__u16		dcid;
 	__u16		scid;
@@ -423,414 +486,236 @@ struct l2cap_chan {
 	__u16		omtu;
 	__u16		flush_to;
 	__u8		mode;
-	__u8		chan_type;
-	__u8		chan_policy;
-
-	__le16		sport;
-
-	__u8		sec_level;
-
-	__u8		ident;
-
-	__u8		conf_req[64];
-	__u8		conf_len;
+	__u8		fixed_channel;
 	__u8		num_conf_req;
 	__u8		num_conf_rsp;
+	__u8		incoming;
 
 	__u8		fcs;
+	__u8		sec_level;
+	__u8		role_switch;
+	__u8		force_reliable;
+	__u8		flushable;
+	__u8		force_active;
 
-	__u16		tx_win;
-	__u16		tx_win_max;
-	__u8		max_tx;
-	__u16		retrans_timeout;
-	__u16		monitor_timeout;
-	__u16		mps;
-
-	unsigned long	conf_state;
-	unsigned long	conn_state;
-	unsigned long	flags;
+	__u8		conf_req[64];
+	__u8		conf_len;
+	__u8		conf_ident;
+	__u16		conf_state;
+	__u8		conn_state;
+	__u8		tx_state;
+	__u8		rx_state;
+	__u8		reconf_state;
+
+	__u8		amp_id;
+	__u8		amp_move_id;
+	__u8		amp_move_state;
+	__u8		amp_move_role;
+	__u8		amp_move_cmd_ident;
+	__u16		amp_move_reqseq;
+	__u16		amp_move_event;
 
 	__u16		next_tx_seq;
 	__u16		expected_ack_seq;
 	__u16		expected_tx_seq;
 	__u16		buffer_seq;
-	__u16		buffer_seq_srej;
 	__u16		srej_save_reqseq;
-	__u16		frames_sent;
+	__u16		last_acked_seq;
+	__u32		frames_sent;
 	__u16		unacked_frames;
 	__u8		retry_count;
-	__u8		num_acked;
+	__u16		srej_queue_next;
 	__u16		sdu_len;
 	struct sk_buff	*sdu;
 	struct sk_buff	*sdu_last_frag;
+	atomic_t	ertm_queued;
+
+	__u8		ident;
 
+	__u16		tx_win;
+	__u16		tx_win_max;
+	__u16		ack_win;
+	__u8		max_tx;
+	__u8		amp_pref;
 	__u16		remote_tx_win;
 	__u8		remote_max_tx;
+	__u8		extended_control;
+	__u16		retrans_timeout;
+	__u16		monitor_timeout;
 	__u16		remote_mps;
+	__u16		mps;
 
-	__u8		local_id;
-	__u8		local_stype;
-	__u16		local_msdu;
-	__u32		local_sdu_itime;
-	__u32		local_acc_lat;
-	__u32		local_flush_to;
-
-	__u8		remote_id;
-	__u8		remote_stype;
-	__u16		remote_msdu;
-	__u32		remote_sdu_itime;
-	__u32		remote_acc_lat;
-	__u32		remote_flush_to;
-
-	struct delayed_work	chan_timer;
-	struct delayed_work	retrans_timer;
-	struct delayed_work	monitor_timer;
-	struct delayed_work	ack_timer;
-
-	struct sk_buff		*tx_send_head;
-	struct sk_buff_head	tx_q;
-	struct sk_buff_head	srej_q;
-	struct list_head	srej_l;
-
-	struct list_head list;
-	struct list_head global_l;
-
-	void		*data;
-	struct l2cap_ops *ops;
-};
-
-struct l2cap_ops {
-	char		*name;
-
-	struct l2cap_chan	*(*new_connection) (void *data);
-	int			(*recv) (void *data, struct sk_buff *skb);
-	void			(*close) (void *data);
-	void			(*state_change) (void *data, int state);
-};
-
-struct l2cap_conn {
-	struct hci_conn	*hcon;
-	struct hci_chan	*hchan;
-
-	bdaddr_t	*dst;
-	bdaddr_t	*src;
-
-	unsigned int	mtu;
-
-	__u32		feat_mask;
-
-	__u8		info_state;
-	__u8		info_ident;
-
-	struct delayed_work info_timer;
-
-	spinlock_t	lock;
-
-	struct sk_buff *rx_skb;
-	__u32		rx_len;
-	__u8		tx_ident;
-
-	__u8		disc_reason;
-
-	struct delayed_work  security_timer;
-	struct smp_chan *smp_chan;
-
-	struct list_head chan_l;
-	struct mutex	chan_lock;
-};
-
-#define L2CAP_INFO_CL_MTU_REQ_SENT	0x01
-#define L2CAP_INFO_FEAT_MASK_REQ_SENT	0x04
-#define L2CAP_INFO_FEAT_MASK_REQ_DONE	0x08
-
-#define L2CAP_CHAN_RAW			1
-#define L2CAP_CHAN_CONN_LESS		2
-#define L2CAP_CHAN_CONN_ORIENTED	3
-
-/* ----- L2CAP socket info ----- */
-#define l2cap_pi(sk) ((struct l2cap_pinfo *) sk)
+	__le16		sport;
 
-struct l2cap_pinfo {
-	struct bt_sock	bt;
-	struct l2cap_chan	*chan;
-	struct sk_buff	*rx_busy_skb;
+	struct delayed_work	retrans_work;
+	struct delayed_work	monitor_work;
+	struct delayed_work	ack_work;
+	struct work_struct	tx_work;
+	struct sk_buff_head	tx_queue;
+	struct sk_buff_head	srej_queue;
+	struct l2cap_seq_list srej_list;
+	struct l2cap_seq_list retrans_list;
+	struct hci_conn	*ampcon;
+	struct hci_chan	*ampchan;
+	struct l2cap_conn	*conn;
+	struct l2cap_conf_prm local_conf;
+	struct l2cap_conf_prm remote_conf;
+	struct l2cap_conf_ext_fs local_fs;
+	struct l2cap_conf_ext_fs remote_fs;
+	struct sock		*next_c;
+	struct sock		*prev_c;
 };
 
-enum {
-	CONF_REQ_SENT,
-	CONF_INPUT_DONE,
-	CONF_OUTPUT_DONE,
-	CONF_MTU_DONE,
-	CONF_MODE_DONE,
-	CONF_CONNECT_PEND,
-	CONF_NO_FCS_RECV,
-	CONF_STATE2_DEVICE,
-	CONF_EWS_RECV,
-	CONF_LOC_CONF_PEND,
-	CONF_REM_CONF_PEND,
-};
+#define L2CAP_CONF_REQ_SENT       0x0001
+#define L2CAP_CONF_INPUT_DONE     0x0002
+#define L2CAP_CONF_OUTPUT_DONE    0x0004
+#define L2CAP_CONF_MTU_DONE       0x0008
+#define L2CAP_CONF_MODE_DONE      0x0010
+#define L2CAP_CONF_CONNECT_PEND   0x0020
+#define L2CAP_CONF_NO_FCS_RECV    0x0040
+#define L2CAP_CONF_STATE2_DEVICE  0x0080
+#define L2CAP_CONF_EXT_WIN_RECV   0x0100
+#define L2CAP_CONF_LOCKSTEP       0x0200
+#define L2CAP_CONF_LOCKSTEP_PEND  0x0400
+#define L2CAP_CONF_PEND_SENT      0x0800
+#define L2CAP_CONF_EFS_RECV       0x1000
 
 #define L2CAP_CONF_MAX_CONF_REQ 2
 #define L2CAP_CONF_MAX_CONF_RSP 2
 
-enum {
-	CONN_SREJ_SENT,
-	CONN_WAIT_F,
-	CONN_SREJ_ACT,
-	CONN_SEND_PBIT,
-	CONN_REMOTE_BUSY,
-	CONN_LOCAL_BUSY,
-	CONN_REJ_ACT,
-	CONN_SEND_FBIT,
-	CONN_RNR_SENT,
-};
-
-/* Definitions for flags in l2cap_chan */
-enum {
-	FLAG_ROLE_SWITCH,
-	FLAG_FORCE_ACTIVE,
-	FLAG_FORCE_RELIABLE,
-	FLAG_FLUSHABLE,
-	FLAG_EXT_CTRL,
-	FLAG_EFS_ENABLE,
-};
-
-void l2cap_chan_hold(struct l2cap_chan *c);
-void l2cap_chan_put(struct l2cap_chan *c);
-
-static inline void l2cap_set_timer(struct l2cap_chan *chan,
-					struct delayed_work *work, long timeout)
-{
-	BT_DBG("chan %p state %d timeout %ld", chan, chan->state, timeout);
-
-	if (!cancel_delayed_work(work))
-		l2cap_chan_hold(chan);
-	schedule_delayed_work(work, timeout);
-}
-
-static inline void l2cap_clear_timer(struct l2cap_chan *chan,
-					struct delayed_work *work)
-{
-	if (cancel_delayed_work(work))
-		l2cap_chan_put(chan);
-}
-
-#define __set_chan_timer(c, t) l2cap_set_timer(c, &c->chan_timer, (t))
-#define __clear_chan_timer(c) l2cap_clear_timer(c, &c->chan_timer)
-#define __set_retrans_timer(c) l2cap_set_timer(c, &c->retrans_timer, \
-		msecs_to_jiffies(L2CAP_DEFAULT_RETRANS_TO));
-#define __clear_retrans_timer(c) l2cap_clear_timer(c, &c->retrans_timer)
-#define __set_monitor_timer(c) l2cap_set_timer(c, &c->monitor_timer, \
-		msecs_to_jiffies(L2CAP_DEFAULT_MONITOR_TO));
-#define __clear_monitor_timer(c) l2cap_clear_timer(c, &c->monitor_timer)
-#define __set_ack_timer(c) l2cap_set_timer(c, &chan->ack_timer, \
-		msecs_to_jiffies(L2CAP_DEFAULT_ACK_TO));
-#define __clear_ack_timer(c) l2cap_clear_timer(c, &c->ack_timer)
-
-static inline int __seq_offset(struct l2cap_chan *chan, __u16 seq1, __u16 seq2)
-{
-	int offset;
-
-	offset = (seq1 - seq2) % (chan->tx_win_max + 1);
-	if (offset < 0)
-		offset += (chan->tx_win_max + 1);
-
-	return offset;
-}
-
-static inline __u16 __next_seq(struct l2cap_chan *chan, __u16 seq)
-{
-	return (seq + 1) % (chan->tx_win_max + 1);
-}
-
-static inline int l2cap_tx_window_full(struct l2cap_chan *ch)
-{
-	int sub;
-
-	sub = (ch->next_tx_seq - ch->expected_ack_seq) % 64;
-
-	if (sub < 0)
-		sub += 64;
-
-	return sub == ch->remote_tx_win;
-}
-
-static inline __u16 __get_reqseq(struct l2cap_chan *chan, __u32 ctrl)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return (ctrl & L2CAP_EXT_CTRL_REQSEQ) >>
-						L2CAP_EXT_CTRL_REQSEQ_SHIFT;
-	else
-		return (ctrl & L2CAP_CTRL_REQSEQ) >> L2CAP_CTRL_REQSEQ_SHIFT;
-}
-
-static inline __u32 __set_reqseq(struct l2cap_chan *chan, __u32 reqseq)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return (reqseq << L2CAP_EXT_CTRL_REQSEQ_SHIFT) &
-							L2CAP_EXT_CTRL_REQSEQ;
-	else
-		return (reqseq << L2CAP_CTRL_REQSEQ_SHIFT) & L2CAP_CTRL_REQSEQ;
-}
-
-static inline __u16 __get_txseq(struct l2cap_chan *chan, __u32 ctrl)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return (ctrl & L2CAP_EXT_CTRL_TXSEQ) >>
-						L2CAP_EXT_CTRL_TXSEQ_SHIFT;
-	else
-		return (ctrl & L2CAP_CTRL_TXSEQ) >> L2CAP_CTRL_TXSEQ_SHIFT;
-}
-
-static inline __u32 __set_txseq(struct l2cap_chan *chan, __u32 txseq)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return (txseq << L2CAP_EXT_CTRL_TXSEQ_SHIFT) &
-							L2CAP_EXT_CTRL_TXSEQ;
-	else
-		return (txseq << L2CAP_CTRL_TXSEQ_SHIFT) & L2CAP_CTRL_TXSEQ;
-}
-
-static inline bool __is_sframe(struct l2cap_chan *chan, __u32 ctrl)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return ctrl & L2CAP_EXT_CTRL_FRAME_TYPE;
-	else
-		return ctrl & L2CAP_CTRL_FRAME_TYPE;
-}
-
-static inline __u32 __set_sframe(struct l2cap_chan *chan)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return L2CAP_EXT_CTRL_FRAME_TYPE;
-	else
-		return L2CAP_CTRL_FRAME_TYPE;
-}
-
-static inline __u8 __get_ctrl_sar(struct l2cap_chan *chan, __u32 ctrl)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return (ctrl & L2CAP_EXT_CTRL_SAR) >> L2CAP_EXT_CTRL_SAR_SHIFT;
-	else
-		return (ctrl & L2CAP_CTRL_SAR) >> L2CAP_CTRL_SAR_SHIFT;
-}
-
-static inline __u32 __set_ctrl_sar(struct l2cap_chan *chan, __u32 sar)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return (sar << L2CAP_EXT_CTRL_SAR_SHIFT) & L2CAP_EXT_CTRL_SAR;
-	else
-		return (sar << L2CAP_CTRL_SAR_SHIFT) & L2CAP_CTRL_SAR;
-}
-
-static inline bool __is_sar_start(struct l2cap_chan *chan, __u32 ctrl)
-{
-	return __get_ctrl_sar(chan, ctrl) == L2CAP_SAR_START;
-}
-
-static inline __u32 __get_sar_mask(struct l2cap_chan *chan)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return L2CAP_EXT_CTRL_SAR;
-	else
-		return L2CAP_CTRL_SAR;
-}
-
-static inline __u8 __get_ctrl_super(struct l2cap_chan *chan, __u32 ctrl)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return (ctrl & L2CAP_EXT_CTRL_SUPERVISE) >>
-						L2CAP_EXT_CTRL_SUPER_SHIFT;
-	else
-		return (ctrl & L2CAP_CTRL_SUPERVISE) >> L2CAP_CTRL_SUPER_SHIFT;
-}
-
-static inline __u32 __set_ctrl_super(struct l2cap_chan *chan, __u32 super)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return (super << L2CAP_EXT_CTRL_SUPER_SHIFT) &
-						L2CAP_EXT_CTRL_SUPERVISE;
-	else
-		return (super << L2CAP_CTRL_SUPER_SHIFT) &
-							L2CAP_CTRL_SUPERVISE;
-}
-
-static inline __u32 __set_ctrl_final(struct l2cap_chan *chan)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return L2CAP_EXT_CTRL_FINAL;
-	else
-		return L2CAP_CTRL_FINAL;
-}
-
-static inline bool __is_ctrl_final(struct l2cap_chan *chan, __u32 ctrl)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return ctrl & L2CAP_EXT_CTRL_FINAL;
-	else
-		return ctrl & L2CAP_CTRL_FINAL;
-}
-
-static inline __u32 __set_ctrl_poll(struct l2cap_chan *chan)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return L2CAP_EXT_CTRL_POLL;
-	else
-		return L2CAP_CTRL_POLL;
-}
-
-static inline bool __is_ctrl_poll(struct l2cap_chan *chan, __u32 ctrl)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return ctrl & L2CAP_EXT_CTRL_POLL;
-	else
-		return ctrl & L2CAP_CTRL_POLL;
-}
-
-static inline __u32 __get_control(struct l2cap_chan *chan, void *p)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return get_unaligned_le32(p);
-	else
-		return get_unaligned_le16(p);
-}
-
-static inline void __put_control(struct l2cap_chan *chan, __u32 control,
-								void *p)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return put_unaligned_le32(control, p);
-	else
-		return put_unaligned_le16(control, p);
-}
-
-static inline __u8 __ctrl_size(struct l2cap_chan *chan)
-{
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		return L2CAP_EXT_HDR_SIZE - L2CAP_HDR_SIZE;
-	else
-		return L2CAP_ENH_HDR_SIZE - L2CAP_HDR_SIZE;
-}
+#define L2CAP_RECONF_NONE          0x00
+#define L2CAP_RECONF_INT           0x01
+#define L2CAP_RECONF_ACC           0x02
+
+#define L2CAP_CONN_SREJ_ACT        0x01
+#define L2CAP_CONN_REJ_ACT         0x02
+#define L2CAP_CONN_REMOTE_BUSY     0x04
+#define L2CAP_CONN_LOCAL_BUSY      0x08
+#define L2CAP_CONN_SEND_FBIT       0x10
+#define L2CAP_CONN_SENT_RNR        0x20
+
+#define L2CAP_SEQ_LIST_CLEAR       0xFFFF
+#define L2CAP_SEQ_LIST_TAIL        0x8000
+
+#define L2CAP_ERTM_TX_STATE_XMIT          0x01
+#define L2CAP_ERTM_TX_STATE_WAIT_F        0x02
+
+#define L2CAP_ERTM_RX_STATE_RECV                    0x01
+#define L2CAP_ERTM_RX_STATE_SREJ_SENT               0x02
+#define L2CAP_ERTM_RX_STATE_AMP_MOVE                0x03
+#define L2CAP_ERTM_RX_STATE_WAIT_P_FLAG             0x04
+#define L2CAP_ERTM_RX_STATE_WAIT_P_FLAG_RECONFIGURE 0x05
+#define L2CAP_ERTM_RX_STATE_WAIT_F_FLAG             0x06
+
+#define L2CAP_ERTM_TXSEQ_EXPECTED        0x00
+#define L2CAP_ERTM_TXSEQ_EXPECTED_SREJ   0x01
+#define L2CAP_ERTM_TXSEQ_UNEXPECTED      0x02
+#define L2CAP_ERTM_TXSEQ_UNEXPECTED_SREJ 0x03
+#define L2CAP_ERTM_TXSEQ_DUPLICATE       0x04
+#define L2CAP_ERTM_TXSEQ_DUPLICATE_SREJ  0x05
+#define L2CAP_ERTM_TXSEQ_INVALID         0x06
+#define L2CAP_ERTM_TXSEQ_INVALID_IGNORE  0x07
+
+#define L2CAP_ERTM_EVENT_DATA_REQUEST          0x01
+#define L2CAP_ERTM_EVENT_LOCAL_BUSY_DETECTED   0x02
+#define L2CAP_ERTM_EVENT_LOCAL_BUSY_CLEAR      0x03
+#define L2CAP_ERTM_EVENT_RECV_REQSEQ_AND_FBIT  0x04
+#define L2CAP_ERTM_EVENT_RECV_FBIT             0x05
+#define L2CAP_ERTM_EVENT_RETRANS_TIMER_EXPIRES 0x06
+#define L2CAP_ERTM_EVENT_MONITOR_TIMER_EXPIRES 0x07
+#define L2CAP_ERTM_EVENT_EXPLICIT_POLL         0x08
+#define L2CAP_ERTM_EVENT_RECV_IFRAME           0x09
+#define L2CAP_ERTM_EVENT_RECV_RR               0x0a
+#define L2CAP_ERTM_EVENT_RECV_REJ              0x0b
+#define L2CAP_ERTM_EVENT_RECV_RNR              0x0c
+#define L2CAP_ERTM_EVENT_RECV_SREJ             0x0d
+#define L2CAP_ERTM_EVENT_RECV_FRAME            0x0e
+
+#define L2CAP_AMP_MOVE_NONE      0
+#define L2CAP_AMP_MOVE_INITIATOR 1
+#define L2CAP_AMP_MOVE_RESPONDER 2
+
+#define L2CAP_AMP_STATE_STABLE			0
+#define L2CAP_AMP_STATE_WAIT_CREATE		1
+#define L2CAP_AMP_STATE_WAIT_CREATE_RSP		2
+#define L2CAP_AMP_STATE_WAIT_MOVE		3
+#define L2CAP_AMP_STATE_WAIT_MOVE_RSP		4
+#define L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS	5
+#define L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM	6
+#define L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP	7
+#define L2CAP_AMP_STATE_WAIT_LOGICAL_COMPLETE	8
+#define L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM	9
+#define L2CAP_AMP_STATE_WAIT_LOCAL_BUSY		10
+#define L2CAP_AMP_STATE_WAIT_PREPARE		11
+#define L2CAP_AMP_STATE_RESEGMENT		12
+
+#define L2CAP_ATT_ERROR				0x01
+#define L2CAP_ATT_MTU_REQ			0x02
+#define L2CAP_ATT_MTU_RSP			0x03
+#define L2CAP_ATT_RESPONSE_BIT			0x01
+#define L2CAP_ATT_INDICATE			0x1D
+#define L2CAP_ATT_CONFIRM			0x1E
+#define L2CAP_ATT_NOT_SUPPORTED			0x06
+
+#define __delta_seq(x, y, pi) ((x) >= (y) ? (x) - (y) : \
+				(pi)->tx_win_max + 1 - (y) + (x))
+#define __next_seq(x, pi) ((x + 1) & ((pi)->tx_win_max))
 
 extern bool disable_ertm;
+extern const struct proto_ops l2cap_sock_ops;
+extern struct bt_sock_list l2cap_sk_list;
 
 int l2cap_init_sockets(void);
 void l2cap_cleanup_sockets(void);
 
-void __l2cap_connect_rsp_defer(struct l2cap_chan *chan);
+u8 l2cap_get_ident(struct l2cap_conn *conn);
+void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data);
+int l2cap_build_conf_req(struct sock *sk, void *data);
 int __l2cap_wait_ack(struct sock *sk);
 
-int l2cap_add_psm(struct l2cap_chan *chan, bdaddr_t *src, __le16 psm);
-int l2cap_add_scid(struct l2cap_chan *chan,  __u16 scid);
-
-struct l2cap_chan *l2cap_chan_create(struct sock *sk);
-void l2cap_chan_close(struct l2cap_chan *chan, int reason);
-void l2cap_chan_destroy(struct l2cap_chan *chan);
-int l2cap_chan_connect(struct l2cap_chan *chan, __le16 psm, u16 cid,
-								bdaddr_t *dst);
-int l2cap_chan_send(struct l2cap_chan *chan, struct msghdr *msg, size_t len,
-								u32 priority);
-void l2cap_chan_busy(struct l2cap_chan *chan, int busy);
-int l2cap_chan_check_security(struct l2cap_chan *chan);
+struct sk_buff *l2cap_create_connless_pdu(struct sock *sk, struct msghdr *msg, size_t len);
+struct sk_buff *l2cap_create_basic_pdu(struct sock *sk, struct msghdr *msg, size_t len);
+struct sk_buff *l2cap_create_iframe_pdu(struct sock *sk, struct msghdr *msg,
+				size_t len, u16 sdulen, int reseg);
+int l2cap_segment_sdu(struct sock *sk, struct sk_buff_head* seg_queue,
+			struct msghdr *msg, size_t len, int reseg);
+int l2cap_resegment_queue(struct sock *sk, struct sk_buff_head *queue);
+void l2cap_do_send(struct sock *sk, struct sk_buff *skb);
+void l2cap_streaming_send(struct sock *sk);
+int l2cap_ertm_send(struct sock *sk);
+int l2cap_strm_tx(struct sock *sk, struct sk_buff_head *skbs);
+int l2cap_ertm_tx(struct sock *sk, struct bt_l2cap_control *control,
+			struct sk_buff_head *skbs, u8 event);
+
+int l2cap_sock_le_params_valid(struct bt_le_params *le_params);
+void l2cap_sock_set_timer(struct sock *sk, long timeout);
+void l2cap_sock_clear_timer(struct sock *sk);
+void __l2cap_sock_close(struct sock *sk, int reason);
+void l2cap_sock_kill(struct sock *sk);
+void l2cap_sock_init(struct sock *sk, struct sock *parent);
+struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,
+							int proto, gfp_t prio);
+struct sock *l2cap_find_sock_by_fixed_cid_and_dir(__le16 cid, bdaddr_t *src,
+						bdaddr_t *dst, int server);
+void l2cap_send_disconn_req(struct l2cap_conn *conn, struct sock *sk, int err);
+void l2cap_chan_del(struct sock *sk, int err);
+int l2cap_do_connect(struct sock *sk);
+int l2cap_data_channel(struct sock *sk, struct sk_buff *skb);
+void l2cap_amp_move_init(struct sock *sk);
+void l2cap_ertm_destruct(struct sock *sk);
+void l2cap_ertm_shutdown(struct sock *sk);
+void l2cap_ertm_recv_done(struct sock *sk);
+
+void l2cap_fixed_channel_config(struct sock *sk, struct l2cap_options *opt);
+
+void l2cap_recv_deferred_frame(struct sock *sk, struct sk_buff *skb);
+
+void l2cap_amp_physical_complete(int result, u8 remote_id, u8 local_id,
+				struct sock *sk);
+
+void l2cap_amp_logical_complete(int result, struct hci_conn *ampcon,
+				struct hci_chan *ampchan, struct sock *sk);
+
+void l2cap_amp_logical_destroyed(struct hci_conn *ampcon);
 
 #endif /* __L2CAP_H */
diff --git a/include/net/bluetooth/mgmt.h b/include/net/bluetooth/mgmt.h
index be65d34..3bf514f 100644
--- a/include/net/bluetooth/mgmt.h
+++ b/include/net/bluetooth/mgmt.h
@@ -23,23 +23,6 @@
 
 #define MGMT_INDEX_NONE			0xFFFF
 
-#define MGMT_STATUS_SUCCESS		0x00
-#define MGMT_STATUS_UNKNOWN_COMMAND	0x01
-#define MGMT_STATUS_NOT_CONNECTED	0x02
-#define MGMT_STATUS_FAILED		0x03
-#define MGMT_STATUS_CONNECT_FAILED	0x04
-#define MGMT_STATUS_AUTH_FAILED		0x05
-#define MGMT_STATUS_NOT_PAIRED		0x06
-#define MGMT_STATUS_NO_RESOURCES	0x07
-#define MGMT_STATUS_TIMEOUT		0x08
-#define MGMT_STATUS_ALREADY_CONNECTED	0x09
-#define MGMT_STATUS_BUSY		0x0a
-#define MGMT_STATUS_REJECTED		0x0b
-#define MGMT_STATUS_NOT_SUPPORTED	0x0c
-#define MGMT_STATUS_INVALID_PARAMS	0x0d
-#define MGMT_STATUS_DISCONNECTED	0x0e
-#define MGMT_STATUS_NOT_POWERED		0x0f
-
 struct mgmt_hdr {
 	__le16 opcode;
 	__le16 index;
@@ -61,29 +44,23 @@ struct mgmt_rp_read_index_list {
 /* Reserve one extra byte for names in management messages so that they
  * are always guaranteed to be nul-terminated */
 #define MGMT_MAX_NAME_LENGTH		(HCI_MAX_NAME_LENGTH + 1)
-#define MGMT_MAX_SHORT_NAME_LENGTH	(10 + 1)
-
-#define MGMT_SETTING_POWERED		0x00000001
-#define MGMT_SETTING_CONNECTABLE	0x00000002
-#define MGMT_SETTING_FAST_CONNECTABLE	0x00000004
-#define MGMT_SETTING_DISCOVERABLE	0x00000008
-#define MGMT_SETTING_PAIRABLE		0x00000010
-#define MGMT_SETTING_LINK_SECURITY	0x00000020
-#define MGMT_SETTING_SSP		0x00000040
-#define MGMT_SETTING_BREDR		0x00000080
-#define MGMT_SETTING_HS			0x00000100
-#define MGMT_SETTING_LE			0x00000200
 
 #define MGMT_OP_READ_INFO		0x0004
 struct mgmt_rp_read_info {
+	__u8 type;
+	__u8 powered;
+	__u8 connectable;
+	__u8 discoverable;
+	__u8 pairable;
+	__u8 sec_mode;
 	bdaddr_t bdaddr;
-	__u8 version;
-	__le16 manufacturer;
-	__le32 supported_settings;
-	__le32 current_settings;
 	__u8 dev_class[3];
+	__u8 features[8];
+	__u16 manufacturer;
+	__u8 hci_ver;
+	__u16 hci_rev;
 	__u8 name[MGMT_MAX_NAME_LENGTH];
-	__u8 short_name[MGMT_MAX_SHORT_NAME_LENGTH];
+	__u8 le_white_list_size;
 } __packed;
 
 struct mgmt_mode {
@@ -93,97 +70,74 @@ struct mgmt_mode {
 #define MGMT_OP_SET_POWERED		0x0005
 
 #define MGMT_OP_SET_DISCOVERABLE	0x0006
-struct mgmt_cp_set_discoverable {
-	__u8 val;
-	__u16 timeout;
-} __packed;
 
 #define MGMT_OP_SET_CONNECTABLE		0x0007
 
-#define MGMT_OP_SET_FAST_CONNECTABLE	0x0008
-
-#define MGMT_OP_SET_PAIRABLE		0x0009
-
-#define MGMT_OP_SET_LINK_SECURITY	0x000A
+#define MGMT_OP_SET_PAIRABLE		0x0008
 
-#define MGMT_OP_SET_SSP			0x000B
-
-#define MGMT_OP_SET_HS			0x000C
-
-#define MGMT_OP_SET_LE			0x000D
-
-#define MGMT_OP_SET_DEV_CLASS		0x000E
-struct mgmt_cp_set_dev_class {
-	__u8 major;
-	__u8 minor;
-} __packed;
-
-#define MGMT_OP_SET_LOCAL_NAME		0x000F
-struct mgmt_cp_set_local_name {
-	__u8 name[MGMT_MAX_NAME_LENGTH];
-} __packed;
-
-#define MGMT_OP_ADD_UUID		0x0010
+#define MGMT_OP_ADD_UUID		0x0009
 struct mgmt_cp_add_uuid {
 	__u8 uuid[16];
 	__u8 svc_hint;
 } __packed;
 
-#define MGMT_OP_REMOVE_UUID		0x0011
+#define MGMT_OP_REMOVE_UUID		0x000A
 struct mgmt_cp_remove_uuid {
 	__u8 uuid[16];
 } __packed;
 
-struct mgmt_link_key_info {
+#define MGMT_OP_SET_DEV_CLASS		0x000B
+struct mgmt_cp_set_dev_class {
+	__u8 major;
+	__u8 minor;
+} __packed;
+#define MGMT_MAJOR_CLASS_MASK		0x1F
+#define MGMT_MAJOR_CLASS_LIMITED	0x20
+
+#define MGMT_OP_SET_SERVICE_CACHE	0x000C
+struct mgmt_cp_set_service_cache {
+	__u8 enable;
+} __packed;
+
+struct mgmt_key_info {
 	bdaddr_t bdaddr;
-	u8 type;
+	u8 addr_type;
+	u8 key_type;
 	u8 val[16];
 	u8 pin_len;
+	u8 auth;
+	u8 dlen;
+	u8 data[10];
 } __packed;
 
-#define MGMT_OP_LOAD_LINK_KEYS		0x0012
-struct mgmt_cp_load_link_keys {
+#define MGMT_OP_LOAD_KEYS		0x000D
+struct mgmt_cp_load_keys {
 	__u8 debug_keys;
 	__le16 key_count;
-	struct mgmt_link_key_info keys[0];
+	struct mgmt_key_info keys[0];
 } __packed;
 
-#define MGMT_OP_REMOVE_KEYS		0x0013
-struct mgmt_cp_remove_keys {
+#define MGMT_OP_REMOVE_KEY		0x000E
+struct mgmt_cp_remove_key {
 	bdaddr_t bdaddr;
 	__u8 disconnect;
 } __packed;
-struct mgmt_rp_remove_keys {
-	bdaddr_t bdaddr;
-	__u8 status;
-};
 
-#define MGMT_OP_DISCONNECT		0x0014
+#define MGMT_OP_DISCONNECT		0x000F
 struct mgmt_cp_disconnect {
 	bdaddr_t bdaddr;
 } __packed;
 struct mgmt_rp_disconnect {
 	bdaddr_t bdaddr;
-	__u8 status;
 } __packed;
 
-#define MGMT_ADDR_BREDR			0x00
-#define MGMT_ADDR_LE_PUBLIC		0x01
-#define MGMT_ADDR_LE_RANDOM		0x02
-#define MGMT_ADDR_INVALID		0xff
-
-struct mgmt_addr_info {
-	bdaddr_t bdaddr;
-	__u8 type;
-} __packed;
-
-#define MGMT_OP_GET_CONNECTIONS		0x0015
+#define MGMT_OP_GET_CONNECTIONS		0x0010
 struct mgmt_rp_get_connections {
 	__le16 conn_count;
-	struct mgmt_addr_info addr[0];
+	bdaddr_t conn[0];
 } __packed;
 
-#define MGMT_OP_PIN_CODE_REPLY		0x0016
+#define MGMT_OP_PIN_CODE_REPLY		0x0011
 struct mgmt_cp_pin_code_reply {
 	bdaddr_t bdaddr;
 	__u8 pin_len;
@@ -194,27 +148,27 @@ struct mgmt_rp_pin_code_reply {
 	uint8_t status;
 } __packed;
 
-#define MGMT_OP_PIN_CODE_NEG_REPLY	0x0017
+#define MGMT_OP_PIN_CODE_NEG_REPLY	0x0012
 struct mgmt_cp_pin_code_neg_reply {
 	bdaddr_t bdaddr;
 } __packed;
 
-#define MGMT_OP_SET_IO_CAPABILITY	0x0018
+#define MGMT_OP_SET_IO_CAPABILITY	0x0013
 struct mgmt_cp_set_io_capability {
 	__u8 io_capability;
 } __packed;
 
-#define MGMT_OP_PAIR_DEVICE		0x0019
+#define MGMT_OP_PAIR_DEVICE		0x0014
 struct mgmt_cp_pair_device {
-	struct mgmt_addr_info addr;
+	bdaddr_t bdaddr;
 	__u8 io_cap;
 } __packed;
 struct mgmt_rp_pair_device {
-	struct mgmt_addr_info addr;
+	bdaddr_t bdaddr;
 	__u8 status;
 } __packed;
 
-#define MGMT_OP_USER_CONFIRM_REPLY	0x001A
+#define MGMT_OP_USER_CONFIRM_REPLY	0x0015
 struct mgmt_cp_user_confirm_reply {
 	bdaddr_t bdaddr;
 } __packed;
@@ -223,71 +177,106 @@ struct mgmt_rp_user_confirm_reply {
 	__u8 status;
 } __packed;
 
-#define MGMT_OP_USER_CONFIRM_NEG_REPLY	0x001B
-struct mgmt_cp_user_confirm_neg_reply {
-	bdaddr_t bdaddr;
-} __packed;
-
-#define MGMT_OP_USER_PASSKEY_REPLY	0x001C
-struct mgmt_cp_user_passkey_reply {
-	bdaddr_t bdaddr;
-	__le32 passkey;
-} __packed;
-struct mgmt_rp_user_passkey_reply {
-	bdaddr_t bdaddr;
-	__u8 status;
-} __packed;
+#define MGMT_OP_USER_CONFIRM_NEG_REPLY	0x0016
 
-#define MGMT_OP_USER_PASSKEY_NEG_REPLY	0x001D
-struct mgmt_cp_user_passkey_neg_reply {
-	bdaddr_t bdaddr;
+#define MGMT_OP_SET_LOCAL_NAME		0x0017
+struct mgmt_cp_set_local_name {
+	__u8 name[MGMT_MAX_NAME_LENGTH];
 } __packed;
 
-#define MGMT_OP_READ_LOCAL_OOB_DATA	0x001E
+#define MGMT_OP_READ_LOCAL_OOB_DATA	0x0018
 struct mgmt_rp_read_local_oob_data {
 	__u8 hash[16];
 	__u8 randomizer[16];
 } __packed;
 
-#define MGMT_OP_ADD_REMOTE_OOB_DATA	0x001F
+#define MGMT_OP_ADD_REMOTE_OOB_DATA	0x0019
 struct mgmt_cp_add_remote_oob_data {
 	bdaddr_t bdaddr;
 	__u8 hash[16];
 	__u8 randomizer[16];
 } __packed;
 
-#define MGMT_OP_REMOVE_REMOTE_OOB_DATA	0x0020
+#define MGMT_OP_REMOVE_REMOTE_OOB_DATA	0x001A
 struct mgmt_cp_remove_remote_oob_data {
 	bdaddr_t bdaddr;
 } __packed;
 
-#define MGMT_OP_START_DISCOVERY		0x0021
-struct mgmt_cp_start_discovery {
-	__u8 type;
+#define MGMT_OP_START_DISCOVERY		0x001B
+
+#define MGMT_OP_STOP_DISCOVERY		0x001C
+
+#define MGMT_OP_USER_PASSKEY_REPLY	0x001D
+struct mgmt_cp_user_passkey_reply {
+	bdaddr_t bdaddr;
+	__le32 passkey;
+} __packed;
+
+#define MGMT_OP_RESOLVE_NAME		0x001E
+struct mgmt_cp_resolve_name {
+	bdaddr_t bdaddr;
 } __packed;
 
-#define MGMT_OP_STOP_DISCOVERY		0x0022
+#define MGMT_OP_SET_LIMIT_DISCOVERABLE	0x001F
 
-#define MGMT_OP_CONFIRM_NAME		0x0023
-struct mgmt_cp_confirm_name {
+#define MGMT_OP_SET_CONNECTION_PARAMS	0x0020
+struct mgmt_cp_set_connection_params {
 	bdaddr_t bdaddr;
-	__u8 name_known;
+	__le16 interval_min;
+	__le16 interval_max;
+	__le16 slave_latency;
+	__le16 timeout_multiplier;
 } __packed;
-struct mgmt_rp_confirm_name {
+
+#define MGMT_OP_ENCRYPT_LINK		0x0021
+struct mgmt_cp_encrypt_link {
 	bdaddr_t bdaddr;
-	__u8 status;
+	__u8 enable;
+} __packed;
+
+#define MGMT_OP_SET_RSSI_REPORTER		0x0022
+struct mgmt_cp_set_rssi_reporter {
+	bdaddr_t	bdaddr;
+	__s8		rssi_threshold;
+	__le16	interval;
+	__u8		updateOnThreshExceed;
+} __packed;
+
+#define MGMT_OP_UNSET_RSSI_REPORTER		0x0023
+struct mgmt_cp_unset_rssi_reporter {
+	bdaddr_t	bdaddr;
 } __packed;
 
-#define MGMT_OP_BLOCK_DEVICE		0x0024
-struct mgmt_cp_block_device {
+#define MGMT_OP_CANCEL_RESOLVE_NAME	0x0024
+struct mgmt_cp_cancel_resolve_name {
 	bdaddr_t bdaddr;
 } __packed;
 
-#define MGMT_OP_UNBLOCK_DEVICE		0x0025
-struct mgmt_cp_unblock_device {
+#define MGMT_OP_LE_READ_WHITE_LIST_SIZE	0xE000
+
+#define MGMT_OP_LE_CLEAR_WHITE_LIST	0xE001
+
+#define MGMT_OP_LE_ADD_DEV_WHITE_LIST	0xE002
+struct mgmt_cp_le_add_dev_white_list {
+	__u8 addr_type;
 	bdaddr_t bdaddr;
 } __packed;
 
+#define MGMT_OP_LE_REMOVE_DEV_WHITE_LIST	0xE003
+struct mgmt_cp_le_remove_dev_white_list {
+	__u8 addr_type;
+	bdaddr_t bdaddr;
+} __packed;
+
+#define MGMT_OP_LE_CREATE_CONN_WHITE_LIST	0xE004
+
+#define MGMT_OP_LE_CANCEL_CREATE_CONN_WHITE_LIST	0xE005
+
+#define MGMT_OP_LE_CANCEL_CREATE_CONN	0xE006
+struct mgmt_cp_le_cancel_create_conn {
+	bdaddr_t	bdaddr;
+} __packed;
+
 #define MGMT_EV_CMD_COMPLETE		0x0001
 struct mgmt_ev_cmd_complete {
 	__le16 opcode;
@@ -309,82 +298,124 @@ struct mgmt_ev_controller_error {
 
 #define MGMT_EV_INDEX_REMOVED		0x0005
 
-#define MGMT_EV_NEW_SETTINGS		0x0006
+#define MGMT_EV_POWERED			0x0006
 
-#define MGMT_EV_CLASS_OF_DEV_CHANGED	0x0007
-struct mgmt_ev_class_of_dev_changed {
-	__u8 dev_class[3];
-};
+#define MGMT_EV_DISCOVERABLE		0x0007
 
-#define MGMT_EV_LOCAL_NAME_CHANGED	0x0008
-struct mgmt_ev_local_name_changed {
-	__u8 name[MGMT_MAX_NAME_LENGTH];
-	__u8 short_name[MGMT_MAX_SHORT_NAME_LENGTH];
-} __packed;
+#define MGMT_EV_CONNECTABLE		0x0008
+
+#define MGMT_EV_PAIRABLE		0x0009
 
-#define MGMT_EV_NEW_LINK_KEY		0x0009
-struct mgmt_ev_new_link_key {
+#define MGMT_EV_NEW_KEY			0x000A
+struct mgmt_ev_new_key {
 	__u8 store_hint;
-	struct mgmt_link_key_info key;
+	struct mgmt_key_info key;
 } __packed;
 
-#define MGMT_EV_CONNECTED		0x000A
+#define MGMT_EV_CONNECTED		0x000B
+struct mgmt_ev_connected {
+	bdaddr_t bdaddr;
+	__u8 le;
+} __packed;
 
-#define MGMT_EV_DISCONNECTED		0x000B
+#define MGMT_EV_DISCONNECTED		0x000C
+struct mgmt_ev_disconnected {
+	bdaddr_t bdaddr;
+	__u8     reason;
+} __packed;
 
-#define MGMT_EV_CONNECT_FAILED		0x000C
+#define MGMT_EV_CONNECT_FAILED		0x000D
 struct mgmt_ev_connect_failed {
-	struct mgmt_addr_info addr;
+	bdaddr_t bdaddr;
 	__u8 status;
 } __packed;
 
-#define MGMT_EV_PIN_CODE_REQUEST	0x000D
+#define MGMT_EV_PIN_CODE_REQUEST	0x000E
 struct mgmt_ev_pin_code_request {
 	bdaddr_t bdaddr;
 	__u8 secure;
 } __packed;
 
-#define MGMT_EV_USER_CONFIRM_REQUEST	0x000E
+#define MGMT_EV_USER_CONFIRM_REQUEST	0x000F
 struct mgmt_ev_user_confirm_request {
 	bdaddr_t bdaddr;
-	__u8 confirm_hint;
+	__u8 auto_confirm;
+	__u8 event;
 	__le32 value;
 } __packed;
 
-#define MGMT_EV_USER_PASSKEY_REQUEST	0x000F
-struct mgmt_ev_user_passkey_request {
-	bdaddr_t bdaddr;
-} __packed;
-
 #define MGMT_EV_AUTH_FAILED		0x0010
 struct mgmt_ev_auth_failed {
 	bdaddr_t bdaddr;
 	__u8 status;
 } __packed;
 
-#define MGMT_EV_DEVICE_FOUND		0x0011
+#define MGMT_EV_LOCAL_NAME_CHANGED	0x0011
+struct mgmt_ev_local_name_changed {
+	__u8 name[MGMT_MAX_NAME_LENGTH];
+} __packed;
+
+#define MGMT_EV_DEVICE_FOUND		0x0012
 struct mgmt_ev_device_found {
-	struct mgmt_addr_info addr;
+	bdaddr_t bdaddr;
 	__u8 dev_class[3];
 	__s8 rssi;
-	__u8 confirm_name;
+	__u8 le;
+	__u8 type;
 	__u8 eir[HCI_MAX_EIR_LENGTH];
 } __packed;
 
-#define MGMT_EV_REMOTE_NAME		0x0012
+#define MGMT_EV_REMOTE_NAME		0x0013
 struct mgmt_ev_remote_name {
 	bdaddr_t bdaddr;
+	__u8 status;
 	__u8 name[MGMT_MAX_NAME_LENGTH];
 } __packed;
 
-#define MGMT_EV_DISCOVERING		0x0013
+#define MGMT_EV_DISCOVERING		0x0014
+
+#define MGMT_EV_USER_PASSKEY_REQUEST	0x0015
+struct mgmt_ev_user_passkey_request {
+	bdaddr_t bdaddr;
+} __packed;
+
+#define MGMT_EV_ENCRYPT_CHANGE		0x0016
+struct mgmt_ev_encrypt_change {
+	bdaddr_t bdaddr;
+	__u8 status;
+} __packed;
+
+
+#define MGMT_EV_REMOTE_CLASS		0x0017
+struct mgmt_ev_remote_class {
+	bdaddr_t bdaddr;
+	__u8 dev_class[3];
+} __packed;
 
-#define MGMT_EV_DEVICE_BLOCKED		0x0014
-struct mgmt_ev_device_blocked {
+#define MGMT_EV_REMOTE_VERSION		0x0018
+struct mgmt_ev_remote_version {
 	bdaddr_t bdaddr;
+	__u8	lmp_ver;
+	__u16	manufacturer;
+	__u16	lmp_subver;
 } __packed;
 
-#define MGMT_EV_DEVICE_UNBLOCKED	0x0015
-struct mgmt_ev_device_unblocked {
+#define MGMT_EV_REMOTE_FEATURES		0x0019
+struct mgmt_ev_remote_features {
 	bdaddr_t bdaddr;
+	uint8_t features[8];
+} __packed;
+
+#define MGMT_EV_RSSI_UPDATE		0x0020
+struct mgmt_ev_rssi_update {
+	bdaddr_t	bdaddr;
+	__s8			rssi;
+} __packed;
+
+#define MGMT_EV_LE_CONN_PARAMS		0xF000
+struct mgmt_ev_le_conn_params {
+	bdaddr_t bdaddr;
+	__u16 interval;
+	__u16 latency;
+	__u16 timeout;
 } __packed;
diff --git a/include/net/bluetooth/rfcomm.h b/include/net/bluetooth/rfcomm.h
index e2e3eca..6eac4a7 100644
--- a/include/net/bluetooth/rfcomm.h
+++ b/include/net/bluetooth/rfcomm.h
@@ -211,7 +211,6 @@ struct rfcomm_dlc {
 #define RFCOMM_AUTH_ACCEPT  6
 #define RFCOMM_AUTH_REJECT  7
 #define RFCOMM_DEFER_SETUP  8
-#define RFCOMM_ENC_DROP     9
 
 /* Scheduling flags and events */
 #define RFCOMM_SCHED_WAKEUP 31
@@ -235,8 +234,7 @@ int rfcomm_send_rpn(struct rfcomm_session *s, int cr, u8 dlci,
 /* ---- RFCOMM DLCs (channels) ---- */
 struct rfcomm_dlc *rfcomm_dlc_alloc(gfp_t prio);
 void rfcomm_dlc_free(struct rfcomm_dlc *d);
-int  rfcomm_dlc_open(struct rfcomm_dlc *d, bdaddr_t *src, bdaddr_t *dst,
-								u8 channel);
+int  rfcomm_dlc_open(struct rfcomm_dlc *d, bdaddr_t *src, bdaddr_t *dst, u8 channel);
 int  rfcomm_dlc_close(struct rfcomm_dlc *d, int reason);
 int  rfcomm_dlc_send(struct rfcomm_dlc *d, struct sk_buff *skb);
 int  rfcomm_dlc_set_modem_status(struct rfcomm_dlc *d, u8 v24_sig);
@@ -273,8 +271,7 @@ static inline void rfcomm_dlc_unthrottle(struct rfcomm_dlc *d)
 }
 
 /* ---- RFCOMM sessions ---- */
-void   rfcomm_session_getaddr(struct rfcomm_session *s, bdaddr_t *src,
-								bdaddr_t *dst);
+void   rfcomm_session_getaddr(struct rfcomm_session *s, bdaddr_t *src, bdaddr_t *dst);
 
 static inline void rfcomm_session_hold(struct rfcomm_session *s)
 {
@@ -315,8 +312,7 @@ struct rfcomm_pinfo {
 int  rfcomm_init_sockets(void);
 void rfcomm_cleanup_sockets(void);
 
-int  rfcomm_connect_ind(struct rfcomm_session *s, u8 channel,
-							struct rfcomm_dlc **d);
+int  rfcomm_connect_ind(struct rfcomm_session *s, u8 channel, struct rfcomm_dlc **d);
 
 /* ---- RFCOMM TTY ---- */
 #define RFCOMM_MAX_DEV  256
diff --git a/include/net/bluetooth/sco.h b/include/net/bluetooth/sco.h
index 6d1857a..8c85c98 100644
--- a/include/net/bluetooth/sco.h
+++ b/include/net/bluetooth/sco.h
@@ -1,6 +1,7 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
    Copyright (C) 2000-2001 Qualcomm Incorporated
+   Copyright (c) 2011, The Linux Foundation. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -30,7 +31,7 @@
 #define SCO_DEFAULT_FLUSH_TO	0xFFFF
 
 #define SCO_CONN_TIMEOUT	(HZ * 40)
-#define SCO_DISCONN_TIMEOUT	(HZ * 2)
+#define SCO_DISCONN_TIMEOUT	(HZ * 20)
 #define SCO_CONN_IDLE_TIMEOUT	(HZ * 60)
 
 /* SCO socket address */
@@ -38,6 +39,7 @@ struct sockaddr_sco {
 	sa_family_t	sco_family;
 	bdaddr_t	sco_bdaddr;
 	__u16		sco_pkt_type;
+	__s8		is_wbs;
 };
 
 /* SCO socket options */
diff --git a/include/net/bluetooth/smp.h b/include/net/bluetooth/smp.h
index aeaf5fa..71845dd 100644
--- a/include/net/bluetooth/smp.h
+++ b/include/net/bluetooth/smp.h
@@ -55,6 +55,13 @@ struct smp_cmd_pairing {
 #define SMP_AUTH_BONDING	0x01
 #define SMP_AUTH_MITM		0x04
 
+#define SMP_JUST_WORKS		0x00
+#define SMP_JUST_CFM		0x01
+#define SMP_REQ_PASSKEY		0x02
+#define SMP_CFM_PASSKEY		0x03
+#define SMP_REQ_OOB		0x04
+#define SMP_OVERLAP		0xFF
+
 #define SMP_CMD_PAIRING_CONFIRM	0x03
 struct smp_cmd_pairing_confirm {
 	__u8	confirm_val[16];
@@ -115,32 +122,10 @@ struct smp_cmd_security_req {
 #define SMP_MIN_ENC_KEY_SIZE		7
 #define SMP_MAX_ENC_KEY_SIZE		16
 
-#define SMP_FLAG_TK_VALID	1
-#define SMP_FLAG_CFM_PENDING	2
-#define SMP_FLAG_MITM_AUTH	3
-
-struct smp_chan {
-	struct l2cap_conn *conn;
-	u8		preq[7]; /* SMP Pairing Request */
-	u8		prsp[7]; /* SMP Pairing Response */
-	u8              prnd[16]; /* SMP Pairing Random (local) */
-	u8              rrnd[16]; /* SMP Pairing Random (remote) */
-	u8		pcnf[16]; /* SMP Pairing Confirm */
-	u8		tk[16]; /* SMP Temporary Key */
-	u8		smp_key_size;
-	unsigned long	smp_flags;
-	struct crypto_blkcipher	*tfm;
-	struct work_struct confirm;
-	struct work_struct random;
-
-};
-
 /* SMP Commands */
 int smp_conn_security(struct l2cap_conn *conn, __u8 sec_level);
 int smp_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb);
-int smp_distribute_keys(struct l2cap_conn *conn, __u8 force);
-int smp_user_confirm_reply(struct hci_conn *conn, u16 mgmt_op, __le32 passkey);
-
-void smp_chan_destroy(struct l2cap_conn *conn);
+int smp_link_encrypt_cmplt(struct l2cap_conn *conn, __u8 status, __u8 encrypt);
+void smp_timeout(unsigned long l2cap_conn);
 
 #endif /* __SMP_H */
diff --git a/modules/eurasia_km/eurasiacon/build/linux2/config/core.mk b/modules/eurasia_km/eurasiacon/build/linux2/config/core.mk
index ab878a5..4dab2a3 100755
--- a/modules/eurasia_km/eurasiacon/build/linux2/config/core.mk
+++ b/modules/eurasia_km/eurasiacon/build/linux2/config/core.mk
@@ -222,7 +222,7 @@ ifneq ($(INTERNAL_CLOBBER_ONLY),true)
 # These are defined by the core build system, but we might need them
 # earlier to feature-check the compilers
 #
-_CC		:= $(CROSS_COMPILE)$(if $(filter default,$(origin CC)),gcc,$(CC))
+_CC		:= $(if $(filter default,$(origin CC)),gcc,$(CC))
 HOST_CC	?= gcc
 
 -include ../config/user-defs.mk
diff --git a/net/bluetooth/Kconfig b/net/bluetooth/Kconfig
index 9ec85eb..fc4543a 100644
--- a/net/bluetooth/Kconfig
+++ b/net/bluetooth/Kconfig
@@ -11,6 +11,8 @@ menuconfig BT
 	select CRYPTO_BLKCIPHER
 	select CRYPTO_AES
 	select CRYPTO_ECB
+	select CRYPTO_HMAC
+	select CRYPTO_SHA256
 	help
 	  Bluetooth is low-cost, low-power, short-range wireless technology.
 	  It was designed as a replacement for cables and other short-range
@@ -29,7 +31,6 @@ menuconfig BT
 	     BNEP Module (Bluetooth Network Encapsulation Protocol)
 	     CMTP Module (CAPI Message Transport Protocol)
 	     HIDP Module (Human Interface Device Protocol)
-	     SMP Module (Security Manager Protocol)
 
 	  Say Y here to compile Bluetooth support into the kernel or say M to
 	  compile it as module (bluetooth).
diff --git a/net/bluetooth/Makefile b/net/bluetooth/Makefile
index 2dc5a57..828be1d 100644
--- a/net/bluetooth/Makefile
+++ b/net/bluetooth/Makefile
@@ -9,4 +9,5 @@ obj-$(CONFIG_BT_CMTP)	+= cmtp/
 obj-$(CONFIG_BT_HIDP)	+= hidp/
 
 bluetooth-y := af_bluetooth.o hci_core.o hci_conn.o hci_event.o mgmt.o \
-	hci_sock.o hci_sysfs.o l2cap_core.o l2cap_sock.o smp.o sco.o lib.o
+	hci_sock.o hci_sysfs.o l2cap_core.o l2cap_sock.o smp.o sco.o lib.o \
+	amp.o
diff --git a/net/bluetooth/af_bluetooth.c b/net/bluetooth/af_bluetooth.c
index 269fade..219df5c 100644
--- a/net/bluetooth/af_bluetooth.c
+++ b/net/bluetooth/af_bluetooth.c
@@ -80,16 +80,19 @@ static const char *const bt_slock_key_strings[BT_MAX_PROTO] = {
 	"slock-AF_BLUETOOTH-BTPROTO_AVDTP",
 };
 
-void bt_sock_reclassify_lock(struct sock *sk, int proto)
+static inline void bt_sock_reclassify_lock(struct socket *sock, int proto)
 {
-	BUG_ON(!sk);
+	struct sock *sk = sock->sk;
+
+	if (!sk)
+		return;
+
 	BUG_ON(sock_owned_by_user(sk));
 
 	sock_lock_init_class_and_name(sk,
 			bt_slock_key_strings[proto], &bt_slock_key[proto],
 				bt_key_strings[proto], &bt_lock_key[proto]);
 }
-EXPORT_SYMBOL(bt_sock_reclassify_lock);
 
 int bt_sock_register(int proto, const struct net_proto_family *ops)
 {
@@ -180,8 +183,7 @@ static int bt_sock_create(struct net *net, struct socket *sock, int proto,
 
 	if (bt_proto[proto] && try_module_get(bt_proto[proto]->owner)) {
 		err = bt_proto[proto]->create(net, sock, proto, kern);
-		if (!err)
-			bt_sock_reclassify_lock(sock->sk, proto);
+		bt_sock_reclassify_lock(sock, proto);
 		module_put(bt_proto[proto]->owner);
 	}
 
@@ -192,17 +194,17 @@ static int bt_sock_create(struct net *net, struct socket *sock, int proto,
 
 void bt_sock_link(struct bt_sock_list *l, struct sock *sk)
 {
-	write_lock(&l->lock);
+	write_lock_bh(&l->lock);
 	sk_add_node(sk, &l->head);
-	write_unlock(&l->lock);
+	write_unlock_bh(&l->lock);
 }
 EXPORT_SYMBOL(bt_sock_link);
 
 void bt_sock_unlink(struct bt_sock_list *l, struct sock *sk)
 {
-	write_lock(&l->lock);
+	write_lock_bh(&l->lock);
 	sk_del_node_init(sk);
-	write_unlock(&l->lock);
+	write_unlock_bh(&l->lock);
 }
 EXPORT_SYMBOL(bt_sock_unlink);
 
@@ -235,14 +237,15 @@ struct sock *bt_accept_dequeue(struct sock *parent, struct socket *newsock)
 
 	BT_DBG("parent %p", parent);
 
+	local_bh_disable();
 	list_for_each_safe(p, n, &bt_sk(parent)->accept_q) {
 		sk = (struct sock *) list_entry(p, struct bt_sock, accept_q);
 
-		lock_sock(sk);
+		bh_lock_sock(sk);
 
 		/* FIXME: Is this check still needed */
 		if (sk->sk_state == BT_CLOSED) {
-			release_sock(sk);
+			bh_unlock_sock(sk);
 			bt_accept_unlink(sk);
 			continue;
 		}
@@ -253,12 +256,14 @@ struct sock *bt_accept_dequeue(struct sock *parent, struct socket *newsock)
 			if (newsock)
 				sock_graft(sk, newsock);
 
-			release_sock(sk);
+			bh_unlock_sock(sk);
+			local_bh_enable();
 			return sk;
 		}
 
-		release_sock(sk);
+		bh_unlock_sock(sk);
 	}
+	local_bh_enable();
 
 	return NULL;
 }
@@ -553,8 +558,9 @@ int bt_sock_wait_state(struct sock *sk, int state, unsigned long timeo)
 	BT_DBG("sk %p", sk);
 
 	add_wait_queue(sk_sleep(sk), &wait);
-	set_current_state(TASK_INTERRUPTIBLE);
 	while (sk->sk_state != state) {
+		set_current_state(TASK_INTERRUPTIBLE);
+
 		if (!timeo) {
 			err = -EINPROGRESS;
 			break;
@@ -568,13 +574,12 @@ int bt_sock_wait_state(struct sock *sk, int state, unsigned long timeo)
 		release_sock(sk);
 		timeo = schedule_timeout(timeo);
 		lock_sock(sk);
-		set_current_state(TASK_INTERRUPTIBLE);
 
 		err = sock_error(sk);
 		if (err)
 			break;
 	}
-	__set_current_state(TASK_RUNNING);
+	set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 	return err;
 }
diff --git a/net/bluetooth/amp.c b/net/bluetooth/amp.c
new file mode 100644
index 0000000..c19be91
--- /dev/null
+++ b/net/bluetooth/amp.c
@@ -0,0 +1,2041 @@
+/*
+   Copyright (c) 2010-2012 The Linux Foundation.  All rights reserved.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 and
+   only version 2 as published by the Free Software Foundation.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+*/
+
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+
+#include <linux/skbuff.h>
+#include <linux/list.h>
+#include <linux/workqueue.h>
+#include <linux/timer.h>
+
+#include <linux/crypto.h>
+#include <linux/scatterlist.h>
+#include <linux/err.h>
+#include <crypto/hash.h>
+
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+#include <net/bluetooth/l2cap.h>
+#include <net/bluetooth/amp.h>
+
+static struct workqueue_struct *amp_workqueue;
+
+LIST_HEAD(amp_mgr_list);
+DEFINE_RWLOCK(amp_mgr_list_lock);
+
+static int send_a2mp(struct socket *sock, u8 *data, int len);
+
+static void ctx_timeout(unsigned long data);
+
+static void launch_ctx(struct amp_mgr *mgr);
+static int execute_ctx(struct amp_ctx *ctx, u8 evt_type, void *data);
+static int kill_ctx(struct amp_ctx *ctx);
+static int cancel_ctx(struct amp_ctx *ctx);
+
+static struct socket *open_fixed_channel(bdaddr_t *src, bdaddr_t *dst);
+
+static void remove_amp_mgr(struct amp_mgr *mgr)
+{
+	BT_DBG("mgr %p", mgr);
+
+	write_lock(&amp_mgr_list_lock);
+	list_del(&mgr->list);
+	write_unlock(&amp_mgr_list_lock);
+
+	read_lock(&mgr->ctx_list_lock);
+	while (!list_empty(&mgr->ctx_list)) {
+		struct amp_ctx *ctx;
+		ctx = list_first_entry(&mgr->ctx_list, struct amp_ctx, list);
+		read_unlock(&mgr->ctx_list_lock);
+		BT_DBG("kill ctx %p", ctx);
+		kill_ctx(ctx);
+		read_lock(&mgr->ctx_list_lock);
+	}
+	read_unlock(&mgr->ctx_list_lock);
+
+	kfree(mgr->ctrls);
+
+	kfree(mgr);
+}
+
+static struct amp_mgr *get_amp_mgr_sk(struct sock *sk)
+{
+	struct amp_mgr *mgr;
+	struct amp_mgr *found = NULL;
+
+	read_lock(&amp_mgr_list_lock);
+	list_for_each_entry(mgr, &amp_mgr_list, list) {
+		if ((mgr->a2mp_sock) && (mgr->a2mp_sock->sk == sk)) {
+			found = mgr;
+			break;
+		}
+	}
+	read_unlock(&amp_mgr_list_lock);
+	return found;
+}
+
+static struct amp_mgr *get_create_amp_mgr(struct hci_conn *hcon,
+						struct sk_buff *skb)
+{
+	struct amp_mgr *mgr;
+
+	write_lock(&amp_mgr_list_lock);
+	list_for_each_entry(mgr, &amp_mgr_list, list) {
+		if (mgr->l2cap_conn == hcon->l2cap_data) {
+			BT_DBG("found %p", mgr);
+			write_unlock(&amp_mgr_list_lock);
+			goto gc_finished;
+		}
+	}
+	write_unlock(&amp_mgr_list_lock);
+
+	mgr = kzalloc(sizeof(*mgr), GFP_ATOMIC);
+	if (!mgr)
+		return NULL;
+
+	mgr->l2cap_conn = hcon->l2cap_data;
+	mgr->next_ident = 1;
+	INIT_LIST_HEAD(&mgr->ctx_list);
+	rwlock_init(&mgr->ctx_list_lock);
+	mgr->skb = skb;
+	BT_DBG("hcon %p mgr %p", hcon, mgr);
+	mgr->a2mp_sock = open_fixed_channel(&hcon->hdev->bdaddr, &hcon->dst);
+	if (!mgr->a2mp_sock) {
+		kfree(mgr);
+		return NULL;
+	}
+	write_lock(&amp_mgr_list_lock);
+	list_add(&(mgr->list), &amp_mgr_list);
+	write_unlock(&amp_mgr_list_lock);
+
+gc_finished:
+	return mgr;
+}
+
+static struct amp_ctrl *get_ctrl(struct amp_mgr *mgr, u8 remote_id)
+{
+	if ((mgr->ctrls) && (mgr->ctrls->id == remote_id))
+		return mgr->ctrls;
+	else
+		return NULL;
+}
+
+static struct amp_ctrl *get_create_ctrl(struct amp_mgr *mgr, u8 id)
+{
+	struct amp_ctrl *ctrl;
+
+	BT_DBG("mgr %p, id %d", mgr, id);
+	if ((mgr->ctrls) && (mgr->ctrls->id == id))
+		ctrl = mgr->ctrls;
+	else {
+		kfree(mgr->ctrls);
+		ctrl = kzalloc(sizeof(struct amp_ctrl), GFP_ATOMIC);
+		if (ctrl) {
+			ctrl->mgr = mgr;
+			ctrl->id = id;
+		}
+		mgr->ctrls = ctrl;
+	}
+
+	return ctrl;
+}
+
+static struct amp_ctx *create_ctx(u8 type, u8 state)
+{
+	struct amp_ctx *ctx = NULL;
+
+	ctx = kzalloc(sizeof(*ctx), GFP_ATOMIC);
+	if (ctx) {
+		ctx->type = type;
+		ctx->state = state;
+		init_timer(&(ctx->timer));
+		ctx->timer.function = ctx_timeout;
+		ctx->timer.data = (unsigned long) ctx;
+	}
+	BT_DBG("ctx %p, type %d", ctx, type);
+	return ctx;
+}
+
+static inline void start_ctx(struct amp_mgr *mgr, struct amp_ctx *ctx)
+{
+	BT_DBG("ctx %p", ctx);
+	write_lock(&mgr->ctx_list_lock);
+	list_add(&ctx->list, &mgr->ctx_list);
+	write_unlock(&mgr->ctx_list_lock);
+	ctx->mgr = mgr;
+	execute_ctx(ctx, AMP_INIT, 0);
+}
+
+static void destroy_ctx(struct amp_ctx *ctx)
+{
+	struct amp_mgr *mgr = ctx->mgr;
+
+	BT_DBG("ctx %p deferred %p", ctx, ctx->deferred);
+	del_timer(&ctx->timer);
+	write_lock(&mgr->ctx_list_lock);
+	list_del(&ctx->list);
+	write_unlock(&mgr->ctx_list_lock);
+	if (ctx->deferred)
+		execute_ctx(ctx->deferred, AMP_INIT, 0);
+	kfree(ctx);
+}
+
+static struct amp_ctx *get_ctx_mgr(struct amp_mgr *mgr, u8 type)
+{
+	struct amp_ctx *fnd = NULL;
+	struct amp_ctx *ctx;
+
+	read_lock(&mgr->ctx_list_lock);
+	list_for_each_entry(ctx, &mgr->ctx_list, list) {
+		if (ctx->type == type) {
+			fnd = ctx;
+			break;
+		}
+	}
+	read_unlock(&mgr->ctx_list_lock);
+	return fnd;
+}
+
+static struct amp_ctx *get_ctx_type(struct amp_ctx *cur, u8 type)
+{
+	struct amp_mgr *mgr = cur->mgr;
+	struct amp_ctx *fnd = NULL;
+	struct amp_ctx *ctx;
+
+	read_lock(&mgr->ctx_list_lock);
+	list_for_each_entry(ctx, &mgr->ctx_list, list) {
+		if ((ctx->type == type) && (ctx != cur)) {
+			fnd = ctx;
+			break;
+		}
+	}
+	read_unlock(&mgr->ctx_list_lock);
+	return fnd;
+}
+
+static struct amp_ctx *get_ctx_a2mp(struct amp_mgr *mgr, u8 ident)
+{
+	struct amp_ctx *fnd = NULL;
+	struct amp_ctx *ctx;
+
+	read_lock(&mgr->ctx_list_lock);
+	list_for_each_entry(ctx, &mgr->ctx_list, list) {
+		if ((ctx->evt_type & AMP_A2MP_RSP) &&
+				(ctx->rsp_ident == ident)) {
+			fnd = ctx;
+			break;
+		}
+	}
+	read_unlock(&mgr->ctx_list_lock);
+	return fnd;
+}
+
+static struct amp_ctx *get_ctx_hdev(struct hci_dev *hdev, u8 evt_type,
+					u16 evt_value)
+{
+	struct amp_mgr *mgr;
+	struct amp_ctx *fnd = NULL;
+
+	read_lock(&amp_mgr_list_lock);
+	list_for_each_entry(mgr, &amp_mgr_list, list) {
+		struct amp_ctx *ctx;
+		read_lock(&mgr->ctx_list_lock);
+		list_for_each_entry(ctx, &mgr->ctx_list, list) {
+			struct hci_dev *ctx_hdev;
+			ctx_hdev = hci_dev_get(ctx->id);
+			if ((ctx_hdev == hdev) && (ctx->evt_type & evt_type)) {
+				switch (evt_type) {
+				case AMP_HCI_CMD_STATUS:
+				case AMP_HCI_CMD_CMPLT:
+					if (ctx->opcode == evt_value)
+						fnd = ctx;
+					break;
+				case AMP_HCI_EVENT:
+					if (ctx->evt_code == (u8) evt_value)
+						fnd = ctx;
+					break;
+				}
+			}
+			if (ctx_hdev)
+				hci_dev_put(ctx_hdev);
+
+			if (fnd)
+				break;
+		}
+		read_unlock(&mgr->ctx_list_lock);
+	}
+	read_unlock(&amp_mgr_list_lock);
+	return fnd;
+}
+
+static inline u8 next_ident(struct amp_mgr *mgr)
+{
+	if (++mgr->next_ident == 0)
+		mgr->next_ident = 1;
+	return mgr->next_ident;
+}
+
+static inline void send_a2mp_cmd2(struct amp_mgr *mgr, u8 ident, u8 code,
+				u16 len, void *data, u16 len2, void *data2)
+{
+	struct a2mp_cmd_hdr *hdr;
+	int plen;
+	u8 *p, *cmd;
+
+	BT_DBG("ident %d code 0x%02x", ident, code);
+	if (!mgr->a2mp_sock)
+		return;
+	plen = sizeof(*hdr) + len + len2;
+	cmd = kzalloc(plen, GFP_ATOMIC);
+	if (!cmd)
+		return;
+	hdr = (struct a2mp_cmd_hdr *) cmd;
+	hdr->code  = code;
+	hdr->ident = ident;
+	hdr->len   = cpu_to_le16(len+len2);
+	p = cmd + sizeof(*hdr);
+	memcpy(p, data, len);
+	p += len;
+	memcpy(p, data2, len2);
+	send_a2mp(mgr->a2mp_sock, cmd, plen);
+	kfree(cmd);
+}
+
+static inline void send_a2mp_cmd(struct amp_mgr *mgr, u8 ident,
+				u8 code, u16 len, void *data)
+{
+	send_a2mp_cmd2(mgr, ident, code, len, data, 0, NULL);
+}
+
+static inline int command_rej(struct amp_mgr *mgr, struct sk_buff *skb)
+{
+	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
+	struct a2mp_cmd_rej *rej;
+	struct amp_ctx *ctx;
+
+	BT_DBG("ident %d code %d", hdr->ident, hdr->code);
+	rej = (struct a2mp_cmd_rej *) skb_pull(skb, sizeof(*hdr));
+	if (skb->len < sizeof(*rej))
+		return -EINVAL;
+	BT_DBG("reason %d", le16_to_cpu(rej->reason));
+	ctx = get_ctx_a2mp(mgr, hdr->ident);
+	if (ctx)
+		kill_ctx(ctx);
+	skb_pull(skb, sizeof(*rej));
+	return 0;
+}
+
+static int send_a2mp_cl(struct amp_mgr *mgr, u8 ident, u8 code, u16 len,
+			void *msg)
+{
+	struct a2mp_cl clist[16];
+	struct a2mp_cl *cl;
+	struct hci_dev *hdev;
+	int num_ctrls = 1, id;
+
+	cl = clist;
+	cl->id  = 0;
+	cl->type = 0;
+	cl->status = 1;
+
+	for (id = 0; id < 16; ++id) {
+		hdev = hci_dev_get(id);
+		if (hdev) {
+			if ((hdev->amp_type != HCI_BREDR) &&
+			test_bit(HCI_UP, &hdev->flags)) {
+				(cl + num_ctrls)->id  = hdev->id;
+				(cl + num_ctrls)->type = hdev->amp_type;
+				(cl + num_ctrls)->status = hdev->amp_status;
+				++num_ctrls;
+			}
+			hci_dev_put(hdev);
+		}
+	}
+	send_a2mp_cmd2(mgr, ident, code, len, msg,
+						num_ctrls*sizeof(*cl), clist);
+
+	return 0;
+}
+
+static void send_a2mp_change_notify(void)
+{
+	struct amp_mgr *mgr;
+
+	list_for_each_entry(mgr, &amp_mgr_list, list) {
+		if (mgr->discovered)
+			send_a2mp_cl(mgr, next_ident(mgr),
+					A2MP_CHANGE_NOTIFY, 0, NULL);
+	}
+}
+
+static inline int discover_req(struct amp_mgr *mgr, struct sk_buff *skb)
+{
+	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
+	struct a2mp_discover_req *req;
+	u16 *efm;
+	struct a2mp_discover_rsp rsp;
+
+	req = (struct a2mp_discover_req *) skb_pull(skb, sizeof(*hdr));
+	if (skb->len < sizeof(*req))
+		return -EINVAL;
+	efm = (u16 *) skb_pull(skb, sizeof(*req));
+
+	BT_DBG("mtu %d efm 0x%4.4x", le16_to_cpu(req->mtu),
+		le16_to_cpu(req->ext_feat));
+
+	while (le16_to_cpu(req->ext_feat) & 0x8000) {
+		if (skb->len < sizeof(*efm))
+			return -EINVAL;
+		req->ext_feat = *efm;
+		BT_DBG("efm 0x%4.4x", le16_to_cpu(req->ext_feat));
+		efm = (u16 *) skb_pull(skb, sizeof(*efm));
+	}
+
+	rsp.mtu = cpu_to_le16(L2CAP_A2MP_DEFAULT_MTU);
+	rsp.ext_feat = 0;
+
+	mgr->discovered = 1;
+
+	return send_a2mp_cl(mgr, hdr->ident, A2MP_DISCOVER_RSP,
+				sizeof(rsp), &rsp);
+}
+
+static inline int change_notify(struct amp_mgr *mgr, struct sk_buff *skb)
+{
+	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
+	struct a2mp_cl *cl;
+
+	cl = (struct a2mp_cl *) skb_pull(skb, sizeof(*hdr));
+	while (skb->len >= sizeof(*cl)) {
+		struct amp_ctrl *ctrl;
+		if (cl->id != 0) {
+			ctrl = get_create_ctrl(mgr, cl->id);
+			if (ctrl != NULL) {
+				ctrl->type = cl->type;
+				ctrl->status = cl->status;
+			}
+		}
+		cl = (struct a2mp_cl *) skb_pull(skb, sizeof(*cl));
+	}
+
+	/* TODO find controllers in manager that were not on received */
+	/*      controller list and destroy them */
+	send_a2mp_cmd(mgr, hdr->ident, A2MP_CHANGE_RSP, 0, NULL);
+
+	return 0;
+}
+
+static inline int getinfo_req(struct amp_mgr *mgr, struct sk_buff *skb)
+{
+	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
+	u8 *data;
+	int id;
+	struct hci_dev *hdev;
+	struct a2mp_getinfo_rsp rsp;
+
+	data = (u8 *) skb_pull(skb, sizeof(*hdr));
+	if (le16_to_cpu(hdr->len) < sizeof(*data))
+		return -EINVAL;
+	if (skb->len < sizeof(*data))
+		return -EINVAL;
+	id = *data;
+	skb_pull(skb, sizeof(*data));
+	rsp.id = id;
+	rsp.status = 1;
+
+	BT_DBG("id %d", id);
+	hdev = hci_dev_get(id);
+
+	if (hdev && hdev->amp_type != HCI_BREDR) {
+		rsp.status = 0;
+		rsp.total_bw = cpu_to_le32(hdev->amp_total_bw);
+		rsp.max_bw = cpu_to_le32(hdev->amp_max_bw);
+		rsp.min_latency = cpu_to_le32(hdev->amp_min_latency);
+		rsp.pal_cap = cpu_to_le16(hdev->amp_pal_cap);
+		rsp.assoc_size = cpu_to_le16(hdev->amp_assoc_size);
+	}
+
+	send_a2mp_cmd(mgr, hdr->ident, A2MP_GETINFO_RSP, sizeof(rsp), &rsp);
+
+	if (hdev)
+		hci_dev_put(hdev);
+
+	return 0;
+}
+
+static void create_physical(struct l2cap_conn *conn, struct sock *sk)
+{
+	struct amp_mgr *mgr;
+	struct amp_ctx *ctx = NULL;
+
+	BT_DBG("conn %p", conn);
+	mgr = get_create_amp_mgr(conn->hcon, NULL);
+	if (!mgr)
+		goto cp_finished;
+	BT_DBG("mgr %p", mgr);
+	ctx = create_ctx(AMP_CREATEPHYSLINK, AMP_CPL_INIT);
+	if (!ctx)
+		goto cp_finished;
+	ctx->sk = sk;
+	sock_hold(sk);
+	start_ctx(mgr, ctx);
+	return;
+
+cp_finished:
+	l2cap_amp_physical_complete(-ENOMEM, 0, 0, sk);
+}
+
+static void accept_physical(struct l2cap_conn *lcon, u8 id, struct sock *sk)
+{
+	struct amp_mgr *mgr;
+	struct hci_dev *hdev;
+	struct hci_conn *conn;
+	struct amp_ctx *aplctx = NULL;
+	u8 remote_id = 0;
+	int result = -EINVAL;
+
+	BT_DBG("lcon %p", lcon);
+	hdev = hci_dev_get(id);
+	if (!hdev)
+		goto ap_finished;
+	BT_DBG("hdev %p", hdev);
+	mgr = get_create_amp_mgr(lcon->hcon, NULL);
+	if (!mgr)
+		goto ap_finished;
+	BT_DBG("mgr %p", mgr);
+	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,
+					&mgr->l2cap_conn->hcon->dst);
+	if (conn) {
+		BT_DBG("conn %p", hdev);
+		result = 0;
+		remote_id = conn->dst_id;
+		goto ap_finished;
+	}
+	aplctx = get_ctx_mgr(mgr, AMP_ACCEPTPHYSLINK);
+	if (!aplctx)
+		goto ap_finished;
+	aplctx->sk = sk;
+	sock_hold(sk);
+	return;
+
+ap_finished:
+	if (hdev)
+		hci_dev_put(hdev);
+	l2cap_amp_physical_complete(result, id, remote_id, sk);
+}
+
+static int getampassoc_req(struct amp_mgr *mgr, struct sk_buff *skb)
+{
+	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
+	struct amp_ctx *ctx;
+	struct a2mp_getampassoc_req *req;
+
+	if (hdr->len < sizeof(*req))
+		return -EINVAL;
+	req = (struct a2mp_getampassoc_req *) skb_pull(skb, sizeof(*hdr));
+	skb_pull(skb, sizeof(*req));
+
+	ctx = create_ctx(AMP_GETAMPASSOC, AMP_GAA_INIT);
+	if (!ctx)
+		return -ENOMEM;
+	ctx->id = req->id;
+	ctx->d.gaa.req_ident = hdr->ident;
+	ctx->hdev = hci_dev_get(ctx->id);
+	if (ctx->hdev)
+		ctx->d.gaa.assoc = kmalloc(ctx->hdev->amp_assoc_size,
+						GFP_ATOMIC);
+	start_ctx(mgr, ctx);
+	return 0;
+}
+
+static u8 getampassoc_handler(struct amp_ctx *ctx, u8 evt_type, void *data)
+{
+	struct sk_buff *skb = (struct sk_buff *) data;
+	struct hci_cp_read_local_amp_assoc cp;
+	struct hci_rp_read_local_amp_assoc *rp;
+	struct a2mp_getampassoc_rsp rsp;
+	u16 rem_len;
+	u16 frag_len;
+
+	rsp.status = 1;
+	if ((evt_type == AMP_KILLED) || (!ctx->hdev) || (!ctx->d.gaa.assoc))
+		goto gaa_finished;
+
+	switch (ctx->state) {
+	case AMP_GAA_INIT:
+		ctx->state = AMP_GAA_RLAA_COMPLETE;
+		ctx->evt_type = AMP_HCI_CMD_CMPLT;
+		ctx->opcode = HCI_OP_READ_LOCAL_AMP_ASSOC;
+		ctx->d.gaa.len_so_far = 0;
+		cp.phy_handle = 0;
+		cp.len_so_far = 0;
+		cp.max_len = ctx->hdev->amp_assoc_size;
+		hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(cp), &cp);
+		break;
+
+	case AMP_GAA_RLAA_COMPLETE:
+		if (skb->len < 4)
+			goto gaa_finished;
+		rp = (struct hci_rp_read_local_amp_assoc *) skb->data;
+		if (rp->status)
+			goto gaa_finished;
+		rem_len = le16_to_cpu(rp->rem_len);
+		skb_pull(skb, 4);
+		frag_len = skb->len;
+
+		if (ctx->d.gaa.len_so_far + rem_len <=
+				ctx->hdev->amp_assoc_size) {
+			struct hci_cp_read_local_amp_assoc cp;
+			u8 *assoc = ctx->d.gaa.assoc + ctx->d.gaa.len_so_far;
+			memcpy(assoc, rp->frag, frag_len);
+			ctx->d.gaa.len_so_far += rem_len;
+			rem_len -= frag_len;
+			if (rem_len == 0) {
+				rsp.status = 0;
+				goto gaa_finished;
+			}
+			/* more assoc data to read */
+			cp.phy_handle = 0;
+			cp.len_so_far = ctx->d.gaa.len_so_far;
+			cp.max_len = ctx->hdev->amp_assoc_size;
+			hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(cp), &cp);
+		}
+		break;
+
+	default:
+		goto gaa_finished;
+		break;
+	}
+	return 0;
+
+gaa_finished:
+	rsp.id = ctx->id;
+	send_a2mp_cmd2(ctx->mgr, ctx->d.gaa.req_ident, A2MP_GETAMPASSOC_RSP,
+			sizeof(rsp), &rsp,
+			ctx->d.gaa.len_so_far, ctx->d.gaa.assoc);
+	kfree(ctx->d.gaa.assoc);
+	if (ctx->hdev)
+		hci_dev_put(ctx->hdev);
+	return 1;
+}
+
+struct hmac_sha256_result {
+	struct completion completion;
+	int err;
+};
+
+static void hmac_sha256_final(struct crypto_async_request *req, int err)
+{
+	struct hmac_sha256_result *r = req->data;
+	if (err == -EINPROGRESS)
+		return;
+	r->err = err;
+	complete(&r->completion);
+}
+
+int hmac_sha256(u8 *key, u8 ksize, char *plaintext, u8 psize,
+		u8 *output, u8 outlen)
+{
+	int ret = 0;
+	struct crypto_ahash *tfm;
+	struct scatterlist sg;
+	struct ahash_request *req;
+	struct hmac_sha256_result tresult;
+	void *hash_buff = NULL;
+
+	unsigned char hash_result[64];
+	int i;
+
+	memset(output, 0, outlen);
+
+	init_completion(&tresult.completion);
+
+	tfm = crypto_alloc_ahash("hmac(sha256)", CRYPTO_ALG_TYPE_AHASH,
+				CRYPTO_ALG_TYPE_AHASH_MASK);
+	if (IS_ERR(tfm)) {
+		BT_DBG("crypto_alloc_ahash failed");
+		ret = PTR_ERR(tfm);
+		goto err_tfm;
+	}
+
+	req = ahash_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		BT_DBG("failed to allocate request for hmac(sha256)");
+		ret = -ENOMEM;
+		goto err_req;
+	}
+
+	ahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+					hmac_sha256_final, &tresult);
+
+	hash_buff = kzalloc(psize, GFP_KERNEL);
+	if (!hash_buff) {
+		BT_DBG("failed to kzalloc hash_buff");
+		ret = -ENOMEM;
+		goto err_hash_buf;
+	}
+
+	memset(hash_result, 0, 64);
+	memcpy(hash_buff, plaintext, psize);
+	sg_init_one(&sg, hash_buff, psize);
+
+	if (ksize) {
+		crypto_ahash_clear_flags(tfm, ~0);
+		ret = crypto_ahash_setkey(tfm, key, ksize);
+
+		if (ret) {
+			BT_DBG("crypto_ahash_setkey failed");
+			goto err_setkey;
+		}
+	}
+
+	ahash_request_set_crypt(req, &sg, hash_result, psize);
+	ret = crypto_ahash_digest(req);
+
+	BT_DBG("ret 0x%x", ret);
+
+	switch (ret) {
+	case 0:
+		for (i = 0; i < outlen; i++)
+			output[i] = hash_result[i];
+		break;
+	case -EINPROGRESS:
+	case -EBUSY:
+		ret = wait_for_completion_interruptible(&tresult.completion);
+		if (!ret && !tresult.err) {
+			INIT_COMPLETION(tresult.completion);
+			break;
+		} else {
+			BT_DBG("wait_for_completion_interruptible failed");
+			if (!ret)
+				ret = tresult.err;
+			goto out;
+		}
+	default:
+		goto out;
+	}
+
+out:
+err_setkey:
+	kfree(hash_buff);
+err_hash_buf:
+	ahash_request_free(req);
+err_req:
+	crypto_free_ahash(tfm);
+err_tfm:
+	return ret;
+}
+
+static void show_key(u8 *k)
+{
+	int i = 0;
+	for (i = 0; i < 32; i += 8)
+		BT_DBG("    %02x %02x %02x %02x %02x %02x %02x %02x",
+				*(k+i+0), *(k+i+1), *(k+i+2), *(k+i+3),
+				*(k+i+4), *(k+i+5), *(k+i+6), *(k+i+7));
+}
+
+static int physlink_security(struct hci_conn *conn, u8 *data, u8 *len, u8 *type)
+{
+	u8 bt2_key[32];
+	u8 gamp_key[32];
+	u8 b802_key[32];
+	int result;
+
+	if (!hci_conn_check_link_mode(conn))
+		return -EACCES;
+
+	BT_DBG("key_type %d", conn->key_type);
+	if (conn->key_type < 3)
+		return -EACCES;
+
+	*type = conn->key_type;
+	*len = 32;
+	memcpy(&bt2_key[0], conn->link_key, 16);
+	memcpy(&bt2_key[16], conn->link_key, 16);
+	result = hmac_sha256(bt2_key, 32, "gamp", 4, gamp_key, 32);
+	if (result)
+		goto ps_finished;
+
+	if (conn->key_type == 3) {
+		BT_DBG("gamp_key");
+		show_key(gamp_key);
+		memcpy(data, gamp_key, 32);
+		goto ps_finished;
+	}
+
+	result = hmac_sha256(gamp_key, 32, "802b", 4, b802_key, 32);
+	if (result)
+		goto ps_finished;
+
+	BT_DBG("802b_key");
+	show_key(b802_key);
+	memcpy(data, b802_key, 32);
+
+ps_finished:
+	return result;
+}
+
+static u8 amp_next_handle;
+static inline u8 physlink_handle(struct hci_dev *hdev)
+{
+	/* TODO amp_next_handle should be part of hci_dev */
+	if (amp_next_handle == 0)
+		amp_next_handle = 1;
+	return amp_next_handle++;
+}
+
+/* Start an Accept Physical Link sequence */
+static int createphyslink_req(struct amp_mgr *mgr, struct sk_buff *skb)
+{
+	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
+	struct amp_ctx *ctx = NULL;
+	struct a2mp_createphyslink_req *req;
+
+	if (hdr->len < sizeof(*req))
+		return -EINVAL;
+	req = (struct a2mp_createphyslink_req *) skb_pull(skb, sizeof(*hdr));
+	skb_pull(skb, sizeof(*req));
+	BT_DBG("local_id %d, remote_id %d", req->local_id, req->remote_id);
+
+	/* initialize the context */
+	ctx = create_ctx(AMP_ACCEPTPHYSLINK, AMP_APL_INIT);
+	if (!ctx)
+		return -ENOMEM;
+	ctx->d.apl.req_ident = hdr->ident;
+	ctx->d.apl.remote_id = req->local_id;
+	ctx->id = req->remote_id;
+
+	/* add the supplied remote assoc to the context */
+	ctx->d.apl.remote_assoc = kmalloc(skb->len, GFP_ATOMIC);
+	if (ctx->d.apl.remote_assoc)
+		memcpy(ctx->d.apl.remote_assoc, skb->data, skb->len);
+	ctx->d.apl.len_so_far = 0;
+	ctx->d.apl.rem_len = skb->len;
+	skb_pull(skb, skb->len);
+	ctx->hdev = hci_dev_get(ctx->id);
+	start_ctx(mgr, ctx);
+	return 0;
+}
+
+static u8 acceptphyslink_handler(struct amp_ctx *ctx, u8 evt_type, void *data)
+{
+	struct sk_buff *skb = data;
+	struct hci_cp_accept_phys_link acp;
+	struct hci_cp_write_remote_amp_assoc wcp;
+	struct hci_rp_write_remote_amp_assoc *wrp;
+	struct hci_ev_cmd_status *cs = data;
+	struct hci_ev_phys_link_complete *ev;
+	struct a2mp_createphyslink_rsp rsp;
+	struct amp_ctx *cplctx;
+	struct amp_ctx *aplctx;
+	u16 frag_len;
+	struct hci_conn *conn;
+	int result;
+
+	BT_DBG("state %d", ctx->state);
+	result = -EINVAL;
+	rsp.status = 1;        /* Invalid Controller ID */
+	if (!ctx->hdev || !test_bit(HCI_UP, &ctx->hdev->flags))
+		goto apl_finished;
+	if (evt_type == AMP_KILLED) {
+		result = -EAGAIN;
+		rsp.status = 4;        /* Disconnect request received */
+		goto apl_finished;
+	}
+	if (!ctx->d.apl.remote_assoc) {
+		result = -ENOMEM;
+		rsp.status = 2;        /* Unable to Start */
+		goto apl_finished;
+	}
+
+	switch (ctx->state) {
+	case AMP_APL_INIT:
+		BT_DBG("local_id %d, remote_id %d",
+			ctx->id, ctx->d.apl.remote_id);
+		conn = hci_conn_hash_lookup_id(ctx->hdev,
+					&ctx->mgr->l2cap_conn->hcon->dst,
+					ctx->d.apl.remote_id);
+		if (conn) {
+			result = -EEXIST;
+			rsp.status = 5;   /* Already Exists */
+			goto apl_finished;
+		}
+
+		aplctx = get_ctx_type(ctx, AMP_ACCEPTPHYSLINK);
+		if ((aplctx) &&
+			(aplctx->d.cpl.remote_id == ctx->d.apl.remote_id)) {
+			BT_DBG("deferred to %p", aplctx);
+			aplctx->deferred = ctx;
+			break;
+		}
+
+		cplctx = get_ctx_type(ctx, AMP_CREATEPHYSLINK);
+		if ((cplctx) &&
+			(cplctx->d.cpl.remote_id == ctx->d.apl.remote_id)) {
+			struct hci_conn *bcon = ctx->mgr->l2cap_conn->hcon;
+			BT_DBG("local %s remote %s",
+				batostr(&bcon->hdev->bdaddr),
+				batostr(&bcon->dst));
+			if ((cplctx->state < AMP_CPL_PL_COMPLETE) ||
+				(bacmp(&bcon->hdev->bdaddr, &bcon->dst) < 0)) {
+				BT_DBG("COLLISION LOSER");
+				cplctx->deferred = ctx;
+				cancel_ctx(cplctx);
+				break;
+			} else {
+				BT_DBG("COLLISION WINNER");
+				result = -EISCONN;
+				rsp.status = 3;    /* Collision */
+				goto apl_finished;
+			}
+		}
+
+		result = physlink_security(ctx->mgr->l2cap_conn->hcon, acp.data,
+						&acp.key_len, &acp.type);
+		if (result) {
+			BT_DBG("SECURITY");
+			rsp.status = 6;    /* Security Violation */
+			goto apl_finished;
+		}
+
+		ctx->d.apl.phy_handle = physlink_handle(ctx->hdev);
+		ctx->state = AMP_APL_APL_STATUS;
+		ctx->evt_type = AMP_HCI_CMD_STATUS;
+		ctx->opcode = HCI_OP_ACCEPT_PHYS_LINK;
+		acp.phy_handle = ctx->d.apl.phy_handle;
+		hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(acp), &acp);
+		break;
+
+	case AMP_APL_APL_STATUS:
+		if (cs->status != 0)
+			goto apl_finished;
+		/* PAL will accept link, send a2mp response */
+		rsp.local_id = ctx->id;
+		rsp.remote_id = ctx->d.apl.remote_id;
+		rsp.status = 0;
+		send_a2mp_cmd(ctx->mgr, ctx->d.apl.req_ident,
+				A2MP_CREATEPHYSLINK_RSP, sizeof(rsp), &rsp);
+
+		/* send the first assoc fragment */
+		wcp.phy_handle = ctx->d.apl.phy_handle;
+		wcp.len_so_far = cpu_to_le16(ctx->d.apl.len_so_far);
+		wcp.rem_len = cpu_to_le16(ctx->d.apl.rem_len);
+		frag_len = min_t(u16, 248, ctx->d.apl.rem_len);
+		memcpy(wcp.frag, ctx->d.apl.remote_assoc, frag_len);
+		ctx->state = AMP_APL_WRA_COMPLETE;
+		ctx->evt_type = AMP_HCI_CMD_CMPLT;
+		ctx->opcode = HCI_OP_WRITE_REMOTE_AMP_ASSOC;
+		hci_send_cmd(ctx->hdev, ctx->opcode, 5+frag_len, &wcp);
+		break;
+
+	case AMP_APL_WRA_COMPLETE:
+		/* received write remote amp assoc command complete event */
+		wrp = (struct hci_rp_write_remote_amp_assoc *) skb->data;
+		if (wrp->status != 0)
+			goto apl_finished;
+		if (wrp->phy_handle != ctx->d.apl.phy_handle)
+			goto apl_finished;
+		/* update progress */
+		frag_len = min_t(u16, 248, ctx->d.apl.rem_len);
+		ctx->d.apl.len_so_far += frag_len;
+		ctx->d.apl.rem_len -= frag_len;
+		if (ctx->d.apl.rem_len > 0) {
+			u8 *assoc;
+			/* another assoc fragment to send */
+			wcp.phy_handle = ctx->d.apl.phy_handle;
+			wcp.len_so_far = cpu_to_le16(ctx->d.apl.len_so_far);
+			wcp.rem_len = cpu_to_le16(ctx->d.apl.rem_len);
+			frag_len = min_t(u16, 248, ctx->d.apl.rem_len);
+			assoc = ctx->d.apl.remote_assoc + ctx->d.apl.len_so_far;
+			memcpy(wcp.frag, assoc, frag_len);
+			hci_send_cmd(ctx->hdev, ctx->opcode, 5+frag_len, &wcp);
+			break;
+		}
+		/* wait for physical link complete event */
+		ctx->state = AMP_APL_PL_COMPLETE;
+		ctx->evt_type = AMP_HCI_EVENT;
+		ctx->evt_code = HCI_EV_PHYS_LINK_COMPLETE;
+		break;
+
+	case AMP_APL_PL_COMPLETE:
+		/* physical link complete event received */
+		if (skb->len < sizeof(*ev))
+			goto apl_finished;
+		ev = (struct hci_ev_phys_link_complete *) skb->data;
+		if (ev->phy_handle != ctx->d.apl.phy_handle)
+			break;
+		if (ev->status != 0)
+			goto apl_finished;
+		conn = hci_conn_hash_lookup_handle(ctx->hdev, ev->phy_handle);
+		if (!conn)
+			goto apl_finished;
+		result = 0;
+		BT_DBG("PL_COMPLETE phy_handle %x", ev->phy_handle);
+		conn->dst_id = ctx->d.apl.remote_id;
+		bacpy(&conn->dst, &ctx->mgr->l2cap_conn->hcon->dst);
+		goto apl_finished;
+		break;
+
+	default:
+		goto apl_finished;
+		break;
+	}
+	return 0;
+
+apl_finished:
+	if (ctx->sk)
+		l2cap_amp_physical_complete(result, ctx->id,
+					ctx->d.apl.remote_id, ctx->sk);
+	if ((result) && (ctx->state < AMP_APL_PL_COMPLETE)) {
+		rsp.local_id = ctx->id;
+		rsp.remote_id = ctx->d.apl.remote_id;
+		send_a2mp_cmd(ctx->mgr, ctx->d.apl.req_ident,
+				A2MP_CREATEPHYSLINK_RSP, sizeof(rsp), &rsp);
+	}
+	kfree(ctx->d.apl.remote_assoc);
+	if (ctx->sk)
+		sock_put(ctx->sk);
+	if (ctx->hdev)
+		hci_dev_put(ctx->hdev);
+	return 1;
+}
+
+static void cancel_cpl_ctx(struct amp_ctx *ctx, u8 reason)
+{
+	struct hci_cp_disconn_phys_link dcp;
+
+	ctx->state = AMP_CPL_PL_CANCEL;
+	ctx->evt_type = AMP_HCI_EVENT;
+	ctx->evt_code = HCI_EV_DISCONN_PHYS_LINK_COMPLETE;
+	dcp.phy_handle = ctx->d.cpl.phy_handle;
+	dcp.reason = reason;
+	hci_send_cmd(ctx->hdev, HCI_OP_DISCONN_PHYS_LINK, sizeof(dcp), &dcp);
+}
+
+static u8 createphyslink_handler(struct amp_ctx *ctx, u8 evt_type, void *data)
+{
+	struct amp_ctrl *ctrl;
+	struct sk_buff *skb = data;
+	struct a2mp_cmd_hdr *hdr;
+	struct hci_ev_cmd_status *cs = data;
+	struct amp_ctx *cplctx;
+	struct a2mp_discover_req dreq;
+	struct a2mp_discover_rsp *drsp;
+	u16 *efm;
+	struct a2mp_getinfo_req greq;
+	struct a2mp_getinfo_rsp *grsp;
+	struct a2mp_cl *cl;
+	struct a2mp_getampassoc_req areq;
+	struct a2mp_getampassoc_rsp *arsp;
+	struct hci_cp_create_phys_link cp;
+	struct hci_cp_write_remote_amp_assoc wcp;
+	struct hci_rp_write_remote_amp_assoc *wrp;
+	struct hci_ev_channel_selected *cev;
+	struct hci_cp_read_local_amp_assoc rcp;
+	struct hci_rp_read_local_amp_assoc *rrp;
+	struct a2mp_createphyslink_req creq;
+	struct a2mp_createphyslink_rsp *crsp;
+	struct hci_ev_phys_link_complete *pev;
+	struct hci_ev_disconn_phys_link_complete *dev;
+	u8 *assoc, *rassoc, *lassoc;
+	u16 frag_len;
+	u16 rem_len;
+	int result = -EAGAIN;
+	struct hci_conn *conn;
+
+	BT_DBG("state %d", ctx->state);
+	if (evt_type == AMP_KILLED)
+		goto cpl_finished;
+
+	if (evt_type == AMP_CANCEL) {
+		if ((ctx->state < AMP_CPL_CPL_STATUS) ||
+			((ctx->state == AMP_CPL_PL_COMPLETE) &&
+			!(ctx->evt_type & AMP_HCI_EVENT)))
+			goto cpl_finished;
+
+		cancel_cpl_ctx(ctx, 0x16);
+		return 0;
+	}
+
+	switch (ctx->state) {
+	case AMP_CPL_INIT:
+		cplctx = get_ctx_type(ctx, AMP_CREATEPHYSLINK);
+		if (cplctx) {
+			BT_DBG("deferred to %p", cplctx);
+			cplctx->deferred = ctx;
+			break;
+		}
+		ctx->state = AMP_CPL_DISC_RSP;
+		ctx->evt_type = AMP_A2MP_RSP;
+		ctx->rsp_ident = next_ident(ctx->mgr);
+		dreq.mtu = cpu_to_le16(L2CAP_A2MP_DEFAULT_MTU);
+		dreq.ext_feat = 0;
+		send_a2mp_cmd(ctx->mgr, ctx->rsp_ident, A2MP_DISCOVER_REQ,
+							sizeof(dreq), &dreq);
+		break;
+
+	case AMP_CPL_DISC_RSP:
+		drsp = (struct a2mp_discover_rsp *) skb_pull(skb, sizeof(*hdr));
+		if (skb->len < (sizeof(*drsp))) {
+			result = -EINVAL;
+			goto cpl_finished;
+		}
+
+		efm = (u16 *) skb_pull(skb, sizeof(*drsp));
+		BT_DBG("mtu %d efm 0x%4.4x", le16_to_cpu(drsp->mtu),
+						le16_to_cpu(drsp->ext_feat));
+
+		while (le16_to_cpu(drsp->ext_feat) & 0x8000) {
+			if (skb->len < sizeof(*efm)) {
+				result = -EINVAL;
+				goto cpl_finished;
+			}
+			drsp->ext_feat = *efm;
+			BT_DBG("efm 0x%4.4x", le16_to_cpu(drsp->ext_feat));
+			efm = (u16 *) skb_pull(skb, sizeof(*efm));
+		}
+		cl = (struct a2mp_cl *) efm;
+
+		/* find the first remote and local controller with the
+		 * same type
+		 */
+		greq.id = 0;
+		result = -ENODEV;
+		while (skb->len >= sizeof(*cl)) {
+			if ((cl->id != 0) && (greq.id == 0)) {
+				struct hci_dev *hdev;
+				hdev = hci_dev_get_type(cl->type);
+				if (hdev) {
+					struct hci_conn *conn;
+					ctx->hdev = hdev;
+					ctx->id = hdev->id;
+					ctx->d.cpl.remote_id = cl->id;
+					conn = hci_conn_hash_lookup_ba(hdev,
+					    ACL_LINK,
+					    &ctx->mgr->l2cap_conn->hcon->dst);
+					if (conn) {
+						BT_DBG("PL_COMPLETE exists %x",
+							(int) conn->handle);
+						result = 0;
+					}
+					ctrl = get_create_ctrl(ctx->mgr,
+								cl->id);
+					if (ctrl) {
+						ctrl->type = cl->type;
+						ctrl->status = cl->status;
+					}
+					greq.id = cl->id;
+				}
+			}
+			cl = (struct a2mp_cl *) skb_pull(skb, sizeof(*cl));
+		}
+		if ((!greq.id) || (!result))
+			goto cpl_finished;
+		ctx->state = AMP_CPL_GETINFO_RSP;
+		ctx->evt_type = AMP_A2MP_RSP;
+		ctx->rsp_ident = next_ident(ctx->mgr);
+		send_a2mp_cmd(ctx->mgr, ctx->rsp_ident, A2MP_GETINFO_REQ,
+							sizeof(greq), &greq);
+		break;
+
+	case AMP_CPL_GETINFO_RSP:
+		if (skb->len < sizeof(*grsp))
+			goto cpl_finished;
+		grsp = (struct a2mp_getinfo_rsp *) skb_pull(skb, sizeof(*hdr));
+		skb_pull(skb, sizeof(*grsp));
+		if (grsp->status)
+			goto cpl_finished;
+		if (grsp->id != ctx->d.cpl.remote_id)
+			goto cpl_finished;
+		ctrl = get_ctrl(ctx->mgr, grsp->id);
+		if (!ctrl)
+			goto cpl_finished;
+		ctrl->status = grsp->status;
+		ctrl->total_bw = le32_to_cpu(grsp->total_bw);
+		ctrl->max_bw = le32_to_cpu(grsp->max_bw);
+		ctrl->min_latency = le32_to_cpu(grsp->min_latency);
+		ctrl->pal_cap = le16_to_cpu(grsp->pal_cap);
+		ctrl->max_assoc_size = le16_to_cpu(grsp->assoc_size);
+
+		ctx->d.cpl.max_len = ctrl->max_assoc_size;
+
+		/* setup up GAA request */
+		areq.id = ctx->d.cpl.remote_id;
+
+		/* advance context state */
+		ctx->state = AMP_CPL_GAA_RSP;
+		ctx->evt_type = AMP_A2MP_RSP;
+		ctx->rsp_ident = next_ident(ctx->mgr);
+		send_a2mp_cmd(ctx->mgr, ctx->rsp_ident, A2MP_GETAMPASSOC_REQ,
+							sizeof(areq), &areq);
+		break;
+
+	case AMP_CPL_GAA_RSP:
+		if (skb->len < sizeof(*arsp))
+			goto cpl_finished;
+		hdr = (void *) skb->data;
+		arsp = (void *) skb_pull(skb, sizeof(*hdr));
+		if (arsp->status != 0)
+			goto cpl_finished;
+
+		/* store away remote assoc */
+		assoc = (u8 *) skb_pull(skb, sizeof(*arsp));
+		ctx->d.cpl.len_so_far = 0;
+		ctx->d.cpl.rem_len = hdr->len - sizeof(*arsp);
+		skb_pull(skb, ctx->d.cpl.rem_len);
+		rassoc = kmalloc(ctx->d.cpl.rem_len, GFP_ATOMIC);
+		if (!rassoc)
+			goto cpl_finished;
+		memcpy(rassoc, assoc, ctx->d.cpl.rem_len);
+		ctx->d.cpl.remote_assoc = rassoc;
+
+		/* set up CPL command */
+		ctx->d.cpl.phy_handle = physlink_handle(ctx->hdev);
+		cp.phy_handle = ctx->d.cpl.phy_handle;
+		if (physlink_security(ctx->mgr->l2cap_conn->hcon, cp.data,
+					&cp.key_len, &cp.type)) {
+			result = -EPERM;
+			goto cpl_finished;
+		}
+
+		/* advance context state */
+		ctx->state = AMP_CPL_CPL_STATUS;
+		ctx->evt_type = AMP_HCI_CMD_STATUS;
+		ctx->opcode = HCI_OP_CREATE_PHYS_LINK;
+		hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(cp), &cp);
+		break;
+
+	case AMP_CPL_CPL_STATUS:
+		/* received create physical link command status */
+		if (cs->status != 0)
+			goto cpl_finished;
+		/* send the first assoc fragment */
+		wcp.phy_handle = ctx->d.cpl.phy_handle;
+		wcp.len_so_far = ctx->d.cpl.len_so_far;
+		wcp.rem_len = cpu_to_le16(ctx->d.cpl.rem_len);
+		frag_len = min_t(u16, 248, ctx->d.cpl.rem_len);
+		memcpy(wcp.frag, ctx->d.cpl.remote_assoc, frag_len);
+		ctx->state = AMP_CPL_WRA_COMPLETE;
+		ctx->evt_type = AMP_HCI_CMD_CMPLT;
+		ctx->opcode = HCI_OP_WRITE_REMOTE_AMP_ASSOC;
+		hci_send_cmd(ctx->hdev, ctx->opcode, 5+frag_len, &wcp);
+		break;
+
+	case AMP_CPL_WRA_COMPLETE:
+		/* received write remote amp assoc command complete event */
+		if (skb->len < sizeof(*wrp))
+			goto cpl_finished;
+		wrp = (struct hci_rp_write_remote_amp_assoc *) skb->data;
+		if (wrp->status != 0)
+			goto cpl_finished;
+		if (wrp->phy_handle != ctx->d.cpl.phy_handle)
+			goto cpl_finished;
+
+		/* update progress */
+		frag_len = min_t(u16, 248, ctx->d.cpl.rem_len);
+		ctx->d.cpl.len_so_far += frag_len;
+		ctx->d.cpl.rem_len -= frag_len;
+		if (ctx->d.cpl.rem_len > 0) {
+			/* another assoc fragment to send */
+			wcp.phy_handle = ctx->d.cpl.phy_handle;
+			wcp.len_so_far = cpu_to_le16(ctx->d.cpl.len_so_far);
+			wcp.rem_len = cpu_to_le16(ctx->d.cpl.rem_len);
+			frag_len = min_t(u16, 248, ctx->d.cpl.rem_len);
+			memcpy(wcp.frag,
+				ctx->d.cpl.remote_assoc + ctx->d.cpl.len_so_far,
+				frag_len);
+			hci_send_cmd(ctx->hdev, ctx->opcode, 5+frag_len, &wcp);
+			break;
+		}
+		/* now wait for channel selected event */
+		ctx->state = AMP_CPL_CHANNEL_SELECT;
+		ctx->evt_type = AMP_HCI_EVENT;
+		ctx->evt_code = HCI_EV_CHANNEL_SELECTED;
+		break;
+
+	case AMP_CPL_CHANNEL_SELECT:
+		/* received channel selection event */
+		if (skb->len < sizeof(*cev))
+			goto cpl_finished;
+		cev = (void *) skb->data;
+/* TODO - PK This check is valid but Libra PAL returns 0 for handle during
+			Create Physical Link collision scenario
+		if (cev->phy_handle != ctx->d.cpl.phy_handle)
+			goto cpl_finished;
+*/
+
+		/* request the first local assoc fragment */
+		rcp.phy_handle = ctx->d.cpl.phy_handle;
+		rcp.len_so_far = 0;
+		rcp.max_len = ctx->d.cpl.max_len;
+		lassoc = kmalloc(ctx->d.cpl.max_len, GFP_ATOMIC);
+		if (!lassoc)
+			goto cpl_finished;
+		ctx->d.cpl.local_assoc = lassoc;
+		ctx->d.cpl.len_so_far = 0;
+		ctx->state = AMP_CPL_RLA_COMPLETE;
+		ctx->evt_type = AMP_HCI_CMD_CMPLT;
+		ctx->opcode = HCI_OP_READ_LOCAL_AMP_ASSOC;
+		hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(rcp), &rcp);
+		break;
+
+	case AMP_CPL_RLA_COMPLETE:
+		/* received read local amp assoc command complete event */
+		if (skb->len < 4)
+			goto cpl_finished;
+		rrp = (struct hci_rp_read_local_amp_assoc *) skb->data;
+		if (rrp->status)
+			goto cpl_finished;
+		if (rrp->phy_handle != ctx->d.cpl.phy_handle)
+			goto cpl_finished;
+		rem_len = le16_to_cpu(rrp->rem_len);
+		skb_pull(skb, 4);
+		frag_len = skb->len;
+
+		if (ctx->d.cpl.len_so_far + rem_len > ctx->d.cpl.max_len)
+			goto cpl_finished;
+
+		/* save this fragment in context */
+		lassoc = ctx->d.cpl.local_assoc + ctx->d.cpl.len_so_far;
+		memcpy(lassoc, rrp->frag, frag_len);
+		ctx->d.cpl.len_so_far += frag_len;
+		rem_len -= frag_len;
+		if (rem_len > 0) {
+			/* request another local assoc fragment */
+			rcp.phy_handle = ctx->d.cpl.phy_handle;
+			rcp.len_so_far = ctx->d.cpl.len_so_far;
+			rcp.max_len = ctx->d.cpl.max_len;
+			hci_send_cmd(ctx->hdev, ctx->opcode, sizeof(rcp), &rcp);
+		} else {
+			creq.local_id = ctx->id;
+			creq.remote_id = ctx->d.cpl.remote_id;
+			/* wait for A2MP rsp AND phys link complete event */
+			ctx->state = AMP_CPL_PL_COMPLETE;
+			ctx->evt_type = AMP_A2MP_RSP | AMP_HCI_EVENT;
+			ctx->rsp_ident = next_ident(ctx->mgr);
+			ctx->evt_code = HCI_EV_PHYS_LINK_COMPLETE;
+			send_a2mp_cmd2(ctx->mgr, ctx->rsp_ident,
+				A2MP_CREATEPHYSLINK_REQ, sizeof(creq), &creq,
+				ctx->d.cpl.len_so_far, ctx->d.cpl.local_assoc);
+		}
+		break;
+
+	case AMP_CPL_PL_COMPLETE:
+		if (evt_type == AMP_A2MP_RSP) {
+			/* create physical link response received */
+			ctx->evt_type &= ~AMP_A2MP_RSP;
+			if (skb->len < sizeof(*crsp))
+				goto cpl_finished;
+			crsp = (void *) skb_pull(skb, sizeof(*hdr));
+			if ((crsp->local_id != ctx->d.cpl.remote_id) ||
+				(crsp->remote_id != ctx->id) ||
+				(crsp->status != 0)) {
+				cancel_cpl_ctx(ctx, 0x13);
+				break;
+			}
+
+			/* notify Qualcomm PAL */
+			if (ctx->hdev->manufacturer == 0x001d)
+				hci_send_cmd(ctx->hdev,
+					hci_opcode_pack(0x3f, 0x00), 0, NULL);
+		}
+		if (evt_type == AMP_HCI_EVENT) {
+			ctx->evt_type &= ~AMP_HCI_EVENT;
+			/* physical link complete event received */
+			if (skb->len < sizeof(*pev))
+				goto cpl_finished;
+			pev = (void *) skb->data;
+			if (pev->phy_handle != ctx->d.cpl.phy_handle)
+				break;
+			if (pev->status != 0)
+				goto cpl_finished;
+		}
+		if (ctx->evt_type)
+			break;
+		conn = hci_conn_hash_lookup_handle(ctx->hdev,
+							ctx->d.cpl.phy_handle);
+		if (!conn)
+			goto cpl_finished;
+		result = 0;
+		BT_DBG("PL_COMPLETE phy_handle %x", ctx->d.cpl.phy_handle);
+		bacpy(&conn->dst, &ctx->mgr->l2cap_conn->hcon->dst);
+		conn->dst_id = ctx->d.cpl.remote_id;
+		conn->out = 1;
+		goto cpl_finished;
+		break;
+
+	case AMP_CPL_PL_CANCEL:
+		dev = (void *) skb->data;
+		BT_DBG("PL_COMPLETE cancelled %x", dev->phy_handle);
+		result = -EISCONN;
+		goto cpl_finished;
+		break;
+
+	default:
+		goto cpl_finished;
+		break;
+	}
+	return 0;
+
+cpl_finished:
+	l2cap_amp_physical_complete(result, ctx->id, ctx->d.cpl.remote_id,
+					ctx->sk);
+	if (ctx->sk)
+		sock_put(ctx->sk);
+	if (ctx->hdev)
+		hci_dev_put(ctx->hdev);
+	kfree(ctx->d.cpl.remote_assoc);
+	kfree(ctx->d.cpl.local_assoc);
+	return 1;
+}
+
+static int disconnphyslink_req(struct amp_mgr *mgr, struct sk_buff *skb)
+{
+	struct a2mp_cmd_hdr *hdr = (void *) skb->data;
+	struct a2mp_disconnphyslink_req *req;
+	struct a2mp_disconnphyslink_rsp rsp;
+	struct hci_dev *hdev;
+	struct hci_conn *conn;
+	struct amp_ctx *aplctx;
+
+	BT_DBG("mgr %p skb %p", mgr, skb);
+	if (hdr->len < sizeof(*req))
+		return -EINVAL;
+	req = (void *) skb_pull(skb, sizeof(*hdr));
+	skb_pull(skb, sizeof(*req));
+
+	rsp.local_id = req->remote_id;
+	rsp.remote_id = req->local_id;
+	rsp.status = 0;
+	BT_DBG("local_id %d remote_id %d",
+		(int) rsp.local_id, (int) rsp.remote_id);
+	hdev = hci_dev_get(rsp.local_id);
+	if (!hdev) {
+		rsp.status = 1; /* Invalid Controller ID */
+		goto dpl_finished;
+	}
+	BT_DBG("hdev %p", hdev);
+	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK,
+					&mgr->l2cap_conn->hcon->dst);
+	if (!conn) {
+		aplctx = get_ctx_mgr(mgr, AMP_ACCEPTPHYSLINK);
+		if (aplctx) {
+			kill_ctx(aplctx);
+			rsp.status = 0;
+			goto dpl_finished;
+		}
+		rsp.status = 2;  /* No Physical Link exists */
+		goto dpl_finished;
+	}
+	BT_DBG("conn %p", conn);
+	hci_disconnect(conn, 0x13);
+
+dpl_finished:
+	send_a2mp_cmd(mgr, hdr->ident,
+				A2MP_DISCONNPHYSLINK_RSP, sizeof(rsp), &rsp);
+	if (hdev)
+		hci_dev_put(hdev);
+	return 0;
+}
+
+static int execute_ctx(struct amp_ctx *ctx, u8 evt_type, void *data)
+{
+	struct amp_mgr *mgr = ctx->mgr;
+	u8 finished = 0;
+
+	if (!mgr->connected)
+		return 0;
+
+	switch (ctx->type) {
+	case AMP_GETAMPASSOC:
+		finished = getampassoc_handler(ctx, evt_type, data);
+		break;
+	case AMP_CREATEPHYSLINK:
+		finished = createphyslink_handler(ctx, evt_type, data);
+		break;
+	case AMP_ACCEPTPHYSLINK:
+		finished = acceptphyslink_handler(ctx, evt_type, data);
+		break;
+	}
+
+	if (!finished)
+		mod_timer(&(ctx->timer), jiffies +
+			msecs_to_jiffies(A2MP_RSP_TIMEOUT));
+	else
+		destroy_ctx(ctx);
+	return finished;
+}
+
+static int cancel_ctx(struct amp_ctx *ctx)
+{
+	return execute_ctx(ctx, AMP_CANCEL, 0);
+}
+
+static int kill_ctx(struct amp_ctx *ctx)
+{
+	return execute_ctx(ctx, AMP_KILLED, 0);
+}
+
+static void ctx_timeout_worker(struct work_struct *w)
+{
+	struct amp_work_ctx_timeout *work = (struct amp_work_ctx_timeout *) w;
+	struct amp_ctx *ctx = work->ctx;
+	kill_ctx(ctx);
+	kfree(work);
+}
+
+static void ctx_timeout(unsigned long data)
+{
+	struct amp_ctx *ctx = (struct amp_ctx *) data;
+	struct amp_work_ctx_timeout *work;
+
+	BT_DBG("ctx %p", ctx);
+	work = kmalloc(sizeof(*work), GFP_ATOMIC);
+	if (work) {
+		INIT_WORK((struct work_struct *) work, ctx_timeout_worker);
+		work->ctx = ctx;
+		if (queue_work(amp_workqueue, (struct work_struct *) work) == 0)
+			kfree(work);
+	}
+}
+
+static void launch_ctx(struct amp_mgr *mgr)
+{
+	struct amp_ctx *ctx = NULL;
+
+	BT_DBG("mgr %p", mgr);
+	read_lock(&mgr->ctx_list_lock);
+	if (!list_empty(&mgr->ctx_list))
+		ctx = list_first_entry(&mgr->ctx_list, struct amp_ctx, list);
+	read_unlock(&mgr->ctx_list_lock);
+	BT_DBG("ctx %p", ctx);
+	if (ctx)
+		execute_ctx(ctx, AMP_INIT, NULL);
+}
+
+static inline int a2mp_rsp(struct amp_mgr *mgr, struct sk_buff *skb)
+{
+	struct amp_ctx *ctx;
+	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
+	u16 hdr_len = le16_to_cpu(hdr->len);
+
+	/* find context waiting for A2MP rsp with this rsp's identifier */
+	BT_DBG("ident %d code %d", hdr->ident, hdr->code);
+	ctx = get_ctx_a2mp(mgr, hdr->ident);
+	if (ctx) {
+		execute_ctx(ctx, AMP_A2MP_RSP, skb);
+	} else {
+		BT_DBG("context not found");
+		skb_pull(skb, sizeof(*hdr));
+		if (hdr_len > skb->len)
+			hdr_len = skb->len;
+		skb_pull(skb, hdr_len);
+	}
+	return 0;
+}
+
+/* L2CAP-A2MP interface */
+
+static void a2mp_receive(struct sock *sk, struct sk_buff *skb)
+{
+	struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
+	int len;
+	int err = 0;
+	struct amp_mgr *mgr;
+
+	mgr = get_amp_mgr_sk(sk);
+	if (!mgr)
+		goto a2mp_finished;
+
+	len = skb->len;
+	while (len >= sizeof(*hdr)) {
+		struct a2mp_cmd_hdr *hdr = (struct a2mp_cmd_hdr *) skb->data;
+		u16 clen = le16_to_cpu(hdr->len);
+
+		BT_DBG("code 0x%02x id %d len %d", hdr->code, hdr->ident, clen);
+		if (clen > len || !hdr->ident) {
+			err = -EINVAL;
+			break;
+		}
+		switch (hdr->code) {
+		case A2MP_COMMAND_REJ:
+			command_rej(mgr, skb);
+			break;
+		case A2MP_DISCOVER_REQ:
+			err = discover_req(mgr, skb);
+			break;
+		case A2MP_CHANGE_NOTIFY:
+			err = change_notify(mgr, skb);
+			break;
+		case A2MP_GETINFO_REQ:
+			err = getinfo_req(mgr, skb);
+			break;
+		case A2MP_GETAMPASSOC_REQ:
+			err = getampassoc_req(mgr, skb);
+			break;
+		case A2MP_CREATEPHYSLINK_REQ:
+			err = createphyslink_req(mgr, skb);
+			break;
+		case A2MP_DISCONNPHYSLINK_REQ:
+			err = disconnphyslink_req(mgr, skb);
+			break;
+		case A2MP_CHANGE_RSP:
+		case A2MP_DISCOVER_RSP:
+		case A2MP_GETINFO_RSP:
+		case A2MP_GETAMPASSOC_RSP:
+		case A2MP_CREATEPHYSLINK_RSP:
+		case A2MP_DISCONNPHYSLINK_RSP:
+			err = a2mp_rsp(mgr, skb);
+			break;
+		default:
+			BT_ERR("Unknown A2MP signaling command 0x%2.2x",
+				hdr->code);
+			skb_pull(skb, sizeof(*hdr));
+			err = -EINVAL;
+			break;
+		}
+		len = skb->len;
+	}
+
+a2mp_finished:
+	if (err && mgr) {
+		struct a2mp_cmd_rej rej;
+		rej.reason = cpu_to_le16(0);
+		send_a2mp_cmd(mgr, hdr->ident, A2MP_COMMAND_REJ,
+							sizeof(rej), &rej);
+	}
+}
+
+/* L2CAP-A2MP interface */
+
+static int send_a2mp(struct socket *sock, u8 *data, int len)
+{
+	struct kvec iv = { data, len };
+	struct msghdr msg;
+
+	memset(&msg, 0, sizeof(msg));
+
+	return kernel_sendmsg(sock, &msg, &iv, 1, len);
+}
+
+static void data_ready_worker(struct work_struct *w)
+{
+	struct amp_work_data_ready *work = (struct amp_work_data_ready *) w;
+	struct sock *sk = work->sk;
+	struct sk_buff *skb;
+
+	/* skb_dequeue() is thread-safe */
+	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
+		a2mp_receive(sk, skb);
+		kfree_skb(skb);
+	}
+	sock_put(work->sk);
+	kfree(work);
+}
+
+static void data_ready(struct sock *sk, int bytes)
+{
+	struct amp_work_data_ready *work;
+	work = kmalloc(sizeof(*work), GFP_ATOMIC);
+	if (work) {
+		INIT_WORK((struct work_struct *) work, data_ready_worker);
+		sock_hold(sk);
+		work->sk = sk;
+		work->bytes = bytes;
+		if (!queue_work(amp_workqueue, (struct work_struct *) work)) {
+			kfree(work);
+			sock_put(sk);
+		}
+	}
+}
+
+static void state_change_worker(struct work_struct *w)
+{
+	struct amp_work_state_change *work = (struct amp_work_state_change *) w;
+	struct amp_mgr *mgr;
+	switch (work->sk->sk_state) {
+	case BT_CONNECTED:
+		/* socket is up */
+		BT_DBG("CONNECTED");
+		mgr = get_amp_mgr_sk(work->sk);
+		if (mgr) {
+			mgr->connected = 1;
+			if (mgr->skb) {
+				l2cap_recv_deferred_frame(work->sk, mgr->skb);
+				mgr->skb = NULL;
+			}
+			launch_ctx(mgr);
+		}
+		break;
+
+	case BT_CLOSED:
+		/* connection is gone */
+		BT_DBG("CLOSED");
+		mgr = get_amp_mgr_sk(work->sk);
+		if (mgr) {
+			if (!sock_flag(work->sk, SOCK_DEAD))
+				sock_release(mgr->a2mp_sock);
+			mgr->a2mp_sock = NULL;
+			remove_amp_mgr(mgr);
+		}
+		break;
+
+	default:
+		/* something else happened */
+		break;
+	}
+	sock_put(work->sk);
+	kfree(work);
+}
+
+static void state_change(struct sock *sk)
+{
+	struct amp_work_state_change *work;
+	work = kmalloc(sizeof(*work), GFP_ATOMIC);
+	if (work) {
+		INIT_WORK((struct work_struct *) work, state_change_worker);
+		sock_hold(sk);
+		work->sk = sk;
+		if (!queue_work(amp_workqueue, (struct work_struct *) work)) {
+			kfree(work);
+			sock_put(sk);
+		}
+	}
+}
+
+static struct socket *open_fixed_channel(bdaddr_t *src, bdaddr_t *dst)
+{
+	int err;
+	struct socket *sock;
+	struct sockaddr_l2 addr;
+	struct sock *sk;
+	struct l2cap_options opts = {L2CAP_A2MP_DEFAULT_MTU,
+			L2CAP_A2MP_DEFAULT_MTU, L2CAP_DEFAULT_FLUSH_TO,
+			L2CAP_MODE_ERTM, 1, 0xFF, 1};
+
+
+	err = sock_create_kern(PF_BLUETOOTH, SOCK_SEQPACKET,
+					BTPROTO_L2CAP, &sock);
+
+	if (err) {
+		BT_ERR("sock_create_kern failed %d", err);
+		return NULL;
+	}
+
+	sk = sock->sk;
+	sk->sk_data_ready = data_ready;
+	sk->sk_state_change = state_change;
+
+	memset(&addr, 0, sizeof(addr));
+	bacpy(&addr.l2_bdaddr, src);
+	addr.l2_family = AF_BLUETOOTH;
+	addr.l2_cid = L2CAP_CID_A2MP;
+	err = kernel_bind(sock, (struct sockaddr *) &addr, sizeof(addr));
+	if (err) {
+		BT_ERR("kernel_bind failed %d", err);
+		sock_release(sock);
+		return NULL;
+	}
+
+	l2cap_fixed_channel_config(sk, &opts);
+
+	memset(&addr, 0, sizeof(addr));
+	bacpy(&addr.l2_bdaddr, dst);
+	addr.l2_family = AF_BLUETOOTH;
+	addr.l2_cid = L2CAP_CID_A2MP;
+	err = kernel_connect(sock, (struct sockaddr *) &addr, sizeof(addr),
+							O_NONBLOCK);
+	if ((err == 0) || (err == -EINPROGRESS))
+		return sock;
+	else {
+		BT_ERR("kernel_connect failed %d", err);
+		sock_release(sock);
+		return NULL;
+	}
+}
+
+static void conn_ind_worker(struct work_struct *w)
+{
+	struct amp_work_conn_ind *work = (struct amp_work_conn_ind *) w;
+	struct hci_conn *hcon = work->hcon;
+	struct sk_buff *skb = work->skb;
+	struct amp_mgr *mgr;
+
+	mgr = get_create_amp_mgr(hcon, skb);
+	BT_DBG("mgr %p", mgr);
+	hci_conn_put(hcon);
+	kfree(work);
+}
+
+static void create_physical_worker(struct work_struct *w)
+{
+	struct amp_work_create_physical *work =
+		(struct amp_work_create_physical *) w;
+
+	create_physical(work->conn, work->sk);
+	sock_put(work->sk);
+	kfree(work);
+}
+
+static void accept_physical_worker(struct work_struct *w)
+{
+	struct amp_work_accept_physical *work =
+		(struct amp_work_accept_physical *) w;
+
+	accept_physical(work->conn, work->id, work->sk);
+	sock_put(work->sk);
+	kfree(work);
+}
+
+/* L2CAP Fixed Channel interface */
+
+void amp_conn_ind(struct hci_conn *hcon, struct sk_buff *skb)
+{
+	struct amp_work_conn_ind *work;
+	BT_DBG("hcon %p, skb %p", hcon, skb);
+	work = kmalloc(sizeof(*work), GFP_ATOMIC);
+	if (work) {
+		INIT_WORK((struct work_struct *) work, conn_ind_worker);
+		hci_conn_hold(hcon);
+		work->hcon = hcon;
+		work->skb = skb;
+		if (!queue_work(amp_workqueue, (struct work_struct *) work)) {
+			hci_conn_put(hcon);
+			kfree(work);
+		}
+	}
+}
+
+/* L2CAP Physical Link interface */
+
+void amp_create_physical(struct l2cap_conn *conn, struct sock *sk)
+{
+	struct amp_work_create_physical *work;
+	BT_DBG("conn %p", conn);
+	work = kmalloc(sizeof(*work), GFP_ATOMIC);
+	if (work) {
+		INIT_WORK((struct work_struct *) work, create_physical_worker);
+		work->conn = conn;
+		work->sk = sk;
+		sock_hold(sk);
+		if (!queue_work(amp_workqueue, (struct work_struct *) work)) {
+			sock_put(sk);
+			kfree(work);
+		}
+	}
+}
+
+void amp_accept_physical(struct l2cap_conn *conn, u8 id, struct sock *sk)
+{
+	struct amp_work_accept_physical *work;
+	BT_DBG("conn %p", conn);
+
+	work = kmalloc(sizeof(*work), GFP_ATOMIC);
+	if (work) {
+		INIT_WORK((struct work_struct *) work, accept_physical_worker);
+		work->conn = conn;
+		work->sk = sk;
+		work->id = id;
+		sock_hold(sk);
+		if (!queue_work(amp_workqueue, (struct work_struct *) work)) {
+			sock_put(sk);
+			kfree(work);
+		}
+	}
+}
+
+/* HCI interface */
+
+static void amp_cmd_cmplt_worker(struct work_struct *w)
+{
+	struct amp_work_cmd_cmplt *work = (struct amp_work_cmd_cmplt *) w;
+	struct hci_dev *hdev = work->hdev;
+	u16 opcode = work->opcode;
+	struct sk_buff *skb = work->skb;
+	struct amp_ctx *ctx;
+
+	ctx = get_ctx_hdev(hdev, AMP_HCI_CMD_CMPLT, opcode);
+	if (ctx)
+		execute_ctx(ctx, AMP_HCI_CMD_CMPLT, skb);
+	kfree_skb(skb);
+	kfree(w);
+}
+
+static void amp_cmd_cmplt_evt(struct hci_dev *hdev, u16 opcode,
+				struct sk_buff *skb)
+{
+	struct amp_work_cmd_cmplt *work;
+	struct sk_buff *skbc;
+	BT_DBG("hdev %p opcode 0x%x skb %p len %d",
+		hdev, opcode, skb, skb->len);
+	skbc = skb_clone(skb, GFP_ATOMIC);
+	if (!skbc)
+		return;
+	work = kmalloc(sizeof(*work), GFP_ATOMIC);
+	if (work) {
+		INIT_WORK((struct work_struct *) work, amp_cmd_cmplt_worker);
+		work->hdev = hdev;
+		work->opcode = opcode;
+		work->skb = skbc;
+		if (queue_work(amp_workqueue, (struct work_struct *) work) == 0)
+			kfree(work);
+	}
+}
+
+static void amp_cmd_status_worker(struct work_struct *w)
+{
+	struct amp_work_cmd_status *work = (struct amp_work_cmd_status *) w;
+	struct hci_dev *hdev = work->hdev;
+	u16 opcode = work->opcode;
+	u8 status = work->status;
+	struct amp_ctx *ctx;
+
+	ctx = get_ctx_hdev(hdev, AMP_HCI_CMD_STATUS, opcode);
+	if (ctx)
+		execute_ctx(ctx, AMP_HCI_CMD_STATUS, &status);
+	kfree(w);
+}
+
+static void amp_cmd_status_evt(struct hci_dev *hdev, u16 opcode, u8 status)
+{
+	struct amp_work_cmd_status *work;
+	BT_DBG("hdev %p opcode 0x%x status %d", hdev, opcode, status);
+	work = kmalloc(sizeof(*work), GFP_ATOMIC);
+	if (work) {
+		INIT_WORK((struct work_struct *) work, amp_cmd_status_worker);
+		work->hdev = hdev;
+		work->opcode = opcode;
+		work->status = status;
+		if (queue_work(amp_workqueue, (struct work_struct *) work) == 0)
+			kfree(work);
+	}
+}
+
+static void amp_event_worker(struct work_struct *w)
+{
+	struct amp_work_event *work = (struct amp_work_event *) w;
+	struct hci_dev *hdev = work->hdev;
+	u8 event = work->event;
+	struct sk_buff *skb = work->skb;
+	struct amp_ctx *ctx;
+
+	if (event == HCI_EV_AMP_STATUS_CHANGE) {
+		struct hci_ev_amp_status_change *ev;
+		if (skb->len < sizeof(*ev))
+			goto amp_event_finished;
+		ev = (void *) skb->data;
+		if (ev->status != 0)
+			goto amp_event_finished;
+		if (ev->amp_status == hdev->amp_status)
+			goto amp_event_finished;
+		hdev->amp_status = ev->amp_status;
+		send_a2mp_change_notify();
+		goto amp_event_finished;
+	}
+	ctx = get_ctx_hdev(hdev, AMP_HCI_EVENT, (u16) event);
+	if (ctx)
+		execute_ctx(ctx, AMP_HCI_EVENT, skb);
+
+amp_event_finished:
+	kfree_skb(skb);
+	kfree(w);
+}
+
+static void amp_evt(struct hci_dev *hdev, u8 event, struct sk_buff *skb)
+{
+	struct amp_work_event *work;
+	struct sk_buff *skbc;
+	BT_DBG("hdev %p event 0x%x skb %p", hdev, event, skb);
+	skbc = skb_clone(skb, GFP_ATOMIC);
+	if (!skbc)
+		return;
+	work = kmalloc(sizeof(*work), GFP_ATOMIC);
+	if (work) {
+		INIT_WORK((struct work_struct *) work, amp_event_worker);
+		work->hdev = hdev;
+		work->event = event;
+		work->skb = skbc;
+		if (queue_work(amp_workqueue, (struct work_struct *) work) == 0)
+			kfree(work);
+	}
+}
+
+static void amp_dev_event_worker(struct work_struct *w)
+{
+	send_a2mp_change_notify();
+	kfree(w);
+}
+
+static int amp_dev_event(struct notifier_block *this, unsigned long event,
+			void *ptr)
+{
+	struct hci_dev *hdev = (struct hci_dev *) ptr;
+	struct amp_work_event *work;
+
+	if (hdev->amp_type == HCI_BREDR)
+		return NOTIFY_DONE;
+
+	switch (event) {
+	case HCI_DEV_UNREG:
+	case HCI_DEV_REG:
+	case HCI_DEV_UP:
+	case HCI_DEV_DOWN:
+		BT_DBG("hdev %p event %ld", hdev, event);
+		work = kmalloc(sizeof(*work), GFP_ATOMIC);
+		if (work) {
+			INIT_WORK((struct work_struct *) work,
+				amp_dev_event_worker);
+			if (queue_work(amp_workqueue,
+				(struct work_struct *) work) == 0)
+				kfree(work);
+		}
+	}
+	return NOTIFY_DONE;
+}
+
+
+/* L2CAP module init continued */
+
+static struct notifier_block amp_notifier = {
+	.notifier_call = amp_dev_event
+};
+
+static struct amp_mgr_cb hci_amp = {
+	.amp_cmd_complete_event = amp_cmd_cmplt_evt,
+	.amp_cmd_status_event = amp_cmd_status_evt,
+	.amp_event = amp_evt
+};
+
+int amp_init(void)
+{
+	hci_register_amp(&hci_amp);
+	hci_register_notifier(&amp_notifier);
+	amp_next_handle = 1;
+	amp_workqueue = create_singlethread_workqueue("a2mp");
+	if (!amp_workqueue)
+		return -EPERM;
+	return 0;
+}
+
+void amp_exit(void)
+{
+	hci_unregister_amp(&hci_amp);
+	hci_unregister_notifier(&amp_notifier);
+	flush_workqueue(amp_workqueue);
+	destroy_workqueue(amp_workqueue);
+}
diff --git a/net/bluetooth/bnep/core.c b/net/bluetooth/bnep/core.c
index a779ec7..f504921 100644
--- a/net/bluetooth/bnep/core.c
+++ b/net/bluetooth/bnep/core.c
@@ -26,6 +26,7 @@
 */
 
 #include <linux/module.h>
+#include <linux/interrupt.h>
 
 #include <linux/kernel.h>
 #include <linux/sched.h>
@@ -56,8 +57,8 @@
 
 #define VERSION "1.3"
 
-static bool compress_src = true;
-static bool compress_dst = true;
+static bool compress_src = 1;
+static bool compress_dst = 1;
 
 static LIST_HEAD(bnep_session_list);
 static DECLARE_RWSEM(bnep_session_sem);
@@ -65,24 +66,31 @@ static DECLARE_RWSEM(bnep_session_sem);
 static struct bnep_session *__bnep_get_session(u8 *dst)
 {
 	struct bnep_session *s;
+	struct list_head *p;
 
 	BT_DBG("");
 
-	list_for_each_entry(s, &bnep_session_list, list)
+	list_for_each(p, &bnep_session_list) {
+		s = list_entry(p, struct bnep_session, list);
 		if (!compare_ether_addr(dst, s->eh.h_source))
 			return s;
-
+	}
 	return NULL;
 }
 
 static void __bnep_link_session(struct bnep_session *s)
 {
+	/* It's safe to call __module_get() here because sessions are added
+	   by the socket layer which has to hold the reference to this module.
+	 */
+	__module_get(THIS_MODULE);
 	list_add(&s->list, &bnep_session_list);
 }
 
 static void __bnep_unlink_session(struct bnep_session *s)
 {
 	list_del(&s->list);
+	module_put(THIS_MODULE);
 }
 
 static int bnep_send(struct bnep_session *s, void *data, size_t len)
@@ -502,7 +510,7 @@ static int bnep_session(void *arg)
 
 		schedule();
 	}
-	__set_current_state(TASK_RUNNING);
+	set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 
 	/* Cleanup session */
@@ -523,7 +531,6 @@ static int bnep_session(void *arg)
 
 	up_write(&bnep_session_sem);
 	free_netdev(dev);
-	module_put_and_exit(0);
 	return 0;
 }
 
@@ -610,11 +617,9 @@ int bnep_add_connection(struct bnep_connadd_req *req, struct socket *sock)
 
 	__bnep_link_session(s);
 
-	__module_get(THIS_MODULE);
 	s->task = kthread_run(bnep_session, s, "kbnepd %s", dev->name);
 	if (IS_ERR(s->task)) {
 		/* Session thread start failed, gotta cleanup. */
-		module_put(THIS_MODULE);
 		unregister_netdev(dev);
 		__bnep_unlink_session(s);
 		err = PTR_ERR(s->task);
@@ -663,14 +668,17 @@ static void __bnep_copy_ci(struct bnep_conninfo *ci, struct bnep_session *s)
 
 int bnep_get_connlist(struct bnep_connlist_req *req)
 {
-	struct bnep_session *s;
+	struct list_head *p;
 	int err = 0, n = 0;
 
 	down_read(&bnep_session_sem);
 
-	list_for_each_entry(s, &bnep_session_list, list) {
+	list_for_each(p, &bnep_session_list) {
+		struct bnep_session *s;
 		struct bnep_conninfo ci;
 
+		s = list_entry(p, struct bnep_session, list);
+
 		__bnep_copy_ci(&ci, s);
 
 		if (copy_to_user(req->ci, &ci, sizeof(ci))) {
diff --git a/net/bluetooth/bnep/netdev.c b/net/bluetooth/bnep/netdev.c
index bc40864..155ff74 100644
--- a/net/bluetooth/bnep/netdev.c
+++ b/net/bluetooth/bnep/netdev.c
@@ -26,6 +26,7 @@
 */
 
 #include <linux/module.h>
+#include <linux/interrupt.h>
 #include <linux/slab.h>
 
 #include <linux/socket.h>
diff --git a/net/bluetooth/cmtp/capi.c b/net/bluetooth/cmtp/capi.c
index 50f0d13..744233c 100644
--- a/net/bluetooth/cmtp/capi.c
+++ b/net/bluetooth/cmtp/capi.c
@@ -326,7 +326,7 @@ void cmtp_recv_capimsg(struct cmtp_session *session, struct sk_buff *skb)
 {
 	struct capi_ctr *ctrl = &session->ctrl;
 	struct cmtp_application *application;
-	__u16 appl;
+	__u16 cmd, appl;
 	__u32 contr;
 
 	BT_DBG("session %p skb %p len %d", session, skb, skb->len);
@@ -344,6 +344,7 @@ void cmtp_recv_capimsg(struct cmtp_session *session, struct sk_buff *skb)
 		return;
 	}
 
+	cmd = CAPICMD(CAPIMSG_COMMAND(skb->data), CAPIMSG_SUBCOMMAND(skb->data));
 	appl = CAPIMSG_APPID(skb->data);
 	contr = CAPIMSG_CONTROL(skb->data);
 
@@ -386,8 +387,7 @@ static void cmtp_reset_ctr(struct capi_ctr *ctrl)
 
 	capi_ctr_down(ctrl);
 
-	atomic_inc(&session->terminate);
-	wake_up_process(session->task);
+	kthread_stop(session->task);
 }
 
 static void cmtp_register_appl(struct capi_ctr *ctrl, __u16 appl, capi_register_params *rp)
diff --git a/net/bluetooth/cmtp/cmtp.h b/net/bluetooth/cmtp/cmtp.h
index c32638d..db43b54 100644
--- a/net/bluetooth/cmtp/cmtp.h
+++ b/net/bluetooth/cmtp/cmtp.h
@@ -81,7 +81,6 @@ struct cmtp_session {
 
 	char name[BTNAMSIZ];
 
-	atomic_t terminate;
 	struct task_struct *task;
 
 	wait_queue_head_t wait;
diff --git a/net/bluetooth/cmtp/core.c b/net/bluetooth/cmtp/core.c
index 6c9c1fd..bff02ad 100644
--- a/net/bluetooth/cmtp/core.c
+++ b/net/bluetooth/cmtp/core.c
@@ -53,24 +53,28 @@ static LIST_HEAD(cmtp_session_list);
 static struct cmtp_session *__cmtp_get_session(bdaddr_t *bdaddr)
 {
 	struct cmtp_session *session;
+	struct list_head *p;
 
 	BT_DBG("");
 
-	list_for_each_entry(session, &cmtp_session_list, list)
+	list_for_each(p, &cmtp_session_list) {
+		session = list_entry(p, struct cmtp_session, list);
 		if (!bacmp(bdaddr, &session->bdaddr))
 			return session;
-
+	}
 	return NULL;
 }
 
 static void __cmtp_link_session(struct cmtp_session *session)
 {
+	__module_get(THIS_MODULE);
 	list_add(&session->list, &cmtp_session_list);
 }
 
 static void __cmtp_unlink_session(struct cmtp_session *session)
 {
 	list_del(&session->list);
+	module_put(THIS_MODULE);
 }
 
 static void __cmtp_copy_session(struct cmtp_session *session, struct cmtp_conninfo *ci)
@@ -288,11 +292,9 @@ static int cmtp_session(void *arg)
 
 	init_waitqueue_entry(&wait, current);
 	add_wait_queue(sk_sleep(sk), &wait);
-	while (1) {
+	while (!kthread_should_stop()) {
 		set_current_state(TASK_INTERRUPTIBLE);
 
-		if (atomic_read(&session->terminate))
-			break;
 		if (sk->sk_state != BT_CONNECTED)
 			break;
 
@@ -308,7 +310,7 @@ static int cmtp_session(void *arg)
 
 		schedule();
 	}
-	__set_current_state(TASK_RUNNING);
+	set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 
 	down_write(&cmtp_session_sem);
@@ -323,7 +325,6 @@ static int cmtp_session(void *arg)
 	up_write(&cmtp_session_sem);
 
 	kfree(session);
-	module_put_and_exit(0);
 	return 0;
 }
 
@@ -348,8 +349,7 @@ int cmtp_add_connection(struct cmtp_connadd_req *req, struct socket *sock)
 
 	bacpy(&session->bdaddr, &bt_sk(sock->sk)->dst);
 
-	session->mtu = min_t(uint, l2cap_pi(sock->sk)->chan->omtu,
-					l2cap_pi(sock->sk)->chan->imtu);
+	session->mtu = min_t(uint, l2cap_pi(sock->sk)->omtu, l2cap_pi(sock->sk)->imtu);
 
 	BT_DBG("mtu %d", session->mtu);
 
@@ -373,28 +373,25 @@ int cmtp_add_connection(struct cmtp_connadd_req *req, struct socket *sock)
 
 	__cmtp_link_session(session);
 
-	__module_get(THIS_MODULE);
 	session->task = kthread_run(cmtp_session, session, "kcmtpd_ctr_%d",
 								session->num);
 	if (IS_ERR(session->task)) {
-		module_put(THIS_MODULE);
 		err = PTR_ERR(session->task);
 		goto unlink;
 	}
 
 	if (!(session->flags & (1 << CMTP_LOOPBACK))) {
 		err = cmtp_attach_device(session);
-		if (err < 0) {
-			atomic_inc(&session->terminate);
-			wake_up_process(session->task);
-			up_write(&cmtp_session_sem);
-			return err;
-		}
+		if (err < 0)
+			goto detach;
 	}
 
 	up_write(&cmtp_session_sem);
 	return 0;
 
+detach:
+	cmtp_detach_device(session);
+
 unlink:
 	__cmtp_unlink_session(session);
 
@@ -419,8 +416,7 @@ int cmtp_del_connection(struct cmtp_conndel_req *req)
 		skb_queue_purge(&session->transmit);
 
 		/* Stop session thread */
-		atomic_inc(&session->terminate);
-		wake_up_process(session->task);
+		kthread_stop(session->task);
 	} else
 		err = -ENOENT;
 
@@ -430,16 +426,19 @@ int cmtp_del_connection(struct cmtp_conndel_req *req)
 
 int cmtp_get_connlist(struct cmtp_connlist_req *req)
 {
-	struct cmtp_session *session;
+	struct list_head *p;
 	int err = 0, n = 0;
 
 	BT_DBG("");
 
 	down_read(&cmtp_session_sem);
 
-	list_for_each_entry(session, &cmtp_session_list, list) {
+	list_for_each(p, &cmtp_session_list) {
+		struct cmtp_session *session;
 		struct cmtp_conninfo ci;
 
+		session = list_entry(p, struct cmtp_session, list);
+
 		__cmtp_copy_session(session, &ci);
 
 		if (copy_to_user(req->ci, &ci, sizeof(ci))) {
diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
old mode 100755
new mode 100644
index 4fd8b77..9ffd0f1
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1,6 +1,7 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
+   Copyright (c) 2000-2001, The Linux Foundation. All rights reserved.
+   Copyright (c) 2010-2013, The Linux Foundation. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -44,36 +45,175 @@
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
+#include <net/bluetooth/l2cap.h>
 
-static void hci_le_connect(struct hci_conn *conn)
+struct hci_conn *hci_le_connect(struct hci_dev *hdev, __u16 pkt_type,
+				bdaddr_t *dst, __u8 sec_level, __u8 auth_type,
+				struct bt_le_params *le_params)
 {
-	struct hci_dev *hdev = conn->hdev;
+	struct hci_conn *le, *le_wlist_conn;
 	struct hci_cp_le_create_conn cp;
+	struct adv_entry *entry;
+	struct link_key *key;
+
+	BT_DBG("%p", hdev);
+
+	le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
+	if (le) {
+		le_wlist_conn = hci_conn_hash_lookup_ba(hdev, LE_LINK,
+								BDADDR_ANY);
+		if (!le_wlist_conn) {
+			hci_conn_hold(le);
+			return le;
+		} else {
+			BT_DBG("remove wlist conn");
+			le->out = 1;
+			le->link_mode |= HCI_LM_MASTER;
+			le->sec_level = BT_SECURITY_LOW;
+			le->type = LE_LINK;
+			hci_proto_connect_cfm(le, 0);
+			hci_conn_del(le_wlist_conn);
+			return le;
+		}
+	}
 
-	conn->state = BT_CONNECT;
-	conn->out = 1;
-	conn->link_mode |= HCI_LM_MASTER;
-	conn->sec_level = BT_SECURITY_LOW;
+	key = hci_find_link_key_type(hdev, dst, KEY_TYPE_LTK);
+	if (!key) {
+		entry = hci_find_adv_entry(hdev, dst);
+		if (entry)
+			le = hci_le_conn_add(hdev, dst,
+					entry->bdaddr_type);
+		else
+			le = hci_le_conn_add(hdev, dst, 0);
+	} else {
+		le = hci_le_conn_add(hdev, dst, key->addr_type);
+	}
+
+	if (!le)
+		return ERR_PTR(-ENOMEM);
+
+	hci_conn_hold(le);
+
+	le->state = BT_CONNECT;
+	le->out = 1;
+	le->link_mode |= HCI_LM_MASTER;
+	le->sec_level = BT_SECURITY_LOW;
+	le->type = LE_LINK;
 
 	memset(&cp, 0, sizeof(cp));
-	cp.scan_interval = cpu_to_le16(0x0060);
-	cp.scan_window = cpu_to_le16(0x0030);
-	bacpy(&cp.peer_addr, &conn->dst);
-	cp.peer_addr_type = conn->dst_type;
-	cp.conn_interval_min = cpu_to_le16(0x0028);
-	cp.conn_interval_max = cpu_to_le16(0x0038);
-	cp.supervision_timeout = cpu_to_le16(0x002a);
-	cp.min_ce_len = cpu_to_le16(0x0000);
-	cp.max_ce_len = cpu_to_le16(0x0000);
+	if (l2cap_sock_le_params_valid(le_params)) {
+		cp.supervision_timeout =
+				cpu_to_le16(le_params->supervision_timeout);
+		cp.scan_interval = cpu_to_le16(le_params->scan_interval);
+		cp.scan_window = cpu_to_le16(le_params->scan_window);
+		cp.conn_interval_min = cpu_to_le16(le_params->interval_min);
+		cp.conn_interval_max = cpu_to_le16(le_params->interval_max);
+		cp.conn_latency = cpu_to_le16(le_params->latency);
+		cp.min_ce_len = cpu_to_le16(le_params->min_ce_len);
+		cp.max_ce_len = cpu_to_le16(le_params->max_ce_len);
+		le->conn_timeout = le_params->conn_timeout;
+	} else {
+		cp.supervision_timeout = cpu_to_le16(BT_LE_SUP_TO_DEFAULT);
+		cp.scan_interval = cpu_to_le16(BT_LE_SCAN_INTERVAL_DEF);
+		cp.scan_window = cpu_to_le16(BT_LE_SCAN_WINDOW_DEF);
+		cp.conn_interval_min = cpu_to_le16(BT_LE_CONN_INTERVAL_MIN_DEF);
+		cp.conn_interval_max = cpu_to_le16(BT_LE_CONN_INTERVAL_MAX_DEF);
+		cp.conn_latency = cpu_to_le16(BT_LE_LATENCY_DEF);
+		le->conn_timeout = 5;
+	}
+	if (!bacmp(&le->dst, BDADDR_ANY)) {
+		cp.filter_policy = 0x01;
+		le->conn_timeout = 0;
+	} else {
+		bacpy(&cp.peer_addr, &le->dst);
+		cp.peer_addr_type = le->dst_type;
+	}
 
 	hci_send_cmd(hdev, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
+
+	return le;
 }
+EXPORT_SYMBOL(hci_le_connect);
 
 static void hci_le_connect_cancel(struct hci_conn *conn)
 {
 	hci_send_cmd(conn->hdev, HCI_OP_LE_CREATE_CONN_CANCEL, 0, NULL);
 }
 
+void hci_le_cancel_create_connect(struct hci_dev *hdev, bdaddr_t *dst)
+{
+	struct hci_conn *le;
+
+	BT_DBG("%p", hdev);
+
+	le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
+	if (le) {
+		BT_DBG("send hci connect cancel");
+		hci_le_connect_cancel(le);
+		hci_conn_del(le);
+	}
+}
+EXPORT_SYMBOL(hci_le_cancel_create_connect);
+
+void hci_le_add_dev_white_list(struct hci_dev *hdev, bdaddr_t *dst)
+{
+	struct hci_cp_le_add_dev_white_list cp;
+	struct adv_entry *entry;
+	struct link_key *key;
+
+	BT_DBG("%p", hdev);
+
+	memset(&cp, 0, sizeof(cp));
+	bacpy(&cp.addr, dst);
+
+	key = hci_find_link_key_type(hdev, dst, KEY_TYPE_LTK);
+	if (!key) {
+		entry = hci_find_adv_entry(hdev, dst);
+		if (entry)
+			cp.addr_type = entry->bdaddr_type;
+		else
+			cp.addr_type = 0x00;
+	} else {
+		cp.addr_type = key->addr_type;
+	}
+
+	hci_send_cmd(hdev, HCI_OP_LE_ADD_DEV_WHITE_LIST, sizeof(cp), &cp);
+}
+EXPORT_SYMBOL(hci_le_add_dev_white_list);
+
+void hci_le_remove_dev_white_list(struct hci_dev *hdev, bdaddr_t *dst)
+{
+	struct hci_cp_le_remove_dev_white_list cp;
+	struct adv_entry *entry;
+	struct link_key *key;
+
+	BT_DBG("%p", hdev);
+
+	memset(&cp, 0, sizeof(cp));
+	bacpy(&cp.addr, dst);
+
+	key = hci_find_link_key_type(hdev, dst, KEY_TYPE_LTK);
+	if (!key) {
+		entry = hci_find_adv_entry(hdev, dst);
+		if (entry)
+			cp.addr_type = entry->bdaddr_type;
+		else
+			cp.addr_type = 0x00;
+	} else {
+		cp.addr_type = key->addr_type;
+	}
+
+	hci_send_cmd(hdev, HCI_OP_LE_REMOVE_DEV_WHITE_LIST, sizeof(cp), &cp);
+}
+EXPORT_SYMBOL(hci_le_remove_dev_white_list);
+
+static inline bool is_role_switch_possible(struct hci_dev *hdev)
+{
+	if (hci_conn_hash_lookup_state(hdev, ACL_LINK, BT_CONNECTED))
+		return false;
+	return true;
+}
+
 void hci_acl_connect(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
@@ -109,7 +249,8 @@ void hci_acl_connect(struct hci_conn *conn)
 	}
 
 	cp.pkt_type = cpu_to_le16(conn->pkt_type);
-	if (lmp_rswitch_capable(hdev) && !(hdev->link_mode & HCI_LM_MASTER))
+	if (lmp_rswitch_capable(hdev) && !(hdev->link_mode & HCI_LM_MASTER)
+		&& is_role_switch_possible(hdev))
 		cp.role_switch = 0x01;
 	else
 		cp.role_switch = 0x00;
@@ -123,7 +264,7 @@ static void hci_acl_connect_cancel(struct hci_conn *conn)
 
 	BT_DBG("%p", conn);
 
-	if (conn->hdev->hci_ver < BLUETOOTH_VER_1_2)
+	if (conn->hdev->hci_ver < 2)
 		return;
 
 	bacpy(&cp.bdaddr, &conn->dst);
@@ -132,15 +273,22 @@ static void hci_acl_connect_cancel(struct hci_conn *conn)
 
 void hci_acl_disconn(struct hci_conn *conn, __u8 reason)
 {
-	struct hci_cp_disconnect cp;
-
 	BT_DBG("%p", conn);
 
 	conn->state = BT_DISCONN;
 
-	cp.handle = cpu_to_le16(conn->handle);
-	cp.reason = reason;
-	hci_send_cmd(conn->hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp);
+	if (conn->hdev->dev_type == HCI_BREDR) {
+		struct hci_cp_disconnect cp;
+		cp.handle = cpu_to_le16(conn->handle);
+		cp.reason = reason;
+		hci_send_cmd(conn->hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp);
+	} else {
+		struct hci_cp_disconn_phys_link cp;
+		cp.phy_handle = (u8) conn->handle;
+		cp.reason = reason;
+		hci_send_cmd(conn->hdev, HCI_OP_DISCONN_PHYS_LINK,
+				sizeof(cp), &cp);
+	}
 }
 
 void hci_add_sco(struct hci_conn *conn, __u16 handle)
@@ -174,13 +322,23 @@ void hci_setup_sync(struct hci_conn *conn, __u16 handle)
 	conn->attempt++;
 
 	cp.handle   = cpu_to_le16(handle);
-	cp.pkt_type = cpu_to_le16(conn->pkt_type);
 
 	cp.tx_bandwidth   = cpu_to_le32(0x00001f40);
 	cp.rx_bandwidth   = cpu_to_le32(0x00001f40);
-	cp.max_latency    = cpu_to_le16(0xffff);
-	cp.voice_setting  = cpu_to_le16(hdev->voice_setting);
-	cp.retrans_effort = 0xff;
+	if (conn->hdev->is_wbs) {
+		/* Transparent Data */
+		uint16_t voice_setting = hdev->voice_setting | ACF_TRANS;
+		cp.max_latency    = cpu_to_le16(0x000D);
+		cp.pkt_type = cpu_to_le16(ESCO_WBS);
+		cp.voice_setting  = cpu_to_le16(voice_setting);
+		/* Retransmission Effort */
+		cp.retrans_effort = RE_LINK_QUALITY;
+	} else {
+		cp.max_latency    = cpu_to_le16(0x000A);
+		cp.pkt_type = cpu_to_le16(conn->pkt_type);
+		cp.voice_setting  = cpu_to_le16(hdev->voice_setting);
+		cp.retrans_effort = RE_POWER_CONSUMP;
+	}
 
 	hci_send_cmd(hdev, HCI_OP_SETUP_SYNC_CONN, sizeof(cp), &cp);
 }
@@ -205,6 +363,18 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 }
 EXPORT_SYMBOL(hci_le_conn_update);
 
+void hci_read_rssi(struct hci_conn *conn)
+{
+	struct hci_cp_read_rssi cp;
+	struct hci_dev *hdev = conn->hdev;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.handle   = cpu_to_le16(conn->handle);
+
+	hci_send_cmd(hdev, HCI_OP_READ_RSSI, sizeof(cp), &cp);
+}
+EXPORT_SYMBOL(hci_read_rssi);
+
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 							__u8 ltk[16])
 {
@@ -275,17 +445,15 @@ void hci_sco_setup(struct hci_conn *conn, __u8 status)
 	}
 }
 
-static void hci_conn_timeout(struct work_struct *work)
+static void hci_conn_timeout(unsigned long arg)
 {
-	struct hci_conn *conn = container_of(work, struct hci_conn,
-							disc_work.work);
+	struct hci_conn *conn = (void *) arg;
 	struct hci_dev *hdev = conn->hdev;
 	__u8 reason;
 
 	BT_DBG("conn %p state %d", conn, conn->state);
 
-	if (atomic_read(&conn->refcnt))
-		return;
+	hci_dev_lock(hdev);
 
 	switch (conn->state) {
 	case BT_CONNECT:
@@ -299,67 +467,57 @@ static void hci_conn_timeout(struct work_struct *work)
 		break;
 	case BT_CONFIG:
 	case BT_CONNECTED:
-		reason = hci_proto_disconn_ind(conn);
-		hci_acl_disconn(conn, reason);
+		if (!atomic_read(&conn->refcnt)) {
+			reason = hci_proto_disconn_ind(conn);
+			hci_acl_disconn(conn, reason);
+		}
 		break;
 	default:
-		conn->state = BT_CLOSED;
+		if (!atomic_read(&conn->refcnt))
+			conn->state = BT_CLOSED;
 		break;
 	}
+
+	hci_dev_unlock(hdev);
 }
 
-/* Enter sniff mode */
-static void hci_conn_enter_sniff_mode(struct hci_conn *conn)
+static void hci_conn_idle(unsigned long arg)
 {
-	struct hci_dev *hdev = conn->hdev;
+	struct hci_conn *conn = (void *) arg;
 
 	BT_DBG("conn %p mode %d", conn, conn->mode);
 
-	if (test_bit(HCI_RAW, &hdev->flags))
-		return;
-
-	if (!lmp_sniff_capable(hdev) || !lmp_sniff_capable(conn))
-		return;
-
-	if (conn->mode != HCI_CM_ACTIVE || !(conn->link_policy & HCI_LP_SNIFF))
-		return;
-
-	if (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {
-		struct hci_cp_sniff_subrate cp;
-		cp.handle             = cpu_to_le16(conn->handle);
-		cp.max_latency        = cpu_to_le16(0);
-		cp.min_remote_timeout = cpu_to_le16(0);
-		cp.min_local_timeout  = cpu_to_le16(0);
-		hci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);
-	}
-
-	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
-		struct hci_cp_sniff_mode cp;
-		cp.handle       = cpu_to_le16(conn->handle);
-		cp.max_interval = cpu_to_le16(hdev->sniff_max_interval);
-		cp.min_interval = cpu_to_le16(hdev->sniff_min_interval);
-		cp.attempt      = cpu_to_le16(4);
-		cp.timeout      = cpu_to_le16(1);
-		hci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);
-	}
+	hci_conn_enter_sniff_mode(conn);
 }
 
-static void hci_conn_idle(unsigned long arg)
+static void hci_conn_rssi_update(struct work_struct *work)
 {
-	struct hci_conn *conn = (void *) arg;
+	struct delayed_work *delayed =
+		container_of(work, struct delayed_work, work);
+	struct hci_conn *conn =
+		container_of(delayed, struct hci_conn, rssi_update_work);
 
 	BT_DBG("conn %p mode %d", conn, conn->mode);
 
-	hci_conn_enter_sniff_mode(conn);
+	hci_read_rssi(conn);
 }
 
-static void hci_conn_auto_accept(unsigned long arg)
+static void encryption_disabled_timeout(unsigned long userdata)
 {
-	struct hci_conn *conn = (void *) arg;
-	struct hci_dev *hdev = conn->hdev;
+	struct hci_conn *conn = (struct hci_conn *)userdata;
+	BT_INFO("conn %p Grace Prd Exp ", conn);
+
+	hci_encrypt_cfm(conn, 0, 0);
+
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
+		struct hci_cp_set_conn_encrypt cp;
+		BT_INFO("HCI_CONN_ENCRYPT_PEND is set");
+		cp.handle  = cpu_to_le16(conn->handle);
+		cp.encrypt = 1;
+		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT,
+						sizeof(cp), &cp);
+	}
 
-	hci_send_cmd(hdev, HCI_OP_USER_CONFIRM_REPLY, sizeof(conn->dst),
-								&conn->dst);
 }
 
 struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
@@ -381,14 +539,16 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
 	conn->auth_type = HCI_AT_GENERAL_BONDING;
 	conn->io_capability = hdev->io_capability;
 	conn->remote_auth = 0xff;
-	conn->key_type = 0xff;
 
 	conn->power_save = 1;
 	conn->disc_timeout = HCI_DISCONN_TIMEOUT;
+	conn->conn_valid = true;
+	spin_lock_init(&conn->lock);
 
 	switch (type) {
 	case ACL_LINK:
 		conn->pkt_type = hdev->pkt_type & ACL_PTYPE_MASK;
+		conn->link_policy = hdev->link_policy;
 		break;
 	case SCO_LINK:
 		if (!pkt_type)
@@ -412,17 +572,18 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
 
 	skb_queue_head_init(&conn->data_q);
 
-	INIT_LIST_HEAD(&conn->chan_list);;
-
-	INIT_DELAYED_WORK(&conn->disc_work, hci_conn_timeout);
+	setup_timer(&conn->disc_timer, hci_conn_timeout, (unsigned long)conn);
 	setup_timer(&conn->idle_timer, hci_conn_idle, (unsigned long)conn);
-	setup_timer(&conn->auto_accept_timer, hci_conn_auto_accept,
-							(unsigned long) conn);
+	INIT_DELAYED_WORK(&conn->rssi_update_work, hci_conn_rssi_update);
+	setup_timer(&conn->encrypt_pause_timer, encryption_disabled_timeout,
+			(unsigned long)conn);
 
 	atomic_set(&conn->refcnt, 0);
 
 	hci_dev_hold(hdev);
 
+	tasklet_disable(&hdev->tx_task);
+
 	hci_conn_hash_add(hdev, conn);
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
@@ -431,6 +592,20 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
 
 	hci_conn_init_sysfs(conn);
 
+	tasklet_enable(&hdev->tx_task);
+
+	return conn;
+}
+
+struct hci_conn *hci_le_conn_add(struct hci_dev *hdev, bdaddr_t *dst,
+							__u8 addr_type)
+{
+	struct hci_conn *conn = hci_conn_add(hdev, LE_LINK, 0, dst);
+	if (!conn)
+		return NULL;
+
+	conn->dst_type = addr_type;
+
 	return conn;
 }
 
@@ -440,11 +615,16 @@ int hci_conn_del(struct hci_conn *conn)
 
 	BT_DBG("%s conn %p handle %d", hdev->name, conn, conn->handle);
 
-	del_timer(&conn->idle_timer);
-
-	cancel_delayed_work_sync(&conn->disc_work);
+	spin_lock_bh(&conn->lock);
+	conn->conn_valid = false; /* conn data is being released */
+	spin_unlock_bh(&conn->lock);
 
-	del_timer(&conn->auto_accept_timer);
+	/* Make sure no timers are running */
+	del_timer(&conn->idle_timer);
+	del_timer(&conn->disc_timer);
+	del_timer(&conn->smp_timer);
+	__cancel_delayed_work(&conn->rssi_update_work);
+	del_timer(&conn->encrypt_pause_timer);
 
 	if (conn->type == ACL_LINK) {
 		struct hci_conn *sco = conn->link;
@@ -466,35 +646,105 @@ int hci_conn_del(struct hci_conn *conn)
 		}
 	}
 
-
-	hci_chan_list_flush(conn);
+	tasklet_disable(&hdev->tx_task);
 
 	hci_conn_hash_del(hdev, conn);
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
 
+	tasklet_schedule(&hdev->tx_task);
+
+	tasklet_enable(&hdev->tx_task);
+
 	skb_queue_purge(&conn->data_q);
 
 	hci_conn_put_device(conn);
 
+	if (conn->hidp_session_valid)
+		hci_conn_put_device(conn);
+
 	hci_dev_put(hdev);
 
-	if (conn->handle == 0)
-		kfree(conn);
+	return 0;
+}
+
+struct hci_chan *hci_chan_add(struct hci_dev *hdev)
+{
+	struct hci_chan *chan;
+
+	BT_DBG("%s", hdev->name);
+
+	chan = kzalloc(sizeof(struct hci_chan), GFP_ATOMIC);
+	if (!chan)
+		return NULL;
+
+	atomic_set(&chan->refcnt, 0);
+
+	hci_dev_hold(hdev);
+
+	chan->hdev = hdev;
+
+	list_add(&chan->list, &hdev->chan_list.list);
+
+	return chan;
+}
+EXPORT_SYMBOL(hci_chan_add);
+
+int hci_chan_del(struct hci_chan *chan)
+{
+	BT_DBG("%s chan %p", chan->hdev->name, chan);
+
+	list_del(&chan->list);
+
+	hci_conn_put(chan->conn);
+	hci_dev_put(chan->hdev);
+
+	kfree(chan);
 
 	return 0;
 }
 
+int hci_chan_put(struct hci_chan *chan)
+{
+	struct hci_cp_disconn_logical_link cp;
+	struct hci_conn *hcon;
+	u16 ll_handle;
+
+	BT_DBG("chan %p refcnt %d", chan, atomic_read(&chan->refcnt));
+	if (!atomic_dec_and_test(&chan->refcnt))
+		return 0;
+
+	hcon = chan->conn;
+	ll_handle = chan->ll_handle;
+
+	hci_chan_del(chan);
+
+	BT_DBG("chan->conn->state %d", hcon->state);
+	if (hcon->state == BT_CONNECTED) {
+		cp.log_handle = cpu_to_le16(ll_handle);
+		hci_send_cmd(hcon->hdev, HCI_OP_DISCONN_LOGICAL_LINK,
+				sizeof(cp), &cp);
+	}
+
+	return 1;
+}
+EXPORT_SYMBOL(hci_chan_put);
+
 struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 {
 	int use_src = bacmp(src, BDADDR_ANY);
-	struct hci_dev *hdev = NULL, *d;
+	struct hci_dev *hdev = NULL;
+	struct list_head *p;
 
 	BT_DBG("%s -> %s", batostr(src), batostr(dst));
 
-	read_lock(&hci_dev_list_lock);
+	read_lock_bh(&hci_dev_list_lock);
 
-	list_for_each_entry(d, &hci_dev_list, list) {
+	list_for_each(p, &hci_dev_list) {
+		struct hci_dev *d = list_entry(p, struct hci_dev, list);
+
+		if (d->dev_type != HCI_BREDR)
+			continue;
 		if (!test_bit(HCI_UP, &d->flags) || test_bit(HCI_RAW, &d->flags))
 			continue;
 
@@ -517,47 +767,78 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 	if (hdev)
 		hdev = hci_dev_hold(hdev);
 
-	read_unlock(&hci_dev_list_lock);
+	read_unlock_bh(&hci_dev_list_lock);
 	return hdev;
 }
 EXPORT_SYMBOL(hci_get_route);
 
-/* Create SCO, ACL or LE connection.
- * Device _must_ be locked */
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
-					__u16 pkt_type, bdaddr_t *dst,
-					__u8 sec_level, __u8 auth_type)
+struct hci_dev *hci_dev_get_type(u8 amp_type)
 {
-	struct hci_conn *acl;
-	struct hci_conn *sco;
-	struct hci_conn *le;
+	struct hci_dev *hdev = NULL;
+	struct hci_dev *d;
 
-	BT_DBG("%s dst %s", hdev->name, batostr(dst));
+	BT_DBG("amp_type %d", amp_type);
 
-	if (type == LE_LINK) {
-		struct adv_entry *entry;
+	read_lock_bh(&hci_dev_list_lock);
 
-		le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
-		if (le)
-			return ERR_PTR(-EBUSY);
+	list_for_each_entry(d, &hci_dev_list, list) {
+		if ((d->amp_type == amp_type) && test_bit(HCI_UP, &d->flags)) {
+			hdev = d;
+			break;
+		}
+	}
 
-		entry = hci_find_adv_entry(hdev, dst);
-		if (!entry)
-			return ERR_PTR(-EHOSTUNREACH);
+	if (hdev)
+		hdev = hci_dev_hold(hdev);
 
-		le = hci_conn_add(hdev, LE_LINK, 0, dst);
-		if (!le)
-			return ERR_PTR(-ENOMEM);
+	read_unlock_bh(&hci_dev_list_lock);
+	return hdev;
+}
+EXPORT_SYMBOL(hci_dev_get_type);
 
-		le->dst_type = entry->bdaddr_type;
+struct hci_dev *hci_dev_get_amp(bdaddr_t *dst)
+{
+	struct hci_dev *d;
+	struct hci_dev *hdev = NULL;
 
-		hci_le_connect(le);
+	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
-		hci_conn_hold(le);
+	read_lock_bh(&hci_dev_list_lock);
 
-		return le;
+	list_for_each_entry(d, &hci_dev_list, list) {
+		struct hci_conn *conn;
+		if (d->dev_type == HCI_BREDR)
+			continue;
+		conn = hci_conn_hash_lookup_ba(d, ACL_LINK, dst);
+		if (conn) {
+			hdev = d;
+			break;
+		}
 	}
 
+	if (hdev)
+		hdev = hci_dev_hold(hdev);
+
+	read_unlock_bh(&hci_dev_list_lock);
+	return hdev;
+}
+EXPORT_SYMBOL(hci_dev_get_amp);
+
+/* Create SCO, ACL or LE connection.
+ * Device _must_ be locked */
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
+					__u16 pkt_type, bdaddr_t *dst,
+					__u8 sec_level, __u8 auth_type)
+{
+	struct hci_conn *acl;
+	struct hci_conn *sco;
+
+	BT_DBG("%s dst %s", hdev->name, batostr(dst));
+
+	if (type == LE_LINK)
+		return hci_le_connect(hdev, pkt_type, dst, sec_level,
+							auth_type, NULL);
+
 	acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
 	if (!acl) {
 		acl = hci_conn_add(hdev, ACL_LINK, 0, dst);
@@ -577,7 +858,18 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
 	if (type == ACL_LINK)
 		return acl;
 
+	/* type of connection already existing can be ESCO or SCO
+	 * so check for both types before creating new */
+
 	sco = hci_conn_hash_lookup_ba(hdev, type, dst);
+
+	if (!sco && type == ESCO_LINK) {
+		sco = hci_conn_hash_lookup_ba(hdev, SCO_LINK, dst);
+	} else if (!sco && type == SCO_LINK) {
+		/* this case can be practically not possible */
+		sco = hci_conn_hash_lookup_ba(hdev, ESCO_LINK, dst);
+	}
+
 	if (!sco) {
 		sco = hci_conn_add(hdev, type, pkt_type, dst);
 		if (!sco) {
@@ -594,7 +886,7 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
 	if (acl->state == BT_CONNECTED &&
 			(sco->state == BT_OPEN || sco->state == BT_CLOSED)) {
 		acl->power_save = 1;
-		hci_conn_enter_active_mode(acl, BT_POWER_FORCE_ACTIVE_ON);
+		hci_conn_enter_active_mode(acl, 1);
 
 		if (test_bit(HCI_CONN_MODE_CHANGE_PEND, &acl->pend)) {
 			/* defer SCO setup until mode change completed */
@@ -609,6 +901,36 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
 }
 EXPORT_SYMBOL(hci_connect);
 
+void hci_disconnect(struct hci_conn *conn, __u8 reason)
+{
+	BT_DBG("conn %p", conn);
+
+	hci_proto_disconn_cfm(conn, reason, 0);
+}
+EXPORT_SYMBOL(hci_disconnect);
+
+void hci_disconnect_amp(struct hci_conn *conn, __u8 reason)
+{
+	struct hci_dev *hdev = NULL;
+
+	BT_DBG("conn %p", conn);
+
+	read_lock_bh(&hci_dev_list_lock);
+
+	list_for_each_entry(hdev, &hci_dev_list, list) {
+		struct hci_conn *c;
+		if (hdev == conn->hdev)
+			continue;
+		if (hdev->amp_type == HCI_BREDR)
+			continue;
+		c = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &conn->dst);
+		if (c)
+			hci_disconnect(c, reason);
+	}
+
+	read_unlock_bh(&hci_dev_list_lock);
+}
+
 /* Check link security requirement */
 int hci_conn_check_link_mode(struct hci_conn *conn)
 {
@@ -637,8 +959,8 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 
 	/* Make sure we preserve an existing MITM requirement*/
 	auth_type |= (conn->auth_type & 0x01);
-
 	conn->auth_type = auth_type;
+	conn->auth_initiator = 1;
 
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
 		struct hci_cp_auth_requested cp;
@@ -649,98 +971,53 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
 							sizeof(cp), &cp);
-		if (conn->key_type != 0xff)
-			set_bit(HCI_CONN_REAUTH_PEND, &conn->pend);
 	}
 
 	return 0;
 }
 
-/* Encrypt the the link */
-static void hci_conn_encrypt(struct hci_conn *conn)
-{
-	BT_DBG("conn %p", conn);
-
-	if (!test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
-		struct hci_cp_set_conn_encrypt cp;
-		cp.handle  = cpu_to_le16(conn->handle);
-		cp.encrypt = 0x01;
-		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),
-									&cp);
-	}
-}
-
 /* Enable security */
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 {
-	BT_DBG("conn %p", conn);
+	BT_DBG("conn %p %d %d", conn, sec_level, auth_type);
 
-	/* For sdp we don't need the link key. */
 	if (sec_level == BT_SECURITY_SDP)
 		return 1;
 
-	/* For non 2.1 devices and low security level we don't need the link
-	   key. */
 	if (sec_level == BT_SECURITY_LOW &&
 				(!conn->ssp_mode || !conn->hdev->ssp_mode))
 		return 1;
 
-	/* For other security levels we need the link key. */
-	if (!(conn->link_mode & HCI_LM_AUTH))
-		goto auth;
-
-	/* An authenticated combination key has sufficient security for any
-	   security level. */
-	if (conn->key_type == HCI_LK_AUTH_COMBINATION)
-		goto encrypt;
-
-	/* An unauthenticated combination key has sufficient security for
-	   security level 1 and 2. */
-	if (conn->key_type == HCI_LK_UNAUTH_COMBINATION &&
-			(sec_level == BT_SECURITY_MEDIUM ||
-			sec_level == BT_SECURITY_LOW))
-		goto encrypt;
-
-	/* A combination key has always sufficient security for the security
-	   levels 1 or 2. High security level requires the combination key
-	   is generated using maximum PIN code length (16).
-	   For pre 2.1 units. */
-	if (conn->key_type == HCI_LK_COMBINATION &&
-			(sec_level != BT_SECURITY_HIGH ||
-			conn->pin_length == 16))
-		goto encrypt;
-
-auth:
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
-		return 0;
+	if (conn->type == LE_LINK) {
+		if (conn->pending_sec_level > sec_level)
+			sec_level = conn->pending_sec_level;
 
-	if (!hci_conn_auth(conn, sec_level, auth_type))
+		if (sec_level > conn->sec_level)
+			conn->pending_sec_level = sec_level;
+		hci_proto_connect_cfm(conn, 0);
 		return 0;
+	} else if (conn->link_mode & HCI_LM_ENCRYPT) {
+		return hci_conn_auth(conn, sec_level, auth_type);
+	} else if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
+		return 0;
+	}
 
-encrypt:
-	if (conn->link_mode & HCI_LM_ENCRYPT)
-		return 1;
+	if (hci_conn_auth(conn, sec_level, auth_type)) {
+		struct hci_cp_set_conn_encrypt cp;
+		if (timer_pending(&conn->encrypt_pause_timer)) {
+			BT_INFO("encrypt_pause_timer is pending");
+			return 0;
+		}
+		cp.handle  = cpu_to_le16(conn->handle);
+		cp.encrypt = 1;
+		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT,
+							sizeof(cp), &cp);
+	}
 
-	hci_conn_encrypt(conn);
 	return 0;
 }
 EXPORT_SYMBOL(hci_conn_security);
 
-/* Check secure link requirement */
-int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level)
-{
-	BT_DBG("conn %p", conn);
-
-	if (sec_level != BT_SECURITY_HIGH)
-		return 1; /* Accept if non-secure is required */
-
-	if (conn->sec_level == BT_SECURITY_HIGH)
-		return 1;
-
-	return 0; /* Reject not secure link */
-}
-EXPORT_SYMBOL(hci_conn_check_secure);
-
 /* Change link key */
 int hci_conn_change_link_key(struct hci_conn *conn)
 {
@@ -786,6 +1063,9 @@ void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)
 	if (test_bit(HCI_RAW, &hdev->flags))
 		return;
 
+	if (conn->type == LE_LINK)
+		return;
+
 	if (conn->mode != HCI_CM_SNIFF)
 		goto timer;
 
@@ -799,23 +1079,170 @@ void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)
 	}
 
 timer:
-	if (hdev->idle_timeout > 0)
-		mod_timer(&conn->idle_timer,
-			jiffies + msecs_to_jiffies(hdev->idle_timeout));
+	if (hdev->idle_timeout > 0) {
+		spin_lock_bh(&conn->lock);
+		if (conn->conn_valid) {
+			mod_timer(&conn->idle_timer,
+				jiffies + msecs_to_jiffies(hdev->idle_timeout));
+		}
+		spin_unlock_bh(&conn->lock);
+	}
+}
+
+static inline void hci_conn_stop_rssi_timer(struct hci_conn *conn)
+{
+	BT_DBG("conn %p", conn);
+	cancel_delayed_work(&conn->rssi_update_work);
+}
+
+static inline void hci_conn_start_rssi_timer(struct hci_conn *conn,
+	u16 interval)
+{
+	struct hci_dev *hdev = conn->hdev;
+	BT_DBG("conn %p, pending %d", conn,
+			delayed_work_pending(&conn->rssi_update_work));
+	if (!delayed_work_pending(&conn->rssi_update_work)) {
+		queue_delayed_work(hdev->workqueue, &conn->rssi_update_work,
+				msecs_to_jiffies(interval));
+	}
+}
+
+void hci_conn_set_rssi_reporter(struct hci_conn *conn,
+	s8 rssi_threshold, u16 interval, u8 updateOnThreshExceed)
+{
+	if (conn) {
+		conn->rssi_threshold = rssi_threshold;
+		conn->rssi_update_interval = interval;
+		conn->rssi_update_thresh_exceed = updateOnThreshExceed;
+		hci_conn_start_rssi_timer(conn, interval);
+	}
+}
+
+void hci_conn_unset_rssi_reporter(struct hci_conn *conn)
+{
+	if (conn) {
+		BT_DBG("Deleting the rssi_update_timer");
+		hci_conn_stop_rssi_timer(conn);
+	}
 }
 
+/* Enter sniff mode */
+void hci_conn_enter_sniff_mode(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+
+	BT_DBG("conn %p mode %d", conn, conn->mode);
+
+	if (test_bit(HCI_RAW, &hdev->flags))
+		return;
+
+	if (conn->type == LE_LINK)
+		return;
+
+	if (!lmp_sniff_capable(hdev) || !lmp_sniff_capable(conn))
+		return;
+
+	if (conn->mode != HCI_CM_ACTIVE ||
+		!(conn->link_policy & HCI_LP_SNIFF) ||
+		(hci_find_link_key(hdev, &conn->dst) == NULL))
+		return;
+
+	if (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {
+		struct hci_cp_sniff_subrate cp;
+		cp.handle             = cpu_to_le16(conn->handle);
+		cp.max_latency        = cpu_to_le16(0);
+		cp.min_remote_timeout = cpu_to_le16(0);
+		cp.min_local_timeout  = cpu_to_le16(0);
+		hci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);
+	}
+
+	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
+		struct hci_cp_sniff_mode cp;
+		cp.handle       = cpu_to_le16(conn->handle);
+		cp.max_interval = cpu_to_le16(hdev->sniff_max_interval);
+		cp.min_interval = cpu_to_le16(hdev->sniff_min_interval);
+		cp.attempt      = cpu_to_le16(4);
+		cp.timeout      = cpu_to_le16(1);
+		hci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);
+	}
+}
+
+struct hci_chan *hci_chan_create(struct hci_chan *chan,
+			struct hci_ext_fs *tx_fs, struct hci_ext_fs *rx_fs)
+{
+	struct hci_cp_create_logical_link cp;
+
+	chan->state = BT_CONNECT;
+	chan->tx_fs = *tx_fs;
+	chan->rx_fs = *rx_fs;
+	cp.phy_handle = chan->conn->handle;
+	cp.tx_fs.id = chan->tx_fs.id;
+	cp.tx_fs.type = chan->tx_fs.type;
+	cp.tx_fs.max_sdu = cpu_to_le16(chan->tx_fs.max_sdu);
+	cp.tx_fs.sdu_arr_time = cpu_to_le32(chan->tx_fs.sdu_arr_time);
+	cp.tx_fs.acc_latency = cpu_to_le32(chan->tx_fs.acc_latency);
+	cp.tx_fs.flush_to = cpu_to_le32(chan->tx_fs.flush_to);
+	cp.rx_fs.id = chan->rx_fs.id;
+	cp.rx_fs.type = chan->rx_fs.type;
+	cp.rx_fs.max_sdu = cpu_to_le16(chan->rx_fs.max_sdu);
+	cp.rx_fs.sdu_arr_time = cpu_to_le32(chan->rx_fs.sdu_arr_time);
+	cp.rx_fs.acc_latency = cpu_to_le32(chan->rx_fs.acc_latency);
+	cp.rx_fs.flush_to = cpu_to_le32(chan->rx_fs.flush_to);
+	hci_conn_hold(chan->conn);
+	if (chan->conn->out)
+		hci_send_cmd(chan->conn->hdev, HCI_OP_CREATE_LOGICAL_LINK,
+							sizeof(cp), &cp);
+	else
+		hci_send_cmd(chan->conn->hdev, HCI_OP_ACCEPT_LOGICAL_LINK,
+							sizeof(cp), &cp);
+	return chan;
+}
+EXPORT_SYMBOL(hci_chan_create);
+
+void hci_chan_modify(struct hci_chan *chan,
+			struct hci_ext_fs *tx_fs, struct hci_ext_fs *rx_fs)
+{
+	struct hci_cp_flow_spec_modify cp;
+
+	chan->tx_fs = *tx_fs;
+	chan->rx_fs = *rx_fs;
+	cp.log_handle = cpu_to_le16(chan->ll_handle);
+	cp.tx_fs.id = tx_fs->id;
+	cp.tx_fs.type = tx_fs->type;
+	cp.tx_fs.max_sdu = cpu_to_le16(tx_fs->max_sdu);
+	cp.tx_fs.sdu_arr_time = cpu_to_le32(tx_fs->sdu_arr_time);
+	cp.tx_fs.acc_latency = cpu_to_le32(tx_fs->acc_latency);
+	cp.tx_fs.flush_to = cpu_to_le32(tx_fs->flush_to);
+	cp.rx_fs.id = rx_fs->id;
+	cp.rx_fs.type = rx_fs->type;
+	cp.rx_fs.max_sdu = cpu_to_le16(rx_fs->max_sdu);
+	cp.rx_fs.sdu_arr_time = cpu_to_le32(rx_fs->sdu_arr_time);
+	cp.rx_fs.acc_latency = cpu_to_le32(rx_fs->acc_latency);
+	cp.rx_fs.flush_to = cpu_to_le32(rx_fs->flush_to);
+	hci_conn_hold(chan->conn);
+	hci_send_cmd(chan->conn->hdev, HCI_OP_FLOW_SPEC_MODIFY, sizeof(cp),
+									&cp);
+}
+EXPORT_SYMBOL(hci_chan_modify);
+
 /* Drop all connection on the device */
-void hci_conn_hash_flush(struct hci_dev *hdev)
+void hci_conn_hash_flush(struct hci_dev *hdev, u8 is_process)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct hci_conn *c;
+	struct list_head *p;
 
 	BT_DBG("hdev %s", hdev->name);
 
-	list_for_each_entry_rcu(c, &h->list, list) {
+	p = h->list.next;
+	while (p != &h->list) {
+		struct hci_conn *c;
+
+		c = list_entry(p, struct hci_conn, list);
+		p = p->next;
+
 		c->state = BT_CLOSED;
 
-		hci_proto_disconn_cfm(c, HCI_ERROR_LOCAL_HOST_TERM);
+		hci_proto_disconn_cfm(c, 0x16, is_process);
 		hci_conn_del(c);
 	}
 }
@@ -844,17 +1271,19 @@ EXPORT_SYMBOL(hci_conn_hold_device);
 
 void hci_conn_put_device(struct hci_conn *conn)
 {
-	if (atomic_dec_and_test(&conn->devref))
+	if (atomic_dec_and_test(&conn->devref)) {
+		conn->hidp_session_valid = false;
 		hci_conn_del_sysfs(conn);
+	}
 }
 EXPORT_SYMBOL(hci_conn_put_device);
 
 int hci_get_conn_list(void __user *arg)
 {
-	register struct hci_conn *c;
 	struct hci_conn_list_req req, *cl;
 	struct hci_conn_info *ci;
 	struct hci_dev *hdev;
+	struct list_head *p;
 	int n = 0, size, err;
 
 	if (copy_from_user(&req, arg, sizeof(req)))
@@ -877,8 +1306,11 @@ int hci_get_conn_list(void __user *arg)
 
 	ci = cl->conn_info;
 
-	hci_dev_lock(hdev);
-	list_for_each_entry(c, &hdev->conn_hash.list, list) {
+	hci_dev_lock_bh(hdev);
+	list_for_each(p, &hdev->conn_hash.list) {
+		register struct hci_conn *c;
+		c = list_entry(p, struct hci_conn, list);
+
 		bacpy(&(ci + n)->bdaddr, &c->dst);
 		(ci + n)->handle = c->handle;
 		(ci + n)->type  = c->type;
@@ -897,7 +1329,7 @@ int hci_get_conn_list(void __user *arg)
 		if (++n >= req.conn_num)
 			break;
 	}
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 
 	cl->dev_id = hdev->id;
 	cl->conn_num = n;
@@ -921,7 +1353,7 @@ int hci_get_conn_info(struct hci_dev *hdev, void __user *arg)
 	if (copy_from_user(&req, arg, sizeof(req)))
 		return -EFAULT;
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 	conn = hci_conn_hash_lookup_ba(hdev, req.type, &req.bdaddr);
 	if (conn) {
 		bacpy(&ci.bdaddr, &conn->dst);
@@ -939,8 +1371,10 @@ int hci_get_conn_info(struct hci_dev *hdev, void __user *arg)
 			ci.cnt = hdev->acl_cnt;
 			ci.pkts = hdev->acl_pkts;
 		}
+		ci.pending_sec_level = conn->pending_sec_level;
+		ci.ssp_mode = conn->ssp_mode;
 	}
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 
 	if (!conn)
 		return -ENOENT;
@@ -956,11 +1390,11 @@ int hci_get_auth_info(struct hci_dev *hdev, void __user *arg)
 	if (copy_from_user(&req, arg, sizeof(req)))
 		return -EFAULT;
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &req.bdaddr);
 	if (conn)
 		req.type = conn->auth_type;
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 
 	if (!conn)
 		return -ENOENT;
@@ -968,48 +1402,38 @@ int hci_get_auth_info(struct hci_dev *hdev, void __user *arg)
 	return copy_to_user(arg, &req, sizeof(req)) ? -EFAULT : 0;
 }
 
-struct hci_chan *hci_chan_create(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_chan *chan;
-
-	BT_DBG("%s conn %p", hdev->name, conn);
-
-	chan = kzalloc(sizeof(struct hci_chan), GFP_ATOMIC);
-	if (!chan)
-		return NULL;
-
-	chan->conn = conn;
-	skb_queue_head_init(&chan->data_q);
-
-	list_add_rcu(&chan->list, &conn->chan_list);
-
-	return chan;
-}
-
-int hci_chan_del(struct hci_chan *chan)
+int hci_set_auth_info(struct hci_dev *hdev, void __user *arg)
 {
-	struct hci_conn *conn = chan->conn;
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("%s conn %p chan %p", hdev->name, conn, chan);
-
-	list_del_rcu(&chan->list);
-
-	synchronize_rcu();
-
-	skb_queue_purge(&chan->data_q);
-	kfree(chan);
+	struct hci_auth_info_req req;
+	struct hci_conn *conn;
 
-	return 0;
-}
+	if (copy_from_user(&req, arg, sizeof(req)))
+		return -EFAULT;
 
-void hci_chan_list_flush(struct hci_conn *conn)
-{
-	struct hci_chan *chan;
+	hci_dev_lock_bh(hdev);
+	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &req.bdaddr);
+	if (conn) {
+		conn->auth_type = req.type;
+		switch (conn->auth_type) {
+		case HCI_AT_NO_BONDING:
+			conn->pending_sec_level = BT_SECURITY_LOW;
+			break;
+		case HCI_AT_DEDICATED_BONDING:
+		case HCI_AT_GENERAL_BONDING:
+			conn->pending_sec_level = BT_SECURITY_MEDIUM;
+			break;
+		case HCI_AT_DEDICATED_BONDING_MITM:
+		case HCI_AT_GENERAL_BONDING_MITM:
+			conn->pending_sec_level = BT_SECURITY_HIGH;
+			break;
+		default:
+			break;
+		}
+	}
+	hci_dev_unlock_bh(hdev);
 
-	BT_DBG("conn %p", conn);
+	if (!conn)
+		return -ENOENT;
 
-	list_for_each_entry_rcu(chan, &conn->chan_list, list)
-		hci_chan_del(chan);
+	return copy_to_user(arg, &req, sizeof(req)) ? -EFAULT : 0;
 }
diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
old mode 100755
new mode 100644
index f37ad7f..9962c88
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -1,7 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (C) 2000-2001 Qualcomm Incorporated
-   Copyright (C) 2011 ProFUSION Embedded Systems
+   Copyright (c) 2000-2001, 2010-2012 The Linux Foundation.  All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -55,11 +54,13 @@
 
 #define AUTO_OFF_TIMEOUT 2000
 
-bool enable_hs;
+static void hci_cmd_task(unsigned long arg);
+static void hci_rx_task(unsigned long arg);
+static void hci_tx_task(unsigned long arg);
 
-static void hci_rx_work(struct work_struct *work);
-static void hci_cmd_work(struct work_struct *work);
-static void hci_tx_work(struct work_struct *work);
+static DEFINE_RWLOCK(hci_task_lock);
+
+static bool enable_smp = 1;
 
 /* HCI device list */
 LIST_HEAD(hci_dev_list);
@@ -69,6 +70,14 @@ DEFINE_RWLOCK(hci_dev_list_lock);
 LIST_HEAD(hci_cb_list);
 DEFINE_RWLOCK(hci_cb_list_lock);
 
+/* AMP Manager event callbacks */
+LIST_HEAD(amp_mgr_cb_list);
+DEFINE_RWLOCK(amp_mgr_cb_list_lock);
+
+/* HCI protocols */
+#define HCI_MAX_PROTO	2
+struct hci_proto *hci_proto[HCI_MAX_PROTO];
+
 /* HCI notifiers list */
 static ATOMIC_NOTIFIER_HEAD(hci_notifier);
 
@@ -78,17 +87,11 @@ int hci_register_notifier(struct notifier_block *nb)
 {
 	return atomic_notifier_chain_register(&hci_notifier, nb);
 }
-#ifdef CONFIG_BT_BLUESLEEP
-EXPORT_SYMBOL(hci_register_notifier);
-#endif
 
 int hci_unregister_notifier(struct notifier_block *nb)
 {
 	return atomic_notifier_chain_unregister(&hci_notifier, nb);
 }
-#ifdef CONFIG_BT_BLUESLEEP
-EXPORT_SYMBOL(hci_unregister_notifier);
-#endif
 
 static void hci_notify(struct hci_dev *hdev, int event)
 {
@@ -149,7 +152,7 @@ static int __hci_request(struct hci_dev *hdev, void (*req)(struct hci_dev *hdev,
 
 	switch (hdev->req_status) {
 	case HCI_REQ_DONE:
-		err = -bt_to_errno(hdev->req_result);
+		err = -bt_err(hdev->req_result);
 		break;
 
 	case HCI_REQ_CANCELED:
@@ -190,104 +193,110 @@ static void hci_reset_req(struct hci_dev *hdev, unsigned long opt)
 
 	/* Reset device */
 	set_bit(HCI_RESET, &hdev->flags);
+	memset(&hdev->features, 0, sizeof(hdev->features));
 	hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
 }
 
-static void bredr_init(struct hci_dev *hdev)
+static void hci_init_req(struct hci_dev *hdev, unsigned long opt)
 {
 	struct hci_cp_delete_stored_link_key cp;
+	struct sk_buff *skb;
 	__le16 param;
 	__u8 flt_type;
 
-	hdev->flow_ctl_mode = HCI_FLOW_CTL_MODE_PACKET_BASED;
+	BT_DBG("%s %ld", hdev->name, opt);
+
+	/* Driver initialization */
+
+	/* Special commands */
+	while ((skb = skb_dequeue(&hdev->driver_init))) {
+		bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
+		skb->dev = (void *) hdev;
+
+		skb_queue_tail(&hdev->cmd_q, skb);
+		tasklet_schedule(&hdev->cmd_task);
+	}
+	skb_queue_purge(&hdev->driver_init);
 
 	/* Mandatory initialization */
 
 	/* Reset */
 	if (!test_bit(HCI_QUIRK_NO_RESET, &hdev->quirks)) {
-		set_bit(HCI_RESET, &hdev->flags);
-		hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
+			set_bit(HCI_RESET, &hdev->flags);
+			hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
 	}
 
-	/* Read Local Supported Features */
-	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_FEATURES, 0, NULL);
-
 	/* Read Local Version */
 	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL);
 
-	/* Read Buffer Size (ACL mtu, max pkt, etc.) */
-	hci_send_cmd(hdev, HCI_OP_READ_BUFFER_SIZE, 0, NULL);
-
-	/* Read BD Address */
-	hci_send_cmd(hdev, HCI_OP_READ_BD_ADDR, 0, NULL);
-
-	/* Read Class of Device */
-	hci_send_cmd(hdev, HCI_OP_READ_CLASS_OF_DEV, 0, NULL);
 
-	/* Read Local Name */
-	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_NAME, 0, NULL);
-
-	/* Read Voice Setting */
-	hci_send_cmd(hdev, HCI_OP_READ_VOICE_SETTING, 0, NULL);
-
-	/* Optional initialization */
+	/* Set default HCI Flow Control Mode */
+	if (hdev->dev_type == HCI_BREDR)
+		hdev->flow_ctl_mode = HCI_PACKET_BASED_FLOW_CTL_MODE;
+	else
+		hdev->flow_ctl_mode = HCI_BLOCK_BASED_FLOW_CTL_MODE;
 
-	/* Clear Event Filters */
-	flt_type = HCI_FLT_CLEAR_ALL;
-	hci_send_cmd(hdev, HCI_OP_SET_EVENT_FLT, 1, &flt_type);
+	/* Read HCI Flow Control Mode */
+	hci_send_cmd(hdev, HCI_OP_READ_FLOW_CONTROL_MODE, 0, NULL);
 
-	/* Connection accept timeout ~20 secs */
-	param = cpu_to_le16(0x7d00);
-	hci_send_cmd(hdev, HCI_OP_WRITE_CA_TIMEOUT, 2, &param);
+	/* Read Buffer Size (ACL mtu, max pkt, etc.) */
+	hci_send_cmd(hdev, HCI_OP_READ_BUFFER_SIZE, 0, NULL);
 
-	bacpy(&cp.bdaddr, BDADDR_ANY);
-	cp.delete_all = 1;
-	hci_send_cmd(hdev, HCI_OP_DELETE_STORED_LINK_KEY, sizeof(cp), &cp);
-}
+	/* Read Data Block Size (ACL mtu, max pkt, etc.) */
+	hci_send_cmd(hdev, HCI_OP_READ_DATA_BLOCK_SIZE, 0, NULL);
 
-static void amp_init(struct hci_dev *hdev)
-{
-	hdev->flow_ctl_mode = HCI_FLOW_CTL_MODE_BLOCK_BASED;
+#if 0
+	/* Host buffer size */
+	{
+		struct hci_cp_host_buffer_size cp;
+		cp.acl_mtu = cpu_to_le16(HCI_MAX_ACL_SIZE);
+		cp.sco_mtu = HCI_MAX_SCO_SIZE;
+		cp.acl_max_pkt = cpu_to_le16(0xffff);
+		cp.sco_max_pkt = cpu_to_le16(0xffff);
+		hci_send_cmd(hdev, HCI_OP_HOST_BUFFER_SIZE, sizeof(cp), &cp);
+	}
+#endif
 
-	/* Reset */
-	hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
+	if (hdev->dev_type == HCI_BREDR) {
+		/* BR-EDR initialization */
 
-	/* Read Local Version */
-	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL);
-}
+		/* Read Local Supported Features */
+		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_FEATURES, 0, NULL);
 
-static void hci_init_req(struct hci_dev *hdev, unsigned long opt)
-{
-	struct sk_buff *skb;
+		/* Read BD Address */
+		hci_send_cmd(hdev, HCI_OP_READ_BD_ADDR, 0, NULL);
 
-	BT_DBG("%s %ld", hdev->name, opt);
+		/* Read Class of Device */
+		hci_send_cmd(hdev, HCI_OP_READ_CLASS_OF_DEV, 0, NULL);
 
-	/* Driver initialization */
+		/* Read Local Name */
+		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_NAME, 0, NULL);
 
-	/* Special commands */
-	while ((skb = skb_dequeue(&hdev->driver_init))) {
-		bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
-		skb->dev = (void *) hdev;
+		/* Read Voice Setting */
+		hci_send_cmd(hdev, HCI_OP_READ_VOICE_SETTING, 0, NULL);
 
-		skb_queue_tail(&hdev->cmd_q, skb);
-		queue_work(hdev->workqueue, &hdev->cmd_work);
-	}
-	skb_queue_purge(&hdev->driver_init);
+		/* Optional initialization */
+		/* Clear Event Filters */
+		flt_type = HCI_FLT_CLEAR_ALL;
+		hci_send_cmd(hdev, HCI_OP_SET_EVENT_FLT, 1, &flt_type);
 
-	switch (hdev->dev_type) {
-	case HCI_BREDR:
-		bredr_init(hdev);
-		break;
+		/* Connection accept timeout ~20 secs */
+		param = cpu_to_le16(0x7d00);
+		hci_send_cmd(hdev, HCI_OP_WRITE_CA_TIMEOUT, 2, &param);
 
-	case HCI_AMP:
-		amp_init(hdev);
-		break;
+		bacpy(&cp.bdaddr, BDADDR_ANY);
+		cp.delete_all = 1;
+		hci_send_cmd(hdev, HCI_OP_DELETE_STORED_LINK_KEY,
+				sizeof(cp), &cp);
+	} else {
+		/* AMP initialization */
+		/* Connection accept timeout ~5 secs */
+		param = cpu_to_le16(0x1f40);
+		hci_send_cmd(hdev, HCI_OP_WRITE_CA_TIMEOUT, 2, &param);
 
-	default:
-		BT_ERR("Unknown device type %d", hdev->dev_type);
-		break;
+		/* Read AMP Info */
+		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_AMP_INFO, 0, NULL);
 	}
-
 }
 
 static void hci_le_init_req(struct hci_dev *hdev, unsigned long opt)
@@ -296,6 +305,12 @@ static void hci_le_init_req(struct hci_dev *hdev, unsigned long opt)
 
 	/* Read LE buffer size */
 	hci_send_cmd(hdev, HCI_OP_LE_READ_BUFFER_SIZE, 0, NULL);
+
+	/* Read LE clear white list */
+	hci_send_cmd(hdev, HCI_OP_LE_CLEAR_WHITE_LIST, 0, NULL);
+
+	/* Read LE white list size */
+	hci_send_cmd(hdev, HCI_OP_LE_READ_WHITE_LIST_SIZE, 0, NULL);
 }
 
 static void hci_scan_req(struct hci_dev *hdev, unsigned long opt)
@@ -342,7 +357,8 @@ static void hci_linkpol_req(struct hci_dev *hdev, unsigned long opt)
  * Device is held on return. */
 struct hci_dev *hci_dev_get(int index)
 {
-	struct hci_dev *hdev = NULL, *d;
+	struct hci_dev *hdev = NULL;
+	struct list_head *p;
 
 	BT_DBG("%d", index);
 
@@ -350,7 +366,8 @@ struct hci_dev *hci_dev_get(int index)
 		return NULL;
 
 	read_lock(&hci_dev_list_lock);
-	list_for_each_entry(d, &hci_dev_list, list) {
+	list_for_each(p, &hci_dev_list) {
+		struct hci_dev *d = list_entry(p, struct hci_dev, list);
 		if (d->id == index) {
 			hdev = hci_dev_hold(d);
 			break;
@@ -359,6 +376,7 @@ struct hci_dev *hci_dev_get(int index)
 	read_unlock(&hci_dev_list_lock);
 	return hdev;
 }
+EXPORT_SYMBOL(hci_dev_get);
 
 /* ---- Inquiry support ---- */
 static void inquiry_cache_flush(struct hci_dev *hdev)
@@ -466,14 +484,14 @@ int hci_inquiry(void __user *arg)
 	if (!hdev)
 		return -ENODEV;
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 	if (inquiry_cache_age(hdev) > INQUIRY_CACHE_AGE_MAX ||
 				inquiry_cache_empty(hdev) ||
 				ir.flags & IREQ_CACHE_FLUSH) {
 		inquiry_cache_flush(hdev);
 		do_inquiry = 1;
 	}
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 
 	timeo = ir.length * msecs_to_jiffies(2000);
 
@@ -495,9 +513,9 @@ int hci_inquiry(void __user *arg)
 		goto done;
 	}
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 	ir.num_rsp = inquiry_cache_dump(hdev, max_rsp, buf);
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 
 	BT_DBG("num_rsp %d", ir.num_rsp);
 
@@ -544,16 +562,24 @@ int hci_dev_open(__u16 dev)
 	if (test_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks))
 		set_bit(HCI_RAW, &hdev->flags);
 
-	/* Treat all non BR/EDR controllers as raw devices if
-	   enable_hs is not set */
-	if (hdev->dev_type != HCI_BREDR && !enable_hs)
-		set_bit(HCI_RAW, &hdev->flags);
-
 	if (hdev->open(hdev)) {
 		ret = -EIO;
 		goto done;
 	}
 
+	if (!skb_queue_empty(&hdev->cmd_q)) {
+		BT_ERR("command queue is not empty, purging");
+		skb_queue_purge(&hdev->cmd_q);
+	}
+	if (!skb_queue_empty(&hdev->rx_q)) {
+		BT_ERR("rx queue is not empty, purging");
+		skb_queue_purge(&hdev->rx_q);
+	}
+	if (!skb_queue_empty(&hdev->raw_q)) {
+		BT_ERR("raw queue is not empty, purging");
+		skb_queue_purge(&hdev->raw_q);
+	}
+
 	if (!test_bit(HCI_RAW, &hdev->flags)) {
 		atomic_set(&hdev->cmd_cnt, 1);
 		set_bit(HCI_INIT, &hdev->flags);
@@ -562,7 +588,7 @@ int hci_dev_open(__u16 dev)
 		ret = __hci_request(hdev, hci_init_req, 0,
 					msecs_to_jiffies(HCI_INIT_TIMEOUT));
 
-		if (lmp_host_le_capable(hdev))
+		if (lmp_le_capable(hdev))
 			ret = __hci_request(hdev, hci_le_init_req, 0,
 					msecs_to_jiffies(HCI_INIT_TIMEOUT));
 
@@ -573,16 +599,17 @@ int hci_dev_open(__u16 dev)
 		hci_dev_hold(hdev);
 		set_bit(HCI_UP, &hdev->flags);
 		hci_notify(hdev, HCI_DEV_UP);
-		if (!test_bit(HCI_SETUP, &hdev->flags)) {
-			hci_dev_lock(hdev);
-			mgmt_powered(hdev, 1);
-			hci_dev_unlock(hdev);
+		if (!test_bit(HCI_SETUP, &hdev->flags) &&
+				hdev->dev_type == HCI_BREDR) {
+			hci_dev_lock_bh(hdev);
+			mgmt_powered(hdev->id, 1);
+			hci_dev_unlock_bh(hdev);
 		}
 	} else {
 		/* Init failed, cleanup */
-		flush_work(&hdev->tx_work);
-		flush_work(&hdev->cmd_work);
-		flush_work(&hdev->rx_work);
+		tasklet_kill(&hdev->rx_task);
+		tasklet_kill(&hdev->tx_task);
+		tasklet_kill(&hdev->cmd_task);
 
 		skb_queue_purge(&hdev->cmd_q);
 		skb_queue_purge(&hdev->rx_q);
@@ -605,8 +632,10 @@ done:
 	return ret;
 }
 
-static int hci_dev_do_close(struct hci_dev *hdev)
+static int hci_dev_do_close(struct hci_dev *hdev, u8 is_process)
 {
+	unsigned long keepflags = 0;
+
 	BT_DBG("%s %p", hdev->name, hdev);
 
 	hci_req_cancel(hdev, ENODEV);
@@ -618,44 +647,38 @@ static int hci_dev_do_close(struct hci_dev *hdev)
 		return 0;
 	}
 
-	/* Flush RX and TX works */
-	flush_work(&hdev->tx_work);
-	flush_work(&hdev->rx_work);
-
-	if (hdev->discov_timeout > 0) {
-		cancel_delayed_work(&hdev->discov_off);
-		hdev->discov_timeout = 0;
-	}
-
-	if (test_and_clear_bit(HCI_AUTO_OFF, &hdev->flags))
-		cancel_delayed_work(&hdev->power_off);
+	/* Kill RX and TX tasks */
+	tasklet_kill(&hdev->rx_task);
+	tasklet_kill(&hdev->tx_task);
 
-	if (test_and_clear_bit(HCI_SERVICE_CACHE, &hdev->flags))
-		cancel_delayed_work(&hdev->service_cache);
-
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 	inquiry_cache_flush(hdev);
-	hci_conn_hash_flush(hdev);
-	hci_dev_unlock(hdev);
+	hci_conn_hash_flush(hdev, is_process);
+	hci_dev_unlock_bh(hdev);
 
 	hci_notify(hdev, HCI_DEV_DOWN);
 
+	if (hdev->dev_type == HCI_BREDR) {
+		hci_dev_lock_bh(hdev);
+		mgmt_powered(hdev->id, 0);
+		hci_dev_unlock_bh(hdev);
+	}
+
 	if (hdev->flush)
 		hdev->flush(hdev);
 
 	/* Reset device */
 	skb_queue_purge(&hdev->cmd_q);
 	atomic_set(&hdev->cmd_cnt, 1);
-	if (!test_bit(HCI_RAW, &hdev->flags) &&
-				test_bit(HCI_QUIRK_NO_RESET, &hdev->quirks)) {
+	if (!test_bit(HCI_RAW, &hdev->flags)) {
 		set_bit(HCI_INIT, &hdev->flags);
 		__hci_request(hdev, hci_reset_req, 0,
 					msecs_to_jiffies(250));
 		clear_bit(HCI_INIT, &hdev->flags);
 	}
 
-	/* flush cmd  work */
-	flush_work(&hdev->cmd_work);
+	/* Kill cmd task */
+	tasklet_kill(&hdev->cmd_task);
 
 	/* Drop queues */
 	skb_queue_purge(&hdev->rx_q);
@@ -673,12 +696,15 @@ static int hci_dev_do_close(struct hci_dev *hdev)
 	 * and no tasks are scheduled. */
 	hdev->close(hdev);
 
-	hci_dev_lock(hdev);
-	mgmt_powered(hdev, 0);
-	hci_dev_unlock(hdev);
+	/* Clear only non-persistent flags */
+	if (test_bit(HCI_MGMT, &hdev->flags))
+		set_bit(HCI_MGMT, &keepflags);
+	if (test_bit(HCI_LINK_KEYS, &hdev->flags))
+		set_bit(HCI_LINK_KEYS, &keepflags);
+	if (test_bit(HCI_DEBUG_KEYS, &hdev->flags))
+		set_bit(HCI_DEBUG_KEYS, &keepflags);
 
-	/* Clear flags */
-	hdev->flags = 0;
+	hdev->flags = keepflags;
 
 	hci_req_unlock(hdev);
 
@@ -694,7 +720,7 @@ int hci_dev_close(__u16 dev)
 	hdev = hci_dev_get(dev);
 	if (!hdev)
 		return -ENODEV;
-	err = hci_dev_do_close(hdev);
+	err = hci_dev_do_close(hdev, 1);
 	hci_dev_put(hdev);
 	return err;
 }
@@ -709,6 +735,7 @@ int hci_dev_reset(__u16 dev)
 		return -ENODEV;
 
 	hci_req_lock(hdev);
+	tasklet_disable(&hdev->tx_task);
 
 	if (!test_bit(HCI_UP, &hdev->flags))
 		goto done;
@@ -717,10 +744,10 @@ int hci_dev_reset(__u16 dev)
 	skb_queue_purge(&hdev->rx_q);
 	skb_queue_purge(&hdev->cmd_q);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 	inquiry_cache_flush(hdev);
-	hci_dev_unlock(hdev);
-	hci_conn_hash_flush(hdev);
+	hci_conn_hash_flush(hdev, 0);
+	hci_dev_unlock_bh(hdev);
 
 	if (hdev->flush)
 		hdev->flush(hdev);
@@ -733,6 +760,7 @@ int hci_dev_reset(__u16 dev)
 					msecs_to_jiffies(HCI_INIT_TIMEOUT));
 
 done:
+	tasklet_enable(&hdev->tx_task);
 	hci_req_unlock(hdev);
 	hci_dev_put(hdev);
 	return ret;
@@ -831,9 +859,9 @@ int hci_dev_cmd(unsigned int cmd, void __user *arg)
 
 int hci_get_dev_list(void __user *arg)
 {
-	struct hci_dev *hdev;
 	struct hci_dev_list_req *dl;
 	struct hci_dev_req *dr;
+	struct list_head *p;
 	int n = 0, size, err;
 	__u16 dev_num;
 
@@ -851,10 +879,13 @@ int hci_get_dev_list(void __user *arg)
 
 	dr = dl->dev_req;
 
-	read_lock(&hci_dev_list_lock);
-	list_for_each_entry(hdev, &hci_dev_list, list) {
-		if (test_and_clear_bit(HCI_AUTO_OFF, &hdev->flags))
-			cancel_delayed_work(&hdev->power_off);
+	read_lock_bh(&hci_dev_list_lock);
+	list_for_each(p, &hci_dev_list) {
+		struct hci_dev *hdev;
+
+		hdev = list_entry(p, struct hci_dev, list);
+
+		hci_del_off_timer(hdev);
 
 		if (!test_bit(HCI_MGMT, &hdev->flags))
 			set_bit(HCI_PAIRABLE, &hdev->flags);
@@ -865,7 +896,7 @@ int hci_get_dev_list(void __user *arg)
 		if (++n >= dev_num)
 			break;
 	}
-	read_unlock(&hci_dev_list_lock);
+	read_unlock_bh(&hci_dev_list_lock);
 
 	dl->dev_num = n;
 	size = sizeof(*dl) + n * sizeof(*dr);
@@ -889,8 +920,7 @@ int hci_get_dev_info(void __user *arg)
 	if (!hdev)
 		return -ENODEV;
 
-	if (test_and_clear_bit(HCI_AUTO_OFF, &hdev->flags))
-		cancel_delayed_work_sync(&hdev->power_off);
+	hci_del_off_timer(hdev);
 
 	if (!test_bit(HCI_MGMT, &hdev->flags))
 		set_bit(HCI_PAIRABLE, &hdev->flags);
@@ -929,7 +959,7 @@ static int hci_rfkill_set_block(void *data, bool blocked)
 	if (!blocked)
 		return 0;
 
-	hci_dev_do_close(hdev);
+	hci_dev_do_close(hdev, 0);
 
 	return 0;
 }
@@ -947,7 +977,6 @@ struct hci_dev *hci_alloc_dev(void)
 	if (!hdev)
 		return NULL;
 
-	hci_init_sysfs(hdev);
 	skb_queue_head_init(&hdev->driver_init);
 
 	return hdev;
@@ -967,48 +996,50 @@ EXPORT_SYMBOL(hci_free_dev);
 static void hci_power_on(struct work_struct *work)
 {
 	struct hci_dev *hdev = container_of(work, struct hci_dev, power_on);
+	int err;
 
 	BT_DBG("%s", hdev->name);
 
-	if (hci_dev_open(hdev->id) < 0)
+	err = hci_dev_open(hdev->id);
+	if (err && err != -EALREADY)
 		return;
 
-	if (test_bit(HCI_AUTO_OFF, &hdev->flags))
-		schedule_delayed_work(&hdev->power_off,
-					msecs_to_jiffies(AUTO_OFF_TIMEOUT));
+	if (test_bit(HCI_AUTO_OFF, &hdev->flags) &&
+				hdev->dev_type == HCI_BREDR)
+		mod_timer(&hdev->off_timer,
+				jiffies + msecs_to_jiffies(AUTO_OFF_TIMEOUT));
 
-	if (test_and_clear_bit(HCI_SETUP, &hdev->flags))
-		mgmt_index_added(hdev);
+	if (test_and_clear_bit(HCI_SETUP, &hdev->flags) &&
+				hdev->dev_type == HCI_BREDR)
+		mgmt_index_added(hdev->id);
 }
 
 static void hci_power_off(struct work_struct *work)
 {
-	struct hci_dev *hdev = container_of(work, struct hci_dev,
-							power_off.work);
+	struct hci_dev *hdev = container_of(work, struct hci_dev, power_off);
 
 	BT_DBG("%s", hdev->name);
 
-	clear_bit(HCI_AUTO_OFF, &hdev->flags);
-
 	hci_dev_close(hdev->id);
 }
 
-static void hci_discov_off(struct work_struct *work)
+static void hci_auto_off(unsigned long data)
 {
-	struct hci_dev *hdev;
-	u8 scan = SCAN_PAGE;
-
-	hdev = container_of(work, struct hci_dev, discov_off.work);
+	struct hci_dev *hdev = (struct hci_dev *) data;
 
 	BT_DBG("%s", hdev->name);
 
-	hci_dev_lock(hdev);
+	clear_bit(HCI_AUTO_OFF, &hdev->flags);
 
-	hci_send_cmd(hdev, HCI_OP_WRITE_SCAN_ENABLE, sizeof(scan), &scan);
+	queue_work(hdev->workqueue, &hdev->power_off);
+}
 
-	hdev->discov_timeout = 0;
+void hci_del_off_timer(struct hci_dev *hdev)
+{
+	BT_DBG("%s", hdev->name);
 
-	hci_dev_unlock(hdev);
+	clear_bit(HCI_AUTO_OFF, &hdev->flags);
+	del_timer(&hdev->off_timer);
 }
 
 int hci_uuids_clear(struct hci_dev *hdev)
@@ -1045,59 +1076,31 @@ int hci_link_keys_clear(struct hci_dev *hdev)
 
 struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr)
 {
-	struct link_key *k;
+	struct list_head *p;
+
+	list_for_each(p, &hdev->link_keys) {
+		struct link_key *k;
+
+		k = list_entry(p, struct link_key, list);
 
-	list_for_each_entry(k, &hdev->link_keys, list)
 		if (bacmp(bdaddr, &k->bdaddr) == 0)
 			return k;
+	}
 
 	return NULL;
 }
 
-static int hci_persistent_key(struct hci_dev *hdev, struct hci_conn *conn,
-						u8 key_type, u8 old_key_type)
-{
-	/* Legacy key */
-	if (key_type < 0x03)
-		return 1;
-
-	/* Debug keys are insecure so don't store them persistently */
-	if (key_type == HCI_LK_DEBUG_COMBINATION)
-		return 0;
-
-	/* Changed combination key and there's no previous one */
-	if (key_type == HCI_LK_CHANGED_COMBINATION && old_key_type == 0xff)
-		return 0;
-
-	/* Security mode 3 case */
-	if (!conn)
-		return 1;
-
-	/* Neither local nor remote side had no-bonding as requirement */
-	if (conn->auth_type > 0x01 && conn->remote_auth > 0x01)
-		return 1;
-
-	/* Local side had dedicated bonding as requirement */
-	if (conn->auth_type == 0x02 || conn->auth_type == 0x03)
-		return 1;
-
-	/* Remote side had dedicated bonding as requirement */
-	if (conn->remote_auth == 0x02 || conn->remote_auth == 0x03)
-		return 1;
-
-	/* If none of the above criteria match, then don't store the key
-	 * persistently */
-	return 0;
-}
-
 struct link_key *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8])
 {
-	struct link_key *k;
+	struct list_head *p;
 
-	list_for_each_entry(k, &hdev->link_keys, list) {
+	list_for_each(p, &hdev->link_keys) {
+		struct link_key *k;
 		struct key_master_id *id;
 
-		if (k->type != HCI_LK_SMP_LTK)
+		k = list_entry(p, struct link_key, list);
+
+		if (k->key_type != KEY_TYPE_LTK)
 			continue;
 
 		if (k->dlen != sizeof(*id))
@@ -1116,28 +1119,35 @@ EXPORT_SYMBOL(hci_find_ltk);
 struct link_key *hci_find_link_key_type(struct hci_dev *hdev,
 					bdaddr_t *bdaddr, u8 type)
 {
-	struct link_key *k;
+	struct list_head *p;
 
-	list_for_each_entry(k, &hdev->link_keys, list)
-		if (k->type == type && bacmp(bdaddr, &k->bdaddr) == 0)
+	list_for_each(p, &hdev->link_keys) {
+		struct link_key *k;
+
+		k = list_entry(p, struct link_key, list);
+
+		if ((k->key_type == type) && (bacmp(bdaddr, &k->bdaddr) == 0))
 			return k;
+	}
 
 	return NULL;
 }
 EXPORT_SYMBOL(hci_find_link_key_type);
 
-int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
-				bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len)
+int hci_add_link_key(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
+						u8 *val, u8 type, u8 pin_len)
 {
 	struct link_key *key, *old_key;
-	u8 old_key_type, persistent;
+	struct hci_conn *conn;
+	u8 old_key_type;
+	u8 bonded = 0;
 
 	old_key = hci_find_link_key(hdev, bdaddr);
 	if (old_key) {
-		old_key_type = old_key->type;
+		old_key_type = old_key->key_type;
 		key = old_key;
 	} else {
-		old_key_type = conn ? conn->key_type : 0xff;
+		old_key_type = 0xff;
 		key = kzalloc(sizeof(*key), GFP_ATOMIC);
 		if (!key)
 			return -ENOMEM;
@@ -1146,75 +1156,76 @@ int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
 
 	BT_DBG("%s key for %s type %u", hdev->name, batostr(bdaddr), type);
 
-	/* Some buggy controller combinations generate a changed
-	 * combination key for legacy pairing even when there's no
-	 * previous key */
-	if (type == HCI_LK_CHANGED_COMBINATION &&
-					(!conn || conn->remote_auth == 0xff) &&
-					old_key_type == 0xff) {
-		type = HCI_LK_COMBINATION;
-		if (conn)
-			conn->key_type = type;
-	}
-
 	bacpy(&key->bdaddr, bdaddr);
 	memcpy(key->val, val, 16);
+	key->auth = 0x01;
+	key->key_type = type;
 	key->pin_len = pin_len;
 
-	if (type == HCI_LK_CHANGED_COMBINATION)
-		key->type = old_key_type;
-	else
-		key->type = type;
-
-	if (!new_key)
-		return 0;
+	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, bdaddr);
+	/* Store the link key persistently if one of the following is true:
+	 * 1. the remote side is using dedicated bonding since in that case
+	 *    also the local requirements are set to dedicated bonding
+	 * 2. the local side had dedicated bonding as a requirement
+	 * 3. this is a legacy link key
+	 * 4. this is a changed combination key and there was a previously
+	 *    stored one
+	 * If none of the above match only keep the link key around for
+	 * this connection and set the temporary flag for the device.
+	*/
 
-	persistent = hci_persistent_key(hdev, conn, type, old_key_type);
+	if (conn) {
+		if ((conn->remote_auth > 0x01) ||
+			(conn->auth_initiator && conn->auth_type > 0x01) ||
+			(key->key_type < 0x03) ||
+			(key->key_type == 0x06 && old_key_type != 0xff))
+			bonded = 1;
+	}
 
-	mgmt_new_link_key(hdev, key, persistent);
+	if (new_key)
+		mgmt_new_key(hdev->id, key, bonded);
 
-	if (!persistent) {
-		list_del(&key->list);
-		kfree(key);
-	}
+	if (type == 0x06)
+		key->key_type = old_key_type;
 
 	return 0;
 }
 
 int hci_add_ltk(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
-			u8 key_size, __le16 ediv, u8 rand[8], u8 ltk[16])
+			u8 addr_type, u8 key_size, u8 auth,
+			__le16 ediv, u8 rand[8], u8 ltk[16])
 {
 	struct link_key *key, *old_key;
 	struct key_master_id *id;
-	u8 old_key_type;
 
-	BT_DBG("%s addr %s", hdev->name, batostr(bdaddr));
+	BT_DBG("%s Auth: %2.2X addr %s type: %d", hdev->name, auth,
+						batostr(bdaddr), addr_type);
 
-	old_key = hci_find_link_key_type(hdev, bdaddr, HCI_LK_SMP_LTK);
+	old_key = hci_find_link_key_type(hdev, bdaddr, KEY_TYPE_LTK);
 	if (old_key) {
 		key = old_key;
-		old_key_type = old_key->type;
 	} else {
 		key = kzalloc(sizeof(*key) + sizeof(*id), GFP_ATOMIC);
 		if (!key)
 			return -ENOMEM;
 		list_add(&key->list, &hdev->link_keys);
-		old_key_type = 0xff;
 	}
 
 	key->dlen = sizeof(*id);
 
 	bacpy(&key->bdaddr, bdaddr);
+	key->addr_type = addr_type;
 	memcpy(key->val, ltk, sizeof(key->val));
-	key->type = HCI_LK_SMP_LTK;
+	key->key_type = KEY_TYPE_LTK;
 	key->pin_len = key_size;
+	key->auth = auth;
 
 	id = (void *) &key->data;
 	id->ediv = ediv;
 	memcpy(id->rand, rand, sizeof(id->rand));
 
 	if (new_key)
-		mgmt_new_link_key(hdev, key, old_key_type);
+		mgmt_new_key(hdev->id, key, auth & 0x01);
 
 	return 0;
 }
@@ -1242,7 +1253,8 @@ static void hci_cmd_timer(unsigned long arg)
 
 	BT_ERR("%s command tx timeout", hdev->name);
 	atomic_set(&hdev->cmd_cnt, 1);
-	queue_work(hdev->workqueue, &hdev->cmd_work);
+	clear_bit(HCI_RESET, &hdev->flags);
+	tasklet_schedule(&hdev->cmd_task);
 }
 
 struct oob_data *hci_find_remote_oob_data(struct hci_dev *hdev,
@@ -1285,137 +1297,85 @@ int hci_remote_oob_data_clear(struct hci_dev *hdev)
 	return 0;
 }
 
-int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *hash,
-								u8 *randomizer)
+static void hci_adv_clear(unsigned long arg)
 {
-	struct oob_data *data;
-
-	data = hci_find_remote_oob_data(hdev, bdaddr);
-
-	if (!data) {
-		data = kmalloc(sizeof(*data), GFP_ATOMIC);
-		if (!data)
-			return -ENOMEM;
-
-		bacpy(&data->bdaddr, bdaddr);
-		list_add(&data->list, &hdev->remote_oob_data);
-	}
-
-	memcpy(data->hash, hash, sizeof(data->hash));
-	memcpy(data->randomizer, randomizer, sizeof(data->randomizer));
-
-	BT_DBG("%s for %s", hdev->name, batostr(bdaddr));
-
-	return 0;
-}
-
-struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev,
-						bdaddr_t *bdaddr)
-{
-	struct bdaddr_list *b;
-
-	list_for_each_entry(b, &hdev->blacklist, list)
-		if (bacmp(bdaddr, &b->bdaddr) == 0)
-			return b;
+	struct hci_dev *hdev = (void *) arg;
 
-	return NULL;
+	hci_adv_entries_clear(hdev);
 }
 
-int hci_blacklist_clear(struct hci_dev *hdev)
+int hci_adv_entries_clear(struct hci_dev *hdev)
 {
 	struct list_head *p, *n;
 
-	list_for_each_safe(p, n, &hdev->blacklist) {
-		struct bdaddr_list *b;
+	BT_DBG("");
+	write_lock_bh(&hdev->adv_entries_lock);
+
+	list_for_each_safe(p, n, &hdev->adv_entries) {
+		struct adv_entry *entry;
 
-		b = list_entry(p, struct bdaddr_list, list);
+		entry = list_entry(p, struct adv_entry, list);
 
 		list_del(p);
-		kfree(b);
+		kfree(entry);
 	}
 
+	write_unlock_bh(&hdev->adv_entries_lock);
+
 	return 0;
 }
 
-int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr)
+struct adv_entry *hci_find_adv_entry(struct hci_dev *hdev, bdaddr_t *bdaddr)
 {
-	struct bdaddr_list *entry;
-
-	if (bacmp(bdaddr, BDADDR_ANY) == 0)
-		return -EBADF;
+	struct list_head *p;
+	struct adv_entry *res = NULL;
 
-	if (hci_blacklist_lookup(hdev, bdaddr))
-		return -EEXIST;
+	BT_DBG("");
+	read_lock_bh(&hdev->adv_entries_lock);
 
-	entry = kzalloc(sizeof(struct bdaddr_list), GFP_KERNEL);
-	if (!entry)
-		return -ENOMEM;
+	list_for_each(p, &hdev->adv_entries) {
+		struct adv_entry *entry;
 
-	bacpy(&entry->bdaddr, bdaddr);
+		entry = list_entry(p, struct adv_entry, list);
 
-	list_add(&entry->list, &hdev->blacklist);
-
-	return mgmt_device_blocked(hdev, bdaddr);
+		if (bacmp(bdaddr, &entry->bdaddr) == 0) {
+			res = entry;
+			goto out;
+		}
+	}
+out:
+	read_unlock_bh(&hdev->adv_entries_lock);
+	return res;
 }
 
-int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr)
+static inline int is_connectable_adv(u8 evt_type)
 {
-	struct bdaddr_list *entry;
-
-	if (bacmp(bdaddr, BDADDR_ANY) == 0)
-		return hci_blacklist_clear(hdev);
-
-	entry = hci_blacklist_lookup(hdev, bdaddr);
-	if (!entry)
-		return -ENOENT;
-
-	list_del(&entry->list);
-	kfree(entry);
+	if (evt_type == ADV_IND || evt_type == ADV_DIRECT_IND)
+		return 1;
 
-	return mgmt_device_unblocked(hdev, bdaddr);
+	return 0;
 }
 
-static void hci_clear_adv_cache(struct work_struct *work)
+int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *hash,
+								u8 *randomizer)
 {
-	struct hci_dev *hdev = container_of(work, struct hci_dev,
-							adv_work.work);
-
-	hci_dev_lock(hdev);
-
-	hci_adv_entries_clear(hdev);
+	struct oob_data *data;
 
-	hci_dev_unlock(hdev);
-}
+	data = hci_find_remote_oob_data(hdev, bdaddr);
 
-int hci_adv_entries_clear(struct hci_dev *hdev)
-{
-	struct adv_entry *entry, *tmp;
+	if (!data) {
+		data = kmalloc(sizeof(*data), GFP_ATOMIC);
+		if (!data)
+			return -ENOMEM;
 
-	list_for_each_entry_safe(entry, tmp, &hdev->adv_entries, list) {
-		list_del(&entry->list);
-		kfree(entry);
+		bacpy(&data->bdaddr, bdaddr);
+		list_add(&data->list, &hdev->remote_oob_data);
 	}
 
-	BT_DBG("%s adv cache cleared", hdev->name);
-
-	return 0;
-}
-
-struct adv_entry *hci_find_adv_entry(struct hci_dev *hdev, bdaddr_t *bdaddr)
-{
-	struct adv_entry *entry;
-
-	list_for_each_entry(entry, &hdev->adv_entries, list)
-		if (bacmp(bdaddr, &entry->bdaddr) == 0)
-			return entry;
-
-	return NULL;
-}
+	memcpy(data->hash, hash, sizeof(data->hash));
+	memcpy(data->randomizer, randomizer, sizeof(data->randomizer));
 
-static inline int is_connectable_adv(u8 evt_type)
-{
-	if (evt_type == ADV_IND || evt_type == ADV_DIRECT_IND)
-		return 1;
+	BT_DBG("%s for %s", hdev->name, batostr(bdaddr));
 
 	return 0;
 }
@@ -1424,14 +1384,32 @@ int hci_add_adv_entry(struct hci_dev *hdev,
 					struct hci_ev_le_advertising_info *ev)
 {
 	struct adv_entry *entry;
+	u8 flags = 0;
+	int i;
+
+	BT_DBG("");
 
 	if (!is_connectable_adv(ev->evt_type))
 		return -EINVAL;
 
+	if (ev->data && ev->length) {
+		for (i = 0; (i + 2) < ev->length; i++)
+			if (ev->data[i+1] == 0x01) {
+				flags = ev->data[i+2];
+				BT_DBG("flags: %2.2x", flags);
+				break;
+			} else {
+				i += ev->data[i];
+			}
+	}
+
+	entry = hci_find_adv_entry(hdev, &ev->bdaddr);
 	/* Only new entries should be added to adv_entries. So, if
 	 * bdaddr was found, don't add it. */
-	if (hci_find_adv_entry(hdev, &ev->bdaddr))
+	if (entry) {
+		entry->flags = flags;
 		return 0;
+	}
 
 	entry = kzalloc(sizeof(*entry), GFP_ATOMIC);
 	if (!entry)
@@ -1439,20 +1417,28 @@ int hci_add_adv_entry(struct hci_dev *hdev,
 
 	bacpy(&entry->bdaddr, &ev->bdaddr);
 	entry->bdaddr_type = ev->bdaddr_type;
+	entry->flags = flags;
 
+	write_lock(&hdev->adv_entries_lock);
 	list_add(&entry->list, &hdev->adv_entries);
-
-	BT_DBG("%s adv entry added: address %s type %u", hdev->name,
-				batostr(&entry->bdaddr), entry->bdaddr_type);
+	write_unlock(&hdev->adv_entries_lock);
 
 	return 0;
 }
 
+static struct crypto_blkcipher *alloc_cypher(void)
+{
+	if (enable_smp)
+		return crypto_alloc_blkcipher("ecb(aes)", 0, CRYPTO_ALG_ASYNC);
+
+	return ERR_PTR(-ENOTSUPP);
+}
+
 /* Register HCI device */
 int hci_register_dev(struct hci_dev *hdev)
 {
 	struct list_head *head = &hci_dev_list, *p;
-	int i, id, error;
+	int i, id;
 
 	BT_DBG("%p name %s bus %d owner %p", hdev, hdev->name,
 						hdev->bus, hdev->owner);
@@ -1460,12 +1446,9 @@ int hci_register_dev(struct hci_dev *hdev)
 	if (!hdev->open || !hdev->close || !hdev->destruct)
 		return -EINVAL;
 
-	/* Do not allow HCI_AMP devices to register at index 0,
-	 * so the index can be used as the AMP controller ID.
-	 */
 	id = (hdev->dev_type == HCI_BREDR) ? 0 : 1;
 
-	write_lock(&hci_dev_list_lock);
+	write_lock_bh(&hci_dev_list_lock);
 
 	/* Find first available device id */
 	list_for_each(p, &hci_dev_list) {
@@ -1476,13 +1459,12 @@ int hci_register_dev(struct hci_dev *hdev)
 
 	sprintf(hdev->name, "hci%d", id);
 	hdev->id = id;
-	list_add_tail(&hdev->list, head);
+	list_add(&hdev->list, head);
 
 	atomic_set(&hdev->refcnt, 1);
-	mutex_init(&hdev->lock);
+	spin_lock_init(&hdev->lock);
 
 	hdev->flags = 0;
-	hdev->dev_flags = 0;
 	hdev->pkt_type  = (HCI_DM1 | HCI_DH1 | HCI_HV1);
 	hdev->esco_type = (ESCO_HV1);
 	hdev->link_mode = (HCI_LM_ACCEPT);
@@ -1492,16 +1474,21 @@ int hci_register_dev(struct hci_dev *hdev)
 	hdev->sniff_max_interval = 800;
 	hdev->sniff_min_interval = 80;
 
-	INIT_WORK(&hdev->rx_work, hci_rx_work);
-	INIT_WORK(&hdev->cmd_work, hci_cmd_work);
-	INIT_WORK(&hdev->tx_work, hci_tx_work);
+	set_bit(HCI_SETUP, &hdev->flags);
 
+	tasklet_init(&hdev->cmd_task, hci_cmd_task, (unsigned long) hdev);
+	tasklet_init(&hdev->rx_task, hci_rx_task, (unsigned long) hdev);
+	tasklet_init(&hdev->tx_task, hci_tx_task, (unsigned long) hdev);
 
 	skb_queue_head_init(&hdev->rx_q);
 	skb_queue_head_init(&hdev->cmd_q);
 	skb_queue_head_init(&hdev->raw_q);
 
 	setup_timer(&hdev->cmd_timer, hci_cmd_timer, (unsigned long) hdev);
+	setup_timer(&hdev->disco_timer, mgmt_disco_timeout,
+						(unsigned long) hdev);
+	setup_timer(&hdev->disco_le_timer, mgmt_disco_le_timeout,
+						(unsigned long) hdev);
 
 	for (i = 0; i < NUM_REASSEMBLY; i++)
 		hdev->reassembly[i] = NULL;
@@ -1512,8 +1499,7 @@ int hci_register_dev(struct hci_dev *hdev)
 	inquiry_cache_init(hdev);
 
 	hci_conn_hash_init(hdev);
-
-	INIT_LIST_HEAD(&hdev->mgmt_pending);
+	hci_chan_list_init(hdev);
 
 	INIT_LIST_HEAD(&hdev->blacklist);
 
@@ -1524,29 +1510,29 @@ int hci_register_dev(struct hci_dev *hdev)
 	INIT_LIST_HEAD(&hdev->remote_oob_data);
 
 	INIT_LIST_HEAD(&hdev->adv_entries);
+	rwlock_init(&hdev->adv_entries_lock);
+	setup_timer(&hdev->adv_timer, hci_adv_clear, (unsigned long) hdev);
 
-	INIT_DELAYED_WORK(&hdev->adv_work, hci_clear_adv_cache);
 	INIT_WORK(&hdev->power_on, hci_power_on);
-	INIT_DELAYED_WORK(&hdev->power_off, hci_power_off);
-
-	INIT_DELAYED_WORK(&hdev->discov_off, hci_discov_off);
+	INIT_WORK(&hdev->power_off, hci_power_off);
+	setup_timer(&hdev->off_timer, hci_auto_off, (unsigned long) hdev);
 
 	memset(&hdev->stat, 0, sizeof(struct hci_dev_stats));
 
 	atomic_set(&hdev->promisc, 0);
 
-	write_unlock(&hci_dev_list_lock);
+	write_unlock_bh(&hci_dev_list_lock);
 
-	hdev->workqueue = alloc_workqueue(hdev->name, WQ_HIGHPRI | WQ_UNBOUND |
-							WQ_MEM_RECLAIM, 1);
-	if (!hdev->workqueue) {
-		error = -ENOMEM;
-		goto err;
-	}
+	hdev->workqueue = create_singlethread_workqueue(hdev->name);
+	if (!hdev->workqueue)
+		goto nomem;
+
+	hdev->tfm = alloc_cypher();
+	if (IS_ERR(hdev->tfm))
+		BT_INFO("Failed to load transform for ecb(aes): %ld",
+							PTR_ERR(hdev->tfm));
 
-	error = hci_add_sysfs(hdev);
-	if (error < 0)
-		goto err_wqueue;
+	hci_register_sysfs(hdev);
 
 	hdev->rfkill = rfkill_alloc(hdev->name, &hdev->dev,
 				RFKILL_TYPE_BLUETOOTH, &hci_rfkill_ops, hdev);
@@ -1558,50 +1544,47 @@ int hci_register_dev(struct hci_dev *hdev)
 	}
 
 	set_bit(HCI_AUTO_OFF, &hdev->flags);
-	set_bit(HCI_SETUP, &hdev->flags);
-	schedule_work(&hdev->power_on);
+	queue_work(hdev->workqueue, &hdev->power_on);
 
 	hci_notify(hdev, HCI_DEV_REG);
 
 	return id;
 
-err_wqueue:
-	destroy_workqueue(hdev->workqueue);
-err:
-	write_lock(&hci_dev_list_lock);
+nomem:
+	write_lock_bh(&hci_dev_list_lock);
 	list_del(&hdev->list);
-	write_unlock(&hci_dev_list_lock);
+	write_unlock_bh(&hci_dev_list_lock);
 
-	return error;
+	return -ENOMEM;
 }
 EXPORT_SYMBOL(hci_register_dev);
 
 /* Unregister HCI device */
-void hci_unregister_dev(struct hci_dev *hdev)
+int hci_unregister_dev(struct hci_dev *hdev)
 {
 	int i;
 
 	BT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);
 
-	write_lock(&hci_dev_list_lock);
+	write_lock_bh(&hci_dev_list_lock);
 	list_del(&hdev->list);
-	write_unlock(&hci_dev_list_lock);
+	write_unlock_bh(&hci_dev_list_lock);
 
-	hci_dev_do_close(hdev);
+	hci_dev_do_close(hdev, hdev->bus == HCI_SMD);
 
 	for (i = 0; i < NUM_REASSEMBLY; i++)
 		kfree_skb(hdev->reassembly[i]);
 
 	if (!test_bit(HCI_INIT, &hdev->flags) &&
-					!test_bit(HCI_SETUP, &hdev->flags)) {
-		hci_dev_lock(hdev);
-		mgmt_index_removed(hdev);
-		hci_dev_unlock(hdev);
+				!test_bit(HCI_SETUP, &hdev->flags) &&
+				hdev->dev_type == HCI_BREDR) {
+		hci_dev_lock_bh(hdev);
+		mgmt_index_removed(hdev->id);
+		hci_dev_unlock_bh(hdev);
 	}
 
-	/* mgmt_index_removed should take care of emptying the
-	 * pending list */
-	BUG_ON(!list_empty(&hdev->mgmt_pending));
+	if (!IS_ERR(hdev->tfm))
+		crypto_free_blkcipher(hdev->tfm);
 
 	hci_notify(hdev, HCI_DEV_UNREG);
 
@@ -1610,21 +1593,28 @@ void hci_unregister_dev(struct hci_dev *hdev)
 		rfkill_destroy(hdev->rfkill);
 	}
 
-	hci_del_sysfs(hdev);
+	hci_unregister_sysfs(hdev);
 
-	cancel_delayed_work_sync(&hdev->adv_work);
+	/* Disable all timers */
+	hci_del_off_timer(hdev);
+	del_timer(&hdev->adv_timer);
+	del_timer(&hdev->cmd_timer);
+	del_timer(&hdev->disco_timer);
+	del_timer(&hdev->disco_le_timer);
 
 	destroy_workqueue(hdev->workqueue);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 	hci_blacklist_clear(hdev);
 	hci_uuids_clear(hdev);
 	hci_link_keys_clear(hdev);
 	hci_remote_oob_data_clear(hdev);
 	hci_adv_entries_clear(hdev);
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 
 	__hci_dev_put(hdev);
+
+	return 0;
 }
 EXPORT_SYMBOL(hci_unregister_dev);
 
@@ -1660,8 +1650,9 @@ int hci_recv_frame(struct sk_buff *skb)
 	/* Time stamp */
 	__net_timestamp(skb);
 
+	/* Queue frame for rx task */
 	skb_queue_tail(&hdev->rx_q, skb);
-	queue_work(hdev->workqueue, &hdev->rx_work);
+	tasklet_schedule(&hdev->rx_task);
 
 	return 0;
 }
@@ -1790,7 +1781,7 @@ int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count)
 
 		data += (count - rem);
 		count = rem;
-	}
+	};
 
 	return rem;
 }
@@ -1825,7 +1816,7 @@ int hci_recv_stream_fragment(struct hci_dev *hdev, void *data, int count)
 
 		data += (count - rem);
 		count = rem;
-	}
+	};
 
 	return rem;
 }
@@ -1833,13 +1824,59 @@ EXPORT_SYMBOL(hci_recv_stream_fragment);
 
 /* ---- Interface to upper protocols ---- */
 
+/* Register/Unregister protocols.
+ * hci_task_lock is used to ensure that no tasks are running. */
+int hci_register_proto(struct hci_proto *hp)
+{
+	int err = 0;
+
+	BT_DBG("%p name %s id %d", hp, hp->name, hp->id);
+
+	if (hp->id >= HCI_MAX_PROTO)
+		return -EINVAL;
+
+	write_lock_bh(&hci_task_lock);
+
+	if (!hci_proto[hp->id])
+		hci_proto[hp->id] = hp;
+	else
+		err = -EEXIST;
+
+	write_unlock_bh(&hci_task_lock);
+
+	return err;
+}
+EXPORT_SYMBOL(hci_register_proto);
+
+int hci_unregister_proto(struct hci_proto *hp)
+{
+	int err = 0;
+
+	BT_DBG("%p name %s id %d", hp, hp->name, hp->id);
+
+	if (hp->id >= HCI_MAX_PROTO)
+		return -EINVAL;
+
+	write_lock_bh(&hci_task_lock);
+
+	if (hci_proto[hp->id])
+		hci_proto[hp->id] = NULL;
+	else
+		err = -ENOENT;
+
+	write_unlock_bh(&hci_task_lock);
+
+	return err;
+}
+EXPORT_SYMBOL(hci_unregister_proto);
+
 int hci_register_cb(struct hci_cb *cb)
 {
 	BT_DBG("%p name %s", cb, cb->name);
 
-	write_lock(&hci_cb_list_lock);
+	write_lock_bh(&hci_cb_list_lock);
 	list_add(&cb->list, &hci_cb_list);
-	write_unlock(&hci_cb_list_lock);
+	write_unlock_bh(&hci_cb_list_lock);
 
 	return 0;
 }
@@ -1849,14 +1886,82 @@ int hci_unregister_cb(struct hci_cb *cb)
 {
 	BT_DBG("%p name %s", cb, cb->name);
 
-	write_lock(&hci_cb_list_lock);
+	write_lock_bh(&hci_cb_list_lock);
 	list_del(&cb->list);
-	write_unlock(&hci_cb_list_lock);
+	write_unlock_bh(&hci_cb_list_lock);
 
 	return 0;
 }
 EXPORT_SYMBOL(hci_unregister_cb);
 
+int hci_register_amp(struct amp_mgr_cb *cb)
+{
+	BT_DBG("%p", cb);
+
+	write_lock_bh(&amp_mgr_cb_list_lock);
+	list_add(&cb->list, &amp_mgr_cb_list);
+	write_unlock_bh(&amp_mgr_cb_list_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(hci_register_amp);
+
+int hci_unregister_amp(struct amp_mgr_cb *cb)
+{
+	BT_DBG("%p", cb);
+
+	write_lock_bh(&amp_mgr_cb_list_lock);
+	list_del(&cb->list);
+	write_unlock_bh(&amp_mgr_cb_list_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(hci_unregister_amp);
+
+void hci_amp_cmd_complete(struct hci_dev *hdev, __u16 opcode,
+			struct sk_buff *skb)
+{
+	struct amp_mgr_cb *cb;
+
+	BT_DBG("opcode 0x%x", opcode);
+
+	read_lock_bh(&amp_mgr_cb_list_lock);
+	list_for_each_entry(cb, &amp_mgr_cb_list, list) {
+		if (cb->amp_cmd_complete_event)
+			cb->amp_cmd_complete_event(hdev, opcode, skb);
+	}
+	read_unlock_bh(&amp_mgr_cb_list_lock);
+}
+
+void hci_amp_cmd_status(struct hci_dev *hdev, __u16 opcode, __u8 status)
+{
+	struct amp_mgr_cb *cb;
+
+	BT_DBG("opcode 0x%x, status %d", opcode, status);
+
+	read_lock_bh(&amp_mgr_cb_list_lock);
+	list_for_each_entry(cb, &amp_mgr_cb_list, list) {
+		if (cb->amp_cmd_status_event)
+			cb->amp_cmd_status_event(hdev, opcode, status);
+	}
+	read_unlock_bh(&amp_mgr_cb_list_lock);
+}
+
+void hci_amp_event_packet(struct hci_dev *hdev, __u8 ev_code,
+			struct sk_buff *skb)
+{
+	struct amp_mgr_cb *cb;
+
+	BT_DBG("ev_code 0x%x", ev_code);
+
+	read_lock_bh(&amp_mgr_cb_list_lock);
+	list_for_each_entry(cb, &amp_mgr_cb_list, list) {
+		if (cb->amp_event)
+			cb->amp_event(hdev, ev_code, skb);
+	}
+	read_unlock_bh(&amp_mgr_cb_list_lock);
+}
+
 static int hci_send_frame(struct sk_buff *skb)
 {
 	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
@@ -1878,11 +1983,7 @@ static int hci_send_frame(struct sk_buff *skb)
 	/* Get rid of skb owner, prior to sending to the driver. */
 	skb_orphan(skb);
 
-#ifdef CONFIG_BT_BLUESLEEP
-	/* Notify the registered devices about a new send */
 	hci_notify(hdev, HCI_DEV_WRITE);
-#endif //CONFIG_BT_BLUESLEEP
-
 	return hdev->send(skb);
 }
 
@@ -1917,10 +2018,11 @@ int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param)
 		hdev->init_last_cmd = opcode;
 
 	skb_queue_tail(&hdev->cmd_q, skb);
-	queue_work(hdev->workqueue, &hdev->cmd_work);
+	tasklet_schedule(&hdev->cmd_task);
 
 	return 0;
 }
+EXPORT_SYMBOL(hci_send_cmd);
 
 /* Get data from the previously sent command */
 void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode)
@@ -1953,18 +2055,27 @@ static void hci_add_acl_hdr(struct sk_buff *skb, __u16 handle, __u16 flags)
 	hdr->dlen   = cpu_to_le16(len);
 }
 
-static void hci_queue_acl(struct hci_conn *conn, struct sk_buff_head *queue,
-				struct sk_buff *skb, __u16 flags)
+void hci_send_acl(struct hci_conn *conn, struct hci_chan *chan,
+		struct sk_buff *skb, __u16 flags)
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct sk_buff *list;
 
+	BT_DBG("%s conn %p chan %p flags 0x%x", hdev->name, conn, chan, flags);
+
+	skb->dev = (void *) hdev;
+	bt_cb(skb)->pkt_type = HCI_ACLDATA_PKT;
+	if (hdev->dev_type == HCI_BREDR)
+		hci_add_acl_hdr(skb, conn->handle, flags);
+	else
+		hci_add_acl_hdr(skb, chan->ll_handle, flags);
+
 	list = skb_shinfo(skb)->frag_list;
 	if (!list) {
 		/* Non fragmented */
 		BT_DBG("%s nonfrag skb %p len %d", hdev->name, skb, skb->len);
 
-		skb_queue_tail(queue, skb);
+		skb_queue_tail(&conn->data_q, skb);
 	} else {
 		/* Fragmented */
 		BT_DBG("%s frag %p len %d", hdev->name, skb, skb->len);
@@ -1972,11 +2083,10 @@ static void hci_queue_acl(struct hci_conn *conn, struct sk_buff_head *queue,
 		skb_shinfo(skb)->frag_list = NULL;
 
 		/* Queue all fragments atomically */
-		spin_lock(&queue->lock);
+		spin_lock_bh(&conn->data_q.lock);
 
-		__skb_queue_tail(queue, skb);
-
-		flags &= ~ACL_START;
+		__skb_queue_tail(&conn->data_q, skb);
+		flags &= ~ACL_PB_MASK;
 		flags |= ACL_CONT;
 		do {
 			skb = list; list = list->next;
@@ -1987,27 +2097,13 @@ static void hci_queue_acl(struct hci_conn *conn, struct sk_buff_head *queue,
 
 			BT_DBG("%s frag %p len %d", hdev->name, skb, skb->len);
 
-			__skb_queue_tail(queue, skb);
+			__skb_queue_tail(&conn->data_q, skb);
 		} while (list);
 
-		spin_unlock(&queue->lock);
+		spin_unlock_bh(&conn->data_q.lock);
 	}
-}
 
-void hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags)
-{
-	struct hci_conn *conn = chan->conn;
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("%s chan %p flags 0x%x", hdev->name, chan, flags);
-
-	skb->dev = (void *) hdev;
-	bt_cb(skb)->pkt_type = HCI_ACLDATA_PKT;
-	hci_add_acl_hdr(skb, conn->handle, flags);
-
-	hci_queue_acl(conn, &chan->data_q, skb, flags);
-
-	queue_work(hdev->workqueue, &hdev->tx_work);
+	tasklet_schedule(&hdev->tx_task);
 }
 EXPORT_SYMBOL(hci_send_acl);
 
@@ -2030,25 +2126,75 @@ void hci_send_sco(struct hci_conn *conn, struct sk_buff *skb)
 	bt_cb(skb)->pkt_type = HCI_SCODATA_PKT;
 
 	skb_queue_tail(&conn->data_q, skb);
-	queue_work(hdev->workqueue, &hdev->tx_work);
+	tasklet_schedule(&hdev->tx_task);
 }
 EXPORT_SYMBOL(hci_send_sco);
 
 /* ---- HCI TX task (outgoing data) ---- */
+/* HCI ACL Connection scheduler */
+static inline struct hci_conn *hci_low_sent_acl(struct hci_dev *hdev,
+								int *quote)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct hci_conn *conn = NULL;
+	int num = 0, min = ~0, conn_num = 0;
+	struct list_head *p;
+
+	/* We don't have to lock device here. Connections are always
+	 * added and removed with TX task disabled. */
+	list_for_each(p, &h->list) {
+		struct hci_conn *c;
+		c = list_entry(p, struct hci_conn, list);
+		if (c->type == ACL_LINK)
+			conn_num++;
+
+		if (skb_queue_empty(&c->data_q))
+			continue;
+
+		if (c->state != BT_CONNECTED && c->state != BT_CONFIG)
+			continue;
+
+		num++;
+
+		if (c->sent < min) {
+			min  = c->sent;
+			conn = c;
+		}
+	}
+
+	if (conn) {
+		int cnt, q;
+		cnt = hdev->acl_cnt;
+		q = cnt / num;
+		*quote = q ? q : 1;
+	} else
+		*quote = 0;
+
+	if ((*quote == hdev->acl_cnt) &&
+		(conn->sent == (hdev->acl_pkts - 1)) &&
+		(conn_num > 1)) {
+			*quote = 0;
+			conn = NULL;
+	}
+
+	BT_DBG("conn %p quote %d", conn, *quote);
+	return conn;
+}
 
 /* HCI Connection scheduler */
 static inline struct hci_conn *hci_low_sent(struct hci_dev *hdev, __u8 type, int *quote)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct hci_conn *conn = NULL, *c;
+	struct hci_conn *conn = NULL;
 	int num = 0, min = ~0;
+	struct list_head *p;
 
 	/* We don't have to lock device here. Connections are always
 	 * added and removed with TX task disabled. */
+	list_for_each(p, &h->list) {
+		struct hci_conn *c;
+		c = list_entry(p, struct hci_conn, list);
 
-	rcu_read_lock();
-
-	list_for_each_entry_rcu(c, &h->list, list) {
 		if (c->type != type || skb_queue_empty(&c->data_q))
 			continue;
 
@@ -2061,13 +2207,8 @@ static inline struct hci_conn *hci_low_sent(struct hci_dev *hdev, __u8 type, int
 			min  = c->sent;
 			conn = c;
 		}
-
-		if (hci_conn_num(hdev, type) == num)
-			break;
 	}
 
-	rcu_read_unlock();
-
 	if (conn) {
 		int cnt, q;
 
@@ -2099,201 +2240,69 @@ static inline struct hci_conn *hci_low_sent(struct hci_dev *hdev, __u8 type, int
 static inline void hci_link_tx_to(struct hci_dev *hdev, __u8 type)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct hci_conn *c;
+	struct list_head *p;
+	struct hci_conn  *c;
 
 	BT_ERR("%s link tx timeout", hdev->name);
 
-	rcu_read_lock();
-
 	/* Kill stalled connections */
-	list_for_each_entry_rcu(c, &h->list, list) {
+	list_for_each(p, &h->list) {
+		c = list_entry(p, struct hci_conn, list);
 		if (c->type == type && c->sent) {
 			BT_ERR("%s killing stalled connection %s",
 				hdev->name, batostr(&c->dst));
 			hci_acl_disconn(c, 0x13);
 		}
 	}
-
-	rcu_read_unlock();
-}
-
-static inline struct hci_chan *hci_chan_sent(struct hci_dev *hdev, __u8 type,
-						int *quote)
-{
-	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct hci_chan *chan = NULL;
-	int num = 0, min = ~0, cur_prio = 0;
-	struct hci_conn *conn;
-	int cnt, q, conn_num = 0;
-
-	BT_DBG("%s", hdev->name);
-
-	rcu_read_lock();
-
-	list_for_each_entry_rcu(conn, &h->list, list) {
-		struct hci_chan *tmp;
-
-		if (conn->type != type)
-			continue;
-
-		if (conn->state != BT_CONNECTED && conn->state != BT_CONFIG)
-			continue;
-
-		conn_num++;
-
-		list_for_each_entry_rcu(tmp, &conn->chan_list, list) {
-			struct sk_buff *skb;
-
-			if (skb_queue_empty(&tmp->data_q))
-				continue;
-
-			skb = skb_peek(&tmp->data_q);
-			if (skb->priority < cur_prio)
-				continue;
-
-			if (skb->priority > cur_prio) {
-				num = 0;
-				min = ~0;
-				cur_prio = skb->priority;
-			}
-
-			num++;
-
-			if (conn->sent < min) {
-				min  = conn->sent;
-				chan = tmp;
-			}
-		}
-
-		if (hci_conn_num(hdev, type) == conn_num)
-			break;
-	}
-
-	rcu_read_unlock();
-
-	if (!chan)
-		return NULL;
-
-	switch (chan->conn->type) {
-	case ACL_LINK:
-		cnt = hdev->acl_cnt;
-		break;
-	case SCO_LINK:
-	case ESCO_LINK:
-		cnt = hdev->sco_cnt;
-		break;
-	case LE_LINK:
-		cnt = hdev->le_mtu ? hdev->le_cnt : hdev->acl_cnt;
-		break;
-	default:
-		cnt = 0;
-		BT_ERR("Unknown link type");
-	}
-
-	q = cnt / num;
-	*quote = q ? q : 1;
-	BT_DBG("chan %p quote %d", chan, *quote);
-	return chan;
-}
-
-static void hci_prio_recalculate(struct hci_dev *hdev, __u8 type)
-{
-	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct hci_conn *conn;
-	int num = 0;
-
-	BT_DBG("%s", hdev->name);
-
-	rcu_read_lock();
-
-	list_for_each_entry_rcu(conn, &h->list, list) {
-		struct hci_chan *chan;
-
-		if (conn->type != type)
-			continue;
-
-		if (conn->state != BT_CONNECTED && conn->state != BT_CONFIG)
-			continue;
-
-		num++;
-
-		list_for_each_entry_rcu(chan, &conn->chan_list, list) {
-			struct sk_buff *skb;
-
-			if (chan->sent) {
-				chan->sent = 0;
-				continue;
-			}
-
-			if (skb_queue_empty(&chan->data_q))
-				continue;
-
-			skb = skb_peek(&chan->data_q);
-			if (skb->priority >= HCI_PRIO_MAX - 1)
-				continue;
-
-			skb->priority = HCI_PRIO_MAX - 1;
-
-			BT_DBG("chan %p skb %p promoted to %d", chan, skb,
-								skb->priority);
-		}
-
-		if (hci_conn_num(hdev, type) == num)
-			break;
-	}
-
-	rcu_read_unlock();
-
 }
 
 static inline void hci_sched_acl(struct hci_dev *hdev)
 {
-	struct hci_chan *chan;
+	struct hci_conn *conn;
 	struct sk_buff *skb;
 	int quote;
-	unsigned int cnt;
 
 	BT_DBG("%s", hdev->name);
 
-	if (!hci_conn_num(hdev, ACL_LINK))
-		return;
-
 	if (!test_bit(HCI_RAW, &hdev->flags)) {
 		/* ACL tx timeout must be longer than maximum
 		 * link supervision timeout (40.9 seconds) */
-		if (!hdev->acl_cnt && time_after(jiffies, hdev->acl_last_tx + HZ * 45))
+		if (hdev->acl_cnt <= 0 &&
+			time_after(jiffies, hdev->acl_last_tx + HZ * 45))
 			hci_link_tx_to(hdev, ACL_LINK);
 	}
 
-	cnt = hdev->acl_cnt;
+	while (hdev->acl_cnt > 0 &&
+		((conn = hci_low_sent_acl(hdev, &quote)) != NULL)) {
 
-	while (hdev->acl_cnt &&
-			(chan = hci_chan_sent(hdev, ACL_LINK, &quote))) {
-		u32 priority = (skb_peek(&chan->data_q))->priority;
-		while (quote-- && (skb = skb_peek(&chan->data_q))) {
-			BT_DBG("chan %p skb %p len %d priority %u", chan, skb,
-					skb->len, skb->priority);
+		while (quote > 0 &&
+			  (skb = skb_dequeue(&conn->data_q))) {
+			int count = 1;
 
-			/* Stop if priority has changed */
-			if (skb->priority < priority)
-				break;
+			BT_DBG("skb %p len %d", skb, skb->len);
 
-			skb = skb_dequeue(&chan->data_q);
+			if (hdev->flow_ctl_mode ==
+				HCI_BLOCK_BASED_FLOW_CTL_MODE)
+				/* Calculate count of blocks used by
+				 * this packet
+				 */
+				count = ((skb->len - HCI_ACL_HDR_SIZE - 1) /
+					hdev->data_block_len) + 1;
 
-			hci_conn_enter_active_mode(chan->conn,
-						bt_cb(skb)->force_active);
+			if (count > hdev->acl_cnt)
+				return;
+
+			hci_conn_enter_active_mode(conn, bt_cb(skb)->force_active);
 
 			hci_send_frame(skb);
 			hdev->acl_last_tx = jiffies;
 
-			hdev->acl_cnt--;
-			chan->sent++;
-			chan->conn->sent++;
+			hdev->acl_cnt -= count;
+			quote -= count;
+
+			conn->sent += count;
 		}
 	}
-
-	if (cnt != hdev->acl_cnt)
-		hci_prio_recalculate(hdev, ACL_LINK);
 }
 
 /* Schedule SCO */
@@ -2305,9 +2314,6 @@ static inline void hci_sched_sco(struct hci_dev *hdev)
 
 	BT_DBG("%s", hdev->name);
 
-	if (!hci_conn_num(hdev, SCO_LINK))
-		return;
-
 	while (hdev->sco_cnt && (conn = hci_low_sent(hdev, SCO_LINK, &quote))) {
 		while (quote-- && (skb = skb_dequeue(&conn->data_q))) {
 			BT_DBG("skb %p len %d", skb, skb->len);
@@ -2328,9 +2334,6 @@ static inline void hci_sched_esco(struct hci_dev *hdev)
 
 	BT_DBG("%s", hdev->name);
 
-	if (!hci_conn_num(hdev, ESCO_LINK))
-		return;
-
 	while (hdev->sco_cnt && (conn = hci_low_sent(hdev, ESCO_LINK, &quote))) {
 		while (quote-- && (skb = skb_dequeue(&conn->data_q))) {
 			BT_DBG("skb %p len %d", skb, skb->len);
@@ -2345,15 +2348,12 @@ static inline void hci_sched_esco(struct hci_dev *hdev)
 
 static inline void hci_sched_le(struct hci_dev *hdev)
 {
-	struct hci_chan *chan;
+	struct hci_conn *conn;
 	struct sk_buff *skb;
-	int quote, cnt, tmp;
+	int quote, cnt;
 
 	BT_DBG("%s", hdev->name);
 
-	if (!hci_conn_num(hdev, LE_LINK))
-		return;
-
 	if (!test_bit(HCI_RAW, &hdev->flags)) {
 		/* LE tx timeout must be longer than maximum
 		 * link supervision timeout (40.9 seconds) */
@@ -2363,42 +2363,30 @@ static inline void hci_sched_le(struct hci_dev *hdev)
 	}
 
 	cnt = hdev->le_pkts ? hdev->le_cnt : hdev->acl_cnt;
-	tmp = cnt;
-	while (cnt && (chan = hci_chan_sent(hdev, LE_LINK, &quote))) {
-		u32 priority = (skb_peek(&chan->data_q))->priority;
-		while (quote-- && (skb = skb_peek(&chan->data_q))) {
-			BT_DBG("chan %p skb %p len %d priority %u", chan, skb,
-					skb->len, skb->priority);
-
-			/* Stop if priority has changed */
-			if (skb->priority < priority)
-				break;
-
-			skb = skb_dequeue(&chan->data_q);
+	while (cnt && (conn = hci_low_sent(hdev, LE_LINK, &quote))) {
+		while (quote-- && (skb = skb_dequeue(&conn->data_q))) {
+			BT_DBG("skb %p len %d", skb, skb->len);
 
 			hci_send_frame(skb);
 			hdev->le_last_tx = jiffies;
 
 			cnt--;
-			chan->sent++;
-			chan->conn->sent++;
+			conn->sent++;
 		}
 	}
-
 	if (hdev->le_pkts)
 		hdev->le_cnt = cnt;
 	else
 		hdev->acl_cnt = cnt;
-
-	if (cnt != tmp)
-		hci_prio_recalculate(hdev, LE_LINK);
 }
 
-static void hci_tx_work(struct work_struct *work)
+static void hci_tx_task(unsigned long arg)
 {
-	struct hci_dev *hdev = container_of(work, struct hci_dev, tx_work);
+	struct hci_dev *hdev = (struct hci_dev *) arg;
 	struct sk_buff *skb;
 
+	read_lock(&hci_task_lock);
+
 	BT_DBG("%s acl %d sco %d le %d", hdev->name, hdev->acl_cnt,
 		hdev->sco_cnt, hdev->le_cnt);
 
@@ -2415,9 +2403,11 @@ static void hci_tx_work(struct work_struct *work)
 	/* Send next queued raw (unknown type) packet */
 	while ((skb = skb_dequeue(&hdev->raw_q)))
 		hci_send_frame(skb);
+
+	read_unlock(&hci_task_lock);
 }
 
-/* ----- HCI RX task (incoming data processing) ----- */
+/* ----- HCI RX task (incoming data proccessing) ----- */
 
 /* ACL data packet */
 static inline void hci_acldata_packet(struct hci_dev *hdev, struct sk_buff *skb)
@@ -2441,11 +2431,16 @@ static inline void hci_acldata_packet(struct hci_dev *hdev, struct sk_buff *skb)
 	hci_dev_unlock(hdev);
 
 	if (conn) {
-		hci_conn_enter_active_mode(conn, BT_POWER_FORCE_ACTIVE_OFF);
+		register struct hci_proto *hp;
+
+		hci_conn_enter_active_mode(conn, bt_cb(skb)->force_active);
 
 		/* Send to upper protocol */
-		l2cap_recv_acldata(conn, skb, flags);
-		return;
+		hp = hci_proto[HCI_PROTO_L2CAP];
+		if (hp && hp->recv_acldata) {
+			hp->recv_acldata(conn, skb, flags);
+			return;
+		}
 	} else {
 		BT_ERR("%s ACL packet for unknown connection handle %d",
 			hdev->name, handle);
@@ -2474,9 +2469,14 @@ static inline void hci_scodata_packet(struct hci_dev *hdev, struct sk_buff *skb)
 	hci_dev_unlock(hdev);
 
 	if (conn) {
+		register struct hci_proto *hp;
+
 		/* Send to upper protocol */
-		sco_recv_scodata(conn, skb);
-		return;
+		hp = hci_proto[HCI_PROTO_SCO];
+		if (hp && hp->recv_scodata) {
+			hp->recv_scodata(conn, skb);
+			return;
+		}
 	} else {
 		BT_ERR("%s SCO packet for unknown connection handle %d",
 			hdev->name, handle);
@@ -2485,13 +2485,15 @@ static inline void hci_scodata_packet(struct hci_dev *hdev, struct sk_buff *skb)
 	kfree_skb(skb);
 }
 
-static void hci_rx_work(struct work_struct *work)
+static void hci_rx_task(unsigned long arg)
 {
-	struct hci_dev *hdev = container_of(work, struct hci_dev, rx_work);
+	struct hci_dev *hdev = (struct hci_dev *) arg;
 	struct sk_buff *skb;
 
 	BT_DBG("%s", hdev->name);
 
+	read_lock(&hci_task_lock);
+
 	while ((skb = skb_dequeue(&hdev->rx_q))) {
 		if (atomic_read(&hdev->promisc)) {
 			/* Send copy to the sockets */
@@ -2516,7 +2518,6 @@ static void hci_rx_work(struct work_struct *work)
 		/* Process frame */
 		switch (bt_cb(skb)->pkt_type) {
 		case HCI_EVENT_PKT:
-			BT_DBG("%s Event packet", hdev->name);
 			hci_event_packet(hdev, skb);
 			break;
 
@@ -2535,11 +2536,13 @@ static void hci_rx_work(struct work_struct *work)
 			break;
 		}
 	}
+
+	read_unlock(&hci_task_lock);
 }
 
-static void hci_cmd_work(struct work_struct *work)
+static void hci_cmd_task(unsigned long arg)
 {
-	struct hci_dev *hdev = container_of(work, struct hci_dev, cmd_work);
+	struct hci_dev *hdev = (struct hci_dev *) arg;
 	struct sk_buff *skb;
 
 	BT_DBG("%s cmd %d", hdev->name, atomic_read(&hdev->cmd_cnt));
@@ -2556,45 +2559,14 @@ static void hci_cmd_work(struct work_struct *work)
 		if (hdev->sent_cmd) {
 			atomic_dec(&hdev->cmd_cnt);
 			hci_send_frame(skb);
-			if (test_bit(HCI_RESET, &hdev->flags))
-				del_timer(&hdev->cmd_timer);
-			else
-				mod_timer(&hdev->cmd_timer,
+			mod_timer(&hdev->cmd_timer,
 				  jiffies + msecs_to_jiffies(HCI_CMD_TIMEOUT));
 		} else {
 			skb_queue_head(&hdev->cmd_q, skb);
-			queue_work(hdev->workqueue, &hdev->cmd_work);
+			tasklet_schedule(&hdev->cmd_task);
 		}
 	}
 }
 
-int hci_do_inquiry(struct hci_dev *hdev, u8 length)
-{
-	/* General inquiry access code (GIAC) */
-	u8 lap[3] = { 0x33, 0x8b, 0x9e };
-	struct hci_cp_inquiry cp;
-
-	BT_DBG("%s", hdev->name);
-
-	if (test_bit(HCI_INQUIRY, &hdev->flags))
-		return -EINPROGRESS;
-
-	memset(&cp, 0, sizeof(cp));
-	memcpy(&cp.lap, lap, sizeof(cp.lap));
-	cp.length  = length;
-
-	return hci_send_cmd(hdev, HCI_OP_INQUIRY, sizeof(cp), &cp);
-}
-
-int hci_cancel_inquiry(struct hci_dev *hdev)
-{
-	BT_DBG("%s", hdev->name);
-
-	if (!test_bit(HCI_INQUIRY, &hdev->flags))
-		return -EPERM;
-
-	return hci_send_cmd(hdev, HCI_OP_INQUIRY_CANCEL, 0, NULL);
-}
-
-module_param(enable_hs, bool, 0644);
-MODULE_PARM_DESC(enable_hs, "Enable High Speed");
+module_param(enable_smp, bool, 0644);
+MODULE_PARM_DESC(enable_smp, "Enable SMP support (LE only)");
diff --git a/net/bluetooth/hci_event.c b/net/bluetooth/hci_event.c
old mode 100755
new mode 100644
index 8a36449..2dba071
--- a/net/bluetooth/hci_event.c
+++ b/net/bluetooth/hci_event.c
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
+   Copyright (c) 2000-2001, 2010-2013 The Linux Foundation. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -45,8 +45,6 @@
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 
-static bool enable_le;
-
 /* Handle HCI Event packets */
 
 static void hci_cc_inquiry_cancel(struct hci_dev *hdev, struct sk_buff *skb)
@@ -55,19 +53,11 @@ static void hci_cc_inquiry_cancel(struct hci_dev *hdev, struct sk_buff *skb)
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
 
-	if (status) {
-		hci_dev_lock(hdev);
-		mgmt_stop_discovery_failed(hdev, status);
-		hci_dev_unlock(hdev);
+	if (status)
 		return;
-	}
 
 	clear_bit(HCI_INQUIRY, &hdev->flags);
 
-	hci_dev_lock(hdev);
-	mgmt_discovering(hdev, 0);
-	hci_dev_unlock(hdev);
-
 	hci_req_complete(hdev, HCI_OP_INQUIRY_CANCEL, status);
 
 	hci_conn_check_pending(hdev);
@@ -82,9 +72,36 @@ static void hci_cc_exit_periodic_inq(struct hci_dev *hdev, struct sk_buff *skb)
 	if (status)
 		return;
 
+	clear_bit(HCI_INQUIRY, &hdev->flags);
+
 	hci_conn_check_pending(hdev);
 }
 
+static void hci_cc_link_key_reply(struct hci_dev *hdev, struct sk_buff *skb)
+{
+	struct hci_rp_link_key_reply *rp = (void *) skb->data;
+	struct hci_conn *conn;
+	struct hci_cp_link_key_reply *cp;
+
+	BT_DBG("%s status 0x%x", hdev->name, rp->status);
+	if (rp->status)
+		return;
+
+	cp = hci_sent_cmd_data(hdev, HCI_OP_LINK_KEY_REPLY);
+	if (!cp)
+		return;
+
+	hci_dev_lock(hdev);
+	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
+	if (conn) {
+		hci_conn_hold(conn);
+		memcpy(conn->link_key, cp->link_key, sizeof(conn->link_key));
+		conn->key_type = 5;
+		hci_conn_put(conn);
+	}
+	hci_dev_unlock(hdev);
+}
+
 static void hci_cc_remote_name_req_cancel(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	BT_DBG("%s", hdev->name);
@@ -194,8 +211,6 @@ static void hci_cc_reset(struct hci_dev *hdev, struct sk_buff *skb)
 	clear_bit(HCI_RESET, &hdev->flags);
 
 	hci_req_complete(hdev, HCI_OP_RESET, status);
-
-	hdev->dev_flags = 0;
 }
 
 static void hci_cc_write_local_name(struct hci_dev *hdev, struct sk_buff *skb)
@@ -208,15 +223,12 @@ static void hci_cc_write_local_name(struct hci_dev *hdev, struct sk_buff *skb)
 	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_LOCAL_NAME);
 	if (!sent)
 		return;
-
 	hci_dev_lock(hdev);
-
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_set_local_name_complete(hdev, sent, status);
-
-	if (status == 0)
+	if (!status)
 		memcpy(hdev->dev_name, sent, HCI_MAX_NAME_LENGTH);
 
+	if (test_bit(HCI_MGMT, &hdev->flags))
+		mgmt_set_local_name_complete(hdev->id, sent, status);
 	hci_dev_unlock(hdev);
 }
 
@@ -280,8 +292,7 @@ static void hci_cc_write_encrypt_mode(struct hci_dev *hdev, struct sk_buff *skb)
 
 static void hci_cc_write_scan_enable(struct hci_dev *hdev, struct sk_buff *skb)
 {
-	__u8 param, status = *((__u8 *) skb->data);
-	int old_pscan, old_iscan;
+	__u8 status = *((__u8 *) skb->data);
 	void *sent;
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
@@ -290,40 +301,30 @@ static void hci_cc_write_scan_enable(struct hci_dev *hdev, struct sk_buff *skb)
 	if (!sent)
 		return;
 
-	param = *((__u8 *) sent);
-
-	hci_dev_lock(hdev);
+	if (!status) {
+		__u8 param = *((__u8 *) sent);
+		int old_pscan, old_iscan;
+		hci_dev_lock(hdev);
 
-	if (status != 0) {
-		mgmt_write_scan_failed(hdev, param, status);
-		hdev->discov_timeout = 0;
-		goto done;
+		old_pscan = test_and_clear_bit(HCI_PSCAN, &hdev->flags);
+		old_iscan = test_and_clear_bit(HCI_ISCAN, &hdev->flags);
+
+		if (param & SCAN_INQUIRY) {
+			set_bit(HCI_ISCAN, &hdev->flags);
+			if (!old_iscan)
+				mgmt_discoverable(hdev->id, 1);
+		} else if (old_iscan)
+			mgmt_discoverable(hdev->id, 0);
+
+		if (param & SCAN_PAGE) {
+			set_bit(HCI_PSCAN, &hdev->flags);
+			if (!old_pscan)
+				mgmt_connectable(hdev->id, 1);
+		} else if (old_pscan)
+			mgmt_connectable(hdev->id, 0);
+		hci_dev_unlock(hdev);
 	}
 
-	old_pscan = test_and_clear_bit(HCI_PSCAN, &hdev->flags);
-	old_iscan = test_and_clear_bit(HCI_ISCAN, &hdev->flags);
-
-	if (param & SCAN_INQUIRY) {
-		set_bit(HCI_ISCAN, &hdev->flags);
-		if (!old_iscan)
-			mgmt_discoverable(hdev, 1);
-		if (hdev->discov_timeout > 0) {
-			int to = msecs_to_jiffies(hdev->discov_timeout * 1000);
-			queue_delayed_work(hdev->workqueue, &hdev->discov_off,
-									to);
-		}
-	} else if (old_iscan)
-		mgmt_discoverable(hdev, 0);
-
-	if (param & SCAN_PAGE) {
-		set_bit(HCI_PSCAN, &hdev->flags);
-		if (!old_pscan)
-			mgmt_connectable(hdev, 1);
-	} else if (old_pscan)
-		mgmt_connectable(hdev, 0);
-
-done:
-	hci_dev_unlock(hdev);
 	hci_req_complete(hdev, HCI_OP_WRITE_SCAN_ENABLE, status);
 }
 
@@ -378,8 +379,11 @@ static void hci_cc_read_voice_setting(struct hci_dev *hdev, struct sk_buff *skb)
 
 	BT_DBG("%s voice setting 0x%04x", hdev->name, setting);
 
-	if (hdev->notify)
+	if (hdev->notify) {
+		tasklet_disable(&hdev->tx_task);
 		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
+		tasklet_enable(&hdev->tx_task);
+	}
 }
 
 static void hci_cc_write_voice_setting(struct hci_dev *hdev, struct sk_buff *skb)
@@ -406,8 +410,11 @@ static void hci_cc_write_voice_setting(struct hci_dev *hdev, struct sk_buff *skb
 
 	BT_DBG("%s voice setting 0x%04x", hdev->name, setting);
 
-	if (hdev->notify)
+	if (hdev->notify) {
+		tasklet_disable(&hdev->tx_task);
 		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
+		tasklet_enable(&hdev->tx_task);
+	}
 }
 
 static void hci_cc_host_buffer_size(struct hci_dev *hdev, struct sk_buff *skb)
@@ -419,6 +426,16 @@ static void hci_cc_host_buffer_size(struct hci_dev *hdev, struct sk_buff *skb)
 	hci_req_complete(hdev, HCI_OP_HOST_BUFFER_SIZE, status);
 }
 
+static void hci_cc_le_clear_white_list(struct hci_dev *hdev,
+							struct sk_buff *skb)
+{
+	__u8 status = *((__u8 *) skb->data);
+
+	BT_DBG("%s status 0x%x", hdev->name, status);
+
+	hci_req_complete(hdev, HCI_OP_LE_CLEAR_WHITE_LIST, status);
+}
+
 static void hci_cc_read_ssp_mode(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_rp_read_ssp_mode *rp = (void *) skb->data;
@@ -492,16 +509,16 @@ static void hci_setup_event_mask(struct hci_dev *hdev)
 	 * command otherwise */
 	u8 events[8] = { 0xff, 0xff, 0xfb, 0xff, 0x00, 0x00, 0x00, 0x00 };
 
-	/* CSR 1.1 dongles does not accept any bitfield so don't try to set
-	 * any event mask for pre 1.2 devices */
-	if (hdev->hci_ver < BLUETOOTH_VER_1_2)
-		return;
+	BT_DBG("");
 
-	events[4] |= 0x01; /* Flow Specification Complete */
-	events[4] |= 0x02; /* Inquiry Result with RSSI */
-	events[4] |= 0x04; /* Read Remote Extended Features Complete */
-	events[5] |= 0x08; /* Synchronous Connection Complete */
-	events[5] |= 0x10; /* Synchronous Connection Changed */
+	/* Events for 1.2 and newer controllers */
+	if (hdev->lmp_ver > 1) {
+		events[4] |= 0x01; /* Flow Specification Complete */
+		events[4] |= 0x02; /* Inquiry Result with RSSI */
+		events[4] |= 0x04; /* Read Remote Extended Features Complete */
+		events[5] |= 0x08; /* Synchronous Connection Complete */
+		events[5] |= 0x10; /* Synchronous Connection Changed */
+	}
 
 	if (hdev->features[3] & LMP_RSSI_INQ)
 		events[4] |= 0x04; /* Inquiry Result with RSSI */
@@ -540,28 +557,9 @@ static void hci_setup_event_mask(struct hci_dev *hdev)
 	hci_send_cmd(hdev, HCI_OP_SET_EVENT_MASK, sizeof(events), events);
 }
 
-static void hci_set_le_support(struct hci_dev *hdev)
-{
-	struct hci_cp_write_le_host_supported cp;
-
-	memset(&cp, 0, sizeof(cp));
-
-	if (enable_le) {
-		cp.le = 1;
-		cp.simul = !!(hdev->features[6] & LMP_SIMUL_LE_BR);
-	}
-
-	hci_send_cmd(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED, sizeof(cp), &cp);
-}
-
 static void hci_setup(struct hci_dev *hdev)
 {
-	if (hdev->dev_type != HCI_BREDR)
-		return;
-
-	hci_setup_event_mask(hdev);
-
-	if (hdev->hci_ver > BLUETOOTH_VER_1_1)
+	if (hdev->lmp_ver > 1)
 		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_COMMANDS, 0, NULL);
 
 	if (hdev->features[6] & LMP_SIMPLE_PAIR) {
@@ -574,17 +572,6 @@ static void hci_setup(struct hci_dev *hdev)
 
 	if (hdev->features[7] & LMP_INQ_TX_PWR)
 		hci_send_cmd(hdev, HCI_OP_READ_INQ_RSP_TX_POWER, 0, NULL);
-
-	if (hdev->features[7] & LMP_EXTFEATURES) {
-		struct hci_cp_read_local_ext_features cp;
-
-		cp.page = 0x01;
-		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_EXT_FEATURES,
-							sizeof(cp), &cp);
-	}
-
-	if (hdev->features[4] & LMP_LE)
-		hci_set_le_support(hdev);
 }
 
 static void hci_cc_read_local_version(struct hci_dev *hdev, struct sk_buff *skb)
@@ -606,7 +593,7 @@ static void hci_cc_read_local_version(struct hci_dev *hdev, struct sk_buff *skb)
 					hdev->manufacturer,
 					hdev->hci_ver, hdev->hci_rev);
 
-	if (test_bit(HCI_INIT, &hdev->flags))
+	if (hdev->dev_type == HCI_BREDR && test_bit(HCI_INIT, &hdev->flags))
 		hci_setup(hdev);
 }
 
@@ -657,6 +644,23 @@ static void hci_cc_read_local_features(struct hci_dev *hdev, struct sk_buff *skb
 
 	memcpy(hdev->features, rp->features, 8);
 
+	if (hdev->dev_type == HCI_BREDR && test_bit(HCI_INIT, &hdev->flags)) {
+		if (hdev->features[6] & LMP_SIMPLE_PAIR) {
+			u8 mode = 0x01;
+			hci_send_cmd(hdev, HCI_OP_WRITE_SSP_MODE,
+					sizeof(mode), &mode);
+		}
+
+		if (hdev->features[3] & LMP_RSSI_INQ)
+			hci_setup_inquiry_mode(hdev);
+
+		if (hdev->features[7] & LMP_INQ_TX_PWR)
+			hci_send_cmd(hdev, HCI_OP_READ_INQ_RSP_TX_POWER,
+								0, NULL);
+
+		hci_setup_event_mask(hdev);
+	}
+
 	/* Adjust default settings according to features
 	 * supported by device. */
 
@@ -701,30 +705,8 @@ static void hci_cc_read_local_features(struct hci_dev *hdev, struct sk_buff *skb
 					hdev->features[6], hdev->features[7]);
 }
 
-static void hci_cc_read_local_ext_features(struct hci_dev *hdev,
-							struct sk_buff *skb)
-{
-	struct hci_rp_read_local_ext_features *rp = (void *) skb->data;
-
-	BT_DBG("%s status 0x%x", hdev->name, rp->status);
-
-	if (rp->status)
-		return;
-
-	switch (rp->page) {
-	case 0:
-		memcpy(hdev->features, rp->features, 8);
-		break;
-	case 1:
-		memcpy(hdev->host_features, rp->features, 8);
-		break;
-	}
-
-	hci_req_complete(hdev, HCI_OP_READ_LOCAL_EXT_FEATURES, rp->status);
-}
-
 static void hci_cc_read_flow_control_mode(struct hci_dev *hdev,
-						struct sk_buff *skb)
+					struct sk_buff *skb)
 {
 	struct hci_rp_read_flow_control_mode *rp = (void *) skb->data;
 
@@ -734,8 +716,6 @@ static void hci_cc_read_flow_control_mode(struct hci_dev *hdev,
 		return;
 
 	hdev->flow_ctl_mode = rp->mode;
-
-	hci_req_complete(hdev, HCI_OP_READ_FLOW_CONTROL_MODE, rp->status);
 }
 
 static void hci_cc_read_buffer_size(struct hci_dev *hdev, struct sk_buff *skb)
@@ -747,18 +727,20 @@ static void hci_cc_read_buffer_size(struct hci_dev *hdev, struct sk_buff *skb)
 	if (rp->status)
 		return;
 
-	hdev->acl_mtu  = __le16_to_cpu(rp->acl_mtu);
-	hdev->sco_mtu  = rp->sco_mtu;
-	hdev->acl_pkts = __le16_to_cpu(rp->acl_max_pkt);
-	hdev->sco_pkts = __le16_to_cpu(rp->sco_max_pkt);
+	if (hdev->flow_ctl_mode == HCI_PACKET_BASED_FLOW_CTL_MODE) {
+		hdev->acl_mtu  = __le16_to_cpu(rp->acl_mtu);
+		hdev->sco_mtu  = rp->sco_mtu;
+		hdev->acl_pkts = __le16_to_cpu(rp->acl_max_pkt);
+		hdev->sco_pkts = __le16_to_cpu(rp->sco_max_pkt);
+		hdev->acl_cnt = hdev->acl_pkts;
+		hdev->sco_cnt = hdev->sco_pkts;
+	}
 
 	if (test_bit(HCI_QUIRK_FIXUP_BUFFER_SIZE, &hdev->quirks)) {
 		hdev->sco_mtu  = 64;
 		hdev->sco_pkts = 8;
 	}
 
-	hdev->acl_cnt = hdev->acl_pkts;
-	hdev->sco_cnt = hdev->sco_pkts;
 
 	BT_DBG("%s acl mtu %d:%d sco mtu %d:%d", hdev->name,
 					hdev->acl_mtu, hdev->acl_pkts,
@@ -777,8 +759,17 @@ static void hci_cc_read_bd_addr(struct hci_dev *hdev, struct sk_buff *skb)
 	hci_req_complete(hdev, HCI_OP_READ_BD_ADDR, rp->status);
 }
 
+static void hci_cc_write_ca_timeout(struct hci_dev *hdev, struct sk_buff *skb)
+{
+	__u8 status = *((__u8 *) skb->data);
+
+	BT_DBG("%s status 0x%x", hdev->name, status);
+
+	hci_req_complete(hdev, HCI_OP_WRITE_CA_TIMEOUT, status);
+}
+
 static void hci_cc_read_data_block_size(struct hci_dev *hdev,
-							struct sk_buff *skb)
+					struct sk_buff *skb)
 {
 	struct hci_rp_read_data_block_size *rp = (void *) skb->data;
 
@@ -787,29 +778,23 @@ static void hci_cc_read_data_block_size(struct hci_dev *hdev,
 	if (rp->status)
 		return;
 
-	hdev->block_mtu = __le16_to_cpu(rp->max_acl_len);
-	hdev->block_len = __le16_to_cpu(rp->block_len);
-	hdev->num_blocks = __le16_to_cpu(rp->num_blocks);
-
-	hdev->block_cnt = hdev->num_blocks;
-
-	BT_DBG("%s blk mtu %d cnt %d len %d", hdev->name, hdev->block_mtu,
-					hdev->block_cnt, hdev->block_len);
-
-	hci_req_complete(hdev, HCI_OP_READ_DATA_BLOCK_SIZE, rp->status);
-}
-
-static void hci_cc_write_ca_timeout(struct hci_dev *hdev, struct sk_buff *skb)
-{
-	__u8 status = *((__u8 *) skb->data);
-
-	BT_DBG("%s status 0x%x", hdev->name, status);
+	if (hdev->flow_ctl_mode == HCI_BLOCK_BASED_FLOW_CTL_MODE) {
+		hdev->acl_mtu  = __le16_to_cpu(rp->max_acl_len);
+		hdev->sco_mtu = 0;
+		hdev->data_block_len = __le16_to_cpu(rp->data_block_len);
+		/* acl_pkts indicates the number of blocks */
+		hdev->acl_pkts = __le16_to_cpu(rp->num_blocks);
+		hdev->sco_pkts = 0;
+		hdev->acl_cnt = hdev->acl_pkts;
+		hdev->sco_cnt = 0;
+	}
 
-	hci_req_complete(hdev, HCI_OP_WRITE_CA_TIMEOUT, status);
+	BT_DBG("%s acl mtu %d:%d, data block len %d", hdev->name,
+			hdev->acl_mtu, hdev->acl_cnt, hdev->data_block_len);
 }
 
 static void hci_cc_read_local_amp_info(struct hci_dev *hdev,
-		struct sk_buff *skb)
+				struct sk_buff *skb)
 {
 	struct hci_rp_read_local_amp_info *rp = (void *) skb->data;
 
@@ -887,11 +872,10 @@ static void hci_cc_pin_code_reply(struct hci_dev *hdev, struct sk_buff *skb)
 	struct hci_conn *conn;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
-
 	hci_dev_lock(hdev);
 
 	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_pin_code_reply_complete(hdev, &rp->bdaddr, rp->status);
+		mgmt_pin_code_reply_complete(hdev->id, &rp->bdaddr, rp->status);
 
 	if (rp->status != 0)
 		goto unlock;
@@ -903,7 +887,6 @@ static void hci_cc_pin_code_reply(struct hci_dev *hdev, struct sk_buff *skb)
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
 	if (conn)
 		conn->pin_length = cp->pin_len;
-
 unlock:
 	hci_dev_unlock(hdev);
 }
@@ -913,16 +896,13 @@ static void hci_cc_pin_code_neg_reply(struct hci_dev *hdev, struct sk_buff *skb)
 	struct hci_rp_pin_code_neg_reply *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
-
 	hci_dev_lock(hdev);
 
 	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_pin_code_neg_reply_complete(hdev, &rp->bdaddr,
+		mgmt_pin_code_neg_reply_complete(hdev->id, &rp->bdaddr,
 								rp->status);
-
 	hci_dev_unlock(hdev);
 }
-
 static void hci_cc_le_read_buffer_size(struct hci_dev *hdev,
 				       struct sk_buff *skb)
 {
@@ -943,66 +923,63 @@ static void hci_cc_le_read_buffer_size(struct hci_dev *hdev,
 	hci_req_complete(hdev, HCI_OP_LE_READ_BUFFER_SIZE, rp->status);
 }
 
-static void hci_cc_user_confirm_reply(struct hci_dev *hdev, struct sk_buff *skb)
+static void hci_cc_le_read_white_list_size(struct hci_dev *hdev,
+				       struct sk_buff *skb)
 {
-	struct hci_rp_user_confirm_reply *rp = (void *) skb->data;
+	struct hci_rp_le_read_white_list_size *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
 
-	hci_dev_lock(hdev);
+	if (rp->status)
+		return;
 
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_user_confirm_reply_complete(hdev, &rp->bdaddr,
-								rp->status);
+	hdev->le_white_list_size = rp->size;
 
-	hci_dev_unlock(hdev);
+	BT_DBG("%s le white list %d", hdev->name, hdev->le_white_list_size);
+
+	hci_req_complete(hdev, HCI_OP_LE_READ_WHITE_LIST_SIZE, rp->status);
 }
 
-static void hci_cc_user_confirm_neg_reply(struct hci_dev *hdev,
-							struct sk_buff *skb)
+static void hci_cc_user_confirm_reply(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_rp_user_confirm_reply *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
-
 	hci_dev_lock(hdev);
 
 	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_user_confirm_neg_reply_complete(hdev, &rp->bdaddr,
+		mgmt_user_confirm_reply_complete(hdev->id, &rp->bdaddr,
 								rp->status);
-
 	hci_dev_unlock(hdev);
 }
 
-static void hci_cc_user_passkey_reply(struct hci_dev *hdev, struct sk_buff *skb)
+static void hci_cc_user_confirm_neg_reply(struct hci_dev *hdev,
+							struct sk_buff *skb)
 {
 	struct hci_rp_user_confirm_reply *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
-
 	hci_dev_lock(hdev);
 
 	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_user_passkey_reply_complete(hdev, &rp->bdaddr,
+		mgmt_user_confirm_neg_reply_complete(hdev->id, &rp->bdaddr,
 								rp->status);
-
 	hci_dev_unlock(hdev);
 }
 
-static void hci_cc_user_passkey_neg_reply(struct hci_dev *hdev,
-							struct sk_buff *skb)
+static void hci_cc_read_rssi(struct hci_dev *hdev, struct sk_buff *skb)
 {
-	struct hci_rp_user_confirm_reply *rp = (void *) skb->data;
+	struct hci_conn *conn;
+	struct hci_rp_read_rssi *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
 
-	hci_dev_lock(hdev);
-
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_user_passkey_neg_reply_complete(hdev, &rp->bdaddr,
-								rp->status);
+	BT_DBG("%s rssi : %d handle : %d", hdev->name, rp->rssi, rp->handle);
 
-	hci_dev_unlock(hdev);
+	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(rp->handle));
+	if (conn)
+		mgmt_read_rssi_complete(hdev->id, rp->rssi, &conn->dst,
+			__le16_to_cpu(rp->handle), rp->status);
 }
 
 static void hci_cc_read_local_oob_data_reply(struct hci_dev *hdev,
@@ -1011,58 +988,13 @@ static void hci_cc_read_local_oob_data_reply(struct hci_dev *hdev,
 	struct hci_rp_read_local_oob_data *rp = (void *) skb->data;
 
 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
-
 	hci_dev_lock(hdev);
-	mgmt_read_local_oob_data_reply_complete(hdev, rp->hash,
+
+	mgmt_read_local_oob_data_reply_complete(hdev->id, rp->hash,
 						rp->randomizer, rp->status);
 	hci_dev_unlock(hdev);
 }
 
-static void hci_cc_le_set_scan_param(struct hci_dev *hdev, struct sk_buff *skb)
-{
-	__u8 status = *((__u8 *) skb->data);
-
-	BT_DBG("%s status 0x%x", hdev->name, status);
-}
-
-static void hci_cc_le_set_scan_enable(struct hci_dev *hdev,
-					struct sk_buff *skb)
-{
-	struct hci_cp_le_set_scan_enable *cp;
-	__u8 status = *((__u8 *) skb->data);
-
-	BT_DBG("%s status 0x%x", hdev->name, status);
-
-	if (status)
-		return;
-
-	cp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_SCAN_ENABLE);
-	if (!cp)
-		return;
-
-	switch (cp->enable) {
-	case LE_SCANNING_ENABLED:
-		set_bit(HCI_LE_SCAN, &hdev->dev_flags);
-
-		cancel_delayed_work_sync(&hdev->adv_work);
-
-		hci_dev_lock(hdev);
-		hci_adv_entries_clear(hdev);
-		hci_dev_unlock(hdev);
-		break;
-
-	case LE_SCANNING_DISABLED:
-		clear_bit(HCI_LE_SCAN, &hdev->dev_flags);
-
-		schedule_delayed_work(&hdev->adv_work, ADV_CLEAR_TIMEOUT);
-		break;
-
-	default:
-		BT_ERR("Used reserved LE_Scan_Enable param %d", cp->enable);
-		break;
-	}
-}
-
 static void hci_cc_le_ltk_reply(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_rp_le_ltk_reply *rp = (void *) skb->data;
@@ -1087,19 +1019,26 @@ static void hci_cc_le_ltk_neg_reply(struct hci_dev *hdev, struct sk_buff *skb)
 	hci_req_complete(hdev, HCI_OP_LE_LTK_NEG_REPLY, rp->status);
 }
 
-static inline void hci_cc_write_le_host_supported(struct hci_dev *hdev,
-							struct sk_buff *skb)
+static void hci_cc_le_set_scan_enable(struct hci_dev *hdev,
+					struct sk_buff *skb)
 {
-	struct hci_cp_read_local_ext_features cp;
+	void *sent;
+	__u8 param_scan_enable;
 	__u8 status = *((__u8 *) skb->data);
 
-	BT_DBG("%s status 0x%x", hdev->name, status);
-
 	if (status)
 		return;
 
-	cp.page = 0x01;
-	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_EXT_FEATURES, sizeof(cp), &cp);
+	sent = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_SCAN_ENABLE);
+	if (!sent)
+		return;
+
+	param_scan_enable = *((__u8 *) sent);
+	if (param_scan_enable == 0x01) {
+		del_timer(&hdev->adv_timer);
+	} else if (param_scan_enable == 0x00) {
+		mod_timer(&hdev->adv_timer, jiffies + ADV_CLEAR_TIMEOUT);
+	}
 }
 
 static inline void hci_cs_inquiry(struct hci_dev *hdev, __u8 status)
@@ -1108,19 +1047,15 @@ static inline void hci_cs_inquiry(struct hci_dev *hdev, __u8 status)
 
 	if (status) {
 		hci_req_complete(hdev, HCI_OP_INQUIRY, status);
+
 		hci_conn_check_pending(hdev);
+	} else {
+		set_bit(HCI_INQUIRY, &hdev->flags);
 		hci_dev_lock(hdev);
 		if (test_bit(HCI_MGMT, &hdev->flags))
-			mgmt_start_discovery_failed(hdev, status);
+			mgmt_inquiry_started(hdev->id);
 		hci_dev_unlock(hdev);
-		return;
 	}
-
-	set_bit(HCI_INQUIRY, &hdev->flags);
-
-	hci_dev_lock(hdev);
-	mgmt_discovering(hdev, 1);
-	hci_dev_unlock(hdev);
 }
 
 static inline void hci_cs_create_conn(struct hci_dev *hdev, __u8 status)
@@ -1205,9 +1140,6 @@ static void hci_cs_auth_requested(struct hci_dev *hdev, __u8 status)
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
 
-	if (!status)
-		return;
-
 	cp = hci_sent_cmd_data(hdev, HCI_OP_AUTH_REQUESTED);
 	if (!cp)
 		return;
@@ -1216,10 +1148,27 @@ static void hci_cs_auth_requested(struct hci_dev *hdev, __u8 status)
 
 	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(cp->handle));
 	if (conn) {
-		if (conn->state == BT_CONFIG) {
-			hci_proto_connect_cfm(conn, status);
-			hci_conn_put(conn);
+		if (status) {
+			mgmt_auth_failed(hdev->id, &conn->dst, status);
+			clear_bit(HCI_CONN_AUTH_PEND, &conn->pend);
+
+			if (conn->state == BT_CONFIG) {
+				conn->state = BT_CONNECTED;
+				hci_proto_connect_cfm(conn, status);
+				hci_conn_put(conn);
+			} else {
+				hci_auth_cfm(conn, status);
+				hci_conn_hold(conn);
+				conn->disc_timeout = HCI_DISCONN_TIMEOUT;
+				hci_conn_put(conn);
+			}
+
+			if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
+				clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend);
+				hci_encrypt_cfm(conn, status, 0x00);
+			}
 		}
+		conn->auth_initiator = 1;
 	}
 
 	hci_dev_unlock(hdev);
@@ -1262,10 +1211,10 @@ static int hci_outgoing_auth_needed(struct hci_dev *hdev,
 		return 0;
 
 	/* Only request authentication for SSP connections or non-SSP
-	 * devices with sec_level HIGH or if MITM protection is requested */
+	 * devices with sec_level >= BT_SECURITY_MEDIUM*/
+	 BT_DBG("Pending sec level is %d", conn->pending_sec_level);
 	if (!(hdev->ssp_mode > 0 && conn->ssp_mode > 0) &&
-				conn->pending_sec_level != BT_SECURITY_HIGH &&
-				!(conn->auth_type & 0x01))
+				conn->pending_sec_level < BT_SECURITY_MEDIUM)
 		return 0;
 
 	return 1;
@@ -1290,19 +1239,12 @@ static void hci_cs_remote_name_req(struct hci_dev *hdev, __u8 status)
 	hci_dev_lock(hdev);
 
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
-	if (!conn)
-		goto unlock;
-
-	if (!hci_outgoing_auth_needed(hdev, conn))
-		goto unlock;
-
-	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
+	if (conn && hci_outgoing_auth_needed(hdev, conn)) {
 		struct hci_cp_auth_requested cp;
 		cp.handle = __cpu_to_le16(conn->handle);
 		hci_send_cmd(hdev, HCI_OP_AUTH_REQUESTED, sizeof(cp), &cp);
 	}
 
-unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -1453,6 +1395,7 @@ static void hci_cs_le_create_conn(struct hci_dev *hdev, __u8 status)
 {
 	struct hci_cp_le_create_conn *cp;
 	struct hci_conn *conn;
+	unsigned long exp = msecs_to_jiffies(5000);
 
 	BT_DBG("%s status 0x%x", hdev->name, status);
 
@@ -1475,43 +1418,179 @@ static void hci_cs_le_create_conn(struct hci_dev *hdev, __u8 status)
 		}
 	} else {
 		if (!conn) {
-			conn = hci_conn_add(hdev, LE_LINK, 0, &cp->peer_addr);
-			if (conn) {
-				conn->dst_type = cp->peer_addr_type;
+			conn = hci_le_conn_add(hdev, &cp->peer_addr,
+						cp->peer_addr_type);
+			if (conn)
 				conn->out = 1;
-			} else {
+			else
 				BT_ERR("No memory for new connection");
-			}
-		}
+		} else
+			exp = msecs_to_jiffies(conn->conn_timeout * 1000);
+
+		if (conn && exp)
+			mod_timer(&conn->disc_timer, jiffies + exp);
 	}
 
 	hci_dev_unlock(hdev);
 }
 
-static void hci_cs_le_start_enc(struct hci_dev *hdev, u8 status)
+static void hci_cs_accept_logical_link(struct hci_dev *hdev, __u8 status)
 {
+	struct hci_cp_create_logical_link *ap;
+	struct hci_chan *chan;
+
 	BT_DBG("%s status 0x%x", hdev->name, status);
-}
 
-static inline void hci_inquiry_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)
-{
-	__u8 status = *((__u8 *) skb->data);
+	ap = hci_sent_cmd_data(hdev, HCI_OP_ACCEPT_LOGICAL_LINK);
+	if (!ap)
+		return;
 
-	BT_DBG("%s status %d", hdev->name, status);
+	hci_dev_lock(hdev);
 
-	hci_req_complete(hdev, HCI_OP_INQUIRY, status);
+	chan = hci_chan_list_lookup_id(hdev, ap->phy_handle);
 
-	hci_conn_check_pending(hdev);
+	BT_DBG("%s chan %p", hdev->name, chan);
 
-	if (!test_and_clear_bit(HCI_INQUIRY, &hdev->flags))
-		return;
+	if (status) {
+		if (chan && chan->state == BT_CONNECT) {
+			chan->state = BT_CLOSED;
+			hci_proto_create_cfm(chan, status);
+		}
+	} else if (chan) {
+		chan->state = BT_CONNECT2;
+	}
 
-	hci_dev_lock(hdev);
-	mgmt_discovering(hdev, 0);
 	hci_dev_unlock(hdev);
 }
 
-static inline void hci_inquiry_result_evt(struct hci_dev *hdev, struct sk_buff *skb)
+static void hci_cs_create_logical_link(struct hci_dev *hdev, __u8 status)
+{
+	struct hci_cp_create_logical_link *cp;
+	struct hci_chan *chan;
+
+	BT_DBG("%s status 0x%x", hdev->name, status);
+
+	cp = hci_sent_cmd_data(hdev, HCI_OP_CREATE_LOGICAL_LINK);
+	if (!cp)
+		return;
+
+	hci_dev_lock(hdev);
+
+	chan = hci_chan_list_lookup_id(hdev, cp->phy_handle);
+
+	BT_DBG("%s chan %p", hdev->name, chan);
+
+	if (status) {
+		if (chan && chan->state == BT_CONNECT) {
+			chan->state = BT_CLOSED;
+			hci_proto_create_cfm(chan, status);
+		}
+	} else if (chan)
+			chan->state = BT_CONNECT2;
+
+	hci_dev_unlock(hdev);
+}
+
+static void hci_cs_flow_spec_modify(struct hci_dev *hdev, __u8 status)
+{
+	struct hci_cp_flow_spec_modify *cp;
+	struct hci_chan *chan;
+
+	BT_DBG("%s status 0x%x", hdev->name, status);
+
+	cp = hci_sent_cmd_data(hdev, HCI_OP_FLOW_SPEC_MODIFY);
+	if (!cp)
+		return;
+
+	hci_dev_lock(hdev);
+
+	chan = hci_chan_list_lookup_handle(hdev, cp->log_handle);
+	if (chan) {
+		if (status)
+			hci_proto_modify_cfm(chan, status);
+		else {
+			chan->tx_fs = cp->tx_fs;
+			chan->rx_fs = cp->rx_fs;
+		}
+	}
+
+	hci_dev_unlock(hdev);
+}
+
+static void hci_cs_disconn_logical_link(struct hci_dev *hdev, __u8 status)
+{
+	struct hci_cp_disconn_logical_link *cp;
+	struct hci_chan *chan;
+
+	if (!status)
+		return;
+
+	BT_DBG("%s status 0x%x", hdev->name, status);
+
+	cp = hci_sent_cmd_data(hdev, HCI_OP_DISCONN_LOGICAL_LINK);
+	if (!cp)
+		return;
+
+	hci_dev_lock(hdev);
+
+	chan = hci_chan_list_lookup_handle(hdev, cp->log_handle);
+	if (chan)
+		hci_chan_del(chan);
+
+	hci_dev_unlock(hdev);
+}
+
+static void hci_cs_disconn_physical_link(struct hci_dev *hdev, __u8 status)
+{
+	struct hci_cp_disconn_phys_link *cp;
+	struct hci_conn *conn;
+
+	if (!status)
+		return;
+
+	BT_DBG("%s status 0x%x", hdev->name, status);
+
+	cp = hci_sent_cmd_data(hdev, HCI_OP_DISCONN_PHYS_LINK);
+	if (!cp)
+		return;
+
+	hci_dev_lock(hdev);
+
+	conn = hci_conn_hash_lookup_handle(hdev, cp->phy_handle);
+	if (conn) {
+		conn->state = BT_CLOSED;
+		hci_conn_del(conn);
+	}
+
+	hci_dev_unlock(hdev);
+}
+
+static void hci_cs_le_start_enc(struct hci_dev *hdev, u8 status)
+{
+	BT_DBG("%s status 0x%x", hdev->name, status);
+}
+
+static inline void hci_inquiry_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)
+{
+	__u8 status = *((__u8 *) skb->data);
+
+	BT_DBG("%s status %d", hdev->name, status);
+
+	if (!hdev->disco_state)
+		clear_bit(HCI_INQUIRY, &hdev->flags);
+
+	hci_req_complete(hdev, HCI_OP_INQUIRY, status);
+	hci_dev_lock(hdev);
+
+	if (test_bit(HCI_MGMT, &hdev->flags))
+		mgmt_inquiry_complete_evt(hdev->id, status);
+	hci_dev_unlock(hdev);
+
+	if (!lmp_le_capable(hdev))
+		hci_conn_check_pending(hdev);
+}
+
+static inline void hci_inquiry_result_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct inquiry_data data;
 	struct inquiry_info *info = (void *) (skb->data + 1);
@@ -1534,8 +1613,8 @@ static inline void hci_inquiry_result_evt(struct hci_dev *hdev, struct sk_buff *
 		data.rssi		= 0x00;
 		data.ssp_mode		= 0x00;
 		hci_inquiry_cache_update(hdev, &data);
-		mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,
-						info->dev_class, 0, NULL);
+		mgmt_device_found(hdev->id, &info->bdaddr, 0, 0,
+					info->dev_class, 0, 0, NULL);
 	}
 
 	hci_dev_unlock(hdev);
@@ -1569,8 +1648,11 @@ static inline void hci_conn_complete_evt(struct hci_dev *hdev, struct sk_buff *s
 			conn->state = BT_CONFIG;
 			hci_conn_hold(conn);
 			conn->disc_timeout = HCI_DISCONN_TIMEOUT;
-			mgmt_connected(hdev, &ev->bdaddr, conn->type,
-							conn->dst_type);
+			mgmt_connected(hdev->id, &ev->bdaddr, 0);
+		} else if (conn->type == LE_LINK) {
+			conn->state = BT_CONNECTED;
+			conn->disc_timeout = HCI_DISCONN_TIMEOUT;
+			mgmt_connected(hdev->id, &ev->bdaddr, 1);
 		} else
 			conn->state = BT_CONNECTED;
 
@@ -1583,16 +1665,18 @@ static inline void hci_conn_complete_evt(struct hci_dev *hdev, struct sk_buff *s
 		if (test_bit(HCI_ENCRYPT, &hdev->flags))
 			conn->link_mode |= HCI_LM_ENCRYPT;
 
-		/* Get remote features */
+		/* Get remote version */
 		if (conn->type == ACL_LINK) {
-			struct hci_cp_read_remote_features cp;
+			struct hci_cp_read_remote_version cp;
 			cp.handle = ev->handle;
-			hci_send_cmd(hdev, HCI_OP_READ_REMOTE_FEATURES,
-							sizeof(cp), &cp);
+			hci_send_cmd(hdev, HCI_OP_READ_CLOCK_OFFSET,
+				sizeof(cp), &cp);
+			hci_send_cmd(hdev, HCI_OP_READ_REMOTE_VERSION,
+				sizeof(cp), &cp);
 		}
 
 		/* Set packet type for incoming connection */
-		if (!conn->out && hdev->hci_ver < BLUETOOTH_VER_2_0) {
+		if (!conn->out && hdev->hci_ver < 3) {
 			struct hci_cp_change_conn_ptype cp;
 			cp.handle = ev->handle;
 			cp.pkt_type = cpu_to_le16(conn->pkt_type);
@@ -1601,9 +1685,8 @@ static inline void hci_conn_complete_evt(struct hci_dev *hdev, struct sk_buff *s
 		}
 	} else {
 		conn->state = BT_CLOSED;
-		if (conn->type == ACL_LINK)
-			mgmt_connect_failed(hdev, &ev->bdaddr, conn->type,
-						conn->dst_type, ev->status);
+		if (conn->type == ACL_LINK || conn->type == LE_LINK)
+			mgmt_connect_failed(hdev->id, &ev->bdaddr, ev->status);
 	}
 
 	if (conn->type == ACL_LINK)
@@ -1664,6 +1747,8 @@ static inline void hci_conn_request_evt(struct hci_dev *hdev, struct sk_buff *sk
 		}
 
 		memcpy(conn->dev_class, ev->dev_class, 3);
+		/* For incoming connection update remote class to userspace */
+		mgmt_remote_class(hdev->id, &ev->bdaddr, ev->dev_class);
 		conn->state = BT_CONNECT;
 
 		hci_dev_unlock(hdev);
@@ -1689,9 +1774,9 @@ static inline void hci_conn_request_evt(struct hci_dev *hdev, struct sk_buff *sk
 
 			cp.tx_bandwidth   = cpu_to_le32(0x00001f40);
 			cp.rx_bandwidth   = cpu_to_le32(0x00001f40);
-			cp.max_latency    = cpu_to_le16(0xffff);
+			cp.max_latency    = cpu_to_le16(0x000A);
 			cp.content_format = cpu_to_le16(hdev->voice_setting);
-			cp.retrans_effort = 0xff;
+			cp.retrans_effort = 0x01;
 
 			hci_send_cmd(hdev, HCI_OP_ACCEPT_SYNC_CONN_REQ,
 							sizeof(cp), &cp);
@@ -1701,7 +1786,7 @@ static inline void hci_conn_request_evt(struct hci_dev *hdev, struct sk_buff *sk
 		struct hci_cp_reject_conn_req cp;
 
 		bacpy(&cp.bdaddr, &ev->bdaddr);
-		cp.reason = HCI_ERROR_REJ_BAD_ADDR;
+		cp.reason = 0x0f;
 		hci_send_cmd(hdev, HCI_OP_REJECT_CONN_REQ, sizeof(cp), &cp);
 	}
 }
@@ -1711,7 +1796,14 @@ static inline void hci_disconn_complete_evt(struct hci_dev *hdev, struct sk_buff
 	struct hci_ev_disconn_complete *ev = (void *) skb->data;
 	struct hci_conn *conn;
 
-	BT_DBG("%s status %d", hdev->name, ev->status);
+	BT_DBG("%s status %d reason %d", hdev->name, ev->status, ev->reason);
+
+	if (ev->status) {
+		hci_dev_lock(hdev);
+		mgmt_disconnect_failed(hdev->id);
+		hci_dev_unlock(hdev);
+		return;
+	}
 
 	hci_dev_lock(hdev);
 
@@ -1719,21 +1811,16 @@ static inline void hci_disconn_complete_evt(struct hci_dev *hdev, struct sk_buff
 	if (!conn)
 		goto unlock;
 
-	if (ev->status == 0)
-		conn->state = BT_CLOSED;
+	conn->state = BT_CLOSED;
 
-	if (conn->type == ACL_LINK || conn->type == LE_LINK) {
-		if (ev->status != 0)
-			mgmt_disconnect_failed(hdev, &conn->dst, ev->status);
-		else
-			mgmt_disconnected(hdev, &conn->dst, conn->type,
-							conn->dst_type);
-	}
+	if (conn->type == ACL_LINK || conn->type == LE_LINK)
+		mgmt_disconnected(hdev->id, &conn->dst, ev->reason);
 
-	if (ev->status == 0) {
-		hci_proto_disconn_cfm(conn, ev->reason);
-		hci_conn_del(conn);
-	}
+	if (conn->type == LE_LINK)
+		del_timer(&conn->smp_timer);
+
+	hci_proto_disconn_cfm(conn, ev->reason, 0);
+	hci_conn_del(conn);
 
 unlock:
 	hci_dev_unlock(hdev);
@@ -1749,58 +1836,82 @@ static inline void hci_auth_complete_evt(struct hci_dev *hdev, struct sk_buff *s
 	hci_dev_lock(hdev);
 
 	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));
-	if (!conn)
-		goto unlock;
+	if (conn) {
+		if (ev->status == 0x06 && hdev->ssp_mode > 0 &&
+							conn->ssp_mode > 0) {
+			struct hci_cp_auth_requested cp;
+			hci_remove_link_key(hdev, &conn->dst);
+			cp.handle = cpu_to_le16(conn->handle);
+			hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
+							sizeof(cp), &cp);
+			hci_dev_unlock(hdev);
+			BT_INFO("Pin or key missing");
+			return;
+		}
 
-	if (!ev->status) {
-		if (!(conn->ssp_mode > 0 && hdev->ssp_mode > 0) &&
-				test_bit(HCI_CONN_REAUTH_PEND,	&conn->pend)) {
-			BT_INFO("re-auth of legacy device is not possible.");
-		} else {
+		if (!ev->status) {
 			conn->link_mode |= HCI_LM_AUTH;
 			conn->sec_level = conn->pending_sec_level;
+		} else {
+			mgmt_auth_failed(hdev->id, &conn->dst, ev->status);
+			conn->sec_level = BT_SECURITY_LOW;
 		}
-	} else {
-		mgmt_auth_failed(hdev, &conn->dst, ev->status);
-	}
 
-	clear_bit(HCI_CONN_AUTH_PEND, &conn->pend);
-	clear_bit(HCI_CONN_REAUTH_PEND, &conn->pend);
+		clear_bit(HCI_CONN_AUTH_PEND, &conn->pend);
 
-	if (conn->state == BT_CONFIG) {
-		if (!ev->status && hdev->ssp_mode > 0 && conn->ssp_mode > 0) {
-			struct hci_cp_set_conn_encrypt cp;
-			cp.handle  = ev->handle;
-			cp.encrypt = 0x01;
-			hci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),
-									&cp);
+		if (conn->state == BT_CONFIG) {
+			if (!ev->status && hdev->ssp_mode > 0 &&
+							conn->ssp_mode > 0) {
+				struct hci_cp_set_conn_encrypt cp;
+				cp.handle  = ev->handle;
+				cp.encrypt = 0x01;
+				hci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT,
+							sizeof(cp), &cp);
+			} else {
+				conn->state = BT_CONNECTED;
+				hci_proto_connect_cfm(conn, ev->status);
+				hci_conn_put(conn);
+			}
 		} else {
-			conn->state = BT_CONNECTED;
-			hci_proto_connect_cfm(conn, ev->status);
+			hci_auth_cfm(conn, ev->status);
+
+			hci_conn_hold(conn);
+			conn->disc_timeout = HCI_DISCONN_TIMEOUT;
 			hci_conn_put(conn);
 		}
-	} else {
-		hci_auth_cfm(conn, ev->status);
-
-		hci_conn_hold(conn);
-		conn->disc_timeout = HCI_DISCONN_TIMEOUT;
-		hci_conn_put(conn);
-	}
 
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
-		if (!ev->status) {
-			struct hci_cp_set_conn_encrypt cp;
-			cp.handle  = ev->handle;
-			cp.encrypt = 0x01;
-			hci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),
-									&cp);
-		} else {
-			clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend);
-			hci_encrypt_cfm(conn, ev->status, 0x00);
+		if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
+			if (!ev->status) {
+				if (conn->link_mode & HCI_LM_ENCRYPT) {
+					/* Encryption implies authentication */
+					conn->link_mode |= HCI_LM_AUTH;
+					conn->link_mode |= HCI_LM_ENCRYPT;
+					conn->sec_level =
+						conn->pending_sec_level;
+					clear_bit(HCI_CONN_ENCRYPT_PEND,
+							&conn->pend);
+					hci_encrypt_cfm(conn, ev->status, 1);
+
+					if (test_bit(HCI_MGMT, &hdev->flags))
+						mgmt_encrypt_change(hdev->id,
+							&conn->dst,
+							ev->status);
+
+				} else {
+					struct hci_cp_set_conn_encrypt cp;
+					cp.handle  = ev->handle;
+					cp.encrypt = 0x01;
+					hci_send_cmd(hdev,
+						HCI_OP_SET_CONN_ENCRYPT,
+						sizeof(cp), &cp);
+				}
+			} else {
+				clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend);
+				hci_encrypt_cfm(conn, ev->status, 0x00);
+			}
 		}
 	}
 
-unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -1815,23 +1926,16 @@ static inline void hci_remote_name_evt(struct hci_dev *hdev, struct sk_buff *skb
 
 	hci_dev_lock(hdev);
 
-	if (ev->status == 0 && test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_remote_name(hdev, &ev->bdaddr, ev->name);
+	if (test_bit(HCI_MGMT, &hdev->flags))
+		mgmt_remote_name(hdev->id, &ev->bdaddr, ev->status, ev->name);
 
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);
-	if (!conn)
-		goto unlock;
-
-	if (!hci_outgoing_auth_needed(hdev, conn))
-		goto unlock;
-
-	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
+	if (conn && hci_outgoing_auth_needed(hdev, conn)) {
 		struct hci_cp_auth_requested cp;
 		cp.handle = __cpu_to_le16(conn->handle);
 		hci_send_cmd(hdev, HCI_OP_AUTH_REQUESTED, sizeof(cp), &cp);
 	}
 
-unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -1864,8 +1968,28 @@ static inline void hci_encrypt_change_evt(struct hci_dev *hdev, struct sk_buff *
 
 			hci_proto_connect_cfm(conn, ev->status);
 			hci_conn_put(conn);
-		} else
-			hci_encrypt_cfm(conn, ev->status, ev->encrypt);
+		} else {
+			/*
+			* If the remote device does not support
+			* Pause Encryption, usually during the
+			* roleSwitch we see Encryption disable
+			* for short duration. Allow remote device
+			* to disable encryption
+			* for short duration in this case.
+			*/
+			if ((ev->encrypt == 0) && (ev->status == 0) &&
+				((conn->features[5] & LMP_PAUSE_ENC) == 0)) {
+				mod_timer(&conn->encrypt_pause_timer,
+					jiffies + msecs_to_jiffies(500));
+				BT_INFO("enc pause timer, enc_pend_flag set");
+			} else {
+				del_timer(&conn->encrypt_pause_timer);
+				hci_encrypt_cfm(conn, ev->status, ev->encrypt);
+			}
+		}
+
+		if (test_bit(HCI_MGMT, &hdev->flags))
+			mgmt_encrypt_change(hdev->id, &conn->dst, ev->status);
 	}
 
 	hci_dev_unlock(hdev);
@@ -1906,8 +2030,10 @@ static inline void hci_remote_features_evt(struct hci_dev *hdev, struct sk_buff
 	if (!conn)
 		goto unlock;
 
-	if (!ev->status)
+	if (!ev->status) {
 		memcpy(conn->features, ev->features, 8);
+		mgmt_remote_features(hdev->id, &conn->dst, ev->features);
+	}
 
 	if (conn->state != BT_CONFIG)
 		goto unlock;
@@ -1919,6 +2045,9 @@ static inline void hci_remote_features_evt(struct hci_dev *hdev, struct sk_buff
 		hci_send_cmd(hdev, HCI_OP_READ_REMOTE_EXT_FEATURES,
 							sizeof(cp), &cp);
 		goto unlock;
+	} else  if (!(lmp_ssp_capable(conn)) && conn->auth_initiator &&
+		(conn->pending_sec_level == BT_SECURITY_VERY_HIGH)) {
+		conn->pending_sec_level = BT_SECURITY_MEDIUM;
 	}
 
 	if (!ev->status) {
@@ -1941,7 +2070,24 @@ unlock:
 
 static inline void hci_remote_version_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
-	BT_DBG("%s", hdev->name);
+	struct hci_ev_remote_version *ev = (void *) skb->data;
+	struct hci_cp_read_remote_features cp;
+	struct hci_conn *conn;
+	BT_DBG("%s status %d", hdev->name, ev->status);
+
+	hci_dev_lock(hdev);
+	cp.handle = ev->handle;
+	hci_send_cmd(hdev, HCI_OP_READ_REMOTE_FEATURES,
+				sizeof(cp), &cp);
+
+	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));
+	if (!conn)
+		goto unlock;
+	if (!ev->status)
+		mgmt_remote_version(hdev->id, &conn->dst, ev->lmp_ver,
+				ev->manufacturer, ev->lmp_subver);
+unlock:
+	hci_dev_unlock(hdev);
 }
 
 static inline void hci_qos_setup_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)
@@ -1958,6 +2104,9 @@ static inline void hci_cmd_complete_evt(struct hci_dev *hdev, struct sk_buff *sk
 
 	opcode = __le16_to_cpu(ev->opcode);
 
+	if (test_bit(HCI_RESET, &hdev->flags) && (opcode != HCI_OP_RESET))
+		return;
+
 	switch (opcode) {
 	case HCI_OP_INQUIRY_CANCEL:
 		hci_cc_inquiry_cancel(hdev, skb);
@@ -1967,6 +2116,10 @@ static inline void hci_cmd_complete_evt(struct hci_dev *hdev, struct sk_buff *sk
 		hci_cc_exit_periodic_inq(hdev, skb);
 		break;
 
+	case HCI_OP_LINK_KEY_REPLY:
+		hci_cc_link_key_reply(hdev, skb);
+		break;
+
 	case HCI_OP_REMOTE_NAME_REQ_CANCEL:
 		hci_cc_remote_name_req_cancel(hdev, skb);
 		break;
@@ -2055,10 +2208,6 @@ static inline void hci_cmd_complete_evt(struct hci_dev *hdev, struct sk_buff *sk
 		hci_cc_read_local_features(hdev, skb);
 		break;
 
-	case HCI_OP_READ_LOCAL_EXT_FEATURES:
-		hci_cc_read_local_ext_features(hdev, skb);
-		break;
-
 	case HCI_OP_READ_BUFFER_SIZE:
 		hci_cc_read_buffer_size(hdev, skb);
 		break;
@@ -2067,10 +2216,6 @@ static inline void hci_cmd_complete_evt(struct hci_dev *hdev, struct sk_buff *sk
 		hci_cc_read_bd_addr(hdev, skb);
 		break;
 
-	case HCI_OP_READ_DATA_BLOCK_SIZE:
-		hci_cc_read_data_block_size(hdev, skb);
-		break;
-
 	case HCI_OP_WRITE_CA_TIMEOUT:
 		hci_cc_write_ca_timeout(hdev, skb);
 		break;
@@ -2079,10 +2224,19 @@ static inline void hci_cmd_complete_evt(struct hci_dev *hdev, struct sk_buff *sk
 		hci_cc_read_flow_control_mode(hdev, skb);
 		break;
 
+	case HCI_OP_READ_DATA_BLOCK_SIZE:
+		hci_cc_read_data_block_size(hdev, skb);
+		break;
+
 	case HCI_OP_READ_LOCAL_AMP_INFO:
 		hci_cc_read_local_amp_info(hdev, skb);
 		break;
 
+	case HCI_OP_READ_LOCAL_AMP_ASSOC:
+	case HCI_OP_WRITE_REMOTE_AMP_ASSOC:
+		hci_amp_cmd_complete(hdev, opcode, skb);
+		break;
+
 	case HCI_OP_DELETE_STORED_LINK_KEY:
 		hci_cc_delete_stored_link_key(hdev, skb);
 		break;
@@ -2119,27 +2273,24 @@ static inline void hci_cmd_complete_evt(struct hci_dev *hdev, struct sk_buff *sk
 		hci_cc_le_read_buffer_size(hdev, skb);
 		break;
 
-	case HCI_OP_USER_CONFIRM_REPLY:
-		hci_cc_user_confirm_reply(hdev, skb);
+	case HCI_OP_LE_READ_WHITE_LIST_SIZE:
+		hci_cc_le_read_white_list_size(hdev, skb);
 		break;
 
-	case HCI_OP_USER_CONFIRM_NEG_REPLY:
-		hci_cc_user_confirm_neg_reply(hdev, skb);
+	case HCI_OP_LE_CLEAR_WHITE_LIST:
+		hci_cc_le_clear_white_list(hdev, skb);
 		break;
 
-	case HCI_OP_USER_PASSKEY_REPLY:
-		hci_cc_user_passkey_reply(hdev, skb);
+	case HCI_OP_READ_RSSI:
+		hci_cc_read_rssi(hdev, skb);
 		break;
 
-	case HCI_OP_USER_PASSKEY_NEG_REPLY:
-		hci_cc_user_passkey_neg_reply(hdev, skb);
-
-	case HCI_OP_LE_SET_SCAN_PARAM:
-		hci_cc_le_set_scan_param(hdev, skb);
+	case HCI_OP_USER_CONFIRM_REPLY:
+		hci_cc_user_confirm_reply(hdev, skb);
 		break;
 
-	case HCI_OP_LE_SET_SCAN_ENABLE:
-		hci_cc_le_set_scan_enable(hdev, skb);
+	case HCI_OP_USER_CONFIRM_NEG_REPLY:
+		hci_cc_user_confirm_neg_reply(hdev, skb);
 		break;
 
 	case HCI_OP_LE_LTK_REPLY:
@@ -2150,8 +2301,8 @@ static inline void hci_cmd_complete_evt(struct hci_dev *hdev, struct sk_buff *sk
 		hci_cc_le_ltk_neg_reply(hdev, skb);
 		break;
 
-	case HCI_OP_WRITE_LE_HOST_SUPPORTED:
-		hci_cc_write_le_host_supported(hdev, skb);
+	case HCI_OP_LE_SET_SCAN_ENABLE:
+		hci_cc_le_set_scan_enable(hdev, skb);
 		break;
 
 	default:
@@ -2165,7 +2316,7 @@ static inline void hci_cmd_complete_evt(struct hci_dev *hdev, struct sk_buff *sk
 	if (ev->ncmd) {
 		atomic_set(&hdev->cmd_cnt, 1);
 		if (!skb_queue_empty(&hdev->cmd_q))
-			queue_work(hdev->workqueue, &hdev->cmd_work);
+			tasklet_schedule(&hdev->cmd_task);
 	}
 }
 
@@ -2223,9 +2374,33 @@ static inline void hci_cmd_status_evt(struct hci_dev *hdev, struct sk_buff *skb)
 		hci_cs_exit_sniff_mode(hdev, ev->status);
 		break;
 
+	case HCI_OP_CREATE_LOGICAL_LINK:
+		hci_cs_create_logical_link(hdev, ev->status);
+		break;
+
+	case HCI_OP_ACCEPT_LOGICAL_LINK:
+		hci_cs_accept_logical_link(hdev, ev->status);
+		break;
+
+	case HCI_OP_DISCONN_LOGICAL_LINK:
+		hci_cs_disconn_logical_link(hdev, ev->status);
+		break;
+
+	case HCI_OP_FLOW_SPEC_MODIFY:
+		hci_cs_flow_spec_modify(hdev, ev->status);
+		break;
+
+	case HCI_OP_CREATE_PHYS_LINK:
+	case HCI_OP_ACCEPT_PHYS_LINK:
+		hci_amp_cmd_status(hdev, opcode, ev->status);
+		break;
+
+	case HCI_OP_DISCONN_PHYS_LINK:
+		hci_cs_disconn_physical_link(hdev, ev->status);
+
 	case HCI_OP_DISCONNECT:
 		if (ev->status != 0)
-			mgmt_disconnect_failed(hdev, NULL, ev->status);
+			mgmt_disconnect_failed(hdev->id);
 		break;
 
 	case HCI_OP_LE_CREATE_CONN:
@@ -2247,10 +2422,25 @@ static inline void hci_cmd_status_evt(struct hci_dev *hdev, struct sk_buff *skb)
 	if (ev->ncmd && !test_bit(HCI_RESET, &hdev->flags)) {
 		atomic_set(&hdev->cmd_cnt, 1);
 		if (!skb_queue_empty(&hdev->cmd_q))
-			queue_work(hdev->workqueue, &hdev->cmd_work);
+			tasklet_schedule(&hdev->cmd_task);
 	}
 }
 
+static inline void hci_hardware_error_evt(struct hci_dev *hdev,
+					struct sk_buff *skb)
+{
+	struct hci_ev_hardware_error *ev = (void *) skb->data;
+
+	BT_ERR("hdev=%p, hw_err_code = %u", hdev, ev->hw_err_code);
+
+	if (hdev && hdev->dev_type == HCI_BREDR) {
+		hci_dev_lock_bh(hdev);
+		mgmt_powered(hdev->id, 1);
+		hci_dev_unlock_bh(hdev);
+	}
+
+}
+
 static inline void hci_role_change_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_ev_role_change *ev = (void *) skb->data;
@@ -2280,67 +2470,125 @@ static inline void hci_role_change_evt(struct hci_dev *hdev, struct sk_buff *skb
 static inline void hci_num_comp_pkts_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_ev_num_comp_pkts *ev = (void *) skb->data;
+	__le16 *ptr;
 	int i;
 
-	if (hdev->flow_ctl_mode != HCI_FLOW_CTL_MODE_PACKET_BASED) {
-		BT_ERR("Wrong event for mode %d", hdev->flow_ctl_mode);
-		return;
-	}
+	skb_pull(skb, sizeof(*ev));
 
-	if (skb->len < sizeof(*ev) || skb->len < sizeof(*ev) +
-			ev->num_hndl * sizeof(struct hci_comp_pkts_info)) {
+	BT_DBG("%s num_hndl %d", hdev->name, ev->num_hndl);
+
+	if (skb->len < ev->num_hndl * 4) {
 		BT_DBG("%s bad parameters", hdev->name);
 		return;
 	}
 
-	BT_DBG("%s num_hndl %d", hdev->name, ev->num_hndl);
+	tasklet_disable(&hdev->tx_task);
 
-	for (i = 0; i < ev->num_hndl; i++) {
-		struct hci_comp_pkts_info *info = &ev->handles[i];
-		struct hci_conn *conn;
+	for (i = 0, ptr = (__le16 *) skb->data; i < ev->num_hndl; i++) {
+		struct hci_conn *conn = NULL;
+		struct hci_chan *chan;
 		__u16  handle, count;
 
-		handle = __le16_to_cpu(info->handle);
-		count  = __le16_to_cpu(info->count);
+		handle = get_unaligned_le16(ptr++);
+		count  = get_unaligned_le16(ptr++);
 
-		conn = hci_conn_hash_lookup_handle(hdev, handle);
-		if (!conn)
-			continue;
-
-		conn->sent -= count;
-
-		switch (conn->type) {
-		case ACL_LINK:
-			hdev->acl_cnt += count;
-			if (hdev->acl_cnt > hdev->acl_pkts)
-				hdev->acl_cnt = hdev->acl_pkts;
-			break;
-
-		case LE_LINK:
-			if (hdev->le_pkts) {
-				hdev->le_cnt += count;
-				if (hdev->le_cnt > hdev->le_pkts)
-					hdev->le_cnt = hdev->le_pkts;
-			} else {
+		if (hdev->dev_type == HCI_BREDR)
+			conn = hci_conn_hash_lookup_handle(hdev, handle);
+		else {
+			chan = hci_chan_list_lookup_handle(hdev, handle);
+			if (chan)
+				conn = chan->conn;
+		}
+		if (conn) {
+			conn->sent -= count;
+
+			if (conn->type == ACL_LINK) {
 				hdev->acl_cnt += count;
 				if (hdev->acl_cnt > hdev->acl_pkts)
 					hdev->acl_cnt = hdev->acl_pkts;
+			} else if (conn->type == LE_LINK) {
+				if (hdev->le_pkts) {
+					hdev->le_cnt += count;
+					if (hdev->le_cnt > hdev->le_pkts)
+						hdev->le_cnt = hdev->le_pkts;
+				} else {
+					hdev->acl_cnt += count;
+					if (hdev->acl_cnt > hdev->acl_pkts)
+						hdev->acl_cnt = hdev->acl_pkts;
+				}
+			} else {
+				hdev->sco_cnt += count;
+				if (hdev->sco_cnt > hdev->sco_pkts)
+					hdev->sco_cnt = hdev->sco_pkts;
 			}
-			break;
+		}
+	}
 
-		case SCO_LINK:
-			hdev->sco_cnt += count;
-			if (hdev->sco_cnt > hdev->sco_pkts)
-				hdev->sco_cnt = hdev->sco_pkts;
-			break;
+	tasklet_schedule(&hdev->tx_task);
 
-		default:
-			BT_ERR("Unknown type %d conn %p", conn->type, conn);
-			break;
+	tasklet_enable(&hdev->tx_task);
+}
+
+static inline void hci_num_comp_blocks_evt(struct hci_dev *hdev,
+					struct sk_buff *skb)
+{
+	struct hci_ev_num_comp_blocks *ev = (void *) skb->data;
+	__le16 *ptr;
+	int i;
+
+	skb_pull(skb, sizeof(*ev));
+
+	BT_DBG("%s total_num_blocks %d num_hndl %d",
+		hdev->name, ev->total_num_blocks, ev->num_hndl);
+
+	if (skb->len < ev->num_hndl * 6) {
+		BT_DBG("%s bad parameters", hdev->name);
+		return;
+	}
+
+	tasklet_disable(&hdev->tx_task);
+
+	for (i = 0, ptr = (__le16 *) skb->data; i < ev->num_hndl; i++) {
+		struct hci_conn *conn = NULL;
+		struct hci_chan *chan;
+		__u16  handle, block_count;
+
+		handle = get_unaligned_le16(ptr++);
+
+		/* Skip packet count */
+		ptr++;
+		block_count  = get_unaligned_le16(ptr++);
+
+		BT_DBG("%s handle %d count %d", hdev->name, handle,
+			block_count);
+
+		if (hdev->dev_type == HCI_BREDR)
+			conn = hci_conn_hash_lookup_handle(hdev, handle);
+		else {
+			chan = hci_chan_list_lookup_handle(hdev, handle);
+			if (chan)
+				conn = chan->conn;
+		}
+		if (conn) {
+			BT_DBG("%s conn %p sent %d", hdev->name,
+				conn, conn->sent);
+
+			conn->sent -= block_count;
+
+			if (conn->type == ACL_LINK) {
+				hdev->acl_cnt += block_count;
+				if (hdev->acl_cnt > hdev->acl_pkts)
+					hdev->acl_cnt = hdev->acl_pkts;
+			} else {
+				/* We should not find ourselves here */
+				BT_DBG("Unexpected event for SCO connection");
+			}
 		}
 	}
 
-	queue_work(hdev->workqueue, &hdev->tx_work);
+	tasklet_schedule(&hdev->tx_task);
+
+	tasklet_enable(&hdev->tx_task);
 }
 
 static inline void hci_mode_change_evt(struct hci_dev *hdev, struct sk_buff *skb)
@@ -2381,30 +2629,20 @@ static inline void hci_pin_code_request_evt(struct hci_dev *hdev, struct sk_buff
 	hci_dev_lock(hdev);
 
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);
-	if (!conn)
-		goto unlock;
-
-	if (conn->state == BT_CONNECTED) {
+	if (conn && conn->state == BT_CONNECTED) {
 		hci_conn_hold(conn);
 		conn->disc_timeout = HCI_PAIRING_TIMEOUT;
 		hci_conn_put(conn);
+		hci_conn_enter_active_mode(conn, 0);
 	}
 
 	if (!test_bit(HCI_PAIRABLE, &hdev->flags))
 		hci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY,
 					sizeof(ev->bdaddr), &ev->bdaddr);
-	else if (test_bit(HCI_MGMT, &hdev->flags)) {
-		u8 secure;
 
-		if (conn->pending_sec_level == BT_SECURITY_HIGH)
-			secure = 1;
-		else
-			secure = 0;
-
-		mgmt_pin_code_request(hdev, &ev->bdaddr, secure);
-	}
+	if (test_bit(HCI_MGMT, &hdev->flags))
+		mgmt_pin_code_request(hdev->id, &ev->bdaddr);
 
-unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -2429,33 +2667,31 @@ static inline void hci_link_key_request_evt(struct hci_dev *hdev, struct sk_buff
 		goto not_found;
 	}
 
-	BT_DBG("%s found key type %u for %s", hdev->name, key->type,
+	BT_DBG("%s found key type %u for %s", hdev->name, key->key_type,
 							batostr(&ev->bdaddr));
 
-	if (!test_bit(HCI_DEBUG_KEYS, &hdev->flags) &&
-				key->type == HCI_LK_DEBUG_COMBINATION) {
+	if (!test_bit(HCI_DEBUG_KEYS, &hdev->flags) && key->key_type == 0x03) {
 		BT_DBG("%s ignoring debug key", hdev->name);
 		goto not_found;
 	}
 
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);
-	if (conn) {
-		if (key->type == HCI_LK_UNAUTH_COMBINATION &&
-				conn->auth_type != 0xff &&
-				(conn->auth_type & 0x01)) {
-			BT_DBG("%s ignoring unauthenticated key", hdev->name);
-			goto not_found;
-		}
 
-		if (key->type == HCI_LK_COMBINATION && key->pin_len < 16 &&
-				conn->pending_sec_level == BT_SECURITY_HIGH) {
-			BT_DBG("%s ignoring key unauthenticated for high \
-							security", hdev->name);
-			goto not_found;
-		}
+	if (conn) {
+		BT_DBG("Conn pending sec level is %d, ssp is %d, key len is %d",
+			conn->pending_sec_level, conn->ssp_mode, key->pin_len);
+	}
+	if (conn && (conn->ssp_mode == 0) &&
+		(conn->pending_sec_level == BT_SECURITY_VERY_HIGH) &&
+		(key->pin_len != 16)) {
+		BT_DBG("Security is high ignoring this key");
+		goto not_found;
+	}
 
-		conn->key_type = key->type;
-		conn->pin_length = key->pin_len;
+	if (key->key_type == 0x04 && conn && conn->auth_type != 0xff &&
+						(conn->auth_type & 0x01)) {
+		BT_DBG("%s ignoring unauthenticated key", hdev->name);
+		goto not_found;
 	}
 
 	bacpy(&cp.bdaddr, &ev->bdaddr);
@@ -2478,7 +2714,7 @@ static inline void hci_link_key_notify_evt(struct hci_dev *hdev, struct sk_buff
 	struct hci_conn *conn;
 	u8 pin_len = 0;
 
-	BT_DBG("%s", hdev->name);
+	BT_DBG("%s type %d", hdev->name, ev->key_type);
 
 	hci_dev_lock(hdev);
 
@@ -2486,16 +2722,19 @@ static inline void hci_link_key_notify_evt(struct hci_dev *hdev, struct sk_buff
 	if (conn) {
 		hci_conn_hold(conn);
 		conn->disc_timeout = HCI_DISCONN_TIMEOUT;
-		pin_len = conn->pin_length;
 
-		if (ev->key_type != HCI_LK_CHANGED_COMBINATION)
-			conn->key_type = ev->key_type;
+		memcpy(conn->link_key, ev->link_key, 16);
+		conn->key_type = ev->key_type;
+		hci_disconnect_amp(conn, 0x06);
 
+		conn->link_mode &= ~HCI_LM_ENCRYPT;
+		pin_len = conn->pin_length;
 		hci_conn_put(conn);
+		hci_conn_enter_active_mode(conn, 0);
 	}
 
 	if (test_bit(HCI_LINK_KEYS, &hdev->flags))
-		hci_add_link_key(hdev, conn, 1, &ev->bdaddr, ev->link_key,
+		hci_add_link_key(hdev, 1, &ev->bdaddr, ev->link_key,
 							ev->key_type, pin_len);
 
 	hci_dev_unlock(hdev);
@@ -2584,9 +2823,9 @@ static inline void hci_inquiry_result_with_rssi_evt(struct hci_dev *hdev, struct
 			data.rssi		= info->rssi;
 			data.ssp_mode		= 0x00;
 			hci_inquiry_cache_update(hdev, &data);
-			mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,
+			mgmt_device_found(hdev->id, &info->bdaddr, 0, 0,
 						info->dev_class, info->rssi,
-						NULL);
+						0, NULL);
 		}
 	} else {
 		struct inquiry_info_with_rssi *info = (void *) (skb->data + 1);
@@ -2601,9 +2840,9 @@ static inline void hci_inquiry_result_with_rssi_evt(struct hci_dev *hdev, struct
 			data.rssi		= info->rssi;
 			data.ssp_mode		= 0x00;
 			hci_inquiry_cache_update(hdev, &data);
-			mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,
+			mgmt_device_found(hdev->id, &info->bdaddr, 0, 0,
 						info->dev_class, info->rssi,
-						NULL);
+						0, NULL);
 		}
 	}
 
@@ -2631,6 +2870,17 @@ static inline void hci_remote_ext_features_evt(struct hci_dev *hdev, struct sk_b
 			ie->data.ssp_mode = (ev->features[0] & 0x01);
 
 		conn->ssp_mode = (ev->features[0] & 0x01);
+		/*In case if remote device ssp supported/2.0 device
+		reduce the security level to MEDIUM if it is VERY HIGH*/
+		if (!conn->ssp_mode && conn->auth_initiator &&
+			(conn->pending_sec_level == BT_SECURITY_VERY_HIGH))
+			conn->pending_sec_level = BT_SECURITY_MEDIUM;
+
+		if (conn->ssp_mode && conn->auth_initiator &&
+			conn->io_capability != 0x03) {
+			conn->pending_sec_level = BT_SECURITY_VERY_HIGH;
+			conn->auth_type = HCI_AT_DEDICATED_BONDING_MITM;
+		}
 	}
 
 	if (conn->state != BT_CONFIG)
@@ -2684,13 +2934,14 @@ static inline void hci_sync_conn_complete_evt(struct hci_dev *hdev, struct sk_bu
 		hci_conn_add_sysfs(conn);
 		break;
 
-	case 0x10:	/* Connection Accept Timeout */
 	case 0x11:	/* Unsupported Feature or Parameter Value */
 	case 0x1c:	/* SCO interval rejected */
 	case 0x1a:	/* Unsupported Remote Feature */
 	case 0x1f:	/* Unspecified error */
 		if (conn->out && conn->attempt < 2) {
-			conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
+			if (!conn->hdev->is_wbs)
+				conn->pkt_type =
+					(hdev->esco_type & SCO_ESCO_MASK) |
 					(hdev->esco_type & EDR_ESCO_MASK);
 			hci_setup_sync(conn, conn->link->handle);
 			goto unlock;
@@ -2718,8 +2969,16 @@ static inline void hci_sync_conn_changed_evt(struct hci_dev *hdev, struct sk_buf
 static inline void hci_sniff_subrate_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_ev_sniff_subrate *ev = (void *) skb->data;
+	struct hci_conn *conn =
+		hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));
 
 	BT_DBG("%s status %d", hdev->name, ev->status);
+	if (conn && (ev->max_rx_latency > hdev->sniff_max_interval)) {
+		BT_ERR("value of rx_latency:%d", ev->max_rx_latency);
+		hci_dev_lock(hdev);
+		hci_conn_enter_active_mode(conn, 1);
+		hci_dev_unlock(hdev);
+	}
 }
 
 static inline void hci_extended_inquiry_result_evt(struct hci_dev *hdev, struct sk_buff *skb)
@@ -2745,8 +3004,9 @@ static inline void hci_extended_inquiry_result_evt(struct hci_dev *hdev, struct
 		data.rssi		= info->rssi;
 		data.ssp_mode		= 0x01;
 		hci_inquiry_cache_update(hdev, &data);
-		mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,
-				info->dev_class, info->rssi, info->data);
+		mgmt_device_found(hdev->id, &info->bdaddr, 0, 0,
+				info->dev_class, info->rssi,
+				HCI_MAX_EIR_LENGTH, info->data);
 	}
 
 	hci_dev_unlock(hdev);
@@ -2754,19 +3014,23 @@ static inline void hci_extended_inquiry_result_evt(struct hci_dev *hdev, struct
 
 static inline u8 hci_get_auth_req(struct hci_conn *conn)
 {
+	BT_DBG("%p", conn);
+
 	/* If remote requests dedicated bonding follow that lead */
 	if (conn->remote_auth == 0x02 || conn->remote_auth == 0x03) {
 		/* If both remote and local IO capabilities allow MITM
 		 * protection then require it, otherwise don't */
-		if (conn->remote_cap == 0x03 || conn->io_capability == 0x03)
+		if (conn->remote_cap == 0x03 || conn->io_capability == 0x03) {
 			return 0x02;
-		else
+		} else {
+			conn->auth_type |= 0x01;
 			return 0x03;
+		}
 	}
 
 	/* If remote requests no-bonding follow that lead */
-	if (conn->remote_auth == 0x00 || conn->remote_auth == 0x01)
-		return conn->remote_auth | (conn->auth_type & 0x01);
+	if (conn->remote_auth <= 0x01)
+		return 0x00;
 
 	return conn->auth_type;
 }
@@ -2792,11 +3056,15 @@ static inline void hci_io_capa_request_evt(struct hci_dev *hdev, struct sk_buff
 	if (test_bit(HCI_PAIRABLE, &hdev->flags) ||
 			(conn->remote_auth & ~0x01) == HCI_AT_NO_BONDING) {
 		struct hci_cp_io_capability_reply cp;
+		u8 io_cap = conn->io_capability;
 
+		/* ACL-SSP does not support IO CAP 0x04 */
+		cp.capability = (io_cap == 0x04) ? 0x01 : io_cap;
 		bacpy(&cp.bdaddr, &ev->bdaddr);
-		cp.capability = conn->io_capability;
-		conn->auth_type = hci_get_auth_req(conn);
-		cp.authentication = conn->auth_type;
+		if (conn->auth_initiator)
+			cp.authentication = conn->auth_type;
+		else
+			cp.authentication = hci_get_auth_req(conn);
 
 		if ((conn->out == 0x01 || conn->remote_oob == 0x01) &&
 				hci_find_remote_oob_data(hdev, &conn->dst))
@@ -2810,7 +3078,7 @@ static inline void hci_io_capa_request_evt(struct hci_dev *hdev, struct sk_buff
 		struct hci_cp_io_capability_neg_reply cp;
 
 		bacpy(&cp.bdaddr, &ev->bdaddr);
-		cp.reason = HCI_ERROR_PAIRING_NOT_ALLOWED;
+		cp.reason = 0x16; /* Pairing not allowed */
 
 		hci_send_cmd(hdev, HCI_OP_IO_CAPABILITY_NEG_REPLY,
 							sizeof(cp), &cp);
@@ -2841,86 +3109,24 @@ unlock:
 	hci_dev_unlock(hdev);
 }
 
-static inline void hci_user_confirm_request_evt(struct hci_dev *hdev,
-							struct sk_buff *skb)
+static inline void hci_user_ssp_confirmation_evt(struct hci_dev *hdev,
+						u8 event, struct sk_buff *skb)
 {
 	struct hci_ev_user_confirm_req *ev = (void *) skb->data;
-	int loc_mitm, rem_mitm, confirm_hint = 0;
-	struct hci_conn *conn;
 
 	BT_DBG("%s", hdev->name);
 
 	hci_dev_lock(hdev);
 
-	if (!test_bit(HCI_MGMT, &hdev->flags))
-		goto unlock;
-
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &ev->bdaddr);
-	if (!conn)
-		goto unlock;
-
-	loc_mitm = (conn->auth_type & 0x01);
-	rem_mitm = (conn->remote_auth & 0x01);
-
-	/* If we require MITM but the remote device can't provide that
-	 * (it has NoInputNoOutput) then reject the confirmation
-	 * request. The only exception is when we're dedicated bonding
-	 * initiators (connect_cfm_cb set) since then we always have the MITM
-	 * bit set. */
-	if (!conn->connect_cfm_cb && loc_mitm && conn->remote_cap == 0x03) {
-		BT_DBG("Rejecting request: remote device can't provide MITM");
-		hci_send_cmd(hdev, HCI_OP_USER_CONFIRM_NEG_REPLY,
-					sizeof(ev->bdaddr), &ev->bdaddr);
-		goto unlock;
-	}
-
-	/* If no side requires MITM protection; auto-accept */
-	if ((!loc_mitm || conn->remote_cap == 0x03) &&
-				(!rem_mitm || conn->io_capability == 0x03)) {
-
-		/* If we're not the initiators request authorization to
-		 * proceed from user space (mgmt_user_confirm with
-		 * confirm_hint set to 1). */
-		if (!test_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
-			BT_DBG("Confirming auto-accept as acceptor");
-			confirm_hint = 1;
-			goto confirm;
-		}
-
-		BT_DBG("Auto-accept of user confirmation with %ums delay",
-						hdev->auto_accept_delay);
-
-		if (hdev->auto_accept_delay > 0) {
-			int delay = msecs_to_jiffies(hdev->auto_accept_delay);
-			mod_timer(&conn->auto_accept_timer, jiffies + delay);
-			goto unlock;
-		}
-
-		hci_send_cmd(hdev, HCI_OP_USER_CONFIRM_REPLY,
-						sizeof(ev->bdaddr), &ev->bdaddr);
-		goto unlock;
+	if (test_bit(HCI_MGMT, &hdev->flags)) {
+		if (event == HCI_EV_USER_PASSKEY_REQUEST)
+			mgmt_user_confirm_request(hdev->id, event,
+							&ev->bdaddr, 0);
+		else
+			mgmt_user_confirm_request(hdev->id, event,
+						&ev->bdaddr, ev->passkey);
 	}
 
-confirm:
-	mgmt_user_confirm_request(hdev, &ev->bdaddr, ev->passkey,
-								confirm_hint);
-
-unlock:
-	hci_dev_unlock(hdev);
-}
-
-static inline void hci_user_passkey_request_evt(struct hci_dev *hdev,
-							struct sk_buff *skb)
-{
-	struct hci_ev_user_passkey_req *ev = (void *) skb->data;
-
-	BT_DBG("%s", hdev->name);
-
-	hci_dev_lock(hdev);
-
-	if (test_bit(HCI_MGMT, &hdev->flags))
-		mgmt_user_passkey_request(hdev, &ev->bdaddr);
-
 	hci_dev_unlock(hdev);
 }
 
@@ -2943,7 +3149,7 @@ static inline void hci_simple_pair_complete_evt(struct hci_dev *hdev, struct sk_
 	 * event gets always produced as initiator and is also mapped to
 	 * the mgmt_auth_failed event */
 	if (!test_bit(HCI_CONN_AUTH_PEND, &conn->pend) && ev->status != 0)
-		mgmt_auth_failed(hdev, &conn->dst, ev->status);
+		mgmt_auth_failed(hdev->id, &conn->dst, ev->status);
 
 	hci_conn_put(conn);
 
@@ -3006,63 +3212,89 @@ static inline void hci_le_conn_complete_evt(struct hci_dev *hdev, struct sk_buff
 {
 	struct hci_ev_le_conn_complete *ev = (void *) skb->data;
 	struct hci_conn *conn;
+	u8 white_list;
 
 	BT_DBG("%s status %d", hdev->name, ev->status);
 
 	hci_dev_lock(hdev);
 
+	/* Ignore event for LE cancel create conn whitelist */
+	if (ev->status && !bacmp(&ev->bdaddr, BDADDR_ANY))
+		goto unlock;
+
+	if (hci_conn_hash_lookup_ba(hdev, LE_LINK, BDADDR_ANY))
+		white_list = 1;
+	else
+		white_list = 0;
+
+	BT_DBG("w_list %d", white_list);
+
 	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &ev->bdaddr);
 	if (!conn) {
-		conn = hci_conn_add(hdev, LE_LINK, 0, &ev->bdaddr);
+		conn = hci_le_conn_add(hdev, &ev->bdaddr, ev->bdaddr_type);
 		if (!conn) {
 			BT_ERR("No memory for new connection");
 			hci_dev_unlock(hdev);
 			return;
 		}
-
-		conn->dst_type = ev->bdaddr_type;
 	}
 
 	if (ev->status) {
-		mgmt_connect_failed(hdev, &ev->bdaddr, conn->type,
-						conn->dst_type, ev->status);
 		hci_proto_connect_cfm(conn, ev->status);
 		conn->state = BT_CLOSED;
 		hci_conn_del(conn);
 		goto unlock;
 	}
 
-	mgmt_connected(hdev, &ev->bdaddr, conn->type, conn->dst_type);
-
 	conn->sec_level = BT_SECURITY_LOW;
 	conn->handle = __le16_to_cpu(ev->handle);
 	conn->state = BT_CONNECTED;
+	conn->disc_timeout = HCI_DISCONN_TIMEOUT;
+	mgmt_connected(hdev->id, &ev->bdaddr, 1);
+	mgmt_le_conn_params(hdev->id, &ev->bdaddr,
+			__le16_to_cpu(ev->interval),
+			__le16_to_cpu(ev->latency),
+			__le16_to_cpu(ev->supervision_timeout));
 
+	hci_conn_hold(conn);
 	hci_conn_hold_device(conn);
 	hci_conn_add_sysfs(conn);
 
-	hci_proto_connect_cfm(conn, ev->status);
+	if (!white_list)
+		hci_proto_connect_cfm(conn, ev->status);
 
 unlock:
 	hci_dev_unlock(hdev);
 }
 
-static inline void hci_le_adv_report_evt(struct hci_dev *hdev,
-						struct sk_buff *skb)
+static inline void hci_le_conn_update_complete_evt(struct hci_dev *hdev,
+							struct sk_buff *skb)
 {
-	u8 num_reports = skb->data[0];
-	void *ptr = &skb->data[1];
+	struct hci_ev_le_conn_update_complete *ev = (void *) skb->data;
+	struct hci_conn *conn;
 
-	hci_dev_lock(hdev);
+	BT_DBG("%s status %d", hdev->name, ev->status);
 
-	while (num_reports--) {
-		struct hci_ev_le_advertising_info *ev = ptr;
+	hci_dev_lock(hdev);
 
-		hci_add_adv_entry(hdev, ev);
+	conn = hci_conn_hash_lookup_handle(hdev,
+				__le16_to_cpu(ev->handle));
+	if (conn == NULL) {
+		BT_ERR("Unknown connection update");
+		goto unlock;
+	}
 
-		ptr += sizeof(*ev) + ev->length + 1;
+	if (ev->status) {
+		BT_ERR("Connection update unsuccessful");
+		goto unlock;
 	}
 
+	mgmt_le_conn_params(hdev->id, &conn->dst,
+			__le16_to_cpu(ev->interval),
+			__le16_to_cpu(ev->latency),
+			__le16_to_cpu(ev->supervision_timeout));
+
+unlock:
 	hci_dev_unlock(hdev);
 }
 
@@ -3103,6 +3335,27 @@ not_found:
 	hci_dev_unlock(hdev);
 }
 
+static inline void hci_le_adv_report_evt(struct hci_dev *hdev,
+						struct sk_buff *skb)
+{
+	struct hci_ev_le_advertising_info *ev;
+	u8 num_reports;
+
+	num_reports = skb->data[0];
+	ev = (void *) &skb->data[1];
+
+	hci_dev_lock(hdev);
+
+	while (num_reports--) {
+		mgmt_device_found(hdev->id, &ev->bdaddr, ev->bdaddr_type,
+				1, NULL, 0, ev->length, ev->data);
+		hci_add_adv_entry(hdev, ev);
+		ev = (void *) (ev->data + ev->length + 1);
+	}
+
+	hci_dev_unlock(hdev);
+}
+
 static inline void hci_le_meta_evt(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_ev_le_meta *le_ev = (void *) skb->data;
@@ -3114,24 +3367,150 @@ static inline void hci_le_meta_evt(struct hci_dev *hdev, struct sk_buff *skb)
 		hci_le_conn_complete_evt(hdev, skb);
 		break;
 
-	case HCI_EV_LE_ADVERTISING_REPORT:
-		hci_le_adv_report_evt(hdev, skb);
+	case HCI_EV_LE_CONN_UPDATE_COMPLETE:
+		hci_le_conn_update_complete_evt(hdev, skb);
 		break;
 
 	case HCI_EV_LE_LTK_REQ:
 		hci_le_ltk_request_evt(hdev, skb);
 		break;
 
+	case HCI_EV_LE_ADVERTISING_REPORT:
+		hci_le_adv_report_evt(hdev, skb);
+		break;
+
 	default:
 		break;
 	}
 }
 
+static inline void hci_phy_link_complete(struct hci_dev *hdev,
+					struct sk_buff *skb)
+{
+	struct hci_ev_phys_link_complete *ev = (void *) skb->data;
+	struct hci_conn *conn;
+
+	BT_DBG("%s handle %d status %d", hdev->name, ev->phy_handle,
+		ev->status);
+
+	hci_dev_lock(hdev);
+
+	if (ev->status == 0) {
+		conn = hci_conn_add(hdev, ACL_LINK, 0, BDADDR_ANY);
+		if (conn) {
+			conn->handle = ev->phy_handle;
+			conn->state = BT_CONNECTED;
+
+			hci_conn_hold(conn);
+			conn->disc_timeout = HCI_DISCONN_TIMEOUT/2;
+			hci_conn_put(conn);
+
+			hci_conn_hold_device(conn);
+			hci_conn_add_sysfs(conn);
+		} else
+			BT_ERR("No memory for new connection");
+	}
+
+	hci_dev_unlock(hdev);
+}
+
+static inline void hci_log_link_complete(struct hci_dev *hdev,
+					struct sk_buff *skb)
+{
+	struct hci_ev_log_link_complete *ev = (void *) skb->data;
+	struct hci_chan *chan;
+
+	BT_DBG("%s handle %d status %d", hdev->name,
+		__le16_to_cpu(ev->log_handle), ev->status);
+
+	hci_dev_lock(hdev);
+
+	chan = hci_chan_list_lookup_id(hdev, ev->phy_handle);
+
+	if (chan) {
+		if (ev->status == 0) {
+			chan->ll_handle = __le16_to_cpu(ev->log_handle);
+			chan->state = BT_CONNECTED;
+		} else {
+			chan->state = BT_CLOSED;
+		}
+
+		hci_proto_create_cfm(chan, ev->status);
+	}
+
+	hci_dev_unlock(hdev);
+}
+
+static inline void hci_flow_spec_modify_complete(struct hci_dev *hdev,
+					struct sk_buff *skb)
+{
+	struct hci_ev_flow_spec_modify_complete *ev = (void *) skb->data;
+	struct hci_chan *chan;
+
+	BT_DBG("%s handle %d status %d", hdev->name,
+		__le16_to_cpu(ev->log_handle), ev->status);
+
+	hci_dev_lock(hdev);
+
+	chan = hci_chan_list_lookup_handle(hdev, ev->log_handle);
+	if (chan)
+		hci_proto_modify_cfm(chan, ev->status);
+
+	hci_dev_unlock(hdev);
+}
+
+static inline void hci_disconn_log_link_complete_evt(struct hci_dev *hdev,
+						struct sk_buff *skb)
+{
+	struct hci_ev_disconn_log_link_complete *ev = (void *) skb->data;
+	struct hci_chan *chan;
+
+	BT_DBG("%s handle %d status %d", hdev->name,
+		__le16_to_cpu(ev->log_handle), ev->status);
+
+	if (ev->status)
+		return;
+
+	hci_dev_lock(hdev);
+
+	chan = hci_chan_list_lookup_handle(hdev, __le16_to_cpu(ev->log_handle));
+	if (chan)
+		hci_proto_destroy_cfm(chan, ev->reason);
+
+	hci_dev_unlock(hdev);
+}
+
+static inline void hci_disconn_phy_link_complete_evt(struct hci_dev *hdev,
+						struct sk_buff *skb)
+{
+	struct hci_ev_disconn_phys_link_complete *ev = (void *) skb->data;
+	struct hci_conn *conn;
+
+	BT_DBG("%s status %d", hdev->name, ev->status);
+
+	if (ev->status)
+		return;
+
+	hci_dev_lock(hdev);
+
+	conn = hci_conn_hash_lookup_handle(hdev, ev->phy_handle);
+	if (conn) {
+		conn->state = BT_CLOSED;
+
+		hci_proto_disconn_cfm(conn, ev->reason, 0);
+		hci_conn_del(conn);
+	}
+
+	hci_dev_unlock(hdev);
+}
+
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_event_hdr *hdr = (void *) skb->data;
 	__u8 event = hdr->evt;
 
+	BT_DBG("");
+
 	skb_pull(skb, HCI_EVENT_HDR_SIZE);
 
 	switch (event) {
@@ -3191,6 +3570,10 @@ void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb)
 		hci_cmd_status_evt(hdev, skb);
 		break;
 
+	case HCI_EV_HARDWARE_ERROR:
+		hci_hardware_error_evt(hdev, skb);
+		break;
+
 	case HCI_EV_ROLE_CHANGE:
 		hci_role_change_evt(hdev, skb);
 		break;
@@ -3259,12 +3642,10 @@ void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb)
 		hci_io_capa_reply_evt(hdev, skb);
 		break;
 
-	case HCI_EV_USER_CONFIRM_REQUEST:
-		hci_user_confirm_request_evt(hdev, skb);
-		break;
-
 	case HCI_EV_USER_PASSKEY_REQUEST:
-		hci_user_passkey_request_evt(hdev, skb);
+	case HCI_EV_USER_PASSKEY_NOTIFICATION:
+	case HCI_EV_USER_CONFIRM_REQUEST:
+		hci_user_ssp_confirmation_evt(hdev, event, skb);
 		break;
 
 	case HCI_EV_SIMPLE_PAIR_COMPLETE:
@@ -3283,6 +3664,40 @@ void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb)
 		hci_remote_oob_data_request_evt(hdev, skb);
 		break;
 
+	case HCI_EV_PHYS_LINK_COMPLETE:
+		hci_phy_link_complete(hdev, skb);
+		hci_amp_event_packet(hdev, event, skb);
+		break;
+
+	case HCI_EV_LOG_LINK_COMPLETE:
+		hci_log_link_complete(hdev, skb);
+		break;
+
+	case HCI_EV_FLOW_SPEC_MODIFY_COMPLETE:
+		hci_flow_spec_modify_complete(hdev, skb);
+		break;
+
+	case HCI_EV_DISCONN_LOG_LINK_COMPLETE:
+		hci_disconn_log_link_complete_evt(hdev, skb);
+		break;
+
+	case HCI_EV_DISCONN_PHYS_LINK_COMPLETE:
+		hci_disconn_phy_link_complete_evt(hdev, skb);
+		hci_amp_event_packet(hdev, event, skb);
+		break;
+
+	case HCI_EV_NUM_COMP_BLOCKS:
+		hci_num_comp_blocks_evt(hdev, skb);
+		break;
+
+	case HCI_EV_CHANNEL_SELECTED:
+		hci_amp_event_packet(hdev, event, skb);
+		break;
+
+	case HCI_EV_AMP_STATUS_CHANGE:
+		hci_amp_event_packet(hdev, event, skb);
+		break;
+
 	default:
 		BT_DBG("%s event 0x%x", hdev->name, event);
 		break;
@@ -3319,6 +3734,3 @@ void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data)
 	hci_send_to_sock(hdev, skb, NULL);
 	kfree_skb(skb);
 }
-
-module_param(enable_le, bool, 0644);
-MODULE_PARM_DESC(enable_le, "Enable LE support");
diff --git a/net/bluetooth/hci_sock.c b/net/bluetooth/hci_sock.c
index 0dcc962..550f601 100644
--- a/net/bluetooth/hci_sock.c
+++ b/net/bluetooth/hci_sock.c
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (C) 2000-2001 Qualcomm Incorporated
+   Copyright (c) 2000-2001, 2011, The Linux Foundation. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -49,7 +49,7 @@
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 
-static bool enable_mgmt;
+static bool enable_mgmt = 1;
 
 /* ----- HCI socket interface ----- */
 
@@ -180,38 +180,82 @@ static int hci_sock_release(struct socket *sock)
 	return 0;
 }
 
-static int hci_sock_blacklist_add(struct hci_dev *hdev, void __user *arg)
+struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr)
+{
+	struct list_head *p;
+
+	list_for_each(p, &hdev->blacklist) {
+		struct bdaddr_list *b;
+
+		b = list_entry(p, struct bdaddr_list, list);
+
+		if (bacmp(bdaddr, &b->bdaddr) == 0)
+			return b;
+	}
+
+	return NULL;
+}
+
+static int hci_blacklist_add(struct hci_dev *hdev, void __user *arg)
 {
 	bdaddr_t bdaddr;
-	int err;
+	struct bdaddr_list *entry;
 
 	if (copy_from_user(&bdaddr, arg, sizeof(bdaddr)))
 		return -EFAULT;
 
-	hci_dev_lock(hdev);
+	if (bacmp(&bdaddr, BDADDR_ANY) == 0)
+		return -EBADF;
 
-	err = hci_blacklist_add(hdev, &bdaddr);
+	if (hci_blacklist_lookup(hdev, &bdaddr))
+		return -EEXIST;
 
-	hci_dev_unlock(hdev);
+	entry = kzalloc(sizeof(struct bdaddr_list), GFP_KERNEL);
+	if (!entry)
+		return -ENOMEM;
 
-	return err;
+	bacpy(&entry->bdaddr, &bdaddr);
+
+	list_add(&entry->list, &hdev->blacklist);
+
+	return 0;
 }
 
-static int hci_sock_blacklist_del(struct hci_dev *hdev, void __user *arg)
+int hci_blacklist_clear(struct hci_dev *hdev)
+{
+	struct list_head *p, *n;
+
+	list_for_each_safe(p, n, &hdev->blacklist) {
+		struct bdaddr_list *b;
+
+		b = list_entry(p, struct bdaddr_list, list);
+
+		list_del(p);
+		kfree(b);
+	}
+
+	return 0;
+}
+
+static int hci_blacklist_del(struct hci_dev *hdev, void __user *arg)
 {
 	bdaddr_t bdaddr;
-	int err;
+	struct bdaddr_list *entry;
 
 	if (copy_from_user(&bdaddr, arg, sizeof(bdaddr)))
 		return -EFAULT;
 
-	hci_dev_lock(hdev);
+	if (bacmp(&bdaddr, BDADDR_ANY) == 0)
+		return hci_blacklist_clear(hdev);
 
-	err = hci_blacklist_del(hdev, &bdaddr);
+	entry = hci_blacklist_lookup(hdev, &bdaddr);
+	if (!entry)
+		return -ENOENT;
 
-	hci_dev_unlock(hdev);
+	list_del(&entry->list);
+	kfree(entry);
 
-	return err;
+	return 0;
 }
 
 /* Ioctls that require bound socket */
@@ -246,12 +290,15 @@ static inline int hci_sock_bound_ioctl(struct sock *sk, unsigned int cmd, unsign
 	case HCIBLOCKADDR:
 		if (!capable(CAP_NET_ADMIN))
 			return -EACCES;
-		return hci_sock_blacklist_add(hdev, (void __user *) arg);
+		return hci_blacklist_add(hdev, (void __user *) arg);
 
 	case HCIUNBLOCKADDR:
 		if (!capable(CAP_NET_ADMIN))
 			return -EACCES;
-		return hci_sock_blacklist_del(hdev, (void __user *) arg);
+		return hci_blacklist_del(hdev, (void __user *) arg);
+
+	case HCISETAUTHINFO:
+		return hci_set_auth_info(hdev, (void __user *) arg);
 
 	default:
 		if (hdev->ioctl)
@@ -281,7 +328,12 @@ static int hci_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long a
 	case HCIDEVUP:
 		if (!capable(CAP_NET_ADMIN))
 			return -EACCES;
-		return hci_dev_open(arg);
+
+		err =  hci_dev_open(arg);
+		if (!err || err == -EALREADY)
+			return 0;
+		else
+			return err;
 
 	case HCIDEVDOWN:
 		if (!capable(CAP_NET_ADMIN))
@@ -343,11 +395,8 @@ static int hci_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_le
 	if (haddr.hci_channel > HCI_CHANNEL_CONTROL)
 		return -EINVAL;
 
-	if (haddr.hci_channel == HCI_CHANNEL_CONTROL) {
-		if (!enable_mgmt)
-			return -EINVAL;
-		set_bit(HCI_PI_MGMT_INIT, &hci_pi(sk)->flags);
-	}
+	if (haddr.hci_channel == HCI_CHANNEL_CONTROL && !enable_mgmt)
+		return -EINVAL;
 
 	lock_sock(sk);
 
@@ -474,6 +523,7 @@ static int hci_sock_sendmsg(struct kiocb *iocb, struct socket *sock,
 	struct sock *sk = sock->sk;
 	struct hci_dev *hdev;
 	struct sk_buff *skb;
+	int reserve = 0;
 	int err;
 
 	BT_DBG("sock %p sk %p", sock, sk);
@@ -511,10 +561,18 @@ static int hci_sock_sendmsg(struct kiocb *iocb, struct socket *sock,
 		goto done;
 	}
 
-	skb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);
+	/* Allocate extra headroom for Qualcomm PAL */
+	if (hdev->dev_type == HCI_AMP && hdev->manufacturer == 0x001d)
+		reserve = BT_SKB_RESERVE_80211;
+
+	skb = bt_skb_send_alloc(sk, len + reserve,
+					msg->msg_flags & MSG_DONTWAIT, &err);
 	if (!skb)
 		goto done;
 
+	if (reserve)
+		skb_reserve(skb, reserve);
+
 	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
 		err = -EFAULT;
 		goto drop;
@@ -538,10 +596,10 @@ static int hci_sock_sendmsg(struct kiocb *iocb, struct socket *sock,
 
 		if (test_bit(HCI_RAW, &hdev->flags) || (ogf == 0x3f)) {
 			skb_queue_tail(&hdev->raw_q, skb);
-			queue_work(hdev->workqueue, &hdev->tx_work);
+			tasklet_schedule(&hdev->tx_task);
 		} else {
 			skb_queue_tail(&hdev->cmd_q, skb);
-			queue_work(hdev->workqueue, &hdev->cmd_work);
+			tasklet_schedule(&hdev->cmd_task);
 		}
 	} else {
 		if (!capable(CAP_NET_RAW)) {
@@ -550,7 +608,7 @@ static int hci_sock_sendmsg(struct kiocb *iocb, struct socket *sock,
 		}
 
 		skb_queue_tail(&hdev->raw_q, skb);
-		queue_work(hdev->workqueue, &hdev->tx_work);
+		tasklet_schedule(&hdev->tx_task);
 	}
 
 	err = len;
@@ -767,6 +825,7 @@ static int hci_sock_dev_event(struct notifier_block *this, unsigned long event,
 		/* Detach sockets from device */
 		read_lock(&hci_sk_list.lock);
 		sk_for_each(sk, node, &hci_sk_list.head) {
+			local_bh_disable();
 			bh_lock_sock_nested(sk);
 			if (hci_pi(sk)->hdev == hdev) {
 				hci_pi(sk)->hdev = NULL;
@@ -777,6 +836,7 @@ static int hci_sock_dev_event(struct notifier_block *this, unsigned long event,
 				hci_dev_put(hdev);
 			}
 			bh_unlock_sock(sk);
+			local_bh_enable();
 		}
 		read_unlock(&hci_sk_list.lock);
 	}
diff --git a/net/bluetooth/hci_sysfs.c b/net/bluetooth/hci_sysfs.c
index 5210956..0a4c7d6 100644
--- a/net/bluetooth/hci_sysfs.c
+++ b/net/bluetooth/hci_sysfs.c
@@ -5,6 +5,7 @@
 #include <linux/init.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
+#include <linux/interrupt.h>
 #include <linux/module.h>
 
 #include <net/bluetooth/bluetooth.h>
@@ -24,8 +25,6 @@ static inline char *link_typetostr(int type)
 		return "SCO";
 	case ESCO_LINK:
 		return "eSCO";
-	case LE_LINK:
-		return "LE";
 	default:
 		return "UNKNOWN";
 	}
@@ -89,35 +88,11 @@ static struct device_type bt_link = {
 	.release = bt_link_release,
 };
 
-/*
- * The rfcomm tty device will possibly retain even when conn
- * is down, and sysfs doesn't support move zombie device,
- * so we should move the device before conn device is destroyed.
- */
-static int __match_tty(struct device *dev, void *data)
-{
-	return !strncmp(dev_name(dev), "rfcomm", 6);
-}
-
-void hci_conn_init_sysfs(struct hci_conn *conn)
+static void add_conn(struct work_struct *work)
 {
+	struct hci_conn *conn = container_of(work, struct hci_conn, work_add);
 	struct hci_dev *hdev = conn->hdev;
 
-	BT_DBG("conn %p", conn);
-
-	conn->dev.type = &bt_link;
-	conn->dev.class = bt_class;
-	conn->dev.parent = &hdev->dev;
-
-	device_initialize(&conn->dev);
-}
-
-void hci_conn_add_sysfs(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("conn %p", conn);
-
 	dev_set_name(&conn->dev, "%s:%d", hdev->name, conn->handle);
 
 	dev_set_drvdata(&conn->dev, conn);
@@ -130,8 +105,19 @@ void hci_conn_add_sysfs(struct hci_conn *conn)
 	hci_dev_hold(hdev);
 }
 
-void hci_conn_del_sysfs(struct hci_conn *conn)
+/*
+ * The rfcomm tty device will possibly retain even when conn
+ * is down, and sysfs doesn't support move zombie device,
+ * so we should move the device before conn device is destroyed.
+ */
+static int __match_tty(struct device *dev, void *data)
+{
+	return !strncmp(dev_name(dev), "rfcomm", 6);
+}
+
+static void del_conn(struct work_struct *work)
 {
+	struct hci_conn *conn = container_of(work, struct hci_conn, work_del);
 	struct hci_dev *hdev = conn->hdev;
 
 	if (!device_is_registered(&conn->dev))
@@ -153,6 +139,36 @@ void hci_conn_del_sysfs(struct hci_conn *conn)
 	hci_dev_put(hdev);
 }
 
+void hci_conn_init_sysfs(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+
+	BT_DBG("conn %p", conn);
+
+	conn->dev.type = &bt_link;
+	conn->dev.class = bt_class;
+	conn->dev.parent = &hdev->dev;
+
+	device_initialize(&conn->dev);
+
+	INIT_WORK(&conn->work_add, add_conn);
+	INIT_WORK(&conn->work_del, del_conn);
+}
+
+void hci_conn_add_sysfs(struct hci_conn *conn)
+{
+	BT_DBG("conn %p", conn);
+
+	queue_work(conn->hdev->workqueue, &conn->work_add);
+}
+
+void hci_conn_del_sysfs(struct hci_conn *conn)
+{
+	BT_DBG("conn %p", conn);
+
+	queue_work(conn->hdev->workqueue, &conn->work_del);
+}
+
 static inline char *host_bustostr(int bus)
 {
 	switch (bus) {
@@ -386,7 +402,7 @@ static int inquiry_cache_show(struct seq_file *f, void *p)
 	struct inquiry_cache *cache = &hdev->inq_cache;
 	struct inquiry_entry *e;
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 
 	for (e = cache->list; e; e = e->next) {
 		struct inquiry_data *data = &e->data;
@@ -399,7 +415,7 @@ static int inquiry_cache_show(struct seq_file *f, void *p)
 			   data->rssi, data->ssp_mode, e->timestamp);
 	}
 
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 
 	return 0;
 }
@@ -419,14 +435,19 @@ static const struct file_operations inquiry_cache_fops = {
 static int blacklist_show(struct seq_file *f, void *p)
 {
 	struct hci_dev *hdev = f->private;
-	struct bdaddr_list *b;
+	struct list_head *l;
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
+
+	list_for_each(l, &hdev->blacklist) {
+		struct bdaddr_list *b;
+
+		b = list_entry(l, struct bdaddr_list, list);
 
-	list_for_each_entry(b, &hdev->blacklist, list)
 		seq_printf(f, "%s\n", batostr(&b->bdaddr));
+	}
 
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 
 	return 0;
 }
@@ -463,14 +484,19 @@ static void print_bt_uuid(struct seq_file *f, u8 *uuid)
 static int uuids_show(struct seq_file *f, void *p)
 {
 	struct hci_dev *hdev = f->private;
-	struct bt_uuid *uuid;
+	struct list_head *l;
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
+
+	list_for_each(l, &hdev->uuids) {
+		struct bt_uuid *uuid;
+
+		uuid = list_entry(l, struct bt_uuid, list);
 
-	list_for_each_entry(uuid, &hdev->uuids, list)
 		print_bt_uuid(f, uuid->uuid);
+	}
 
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 
 	return 0;
 }
@@ -487,57 +513,22 @@ static const struct file_operations uuids_fops = {
 	.release	= single_release,
 };
 
-static int auto_accept_delay_set(void *data, u64 val)
-{
-	struct hci_dev *hdev = data;
-
-	hci_dev_lock(hdev);
-
-	hdev->auto_accept_delay = val;
-
-	hci_dev_unlock(hdev);
-
-	return 0;
-}
-
-static int auto_accept_delay_get(void *data, u64 *val)
-{
-	struct hci_dev *hdev = data;
-
-	hci_dev_lock(hdev);
-
-	*val = hdev->auto_accept_delay;
-
-	hci_dev_unlock(hdev);
-
-	return 0;
-}
-
-DEFINE_SIMPLE_ATTRIBUTE(auto_accept_delay_fops, auto_accept_delay_get,
-					auto_accept_delay_set, "%llu\n");
-
-void hci_init_sysfs(struct hci_dev *hdev)
-{
-	struct device *dev = &hdev->dev;
-
-	dev->type = &bt_host;
-	dev->class = bt_class;
-
-	dev_set_drvdata(dev, hdev);
-	device_initialize(dev);
-}
-
-int hci_add_sysfs(struct hci_dev *hdev)
+int hci_register_sysfs(struct hci_dev *hdev)
 {
 	struct device *dev = &hdev->dev;
 	int err;
 
 	BT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);
 
+	dev->type = &bt_host;
+	dev->class = bt_class;
 	dev->parent = hdev->parent;
+
 	dev_set_name(dev, "%s", hdev->name);
 
-	err = device_add(dev);
+	dev_set_drvdata(dev, hdev);
+
+	err = device_register(dev);
 	if (err < 0)
 		return err;
 
@@ -556,12 +547,10 @@ int hci_add_sysfs(struct hci_dev *hdev)
 
 	debugfs_create_file("uuids", 0444, hdev->debugfs, hdev, &uuids_fops);
 
-	debugfs_create_file("auto_accept_delay", 0444, hdev->debugfs, hdev,
-						&auto_accept_delay_fops);
 	return 0;
 }
 
-void hci_del_sysfs(struct hci_dev *hdev)
+void hci_unregister_sysfs(struct hci_dev *hdev)
 {
 	BT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);
 
diff --git a/net/bluetooth/hidp/core.c b/net/bluetooth/hidp/core.c
index d478be1..e214cb2 100644
--- a/net/bluetooth/hidp/core.c
+++ b/net/bluetooth/hidp/core.c
@@ -1,6 +1,7 @@
 /*
    HIDP implementation for Linux Bluetooth stack (BlueZ).
    Copyright (C) 2003-2004 Marcel Holtmann <marcel@holtmann.org>
+   Copyright (c) 2012-2013 The Linux Foundation.  All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2 as
@@ -21,6 +22,7 @@
 */
 
 #include <linux/module.h>
+#include <linux/interrupt.h>
 
 #include <linux/types.h>
 #include <linux/errno.h>
@@ -36,8 +38,6 @@
 #include <linux/file.h>
 #include <linux/init.h>
 #include <linux/wait.h>
-#include <linux/mutex.h>
-#include <linux/kthread.h>
 #include <net/sock.h>
 
 #include <linux/input.h>
@@ -81,27 +81,44 @@ static unsigned char hidp_mkeyspat[] = { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 };
 static struct hidp_session *__hidp_get_session(bdaddr_t *bdaddr)
 {
 	struct hidp_session *session;
+	struct list_head *p;
 
 	BT_DBG("");
 
-	list_for_each_entry(session, &hidp_session_list, list) {
+	list_for_each(p, &hidp_session_list) {
+		session = list_entry(p, struct hidp_session, list);
 		if (!bacmp(bdaddr, &session->bdaddr))
 			return session;
 	}
-
 	return NULL;
 }
 
 static void __hidp_link_session(struct hidp_session *session)
 {
+	__module_get(THIS_MODULE);
 	list_add(&session->list, &hidp_session_list);
 }
 
 static void __hidp_unlink_session(struct hidp_session *session)
 {
-	hci_conn_put_device(session->conn);
+	bdaddr_t *dst = &session->bdaddr;
+	struct hci_dev *hdev;
+	struct device *dev = NULL;
+
+	hdev = hci_get_route(dst, BDADDR_ANY);
+	if (hdev) {
+		session->conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
+		if (session->conn && session->conn->hidp_session_valid)
+			dev = &session->conn->dev;
+
+		hci_dev_put(hdev);
+	}
+
+	if (dev)
+		hci_conn_put_device(session->conn);
 
 	list_del(&session->list);
+	module_put(THIS_MODULE);
 }
 
 static void __hidp_copy_session(struct hidp_session *session, struct hidp_conninfo *ci)
@@ -250,9 +267,6 @@ static int __hidp_send_ctrl_message(struct hidp_session *session,
 
 	BT_DBG("session %p data %p size %d", session, data, size);
 
-	if (atomic_read(&session->terminate))
-		return -EIO;
-
 	skb = alloc_skb(size + 1, GFP_ATOMIC);
 	if (!skb) {
 		BT_ERR("Can't allocate memory for new frame");
@@ -318,143 +332,24 @@ static int hidp_send_report(struct hidp_session *session, struct hid_report *rep
 	return hidp_queue_report(session, buf, rsize);
 }
 
-static int hidp_get_raw_report(struct hid_device *hid,
-		unsigned char report_number,
-		unsigned char *data, size_t count,
-		unsigned char report_type)
-{
-	struct hidp_session *session = hid->driver_data;
-	struct sk_buff *skb;
-	size_t len;
-	int numbered_reports = hid->report_enum[report_type].numbered;
-	int ret;
-
-	switch (report_type) {
-	case HID_FEATURE_REPORT:
-		report_type = HIDP_TRANS_GET_REPORT | HIDP_DATA_RTYPE_FEATURE;
-		break;
-	case HID_INPUT_REPORT:
-		report_type = HIDP_TRANS_GET_REPORT | HIDP_DATA_RTYPE_INPUT;
-		break;
-	case HID_OUTPUT_REPORT:
-		report_type = HIDP_TRANS_GET_REPORT | HIDP_DATA_RTYPE_OUPUT;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	if (mutex_lock_interruptible(&session->report_mutex))
-		return -ERESTARTSYS;
-
-	/* Set up our wait, and send the report request to the device. */
-	session->waiting_report_type = report_type & HIDP_DATA_RTYPE_MASK;
-	session->waiting_report_number = numbered_reports ? report_number : -1;
-	set_bit(HIDP_WAITING_FOR_RETURN, &session->flags);
-	data[0] = report_number;
-	ret = hidp_send_ctrl_message(hid->driver_data, report_type, data, 1);
-	if (ret)
-		goto err;
-
-	/* Wait for the return of the report. The returned report
-	   gets put in session->report_return.  */
-	while (test_bit(HIDP_WAITING_FOR_RETURN, &session->flags)) {
-		int res;
-
-		res = wait_event_interruptible_timeout(session->report_queue,
-			!test_bit(HIDP_WAITING_FOR_RETURN, &session->flags),
-			5*HZ);
-		if (res == 0) {
-			/* timeout */
-			ret = -EIO;
-			goto err;
-		}
-		if (res < 0) {
-			/* signal */
-			ret = -ERESTARTSYS;
-			goto err;
-		}
-	}
-
-	skb = session->report_return;
-	if (skb) {
-		len = skb->len < count ? skb->len : count;
-		memcpy(data, skb->data, len);
-
-		kfree_skb(skb);
-		session->report_return = NULL;
-	} else {
-		/* Device returned a HANDSHAKE, indicating  protocol error. */
-		len = -EIO;
-	}
-
-	clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags);
-	mutex_unlock(&session->report_mutex);
-
-	return len;
-
-err:
-	clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags);
-	mutex_unlock(&session->report_mutex);
-	return ret;
-}
-
 static int hidp_output_raw_report(struct hid_device *hid, unsigned char *data, size_t count,
 		unsigned char report_type)
 {
-	struct hidp_session *session = hid->driver_data;
-	int ret;
-
 	switch (report_type) {
 	case HID_FEATURE_REPORT:
 		report_type = HIDP_TRANS_SET_REPORT | HIDP_DATA_RTYPE_FEATURE;
 		break;
 	case HID_OUTPUT_REPORT:
-		report_type = HIDP_TRANS_SET_REPORT | HIDP_DATA_RTYPE_OUPUT;
+		report_type = HIDP_TRANS_DATA | HIDP_DATA_RTYPE_OUPUT;
 		break;
 	default:
 		return -EINVAL;
 	}
 
-	if (mutex_lock_interruptible(&session->report_mutex))
-		return -ERESTARTSYS;
-
-	/* Set up our wait, and send the report request to the device. */
-	set_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags);
-	ret = hidp_send_ctrl_message(hid->driver_data, report_type, data,
-									count);
-	if (ret)
-		goto err;
-
-	/* Wait for the ACK from the device. */
-	while (test_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags)) {
-		int res;
-
-		res = wait_event_interruptible_timeout(session->report_queue,
-			!test_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags),
-			10*HZ);
-		if (res == 0) {
-			/* timeout */
-			ret = -EIO;
-			goto err;
-		}
-		if (res < 0) {
-			/* signal */
-			ret = -ERESTARTSYS;
-			goto err;
-		}
-	}
-
-	if (!session->output_report_success) {
-		ret = -EIO;
-		goto err;
-	}
-
-	ret = count;
-
-err:
-	clear_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags);
-	mutex_unlock(&session->report_mutex);
-	return ret;
+	if (hidp_send_ctrl_message(hid->driver_data, report_type,
+			data, count))
+		return -ENOMEM;
+	return count;
 }
 
 static void hidp_idle_timeout(unsigned long arg)
@@ -462,7 +357,7 @@ static void hidp_idle_timeout(unsigned long arg)
 	struct hidp_session *session = (struct hidp_session *) arg;
 
 	atomic_inc(&session->terminate);
-	wake_up_process(session->task);
+	hidp_schedule(session);
 }
 
 static void hidp_set_timer(struct hidp_session *session)
@@ -481,21 +376,16 @@ static void hidp_process_handshake(struct hidp_session *session,
 					unsigned char param)
 {
 	BT_DBG("session %p param 0x%02x", session, param);
-	session->output_report_success = 0; /* default condition */
 
 	switch (param) {
 	case HIDP_HSHK_SUCCESSFUL:
 		/* FIXME: Call into SET_ GET_ handlers here */
-		session->output_report_success = 1;
 		break;
 
 	case HIDP_HSHK_NOT_READY:
 	case HIDP_HSHK_ERR_INVALID_REPORT_ID:
 	case HIDP_HSHK_ERR_UNSUPPORTED_REQUEST:
 	case HIDP_HSHK_ERR_INVALID_PARAMETER:
-		if (test_and_clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags))
-			wake_up_interruptible(&session->report_queue);
-
 		/* FIXME: Call into SET_ GET_ handlers here */
 		break;
 
@@ -514,10 +404,6 @@ static void hidp_process_handshake(struct hidp_session *session,
 			HIDP_TRANS_HANDSHAKE | HIDP_HSHK_ERR_INVALID_PARAMETER, NULL, 0);
 		break;
 	}
-
-	/* Wake up the waiting thread. */
-	if (test_and_clear_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags))
-		wake_up_interruptible(&session->report_queue);
 }
 
 static void hidp_process_hid_control(struct hidp_session *session,
@@ -530,16 +416,15 @@ static void hidp_process_hid_control(struct hidp_session *session,
 		skb_queue_purge(&session->ctrl_transmit);
 		skb_queue_purge(&session->intr_transmit);
 
+		/* Kill session thread */
 		atomic_inc(&session->terminate);
-		wake_up_process(current);
+		hidp_schedule(session);
 	}
 }
 
-/* Returns true if the passed-in skb should be freed by the caller. */
-static int hidp_process_data(struct hidp_session *session, struct sk_buff *skb,
+static void hidp_process_data(struct hidp_session *session, struct sk_buff *skb,
 				unsigned char param)
 {
-	int done_with_skb = 1;
 	BT_DBG("session %p skb %p len %d param 0x%02x", session, skb, skb->len, param);
 
 	switch (param) {
@@ -551,6 +436,7 @@ static int hidp_process_data(struct hidp_session *session, struct sk_buff *skb,
 
 		if (session->hid)
 			hid_input_report(session->hid, HID_INPUT_REPORT, skb->data, skb->len, 0);
+
 		break;
 
 	case HIDP_DATA_RTYPE_OTHER:
@@ -562,27 +448,12 @@ static int hidp_process_data(struct hidp_session *session, struct sk_buff *skb,
 		__hidp_send_ctrl_message(session,
 			HIDP_TRANS_HANDSHAKE | HIDP_HSHK_ERR_INVALID_PARAMETER, NULL, 0);
 	}
-
-	if (test_bit(HIDP_WAITING_FOR_RETURN, &session->flags) &&
-				param == session->waiting_report_type) {
-		if (session->waiting_report_number < 0 ||
-		    session->waiting_report_number == skb->data[0]) {
-			/* hidp_get_raw_report() is waiting on this report. */
-			session->report_return = skb;
-			done_with_skb = 0;
-			clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags);
-			wake_up_interruptible(&session->report_queue);
-		}
-	}
-
-	return done_with_skb;
 }
 
 static void hidp_recv_ctrl_frame(struct hidp_session *session,
 					struct sk_buff *skb)
 {
 	unsigned char hdr, type, param;
-	int free_skb = 1;
 
 	BT_DBG("session %p skb %p len %d", session, skb, skb->len);
 
@@ -602,7 +473,7 @@ static void hidp_recv_ctrl_frame(struct hidp_session *session,
 		break;
 
 	case HIDP_TRANS_DATA:
-		free_skb = hidp_process_data(session, skb, param);
+		hidp_process_data(session, skb, param);
 		break;
 
 	default:
@@ -611,8 +482,7 @@ static void hidp_recv_ctrl_frame(struct hidp_session *session,
 		break;
 	}
 
-	if (free_skb)
-		kfree_skb(skb);
+	kfree_skb(skb);
 }
 
 static void hidp_recv_intr_frame(struct hidp_session *session,
@@ -657,32 +527,25 @@ static int hidp_send_frame(struct socket *sock, unsigned char *data, int len)
 	return kernel_sendmsg(sock, &msg, &iv, 1, len);
 }
 
-static void hidp_process_intr_transmit(struct hidp_session *session)
+static void hidp_process_transmit(struct hidp_session *session)
 {
 	struct sk_buff *skb;
 
 	BT_DBG("session %p", session);
 
-	while ((skb = skb_dequeue(&session->intr_transmit))) {
-		if (hidp_send_frame(session->intr_sock, skb->data, skb->len) < 0) {
-			skb_queue_head(&session->intr_transmit, skb);
+	while ((skb = skb_dequeue(&session->ctrl_transmit))) {
+		if (hidp_send_frame(session->ctrl_sock, skb->data, skb->len) < 0) {
+			skb_queue_head(&session->ctrl_transmit, skb);
 			break;
 		}
 
 		hidp_set_timer(session);
 		kfree_skb(skb);
 	}
-}
-
-static void hidp_process_ctrl_transmit(struct hidp_session *session)
-{
-	struct sk_buff *skb;
-
-	BT_DBG("session %p", session);
 
-	while ((skb = skb_dequeue(&session->ctrl_transmit))) {
-		if (hidp_send_frame(session->ctrl_sock, skb->data, skb->len) < 0) {
-			skb_queue_head(&session->ctrl_transmit, skb);
+	while ((skb = skb_dequeue(&session->intr_transmit))) {
+		if (hidp_send_frame(session->intr_sock, skb->data, skb->len) < 0) {
+			skb_queue_head(&session->intr_transmit, skb);
 			break;
 		}
 
@@ -697,56 +560,59 @@ static int hidp_session(void *arg)
 	struct sock *ctrl_sk = session->ctrl_sock->sk;
 	struct sock *intr_sk = session->intr_sock->sk;
 	struct sk_buff *skb;
+	int vendor = 0x0000, product = 0x0000;
 	wait_queue_t ctrl_wait, intr_wait;
 
 	BT_DBG("session %p", session);
 
-	__module_get(THIS_MODULE);
+	if (session->input) {
+		vendor  = session->input->id.vendor;
+		product = session->input->id.product;
+	}
+
+	if (session->hid) {
+		vendor  = session->hid->vendor;
+		product = session->hid->product;
+	}
+
+	daemonize("khidpd_%04x%04x", vendor, product);
 	set_user_nice(current, -15);
 
 	init_waitqueue_entry(&ctrl_wait, current);
 	init_waitqueue_entry(&intr_wait, current);
 	add_wait_queue(sk_sleep(ctrl_sk), &ctrl_wait);
 	add_wait_queue(sk_sleep(intr_sk), &intr_wait);
-	session->waiting_for_startup = 0;
-	wake_up_interruptible(&session->startup_queue);
-	set_current_state(TASK_INTERRUPTIBLE);
 	while (!atomic_read(&session->terminate)) {
+		set_current_state(TASK_INTERRUPTIBLE);
+
 		if (ctrl_sk->sk_state != BT_CONNECTED ||
 				intr_sk->sk_state != BT_CONNECTED)
 			break;
 
-		while ((skb = skb_dequeue(&intr_sk->sk_receive_queue))) {
+		while ((skb = skb_dequeue(&ctrl_sk->sk_receive_queue))) {
 			skb_orphan(skb);
 			if (!skb_linearize(skb))
-				hidp_recv_intr_frame(session, skb);
+				hidp_recv_ctrl_frame(session, skb);
 			else
 				kfree_skb(skb);
 		}
 
-		hidp_process_intr_transmit(session);
-
-		while ((skb = skb_dequeue(&ctrl_sk->sk_receive_queue))) {
+		while ((skb = skb_dequeue(&intr_sk->sk_receive_queue))) {
 			skb_orphan(skb);
 			if (!skb_linearize(skb))
-				hidp_recv_ctrl_frame(session, skb);
+				hidp_recv_intr_frame(session, skb);
 			else
 				kfree_skb(skb);
 		}
 
-		hidp_process_ctrl_transmit(session);
+		hidp_process_transmit(session);
 
 		schedule();
-		set_current_state(TASK_INTERRUPTIBLE);
 	}
 	set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(intr_sk), &intr_wait);
 	remove_wait_queue(sk_sleep(ctrl_sk), &ctrl_wait);
 
-	clear_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags);
-	clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags);
-	wake_up_interruptible(&session->report_queue);
-
 	down_write(&hidp_session_sem);
 
 	hidp_del_timer(session);
@@ -778,9 +644,7 @@ static int hidp_session(void *arg)
 
 	up_write(&hidp_session_sem);
 
-	kfree(session->rd_data);
 	kfree(session);
-	module_put_and_exit(0);
 	return 0;
 }
 
@@ -795,11 +659,13 @@ static struct hci_conn *hidp_get_connection(struct hidp_session *session)
 	if (!hdev)
 		return NULL;
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
-	if (conn)
+	if (conn) {
+		conn->hidp_session_valid = true;
 		hci_conn_hold_device(conn);
-	hci_dev_unlock(hdev);
+	}
+	hci_dev_unlock_bh(hdev);
 
 	hci_dev_put(hdev);
 
@@ -810,7 +676,7 @@ static int hidp_setup_input(struct hidp_session *session,
 				struct hidp_connadd_req *req)
 {
 	struct input_dev *input;
-	int i;
+	int err, i;
 
 	input = input_allocate_device();
 	if (!input)
@@ -857,6 +723,12 @@ static int hidp_setup_input(struct hidp_session *session,
 
 	input->event = hidp_input_event;
 
+	err = input_register_device(input);
+	if (err < 0) {
+		hci_conn_put_device(session->conn);
+		return err;
+	}
+
 	return 0;
 }
 
@@ -882,9 +754,6 @@ static int hidp_start(struct hid_device *hid)
 	struct hidp_session *session = hid->driver_data;
 	struct hid_report *report;
 
-	if (hid->quirks & HID_QUIRK_NO_INIT_REPORTS)
-		return 0;
-
 	list_for_each_entry(report, &hid->report_enum[HID_INPUT_REPORT].
 			report_list, list)
 		hidp_send_report(session, report);
@@ -915,8 +784,6 @@ static struct hid_ll_driver hidp_hid_driver = {
 	.hidinput_input_event = hidp_hidinput_event,
 };
 
-/* This function sets up the hid device. It does not add it
-   to the HID system. That is done in hidp_add_connection(). */
 static int hidp_setup_hid(struct hidp_session *session,
 				struct hidp_connadd_req *req)
 {
@@ -956,11 +823,18 @@ static int hidp_setup_hid(struct hidp_session *session,
 	hid->dev.parent = &session->conn->dev;
 	hid->ll_driver = &hidp_hid_driver;
 
-	hid->hid_get_raw_report = hidp_get_raw_report;
 	hid->hid_output_raw_report = hidp_output_raw_report;
 
+	err = hid_add_device(hid);
+	if (err < 0)
+		goto failed;
+
 	return 0;
 
+failed:
+	hid_destroy_device(hid);
+	session->hid = NULL;
+
 fault:
 	kfree(session->rd_data);
 	session->rd_data = NULL;
@@ -971,7 +845,6 @@ fault:
 int hidp_add_connection(struct hidp_connadd_req *req, struct socket *ctrl_sock, struct socket *intr_sock)
 {
 	struct hidp_session *session, *s;
-	int vendor, product;
 	int err;
 
 	BT_DBG("");
@@ -980,28 +853,24 @@ int hidp_add_connection(struct hidp_connadd_req *req, struct socket *ctrl_sock,
 			bacmp(&bt_sk(ctrl_sock->sk)->dst, &bt_sk(intr_sock->sk)->dst))
 		return -ENOTUNIQ;
 
+	session = kzalloc(sizeof(struct hidp_session), GFP_KERNEL);
+	if (!session)
+		return -ENOMEM;
+
 	BT_DBG("rd_data %p rd_size %d", req->rd_data, req->rd_size);
 
 	down_write(&hidp_session_sem);
 
 	s = __hidp_get_session(&bt_sk(ctrl_sock->sk)->dst);
 	if (s && s->state == BT_CONNECTED) {
-		up_write(&hidp_session_sem);
-		return -EEXIST;
-	}
-
-	session = kzalloc(sizeof(struct hidp_session), GFP_KERNEL);
-	if (!session) {
-		up_write(&hidp_session_sem);
-		return -ENOMEM;
+		err = -EEXIST;
+		goto failed;
 	}
 
 	bacpy(&session->bdaddr, &bt_sk(ctrl_sock->sk)->dst);
 
-	session->ctrl_mtu = min_t(uint, l2cap_pi(ctrl_sock->sk)->chan->omtu,
-					l2cap_pi(ctrl_sock->sk)->chan->imtu);
-	session->intr_mtu = min_t(uint, l2cap_pi(intr_sock->sk)->chan->omtu,
-					l2cap_pi(intr_sock->sk)->chan->imtu);
+	session->ctrl_mtu = min_t(uint, l2cap_pi(ctrl_sock->sk)->omtu, l2cap_pi(ctrl_sock->sk)->imtu);
+	session->intr_mtu = min_t(uint, l2cap_pi(intr_sock->sk)->omtu, l2cap_pi(intr_sock->sk)->imtu);
 
 	BT_DBG("ctrl mtu %d intr mtu %d", session->ctrl_mtu, session->intr_mtu);
 
@@ -1020,10 +889,6 @@ int hidp_add_connection(struct hidp_connadd_req *req, struct socket *ctrl_sock,
 	skb_queue_head_init(&session->ctrl_transmit);
 	skb_queue_head_init(&session->intr_transmit);
 
-	mutex_init(&session->report_mutex);
-	init_waitqueue_head(&session->report_queue);
-	init_waitqueue_head(&session->startup_queue);
-	session->waiting_for_startup = 1;
 	session->flags   = req->flags & (1 << HIDP_BLUETOOTH_VENDOR_ID);
 	session->idle_to = req->idle_to;
 
@@ -1031,7 +896,7 @@ int hidp_add_connection(struct hidp_connadd_req *req, struct socket *ctrl_sock,
 
 	if (req->rd_size > 0) {
 		err = hidp_setup_hid(session, req);
-		if (err)
+		if (err && err != -ENODEV)
 			goto purge;
 	}
 
@@ -1043,40 +908,9 @@ int hidp_add_connection(struct hidp_connadd_req *req, struct socket *ctrl_sock,
 
 	hidp_set_timer(session);
 
-	if (session->hid) {
-		vendor  = session->hid->vendor;
-		product = session->hid->product;
-	} else if (session->input) {
-		vendor  = session->input->id.vendor;
-		product = session->input->id.product;
-	} else {
-		vendor = 0x0000;
-		product = 0x0000;
-	}
-
-	session->task = kthread_run(hidp_session, session, "khidpd_%04x%04x",
-							vendor, product);
-	if (IS_ERR(session->task)) {
-		err = PTR_ERR(session->task);
+	err = kernel_thread(hidp_session, session, CLONE_KERNEL);
+	if (err < 0)
 		goto unlink;
-	}
-
-	while (session->waiting_for_startup) {
-		wait_event_interruptible(session->startup_queue,
-			!session->waiting_for_startup);
-	}
-
-	if (session->hid)
-		err = hid_add_device(session->hid);
-	else
-		err = input_register_device(session->input);
-
-	if (err < 0) {
-		atomic_inc(&session->terminate);
-		wake_up_process(session->task);
-		up_write(&hidp_session_sem);
-		return err;
-	}
 
 	if (session->input) {
 		hidp_send_ctrl_message(session,
@@ -1115,6 +949,7 @@ purge:
 failed:
 	up_write(&hidp_session_sem);
 
+	input_free_device(session->input);
 	kfree(session);
 	return err;
 }
@@ -1138,8 +973,13 @@ int hidp_del_connection(struct hidp_conndel_req *req)
 			skb_queue_purge(&session->ctrl_transmit);
 			skb_queue_purge(&session->intr_transmit);
 
+			/* Wakeup user-space polling for socket errors */
+			session->intr_sock->sk->sk_err = EUNATCH;
+			session->ctrl_sock->sk->sk_err = EUNATCH;
+
+			/* Kill session thread */
 			atomic_inc(&session->terminate);
-			wake_up_process(session->task);
+			hidp_schedule(session);
 		}
 	} else
 		err = -ENOENT;
@@ -1150,16 +990,19 @@ int hidp_del_connection(struct hidp_conndel_req *req)
 
 int hidp_get_connlist(struct hidp_connlist_req *req)
 {
-	struct hidp_session *session;
+	struct list_head *p;
 	int err = 0, n = 0;
 
 	BT_DBG("");
 
 	down_read(&hidp_session_sem);
 
-	list_for_each_entry(session, &hidp_session_list, list) {
+	list_for_each(p, &hidp_session_list) {
+		struct hidp_session *session;
 		struct hidp_conninfo ci;
 
+		session = list_entry(p, struct hidp_session, list);
+
 		__hidp_copy_session(session, &ci);
 
 		if (copy_to_user(req->ci, &ci, sizeof(ci))) {
diff --git a/net/bluetooth/hidp/hidp.h b/net/bluetooth/hidp/hidp.h
index af1bcc8..28bb9ce 100644
--- a/net/bluetooth/hidp/hidp.h
+++ b/net/bluetooth/hidp/hidp.h
@@ -80,8 +80,6 @@
 #define HIDP_VIRTUAL_CABLE_UNPLUG	0
 #define HIDP_BOOT_PROTOCOL_MODE		1
 #define HIDP_BLUETOOTH_VENDOR_ID	9
-#define HIDP_WAITING_FOR_RETURN		10
-#define HIDP_WAITING_FOR_SEND_ACK	11
 
 struct hidp_connadd_req {
 	int   ctrl_sock;	/* Connected control socket */
@@ -143,7 +141,6 @@ struct hidp_session {
 	uint intr_mtu;
 
 	atomic_t terminate;
-	struct task_struct *task;
 
 	unsigned char keys[8];
 	unsigned char leds;
@@ -157,22 +154,9 @@ struct hidp_session {
 	struct sk_buff_head ctrl_transmit;
 	struct sk_buff_head intr_transmit;
 
-	/* Used in hidp_get_raw_report() */
-	int waiting_report_type; /* HIDP_DATA_RTYPE_* */
-	int waiting_report_number; /* -1 for not numbered */
-	struct mutex report_mutex;
-	struct sk_buff *report_return;
-	wait_queue_head_t report_queue;
-
-	/* Used in hidp_output_raw_report() */
-	int output_report_success; /* boolean */
-
 	/* Report descriptor */
 	__u8 *rd_data;
 	uint rd_size;
-
-	wait_queue_head_t startup_queue;
-	int waiting_for_startup;
 };
 
 static inline void hidp_schedule(struct hidp_session *session)
diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c
old mode 100755
new mode 100644
index 2d1a35c..fd9088a
--- a/net/bluetooth/l2cap_core.c
+++ b/net/bluetooth/l2cap_core.c
@@ -1,9 +1,8 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (C) 2000-2001 Qualcomm Incorporated
+   Copyright (c) 2000-2001, 2010-2013 The Linux Foundation. All rights reserved.
    Copyright (C) 2009-2010 Gustavo F. Padovan <gustavo@padovan.org>
    Copyright (C) 2010 Google Inc.
-   Copyright (C) 2011 ProFUSION Embedded Systems
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -47,6 +46,7 @@
 #include <linux/seq_file.h>
 #include <linux/uaccess.h>
 #include <linux/crc16.h>
+#include <linux/math64.h>
 #include <net/sock.h>
 
 #include <asm/system.h>
@@ -56,348 +56,530 @@
 #include <net/bluetooth/hci_core.h>
 #include <net/bluetooth/l2cap.h>
 #include <net/bluetooth/smp.h>
+#include <net/bluetooth/amp.h>
 
 bool disable_ertm;
+bool enable_hs;
+bool enable_reconfig;
 
 static u32 l2cap_feat_mask = L2CAP_FEAT_FIXED_CHAN;
-static u8 l2cap_fixed_chan[8] = { L2CAP_FC_L2CAP, };
+static u8 l2cap_fc_mask = L2CAP_FC_L2CAP;
 
-static LIST_HEAD(chan_list);
-static DEFINE_RWLOCK(chan_list_lock);
+struct workqueue_struct *_l2cap_wq;
 
-static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,
-				u8 code, u8 ident, u16 dlen, void *data);
-static void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,
-								void *data);
-static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data);
-static void l2cap_send_disconn_req(struct l2cap_conn *conn,
-				struct l2cap_chan *chan, int err);
+struct bt_sock_list l2cap_sk_list = {
+	.lock = __RW_LOCK_UNLOCKED(l2cap_sk_list.lock)
+};
 
-static int l2cap_ertm_data_rcv(struct sock *sk, struct sk_buff *skb);
+static void l2cap_send_move_chan_req(struct l2cap_conn *conn,
+			struct l2cap_pinfo *pi, u16 icid, u8 dest_amp_id);
+static void l2cap_send_move_chan_cfm(struct l2cap_conn *conn,
+			struct l2cap_pinfo *pi, u16 icid, u16 result);
+static void l2cap_send_move_chan_rsp(struct l2cap_conn *conn, u8 ident,
+			u16 icid, u16 result);
 
-/* ---- L2CAP channels ---- */
+static void l2cap_amp_move_setup(struct sock *sk);
+static void l2cap_amp_move_success(struct sock *sk);
+static void l2cap_amp_move_revert(struct sock *sk);
 
-static struct l2cap_chan *__l2cap_get_chan_by_dcid(struct l2cap_conn *conn, u16 cid)
-{
-	struct l2cap_chan *c, *r = NULL;
+static int l2cap_ertm_rx_queued_iframes(struct sock *sk);
 
-	rcu_read_lock();
+static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,
+				u8 code, u8 ident, u16 dlen, void *data);
+static int l2cap_answer_move_poll(struct sock *sk);
+static int l2cap_create_cfm(struct hci_chan *chan, u8 status);
+static int l2cap_deaggregate(struct hci_chan *chan, struct l2cap_pinfo *pi);
+static void l2cap_chan_ready(struct sock *sk);
+static void l2cap_conn_del(struct hci_conn *hcon, int err, u8 is_process);
+static u16 l2cap_get_smallest_flushto(struct l2cap_chan_list *l);
+static void l2cap_set_acl_flushto(struct hci_conn *hcon, u16 flush_to);
+static void l2cap_queue_acl_data(struct work_struct *worker);
+static struct att_channel_parameters{
+	struct sk_buff *skb;
+	struct l2cap_conn *conn;
+	__le16 cid;
+	int dir;
+} att_chn_params;
 
-	list_for_each_entry_rcu(c, &conn->chan_l, list) {
-		if (c->dcid == cid) {
-			r = c;
+/* ---- L2CAP channels ---- */
+static struct sock *__l2cap_get_chan_by_dcid(struct l2cap_chan_list *l, u16 cid)
+{
+	struct sock *s;
+	for (s = l->head; s; s = l2cap_pi(s)->next_c) {
+		if (l2cap_pi(s)->dcid == cid)
 			break;
-		}
 	}
-
-	rcu_read_unlock();
-	return r;
+	return s;
 }
 
-static struct l2cap_chan *__l2cap_get_chan_by_scid(struct l2cap_conn *conn, u16 cid)
+/* Find channel with given DCID.
+ * Returns locked socket */
+static inline struct sock *l2cap_get_chan_by_dcid(struct l2cap_chan_list *l,
+						u16 cid)
 {
-	struct l2cap_chan *c, *r = NULL;
-
-	rcu_read_lock();
+	struct sock *s;
+	read_lock(&l->lock);
+	s = __l2cap_get_chan_by_dcid(l, cid);
+	if (s)
+		bh_lock_sock(s);
+	read_unlock(&l->lock);
+	return s;
+}
 
-	list_for_each_entry_rcu(c, &conn->chan_l, list) {
-		if (c->scid == cid) {
-			r = c;
+static struct sock *__l2cap_get_chan_by_scid(struct l2cap_chan_list *l, u16 cid)
+{
+	struct sock *s;
+	for (s = l->head; s; s = l2cap_pi(s)->next_c) {
+		if (l2cap_pi(s)->scid == cid)
 			break;
-		}
 	}
-
-	rcu_read_unlock();
-	return r;
+	return s;
 }
 
 /* Find channel with given SCID.
  * Returns locked socket */
-static struct l2cap_chan *l2cap_get_chan_by_scid(struct l2cap_conn *conn, u16 cid)
+static inline struct sock *l2cap_get_chan_by_scid(struct l2cap_chan_list *l, u16 cid)
 {
-	struct l2cap_chan *c;
+	struct sock *s;
+	read_lock(&l->lock);
+	s = __l2cap_get_chan_by_scid(l, cid);
+	if (s)
+		bh_lock_sock(s);
+	read_unlock(&l->lock);
+	return s;
+}
 
-	c = __l2cap_get_chan_by_scid(conn, cid);
-	if (c)
-		lock_sock(c->sk);
-	return c;
+static struct sock *__l2cap_get_chan_by_ident(struct l2cap_chan_list *l, u8 ident)
+{
+	struct sock *s;
+	for (s = l->head; s; s = l2cap_pi(s)->next_c) {
+		if (l2cap_pi(s)->ident == ident)
+			break;
+	}
+	return s;
 }
 
-static struct l2cap_chan *__l2cap_get_chan_by_ident(struct l2cap_conn *conn, u8 ident)
+static inline struct sock *l2cap_get_chan_by_ident(struct l2cap_chan_list *l, u8 ident)
 {
-	struct l2cap_chan *c, *r = NULL;
+	struct sock *s;
+	read_lock(&l->lock);
+	s = __l2cap_get_chan_by_ident(l, ident);
+	if (s)
+		bh_lock_sock(s);
+	read_unlock(&l->lock);
+	return s;
+}
 
-	rcu_read_lock();
+static inline struct sk_buff *l2cap_ertm_seq_in_queue(struct sk_buff_head *head,
+						u16 seq)
+{
+	struct sk_buff *skb;
 
-	list_for_each_entry_rcu(c, &conn->chan_l, list) {
-		if (c->ident == ident) {
-			r = c;
-			break;
-		}
+	skb_queue_walk(head, skb) {
+		if (bt_cb(skb)->control.txseq == seq)
+			return skb;
 	}
 
-	rcu_read_unlock();
-	return r;
+	return NULL;
 }
 
-static inline struct l2cap_chan *l2cap_get_chan_by_ident(struct l2cap_conn *conn, u8 ident)
+static int l2cap_seq_list_init(struct l2cap_seq_list *seq_list, u16 size)
 {
-	struct l2cap_chan *c;
+	u16 allocSize = 1;
+	int err = 0;
+	int i;
 
-	c = __l2cap_get_chan_by_ident(conn, ident);
-	if (c)
-		lock_sock(c->sk);
-	return c;
+	/* Actual allocated size must be a power of 2 */
+	while (allocSize && allocSize <= size)
+		allocSize <<= 1;
+	if (!allocSize)
+		return -ENOMEM;
+
+	seq_list->list = kzalloc(sizeof(u16) * allocSize, GFP_ATOMIC);
+	if (!seq_list->list)
+		return -ENOMEM;
+
+	seq_list->size = allocSize;
+	seq_list->mask = allocSize - 1;
+	seq_list->head = L2CAP_SEQ_LIST_CLEAR;
+	seq_list->tail = L2CAP_SEQ_LIST_CLEAR;
+	for (i = 0; i < allocSize; i++)
+		seq_list->list[i] = L2CAP_SEQ_LIST_CLEAR;
+
+	return err;
 }
 
-static struct l2cap_chan *__l2cap_global_chan_by_addr(__le16 psm, bdaddr_t *src)
+static inline void l2cap_seq_list_free(struct l2cap_seq_list *seq_list)
 {
-	struct l2cap_chan *c;
+	kfree(seq_list->list);
+}
 
-	list_for_each_entry(c, &chan_list, global_l) {
-		if (c->sport == psm && !bacmp(&bt_sk(c->sk)->src, src))
-			return c;
-	}
-	return NULL;
+static inline bool l2cap_seq_list_contains(struct l2cap_seq_list *seq_list,
+					u16 seq)
+{
+	return seq_list->list[seq & seq_list->mask] != L2CAP_SEQ_LIST_CLEAR;
 }
 
-int l2cap_add_psm(struct l2cap_chan *chan, bdaddr_t *src, __le16 psm)
+static u16 l2cap_seq_list_remove(struct l2cap_seq_list *seq_list, u16 seq)
 {
-	int err;
+	u16 mask = seq_list->mask;
 
-	write_lock(&chan_list_lock);
+	BT_DBG("seq_list %p, seq %d", seq_list, (int) seq);
 
-	if (psm && __l2cap_global_chan_by_addr(psm, src)) {
-		err = -EADDRINUSE;
-		goto done;
-	}
+	if (seq_list->head == L2CAP_SEQ_LIST_CLEAR) {
+		/* In case someone tries to pop the head of an empty list */
+		BT_DBG("List empty");
+		return L2CAP_SEQ_LIST_CLEAR;
+	} else if (seq_list->head == seq) {
+		/* Head can be removed quickly */
+		BT_DBG("Remove head");
+		seq_list->head = seq_list->list[seq & mask];
+		seq_list->list[seq & mask] = L2CAP_SEQ_LIST_CLEAR;
 
-	if (psm) {
-		chan->psm = psm;
-		chan->sport = psm;
-		err = 0;
+		if (seq_list->head == L2CAP_SEQ_LIST_TAIL) {
+			seq_list->head = L2CAP_SEQ_LIST_CLEAR;
+			seq_list->tail = L2CAP_SEQ_LIST_CLEAR;
+		}
 	} else {
-		u16 p;
-
-		err = -EINVAL;
-		for (p = 0x1001; p < 0x1100; p += 2)
-			if (!__l2cap_global_chan_by_addr(cpu_to_le16(p), src)) {
-				chan->psm   = cpu_to_le16(p);
-				chan->sport = cpu_to_le16(p);
-				err = 0;
-				break;
+		/* Non-head item must be found first */
+		u16 prev = seq_list->head;
+		BT_DBG("Find and remove");
+		while (seq_list->list[prev & mask] != seq) {
+			prev = seq_list->list[prev & mask];
+			if (prev == L2CAP_SEQ_LIST_TAIL) {
+				BT_DBG("seq %d not in list", (int) seq);
+				return L2CAP_SEQ_LIST_CLEAR;
 			}
-	}
+		}
 
-done:
-	write_unlock(&chan_list_lock);
-	return err;
+		seq_list->list[prev & mask] = seq_list->list[seq & mask];
+		seq_list->list[seq & mask] = L2CAP_SEQ_LIST_CLEAR;
+		if (seq_list->tail == seq)
+			seq_list->tail = prev;
+	}
+	return seq;
 }
 
-int l2cap_add_scid(struct l2cap_chan *chan,  __u16 scid)
+static inline u16 l2cap_seq_list_pop(struct l2cap_seq_list *seq_list)
 {
-	write_lock(&chan_list_lock);
-
-	chan->scid = scid;
+	return l2cap_seq_list_remove(seq_list, seq_list->head);
+}
 
-	write_unlock(&chan_list_lock);
+static void l2cap_seq_list_clear(struct l2cap_seq_list *seq_list)
+{
+	if (seq_list->head != L2CAP_SEQ_LIST_CLEAR) {
+		u16 i;
+		for (i = 0; i < seq_list->size; i++)
+			seq_list->list[i] = L2CAP_SEQ_LIST_CLEAR;
 
-	return 0;
+		seq_list->head = L2CAP_SEQ_LIST_CLEAR;
+		seq_list->tail = L2CAP_SEQ_LIST_CLEAR;
+	}
 }
 
-static u16 l2cap_alloc_cid(struct l2cap_conn *conn)
+static void l2cap_seq_list_append(struct l2cap_seq_list *seq_list, u16 seq)
 {
-	u16 cid = L2CAP_CID_DYN_START;
+	u16 mask = seq_list->mask;
 
-	for (; cid < L2CAP_CID_DYN_END; cid++) {
-		if (!__l2cap_get_chan_by_scid(conn, cid))
-			return cid;
-	}
+	BT_DBG("seq_list %p, seq %d", seq_list, (int) seq);
 
-	return 0;
+	if (seq_list->list[seq & mask] == L2CAP_SEQ_LIST_CLEAR) {
+		if (seq_list->tail == L2CAP_SEQ_LIST_CLEAR)
+			seq_list->head = seq;
+		else
+			seq_list->list[seq_list->tail & mask] = seq;
+
+		seq_list->tail = seq;
+		seq_list->list[seq & mask] = L2CAP_SEQ_LIST_TAIL;
+	}
 }
 
-static char *state_to_string(int state)
+static u16 __pack_enhanced_control(struct bt_l2cap_control *control)
 {
-	switch(state) {
-	case BT_CONNECTED:
-		return "BT_CONNECTED";
-	case BT_OPEN:
-		return "BT_OPEN";
-	case BT_BOUND:
-		return "BT_BOUND";
-	case BT_LISTEN:
-		return "BT_LISTEN";
-	case BT_CONNECT:
-		return "BT_CONNECT";
-	case BT_CONNECT2:
-		return "BT_CONNECT2";
-	case BT_CONFIG:
-		return "BT_CONFIG";
-	case BT_DISCONN:
-		return "BT_DISCONN";
-	case BT_CLOSED:
-		return "BT_CLOSED";
+	u16 packed;
+
+	packed = (control->reqseq << L2CAP_CTRL_REQSEQ_SHIFT) &
+		L2CAP_CTRL_REQSEQ;
+	packed |= (control->final << L2CAP_CTRL_FINAL_SHIFT) &
+		L2CAP_CTRL_FINAL;
+
+	if (control->frame_type == 's') {
+		packed |= (control->poll << L2CAP_CTRL_POLL_SHIFT) &
+			L2CAP_CTRL_POLL;
+		packed |= (control->super << L2CAP_CTRL_SUPERVISE_SHIFT) &
+			L2CAP_CTRL_SUPERVISE;
+		packed |= L2CAP_CTRL_FRAME_TYPE;
+	} else {
+		packed |= (control->sar << L2CAP_CTRL_SAR_SHIFT) &
+			L2CAP_CTRL_SAR;
+		packed |= (control->txseq << L2CAP_CTRL_TXSEQ_SHIFT) &
+			L2CAP_CTRL_TXSEQ;
 	}
 
-	return "invalid state";
+	return packed;
 }
 
-static void l2cap_state_change(struct l2cap_chan *chan, int state)
+static void __get_enhanced_control(u16 enhanced,
+					struct bt_l2cap_control *control)
 {
-	BT_DBG("%p %s -> %s", chan, state_to_string(chan->state),
-						state_to_string(state));
+	control->reqseq = (enhanced & L2CAP_CTRL_REQSEQ) >>
+		L2CAP_CTRL_REQSEQ_SHIFT;
+	control->final = (enhanced & L2CAP_CTRL_FINAL) >>
+		L2CAP_CTRL_FINAL_SHIFT;
+
+	if (enhanced & L2CAP_CTRL_FRAME_TYPE) {
+		control->frame_type = 's';
+		control->poll = (enhanced & L2CAP_CTRL_POLL) >>
+			L2CAP_CTRL_POLL_SHIFT;
+		control->super = (enhanced & L2CAP_CTRL_SUPERVISE) >>
+			L2CAP_CTRL_SUPERVISE_SHIFT;
+
+		control->sar = 0;
+		control->txseq = 0;
+	} else {
+		control->frame_type = 'i';
+		control->sar = (enhanced & L2CAP_CTRL_SAR) >>
+			L2CAP_CTRL_SAR_SHIFT;
+		control->txseq = (enhanced & L2CAP_CTRL_TXSEQ) >>
+			L2CAP_CTRL_TXSEQ_SHIFT;
 
-	chan->state = state;
-	chan->ops->state_change(chan->data, state);
+		control->poll = 0;
+		control->super = 0;
+	}
 }
 
-static void l2cap_chan_timeout(struct work_struct *work)
+static u32 __pack_extended_control(struct bt_l2cap_control *control)
 {
-	struct l2cap_chan *chan = container_of(work, struct l2cap_chan,
-							chan_timer.work);
-	struct sock *sk = chan->sk;
-	int reason;
+	u32 packed;
 
-	BT_DBG("chan %p state %d", chan, chan->state);
+	packed = (control->reqseq << L2CAP_EXT_CTRL_REQSEQ_SHIFT) &
+		L2CAP_EXT_CTRL_REQSEQ;
+	packed |= (control->final << L2CAP_EXT_CTRL_FINAL_SHIFT) &
+		L2CAP_EXT_CTRL_FINAL;
 
-	lock_sock(sk);
+	if (control->frame_type == 's') {
+		packed |= (control->poll << L2CAP_EXT_CTRL_POLL_SHIFT) &
+			L2CAP_EXT_CTRL_POLL;
+		packed |= (control->super << L2CAP_EXT_CTRL_SUPERVISE_SHIFT) &
+			L2CAP_EXT_CTRL_SUPERVISE;
+		packed |= L2CAP_EXT_CTRL_FRAME_TYPE;
+	} else {
+		packed |= (control->sar << L2CAP_EXT_CTRL_SAR_SHIFT) &
+			L2CAP_EXT_CTRL_SAR;
+		packed |= (control->txseq << L2CAP_EXT_CTRL_TXSEQ_SHIFT) &
+			L2CAP_EXT_CTRL_TXSEQ;
+	}
 
-	if (chan->state == BT_CONNECTED || chan->state == BT_CONFIG)
-		reason = ECONNREFUSED;
-	else if (chan->state == BT_CONNECT &&
-					chan->sec_level != BT_SECURITY_SDP)
-		reason = ECONNREFUSED;
-	else
-		reason = ETIMEDOUT;
+	return packed;
+}
 
-	l2cap_chan_close(chan, reason);
+static void __get_extended_control(u32 extended,
+				struct bt_l2cap_control *control)
+{
+	control->reqseq = (extended & L2CAP_EXT_CTRL_REQSEQ) >>
+		L2CAP_EXT_CTRL_REQSEQ_SHIFT;
+	control->final = (extended & L2CAP_EXT_CTRL_FINAL) >>
+		L2CAP_EXT_CTRL_FINAL_SHIFT;
 
-	release_sock(sk);
+	if (extended & L2CAP_EXT_CTRL_FRAME_TYPE) {
+		control->frame_type = 's';
+		control->poll = (extended & L2CAP_EXT_CTRL_POLL) >>
+			L2CAP_EXT_CTRL_POLL_SHIFT;
+		control->super = (extended & L2CAP_EXT_CTRL_SUPERVISE) >>
+			L2CAP_EXT_CTRL_SUPERVISE_SHIFT;
 
-	chan->ops->close(chan->data);
-	l2cap_chan_put(chan);
+		control->sar = 0;
+		control->txseq = 0;
+	} else {
+		control->frame_type = 'i';
+		control->sar = (extended & L2CAP_EXT_CTRL_SAR) >>
+			L2CAP_EXT_CTRL_SAR_SHIFT;
+		control->txseq = (extended & L2CAP_EXT_CTRL_TXSEQ) >>
+			L2CAP_EXT_CTRL_TXSEQ_SHIFT;
+
+		control->poll = 0;
+		control->super = 0;
+	}
 }
 
-struct l2cap_chan *l2cap_chan_create(struct sock *sk)
+static inline void l2cap_ertm_stop_ack_timer(struct l2cap_pinfo *pi)
 {
-	struct l2cap_chan *chan;
+	BT_DBG("pi %p", pi);
+	__cancel_delayed_work(&pi->ack_work);
+}
 
-	chan = kzalloc(sizeof(*chan), GFP_ATOMIC);
-	if (!chan)
-		return NULL;
+static inline void l2cap_ertm_start_ack_timer(struct l2cap_pinfo *pi)
+{
+	BT_DBG("pi %p, pending %d", pi, delayed_work_pending(&pi->ack_work));
+	if (!delayed_work_pending(&pi->ack_work)) {
+		queue_delayed_work(_l2cap_wq, &pi->ack_work,
+				msecs_to_jiffies(L2CAP_DEFAULT_ACK_TO));
+	}
+}
 
-	chan->sk = sk;
+static inline void l2cap_ertm_stop_retrans_timer(struct l2cap_pinfo *pi)
+{
+	BT_DBG("pi %p", pi);
+	__cancel_delayed_work(&pi->retrans_work);
+}
 
-	write_lock(&chan_list_lock);
-	list_add(&chan->global_l, &chan_list);
-	write_unlock(&chan_list_lock);
+static inline void l2cap_ertm_start_retrans_timer(struct l2cap_pinfo *pi)
+{
+	BT_DBG("pi %p", pi);
+	if (!delayed_work_pending(&pi->monitor_work) && pi->retrans_timeout) {
+		__cancel_delayed_work(&pi->retrans_work);
+		queue_delayed_work(_l2cap_wq, &pi->retrans_work,
+			msecs_to_jiffies(pi->retrans_timeout));
+	}
+}
 
-	INIT_DELAYED_WORK(&chan->chan_timer, l2cap_chan_timeout);
+static inline void l2cap_ertm_stop_monitor_timer(struct l2cap_pinfo *pi)
+{
+	BT_DBG("pi %p", pi);
+	__cancel_delayed_work(&pi->monitor_work);
+}
 
-	chan->state = BT_OPEN;
+static inline void l2cap_ertm_start_monitor_timer(struct l2cap_pinfo *pi)
+{
+	BT_DBG("pi %p", pi);
+	l2cap_ertm_stop_retrans_timer(pi);
+	__cancel_delayed_work(&pi->monitor_work);
+	if (pi->monitor_timeout) {
+		queue_delayed_work(_l2cap_wq, &pi->monitor_work,
+				msecs_to_jiffies(pi->monitor_timeout));
+	}
+}
 
-	atomic_set(&chan->refcnt, 1);
+static u16 l2cap_alloc_cid(struct l2cap_chan_list *l)
+{
+	u16 cid = L2CAP_CID_DYN_START;
 
-	BT_DBG("sk %p chan %p", sk, chan);
+	for (; cid < L2CAP_CID_DYN_END; cid++) {
+		if (!__l2cap_get_chan_by_scid(l, cid))
+			return cid;
+	}
 
-	return chan;
+	return 0;
 }
 
-void l2cap_chan_destroy(struct l2cap_chan *chan)
+static inline void __l2cap_chan_link(struct l2cap_chan_list *l, struct sock *sk)
 {
-	BT_DBG("chan %p", chan);
+	sock_hold(sk);
 
-	write_lock(&chan_list_lock);
-	list_del(&chan->global_l);
-	write_unlock(&chan_list_lock);
+	if (l->head)
+		l2cap_pi(l->head)->prev_c = sk;
 
-	kfree(chan);
+	l2cap_pi(sk)->next_c = l->head;
+	l2cap_pi(sk)->prev_c = NULL;
+	l->head = sk;
 }
 
-void l2cap_chan_hold(struct l2cap_chan *c)
+static inline void l2cap_chan_unlink(struct l2cap_chan_list *l, struct sock *sk)
 {
-    BT_DBG("chan %p orig refcnt %d", c, atomic_read(&c->refcnt));
+	struct sock *next = l2cap_pi(sk)->next_c, *prev = l2cap_pi(sk)->prev_c;
 
-    atomic_inc(&c->refcnt);
-}
+	write_lock_bh(&l->lock);
+	if (sk == l->head)
+		l->head = next;
 
-void l2cap_chan_put(struct l2cap_chan *c)
-{
-    BT_DBG("chan %p orig refcnt %d", c, atomic_read(&c->refcnt));
+	if (next)
+		l2cap_pi(next)->prev_c = prev;
+	if (prev)
+		l2cap_pi(prev)->next_c = next;
+	write_unlock_bh(&l->lock);
 
-    if (atomic_dec_and_test(&c->refcnt))
-        l2cap_chan_destroy(c);
+	__sock_put(sk);
 }
 
-static void l2cap_chan_add(struct l2cap_conn *conn, struct l2cap_chan *chan)
+static void __l2cap_chan_add(struct l2cap_conn *conn, struct sock *sk)
 {
+	struct l2cap_chan_list *l = &conn->chan_list;
+
 	BT_DBG("conn %p, psm 0x%2.2x, dcid 0x%4.4x", conn,
-			chan->psm, chan->dcid);
+			l2cap_pi(sk)->psm, l2cap_pi(sk)->dcid);
 
-	conn->disc_reason = HCI_ERROR_REMOTE_USER_TERM;
+	conn->disc_reason = 0x13;
 
-	chan->conn = conn;
+	l2cap_pi(sk)->conn = conn;
 
-	if (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED) {
+	if (!l2cap_pi(sk)->fixed_channel &&
+		(sk->sk_type == SOCK_SEQPACKET || sk->sk_type == SOCK_STREAM)) {
 		if (conn->hcon->type == LE_LINK) {
 			/* LE connection */
-			chan->omtu = L2CAP_LE_DEFAULT_MTU;
-			chan->scid = L2CAP_CID_LE_DATA;
-			chan->dcid = L2CAP_CID_LE_DATA;
+			if (l2cap_pi(sk)->imtu < L2CAP_LE_DEFAULT_MTU)
+				l2cap_pi(sk)->imtu = L2CAP_LE_DEFAULT_MTU;
+			if (l2cap_pi(sk)->omtu < L2CAP_LE_DEFAULT_MTU)
+				l2cap_pi(sk)->omtu = L2CAP_LE_DEFAULT_MTU;
+
+			l2cap_pi(sk)->scid = L2CAP_CID_LE_DATA;
+			l2cap_pi(sk)->dcid = L2CAP_CID_LE_DATA;
 		} else {
 			/* Alloc CID for connection-oriented socket */
-			chan->scid = l2cap_alloc_cid(conn);
-			chan->omtu = L2CAP_DEFAULT_MTU;
+			l2cap_pi(sk)->scid = l2cap_alloc_cid(l);
+			l2cap_pi(sk)->omtu = L2CAP_DEFAULT_MTU;
 		}
-	} else if (chan->chan_type == L2CAP_CHAN_CONN_LESS) {
+	} else if (sk->sk_type == SOCK_DGRAM) {
 		/* Connectionless socket */
-		chan->scid = L2CAP_CID_CONN_LESS;
-		chan->dcid = L2CAP_CID_CONN_LESS;
-		chan->omtu = L2CAP_DEFAULT_MTU;
-	} else {
+		l2cap_pi(sk)->scid = L2CAP_CID_CONN_LESS;
+		l2cap_pi(sk)->dcid = L2CAP_CID_CONN_LESS;
+		l2cap_pi(sk)->omtu = L2CAP_DEFAULT_MTU;
+	} else if (sk->sk_type == SOCK_RAW) {
 		/* Raw socket can send/recv signalling messages only */
-		chan->scid = L2CAP_CID_SIGNALING;
-		chan->dcid = L2CAP_CID_SIGNALING;
-		chan->omtu = L2CAP_DEFAULT_MTU;
+		l2cap_pi(sk)->scid = L2CAP_CID_SIGNALING;
+		l2cap_pi(sk)->dcid = L2CAP_CID_SIGNALING;
+		l2cap_pi(sk)->omtu = L2CAP_DEFAULT_MTU;
 	}
 
-	chan->local_id		= L2CAP_BESTEFFORT_ID;
-	chan->local_stype	= L2CAP_SERV_BESTEFFORT;
-	chan->local_msdu	= L2CAP_DEFAULT_MAX_SDU_SIZE;
-	chan->local_sdu_itime	= L2CAP_DEFAULT_SDU_ITIME;
-	chan->local_acc_lat	= L2CAP_DEFAULT_ACC_LAT;
-	chan->local_flush_to	= L2CAP_DEFAULT_FLUSH_TO;
-
-	l2cap_chan_hold(chan);
+	if (l2cap_get_smallest_flushto(l) > l2cap_pi(sk)->flush_to) {
+		/*if flush timeout of the channel is lesser than existing */
+		l2cap_set_acl_flushto(conn->hcon, l2cap_pi(sk)->flush_to);
+	}
+	/* Otherwise, do not set scid/dcid/omtu.  These will be set up
+	 * by l2cap_fixed_channel_config()
+	 */
 
-	list_add_rcu(&chan->list, &conn->chan_l);
+	__l2cap_chan_link(l, sk);
 }
 
 /* Delete channel.
  * Must be called on the locked socket. */
-static void l2cap_chan_del(struct l2cap_chan *chan, int err)
+void l2cap_chan_del(struct sock *sk, int err)
 {
-	struct sock *sk = chan->sk;
-	struct l2cap_conn *conn = chan->conn;
+	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
 	struct sock *parent = bt_sk(sk)->parent;
 
-	__clear_chan_timer(chan);
+	l2cap_sock_clear_timer(sk);
 
-	BT_DBG("chan %p, conn %p, err %d", chan, conn, err);
+	BT_DBG("sk %p, conn %p, err %d", sk, conn, err);
 
 	if (conn) {
-		/* Delete from channel list */
-		list_del_rcu(&chan->list);
-		synchronize_rcu();
-
-		l2cap_chan_put(chan);
-
-		chan->conn = NULL;
-		hci_conn_put(conn->hcon);
+		struct l2cap_chan_list *l = &conn->chan_list;
+		/* Unlink from channel list */
+		l2cap_chan_unlink(l, sk);
+		l2cap_pi(sk)->conn = NULL;
+		if (!l2cap_pi(sk)->fixed_channel)
+			hci_conn_put(conn->hcon);
+
+		read_lock(&l->lock);
+		if (l2cap_pi(sk)->flush_to < l2cap_get_smallest_flushto(l))
+			l2cap_set_acl_flushto(conn->hcon,
+				l2cap_get_smallest_flushto(l));
+		read_unlock(&l->lock);
+	}
+
+	if (l2cap_pi(sk)->ampchan) {
+		struct hci_chan *ampchan = l2cap_pi(sk)->ampchan;
+		struct hci_conn *ampcon = l2cap_pi(sk)->ampcon;
+		l2cap_pi(sk)->ampchan = NULL;
+		l2cap_pi(sk)->ampcon = NULL;
+		l2cap_pi(sk)->amp_id = 0;
+		if (hci_chan_put(ampchan))
+			ampcon->l2cap_data = NULL;
+		else
+			l2cap_deaggregate(ampchan, l2cap_pi(sk));
 	}
 
-	l2cap_state_change(chan, BT_CLOSED);
+	sk->sk_state = BT_CLOSED;
 	sock_set_flag(sk, SOCK_ZAPPED);
 
 	if (err)
@@ -409,109 +591,26 @@ static void l2cap_chan_del(struct l2cap_chan *chan, int err)
 	} else
 		sk->sk_state_change(sk);
 
-	if (!(test_bit(CONF_OUTPUT_DONE, &chan->conf_state) &&
-			test_bit(CONF_INPUT_DONE, &chan->conf_state)))
-		return;
-
-	skb_queue_purge(&chan->tx_q);
-
-	if (chan->mode == L2CAP_MODE_ERTM) {
-		struct srej_list *l, *tmp;
-
-		__clear_retrans_timer(chan);
-		__clear_monitor_timer(chan);
-		__clear_ack_timer(chan);
-
-		skb_queue_purge(&chan->srej_q);
-
-		list_for_each_entry_safe(l, tmp, &chan->srej_l, list) {
-			list_del(&l->list);
-			kfree(l);
-		}
-	}
-}
-
-static void l2cap_chan_cleanup_listen(struct sock *parent)
-{
-	struct sock *sk;
-
-	BT_DBG("parent %p", parent);
-
-	/* Close not yet accepted channels */
-	while ((sk = bt_accept_dequeue(parent, NULL))) {
-		struct l2cap_chan *chan = l2cap_pi(sk)->chan;
-		__clear_chan_timer(chan);
-		lock_sock(sk);
-		l2cap_chan_close(chan, ECONNRESET);
-		release_sock(sk);
-		chan->ops->close(chan->data);
-	}
-}
-
-void l2cap_chan_close(struct l2cap_chan *chan, int reason)
-{
-	struct l2cap_conn *conn = chan->conn;
-	struct sock *sk = chan->sk;
-
-	BT_DBG("chan %p state %d socket %p", chan, chan->state, sk->sk_socket);
-
-	switch (chan->state) {
-	case BT_LISTEN:
-		l2cap_chan_cleanup_listen(sk);
-
-		l2cap_state_change(chan, BT_CLOSED);
-		sock_set_flag(sk, SOCK_ZAPPED);
-		break;
-
-	case BT_CONNECTED:
-	case BT_CONFIG:
-		if (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED &&
-					conn->hcon->type == ACL_LINK) {
-			__clear_chan_timer(chan);
-			__set_chan_timer(chan, sk->sk_sndtimeo);
-			l2cap_send_disconn_req(conn, chan, reason);
-		} else
-			l2cap_chan_del(chan, reason);
-		break;
-
-	case BT_CONNECT2:
-		if (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED &&
-					conn->hcon->type == ACL_LINK) {
-			struct l2cap_conn_rsp rsp;
-			__u16 result;
-
-			if (bt_sk(sk)->defer_setup)
-				result = L2CAP_CR_SEC_BLOCK;
-			else
-				result = L2CAP_CR_BAD_PSM;
-			l2cap_state_change(chan, BT_DISCONN);
-
-			rsp.scid   = cpu_to_le16(chan->dcid);
-			rsp.dcid   = cpu_to_le16(chan->scid);
-			rsp.result = cpu_to_le16(result);
-			rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-			l2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,
-							sizeof(rsp), &rsp);
-		}
+	sk->sk_send_head = NULL;
+	skb_queue_purge(TX_QUEUE(sk));
 
-		l2cap_chan_del(chan, reason);
-		break;
+	if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM) {
+		if (l2cap_pi(sk)->sdu)
+			kfree_skb(l2cap_pi(sk)->sdu);
 
-	case BT_CONNECT:
-	case BT_DISCONN:
-		l2cap_chan_del(chan, reason);
-		break;
+		skb_queue_purge(SREJ_QUEUE(sk));
 
-	default:
-		sock_set_flag(sk, SOCK_ZAPPED);
-		break;
+		__cancel_delayed_work(&l2cap_pi(sk)->ack_work);
+		__cancel_delayed_work(&l2cap_pi(sk)->retrans_work);
+		__cancel_delayed_work(&l2cap_pi(sk)->monitor_work);
 	}
 }
 
-static inline u8 l2cap_get_auth_type(struct l2cap_chan *chan)
+static inline u8 l2cap_get_auth_type(struct sock *sk)
 {
-	if (chan->chan_type == L2CAP_CHAN_RAW) {
-		switch (chan->sec_level) {
+	if (sk->sk_type == SOCK_RAW) {
+		switch (l2cap_pi(sk)->sec_level) {
+		case BT_SECURITY_VERY_HIGH:
 		case BT_SECURITY_HIGH:
 			return HCI_AT_DEDICATED_BONDING_MITM;
 		case BT_SECURITY_MEDIUM:
@@ -519,16 +618,18 @@ static inline u8 l2cap_get_auth_type(struct l2cap_chan *chan)
 		default:
 			return HCI_AT_NO_BONDING;
 		}
-	} else if (chan->psm == cpu_to_le16(0x0001)) {
-		if (chan->sec_level == BT_SECURITY_LOW)
-			chan->sec_level = BT_SECURITY_SDP;
+	} else if (l2cap_pi(sk)->psm == cpu_to_le16(0x0001)) {
+		if (l2cap_pi(sk)->sec_level == BT_SECURITY_LOW)
+			l2cap_pi(sk)->sec_level = BT_SECURITY_SDP;
 
-		if (chan->sec_level == BT_SECURITY_HIGH)
+		if (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH ||
+			l2cap_pi(sk)->sec_level == BT_SECURITY_VERY_HIGH)
 			return HCI_AT_NO_BONDING_MITM;
 		else
 			return HCI_AT_NO_BONDING;
 	} else {
-		switch (chan->sec_level) {
+		switch (l2cap_pi(sk)->sec_level) {
+		case BT_SECURITY_VERY_HIGH:
 		case BT_SECURITY_HIGH:
 			return HCI_AT_GENERAL_BONDING_MITM;
 		case BT_SECURITY_MEDIUM:
@@ -540,17 +641,18 @@ static inline u8 l2cap_get_auth_type(struct l2cap_chan *chan)
 }
 
 /* Service level security */
-int l2cap_chan_check_security(struct l2cap_chan *chan)
+static inline int l2cap_check_security(struct sock *sk)
 {
-	struct l2cap_conn *conn = chan->conn;
+	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
 	__u8 auth_type;
 
-	auth_type = l2cap_get_auth_type(chan);
+	auth_type = l2cap_get_auth_type(sk);
 
-	return hci_conn_security(conn->hcon, chan->sec_level, auth_type);
+	return hci_conn_security(conn->hcon, l2cap_pi(sk)->sec_level,
+								auth_type);
 }
 
-static u8 l2cap_get_ident(struct l2cap_conn *conn)
+u8 l2cap_get_ident(struct l2cap_conn *conn)
 {
 	u8 id;
 
@@ -560,19 +662,46 @@ static u8 l2cap_get_ident(struct l2cap_conn *conn)
 	 *  200 - 254 are used by utilities like l2ping, etc.
 	 */
 
-	spin_lock(&conn->lock);
+	spin_lock_bh(&conn->lock);
 
 	if (++conn->tx_ident > 128)
 		conn->tx_ident = 1;
 
 	id = conn->tx_ident;
 
-	spin_unlock(&conn->lock);
+	spin_unlock_bh(&conn->lock);
 
 	return id;
 }
 
-static void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data)
+static void apply_fcs(struct sk_buff *skb)
+{
+	size_t len;
+	u16 partial_crc;
+	struct sk_buff *iter;
+	struct sk_buff *final_frag = skb;
+
+	if (skb_has_frag_list(skb))
+		len = skb_headlen(skb);
+	else
+		len = skb->len - L2CAP_FCS_SIZE;
+
+	partial_crc = crc16(0, (u8 *) skb->data, len);
+
+	skb_walk_frags(skb, iter) {
+		len = iter->len;
+		if (!iter->next)
+			len -= L2CAP_FCS_SIZE;
+
+		partial_crc = crc16(partial_crc, iter->data, len);
+		final_frag = iter;
+	}
+
+	put_unaligned_le16(partial_crc,
+		final_frag->data + final_frag->len - L2CAP_FCS_SIZE);
+}
+
+void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data)
 {
 	struct sk_buff *skb = l2cap_build_cmd(conn, code, ident, len, data);
 	u8 flags;
@@ -582,121 +711,68 @@ static void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,
 	if (!skb)
 		return;
 
+	if (conn->hcon == NULL || conn->hcon->hdev == NULL)
+		return;
+
 	if (lmp_no_flush_capable(conn->hcon->hdev))
 		flags = ACL_START_NO_FLUSH;
 	else
 		flags = ACL_START;
 
-	bt_cb(skb)->force_active = BT_POWER_FORCE_ACTIVE_ON;
-	skb->priority = HCI_PRIO_MAX;
+	bt_cb(skb)->force_active = 1;
 
-	hci_send_acl(conn->hchan, skb, flags);
+	hci_send_acl(conn->hcon, NULL, skb, flags);
 }
 
-static void l2cap_do_send(struct l2cap_chan *chan, struct sk_buff *skb)
+static inline int __l2cap_no_conn_pending(struct sock *sk)
 {
-	struct hci_conn *hcon = chan->conn->hcon;
-	u16 flags;
-
-	BT_DBG("chan %p, skb %p len %d priority %u", chan, skb, skb->len,
-							skb->priority);
-
-	if (!test_bit(FLAG_FLUSHABLE, &chan->flags) &&
-					lmp_no_flush_capable(hcon->hdev))
-		flags = ACL_START_NO_FLUSH;
-	else
-		flags = ACL_START;
-
-	bt_cb(skb)->force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);
-	hci_send_acl(chan->conn->hchan, skb, flags);
+	return !(l2cap_pi(sk)->conf_state & L2CAP_CONF_CONNECT_PEND);
 }
 
-static inline void l2cap_send_sframe(struct l2cap_chan *chan, u32 control)
+static void l2cap_send_conn_req(struct sock *sk)
 {
-	struct sk_buff *skb;
-	struct l2cap_hdr *lh;
-	struct l2cap_conn *conn = chan->conn;
-	int count, hlen;
-
-	if (chan->state != BT_CONNECTED)
-		return;
-
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		hlen = L2CAP_EXT_HDR_SIZE;
-	else
-		hlen = L2CAP_ENH_HDR_SIZE;
-
-	if (chan->fcs == L2CAP_FCS_CRC16)
-		hlen += L2CAP_FCS_SIZE;
-
-	BT_DBG("chan %p, control 0x%8.8x", chan, control);
-
-	count = min_t(unsigned int, conn->mtu, hlen);
-
-	control |= __set_sframe(chan);
-
-	if (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))
-		control |= __set_ctrl_final(chan);
+	struct l2cap_conn_req req;
+	req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
+	req.psm  = l2cap_pi(sk)->psm;
 
-	if (test_and_clear_bit(CONN_SEND_PBIT, &chan->conn_state))
-		control |= __set_ctrl_poll(chan);
+	l2cap_pi(sk)->ident = l2cap_get_ident(l2cap_pi(sk)->conn);
 
-	skb = bt_skb_alloc(count, GFP_ATOMIC);
-	if (!skb)
-		return;
-
-	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->len = cpu_to_le16(hlen - L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(chan->dcid);
-
-	__put_control(chan, control, skb_put(skb, __ctrl_size(chan)));
-
-	if (chan->fcs == L2CAP_FCS_CRC16) {
-		u16 fcs = crc16(0, (u8 *)lh, count - L2CAP_FCS_SIZE);
-		put_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));
-	}
-
-	skb->priority = HCI_PRIO_MAX;
-	l2cap_do_send(chan, skb);
+	l2cap_send_cmd(l2cap_pi(sk)->conn, l2cap_pi(sk)->ident,
+			L2CAP_CONN_REQ, sizeof(req), &req);
 }
 
-static inline void l2cap_send_rr_or_rnr(struct l2cap_chan *chan, u32 control)
+static void l2cap_send_create_chan_req(struct sock *sk, u8 amp_id)
 {
-	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
-		control |= __set_ctrl_super(chan, L2CAP_SUPER_RNR);
-		set_bit(CONN_RNR_SENT, &chan->conn_state);
-	} else
-		control |= __set_ctrl_super(chan, L2CAP_SUPER_RR);
-
-	control |= __set_reqseq(chan, chan->buffer_seq);
+	struct l2cap_create_chan_req req;
+	req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
+	req.psm  = l2cap_pi(sk)->psm;
+	req.amp_id = amp_id;
 
-	l2cap_send_sframe(chan, control);
-}
+	l2cap_pi(sk)->conf_state |= L2CAP_CONF_LOCKSTEP;
+	l2cap_pi(sk)->ident = l2cap_get_ident(l2cap_pi(sk)->conn);
 
-static inline int __l2cap_no_conn_pending(struct l2cap_chan *chan)
-{
-	return !test_bit(CONF_CONNECT_PEND, &chan->conf_state);
+	l2cap_send_cmd(l2cap_pi(sk)->conn, l2cap_pi(sk)->ident,
+			L2CAP_CREATE_CHAN_REQ, sizeof(req), &req);
 }
 
-static void l2cap_do_start(struct l2cap_chan *chan)
+static void l2cap_do_start(struct sock *sk)
 {
-	struct l2cap_conn *conn = chan->conn;
+	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
 
 	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) {
 		if (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE))
 			return;
 
-		if (l2cap_chan_check_security(chan) &&
-				__l2cap_no_conn_pending(chan)) {
-			struct l2cap_conn_req req;
-			req.scid = cpu_to_le16(chan->scid);
-			req.psm  = chan->psm;
+		if (l2cap_check_security(sk) && __l2cap_no_conn_pending(sk)) {
+			l2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;
 
-			chan->ident = l2cap_get_ident(conn);
-			set_bit(CONF_CONNECT_PEND, &chan->conf_state);
-
-			l2cap_send_cmd(conn, chan->ident, L2CAP_CONN_REQ,
-							sizeof(req), &req);
+			if (l2cap_pi(sk)->amp_pref ==
+					BT_AMP_POLICY_PREFER_AMP &&
+					enable_hs &&
+					conn->fc_mask & L2CAP_FC_A2MP)
+				amp_create_physical(conn, sk);
+			else
+				l2cap_send_conn_req(sk);
 		}
 	} else {
 		struct l2cap_info_req req;
@@ -705,7 +781,7 @@ static void l2cap_do_start(struct l2cap_chan *chan)
 		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;
 		conn->info_ident = l2cap_get_ident(conn);
 
-		schedule_delayed_work(&conn->info_timer,
+		mod_timer(&conn->info_timer, jiffies +
 					msecs_to_jiffies(L2CAP_INFO_TIMEOUT));
 
 		l2cap_send_cmd(conn, conn->info_ident,
@@ -729,85 +805,91 @@ static inline int l2cap_mode_supported(__u8 mode, __u32 feat_mask)
 	}
 }
 
-static void l2cap_send_disconn_req(struct l2cap_conn *conn, struct l2cap_chan *chan, int err)
+void l2cap_send_disconn_req(struct l2cap_conn *conn, struct sock *sk, int err)
 {
-	struct sock *sk;
 	struct l2cap_disconn_req req;
 
 	if (!conn)
 		return;
 
-	sk = chan->sk;
+	sk->sk_send_head = NULL;
+	skb_queue_purge(TX_QUEUE(sk));
+
+	if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM) {
+		skb_queue_purge(SREJ_QUEUE(sk));
 
-	if (chan->mode == L2CAP_MODE_ERTM) {
-		__clear_retrans_timer(chan);
-		__clear_monitor_timer(chan);
-		__clear_ack_timer(chan);
+		__cancel_delayed_work(&l2cap_pi(sk)->ack_work);
+		__cancel_delayed_work(&l2cap_pi(sk)->retrans_work);
+		__cancel_delayed_work(&l2cap_pi(sk)->monitor_work);
 	}
 
-	req.dcid = cpu_to_le16(chan->dcid);
-	req.scid = cpu_to_le16(chan->scid);
+	req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);
+	req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
 	l2cap_send_cmd(conn, l2cap_get_ident(conn),
 			L2CAP_DISCONN_REQ, sizeof(req), &req);
 
-	l2cap_state_change(chan, BT_DISCONN);
+	sk->sk_state = BT_DISCONN;
 	sk->sk_err = err;
 }
 
 /* ---- L2CAP connections ---- */
 static void l2cap_conn_start(struct l2cap_conn *conn)
 {
-	struct l2cap_chan *chan;
+	struct l2cap_chan_list *l = &conn->chan_list;
+	struct sock_del_list del, *tmp1, *tmp2;
+	struct sock *sk;
 
 	BT_DBG("conn %p", conn);
 
-	rcu_read_lock();
+	INIT_LIST_HEAD(&del.list);
 
-	list_for_each_entry_rcu(chan, &conn->chan_l, list) {
-		struct sock *sk = chan->sk;
+	read_lock(&l->lock);
 
+	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
 		bh_lock_sock(sk);
 
-		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {
+		if (sk->sk_type != SOCK_SEQPACKET &&
+				sk->sk_type != SOCK_STREAM) {
 			bh_unlock_sock(sk);
 			continue;
 		}
 
-		if (chan->state == BT_CONNECT) {
-			struct l2cap_conn_req req;
-
-			if (!l2cap_chan_check_security(chan) ||
-					!__l2cap_no_conn_pending(chan)) {
+		if (sk->sk_state == BT_CONNECT) {
+			if (!l2cap_check_security(sk) ||
+					!__l2cap_no_conn_pending(sk)) {
 				bh_unlock_sock(sk);
 				continue;
 			}
 
-			if (!l2cap_mode_supported(chan->mode, conn->feat_mask)
-					&& test_bit(CONF_STATE2_DEVICE,
-					&chan->conf_state)) {
-				/* l2cap_chan_close() calls list_del(chan)
-				 * so release the lock */
-				l2cap_chan_close(chan, ECONNRESET);
+			if (!l2cap_mode_supported(l2cap_pi(sk)->mode,
+					conn->feat_mask)
+					&& l2cap_pi(sk)->conf_state &
+					L2CAP_CONF_STATE2_DEVICE) {
+				tmp1 = kzalloc(sizeof(struct sock_del_list),
+						GFP_ATOMIC);
+				tmp1->sk = sk;
+				list_add_tail(&tmp1->list, &del.list);
 				bh_unlock_sock(sk);
 				continue;
 			}
 
-			req.scid = cpu_to_le16(chan->scid);
-			req.psm  = chan->psm;
+			l2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;
 
-			chan->ident = l2cap_get_ident(conn);
-			set_bit(CONF_CONNECT_PEND, &chan->conf_state);
-
-			l2cap_send_cmd(conn, chan->ident, L2CAP_CONN_REQ,
-							sizeof(req), &req);
+			if (l2cap_pi(sk)->amp_pref ==
+					BT_AMP_POLICY_PREFER_AMP &&
+					enable_hs &&
+					conn->fc_mask & L2CAP_FC_A2MP)
+				amp_create_physical(conn, sk);
+			else
+				l2cap_send_conn_req(sk);
 
-		} else if (chan->state == BT_CONNECT2) {
+		} else if (sk->sk_state == BT_CONNECT2) {
 			struct l2cap_conn_rsp rsp;
 			char buf[128];
-			rsp.scid = cpu_to_le16(chan->dcid);
-			rsp.dcid = cpu_to_le16(chan->scid);
+			rsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);
+			rsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);
 
-			if (l2cap_chan_check_security(chan)) {
+			if (l2cap_check_security(sk)) {
 				if (bt_sk(sk)->defer_setup) {
 					struct sock *parent = bt_sk(sk)->parent;
 					rsp.result = cpu_to_le16(L2CAP_CR_PEND);
@@ -816,7 +898,7 @@ static void l2cap_conn_start(struct l2cap_conn *conn)
 						parent->sk_data_ready(parent, 0);
 
 				} else {
-					l2cap_state_change(chan, BT_CONFIG);
+					sk->sk_state = BT_CONFIG;
 					rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
 					rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
 				}
@@ -825,76 +907,124 @@ static void l2cap_conn_start(struct l2cap_conn *conn)
 				rsp.status = cpu_to_le16(L2CAP_CS_AUTHEN_PEND);
 			}
 
-			l2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,
-							sizeof(rsp), &rsp);
+			if (rsp.result == cpu_to_le16(L2CAP_CR_SUCCESS) &&
+					l2cap_pi(sk)->amp_id) {
+				amp_accept_physical(conn,
+						l2cap_pi(sk)->amp_id, sk);
+				bh_unlock_sock(sk);
+				continue;
+			}
 
-			if (test_bit(CONF_REQ_SENT, &chan->conf_state) ||
+			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
+					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
+
+			if (l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT ||
 					rsp.result != L2CAP_CR_SUCCESS) {
 				bh_unlock_sock(sk);
 				continue;
 			}
 
-			set_bit(CONF_REQ_SENT, &chan->conf_state);
+			l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
 			l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-						l2cap_build_conf_req(chan, buf), buf);
-			chan->num_conf_req++;
+						l2cap_build_conf_req(sk, buf), buf);
+			l2cap_pi(sk)->num_conf_req++;
 		}
 
 		bh_unlock_sock(sk);
 	}
 
-	rcu_read_unlock();
+	read_unlock(&l->lock);
+
+	list_for_each_entry_safe(tmp1, tmp2, &del.list, list) {
+		bh_lock_sock(tmp1->sk);
+		__l2cap_sock_close(tmp1->sk, ECONNRESET);
+		bh_unlock_sock(tmp1->sk);
+		list_del(&tmp1->list);
+		kfree(tmp1);
+	}
+}
+
+/* Find socket with fixed cid with given source and destination bdaddrs.
+ * Direction of the req/rsp must match.
+ */
+struct sock *l2cap_find_sock_by_fixed_cid_and_dir(__le16 cid, bdaddr_t *src,
+						bdaddr_t *dst, int incoming)
+{
+	struct sock *sk = NULL, *sk1 = NULL;
+	struct hlist_node *node;
+
+	BT_DBG(" %d", incoming);
+
+	read_lock(&l2cap_sk_list.lock);
+
+	sk_for_each(sk, node, &l2cap_sk_list.head) {
+
+		if (incoming && !l2cap_pi(sk)->incoming)
+			continue;
+
+		if (!incoming && l2cap_pi(sk)->incoming)
+			continue;
+
+		if (l2cap_pi(sk)->scid == cid && !bacmp(&bt_sk(sk)->dst, dst)) {
+			/* Exact match. */
+			if (!bacmp(&bt_sk(sk)->src, src))
+				break;
+
+			/* Closest match */
+			if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))
+				sk1 = sk;
+		}
+	}
+
+	read_unlock(&l2cap_sk_list.lock);
+
+	return node ? sk : sk1;
 }
 
 /* Find socket with cid and source bdaddr.
  * Returns closest match, locked.
  */
-static struct l2cap_chan *l2cap_global_chan_by_scid(int state, __le16 cid, bdaddr_t *src)
+static struct sock *l2cap_get_sock_by_scid(int state, __le16 cid, bdaddr_t *src)
 {
-	struct l2cap_chan *c, *c1 = NULL;
+	struct sock *sk = NULL, *sk1 = NULL;
+	struct hlist_node *node;
 
-	read_lock(&chan_list_lock);
+	read_lock(&l2cap_sk_list.lock);
 
-	list_for_each_entry(c, &chan_list, global_l) {
-		struct sock *sk = c->sk;
-
-		if (state && c->state != state)
+	sk_for_each(sk, node, &l2cap_sk_list.head) {
+		if (state && sk->sk_state != state)
 			continue;
 
-		if (c->scid == cid) {
+		if (l2cap_pi(sk)->scid == cid) {
 			/* Exact match. */
-			if (!bacmp(&bt_sk(sk)->src, src)) {
-				read_unlock(&chan_list_lock);
-				return c;
-			}
+			if (!bacmp(&bt_sk(sk)->src, src))
+				break;
 
 			/* Closest match */
 			if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))
-				c1 = c;
+				sk1 = sk;
 		}
 	}
 
-	read_unlock(&chan_list_lock);
+	read_unlock(&l2cap_sk_list.lock);
 
-	return c1;
+	return node ? sk : sk1;
 }
 
 static void l2cap_le_conn_ready(struct l2cap_conn *conn)
 {
-	struct sock *parent, *sk;
-	struct l2cap_chan *chan, *pchan;
+	struct l2cap_chan_list *list = &conn->chan_list;
+	struct sock *parent, *uninitialized_var(sk);
 
 	BT_DBG("");
 
 	/* Check if we have socket listening on cid */
-	pchan = l2cap_global_chan_by_scid(BT_LISTEN, L2CAP_CID_LE_DATA,
+	parent = l2cap_get_sock_by_scid(BT_LISTEN, L2CAP_CID_LE_DATA,
 							conn->src);
-	if (!pchan)
+	if (!parent)
 		return;
 
-	parent = pchan->sk;
-
-	lock_sock(parent);
+	bh_lock_sock(parent);
 
 	/* Check for backlog size */
 	if (sk_acceptq_is_full(parent)) {
@@ -902,107 +1032,101 @@ static void l2cap_le_conn_ready(struct l2cap_conn *conn)
 		goto clean;
 	}
 
-	chan = pchan->ops->new_connection(pchan->data);
-	if (!chan)
+	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP, GFP_ATOMIC);
+	if (!sk)
 		goto clean;
 
-	sk = chan->sk;
+	write_lock_bh(&list->lock);
 
 	hci_conn_hold(conn->hcon);
 
+	l2cap_sock_init(sk, parent);
 	bacpy(&bt_sk(sk)->src, conn->src);
 	bacpy(&bt_sk(sk)->dst, conn->dst);
+	l2cap_pi(sk)->incoming = 1;
 
 	bt_accept_enqueue(parent, sk);
 
-	l2cap_chan_add(conn, chan);
+	__l2cap_chan_add(conn, sk);
 
-	__set_chan_timer(chan, sk->sk_sndtimeo);
-
-	l2cap_state_change(chan, BT_CONNECTED);
+	sk->sk_state = BT_CONNECTED;
 	parent->sk_data_ready(parent, 0);
 
+	write_unlock_bh(&list->lock);
+
 clean:
-	release_sock(parent);
+	bh_unlock_sock(parent);
 }
 
-static void l2cap_chan_ready(struct sock *sk)
+static void l2cap_conn_ready(struct l2cap_conn *conn)
 {
-	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
-	struct sock *parent = bt_sk(sk)->parent;
+	struct l2cap_chan_list *l = &conn->chan_list;
+	struct sock *sk;
 
-	BT_DBG("sk %p, parent %p", sk, parent);
+	BT_DBG("conn %p", conn);
 
-	chan->conf_state = 0;
-	__clear_chan_timer(chan);
+	if (!conn->hcon->out && conn->hcon->type == LE_LINK)
+		l2cap_le_conn_ready(conn);
 
-	l2cap_state_change(chan, BT_CONNECTED);
-	sk->sk_state_change(sk);
+	read_lock(&l->lock);
 
-	if (parent)
-		parent->sk_data_ready(parent, 0);
-}
-
-static void l2cap_conn_ready(struct l2cap_conn *conn)
-{
-	struct l2cap_chan *chan;
-
-	BT_DBG("conn %p", conn);
-
-	if (!conn->hcon->out && conn->hcon->type == LE_LINK)
-		l2cap_le_conn_ready(conn);
-
-	if (conn->hcon->out && conn->hcon->type == LE_LINK)
-		smp_conn_security(conn, conn->hcon->pending_sec_level);
+	if (l->head) {
+		for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
+			bh_lock_sock(sk);
 
-	rcu_read_lock();
+			if (conn->hcon->type == LE_LINK) {
+				u8 sec_level = l2cap_pi(sk)->sec_level;
+				u8 pending_sec = conn->hcon->pending_sec_level;
 
-	list_for_each_entry_rcu(chan, &conn->chan_l, list) {
-		struct sock *sk = chan->sk;
+				if (pending_sec > sec_level)
+					sec_level = pending_sec;
 
-		bh_lock_sock(sk);
-
-		if (conn->hcon->type == LE_LINK) {
-			if (smp_conn_security(conn, chan->sec_level))
-				l2cap_chan_ready(sk);
+				if (smp_conn_security(conn, sec_level))
+					l2cap_chan_ready(sk);
 
-		} else if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {
-			__clear_chan_timer(chan);
-			l2cap_state_change(chan, BT_CONNECTED);
-			sk->sk_state_change(sk);
+				hci_conn_put(conn->hcon);
 
-		} else if (chan->state == BT_CONNECT)
-			l2cap_do_start(chan);
+			} else if (sk->sk_type != SOCK_SEQPACKET &&
+					sk->sk_type != SOCK_STREAM) {
+				l2cap_sock_clear_timer(sk);
+				sk->sk_state = BT_CONNECTED;
+				sk->sk_state_change(sk);
+			} else if (sk->sk_state == BT_CONNECT)
+				l2cap_do_start(sk);
 
-		bh_unlock_sock(sk);
+			bh_unlock_sock(sk);
+		}
+	} else if (conn->hcon->type == LE_LINK) {
+		smp_conn_security(conn, BT_SECURITY_HIGH);
 	}
 
-	rcu_read_unlock();
+	read_unlock(&l->lock);
+
+	if (conn->hcon->out && conn->hcon->type == LE_LINK)
+		l2cap_le_conn_ready(conn);
 }
 
 /* Notify sockets that we cannot guaranty reliability anymore */
 static void l2cap_conn_unreliable(struct l2cap_conn *conn, int err)
 {
-	struct l2cap_chan *chan;
+	struct l2cap_chan_list *l = &conn->chan_list;
+	struct sock *sk;
 
 	BT_DBG("conn %p", conn);
 
-	rcu_read_lock();
-
-	list_for_each_entry_rcu(chan, &conn->chan_l, list) {
-		struct sock *sk = chan->sk;
+	read_lock(&l->lock);
 
-		if (test_bit(FLAG_FORCE_RELIABLE, &chan->flags))
+	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
+		if (l2cap_pi(sk)->force_reliable)
 			sk->sk_err = err;
 	}
 
-	rcu_read_unlock();
+	read_unlock(&l->lock);
 }
 
-static void l2cap_info_timeout(struct work_struct *work)
+static void l2cap_info_timeout(unsigned long arg)
 {
-	struct l2cap_conn *conn = container_of(work, struct l2cap_conn,
-							info_timer.work);
+	struct l2cap_conn *conn = (void *) arg;
 
 	conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
 	conn->info_ident = 0;
@@ -1010,73 +1134,21 @@ static void l2cap_info_timeout(struct work_struct *work)
 	l2cap_conn_start(conn);
 }
 
-static void l2cap_conn_del(struct hci_conn *hcon, int err)
-{
-	struct l2cap_conn *conn = hcon->l2cap_data;
-	struct l2cap_chan *chan, *l;
-	struct sock *sk;
-
-	if (!conn)
-		return;
-
-	BT_DBG("hcon %p conn %p, err %d", hcon, conn, err);
-
-	kfree_skb(conn->rx_skb);
-
-	/* Kill channels */
-	list_for_each_entry_safe(chan, l, &conn->chan_l, list) {
-		sk = chan->sk;
-		lock_sock(sk);
-		l2cap_chan_del(chan, err);
-		release_sock(sk);
-		chan->ops->close(chan->data);
-	}
-
-	hci_chan_del(conn->hchan);
-
-	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)
-		cancel_delayed_work_sync(&conn->info_timer);
-
-	if (test_and_clear_bit(HCI_CONN_LE_SMP_PEND, &hcon->pend)) {
-		cancel_delayed_work_sync(&conn->security_timer);
-		smp_chan_destroy(conn);
-	}
-
-	hcon->l2cap_data = NULL;
-	kfree(conn);
-}
-
-static void security_timeout(struct work_struct *work)
-{
-	struct l2cap_conn *conn = container_of(work, struct l2cap_conn,
-						security_timer.work);
-
-	l2cap_conn_del(conn->hcon, ETIMEDOUT);
-}
-
 static struct l2cap_conn *l2cap_conn_add(struct hci_conn *hcon, u8 status)
 {
 	struct l2cap_conn *conn = hcon->l2cap_data;
-	struct hci_chan *hchan;
 
 	if (conn || status)
 		return conn;
 
-	hchan = hci_chan_create(hcon);
-	if (!hchan)
-		return NULL;
-
 	conn = kzalloc(sizeof(struct l2cap_conn), GFP_ATOMIC);
-	if (!conn) {
-		hci_chan_del(hchan);
+	if (!conn)
 		return NULL;
-	}
 
 	hcon->l2cap_data = conn;
 	conn->hcon = hcon;
-	conn->hchan = hchan;
 
-	BT_DBG("hcon %p conn %p hchan %p", hcon, conn, hchan);
+	BT_DBG("hcon %p conn %p", hcon, conn);
 
 	if (hcon->hdev->le_mtu && hcon->type == LE_LINK)
 		conn->mtu = hcon->hdev->le_mtu;
@@ -1089,58 +1161,112 @@ static struct l2cap_conn *l2cap_conn_add(struct hci_conn *hcon, u8 status)
 	conn->feat_mask = 0;
 
 	spin_lock_init(&conn->lock);
-
-	INIT_LIST_HEAD(&conn->chan_l);
+	rwlock_init(&conn->chan_list.lock);
 
 	if (hcon->type == LE_LINK)
-		INIT_DELAYED_WORK(&conn->security_timer, security_timeout);
+		setup_timer(&hcon->smp_timer, smp_timeout,
+						(unsigned long) conn);
 	else
-		INIT_DELAYED_WORK(&conn->info_timer, l2cap_info_timeout);
+		setup_timer(&conn->info_timer, l2cap_info_timeout,
+						(unsigned long) conn);
 
-	conn->disc_reason = HCI_ERROR_REMOTE_USER_TERM;
+	conn->disc_reason = 0x13;
 
 	return conn;
 }
 
+static void l2cap_conn_del(struct hci_conn *hcon, int err, u8 is_process)
+{
+	struct l2cap_conn *conn = hcon->l2cap_data;
+	struct sock *sk;
+	struct sock *next;
+
+	if (!conn)
+		return;
+
+	BT_DBG("hcon %p conn %p, err %d", hcon, conn, err);
+
+	if ((conn->hcon == hcon) && (conn->rx_skb))
+		kfree_skb(conn->rx_skb);
+
+	BT_DBG("conn->hcon %p", conn->hcon);
+
+	/* Kill channels */
+	for (sk = conn->chan_list.head; sk; ) {
+		BT_DBG("ampcon %p", l2cap_pi(sk)->ampcon);
+		if ((conn->hcon == hcon) || (l2cap_pi(sk)->ampcon == hcon)) {
+			next = l2cap_pi(sk)->next_c;
+			if (is_process)
+				lock_sock(sk);
+			else
+				bh_lock_sock(sk);
+			l2cap_chan_del(sk, err);
+			if (is_process)
+				release_sock(sk);
+			else
+				bh_unlock_sock(sk);
+			l2cap_sock_kill(sk);
+			sk = next;
+		} else
+			sk = l2cap_pi(sk)->next_c;
+	}
+
+	if (conn->hcon == hcon) {
+		if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)
+			del_timer_sync(&conn->info_timer);
+
+		hcon->l2cap_data = NULL;
+
+		kfree(conn);
+	}
+	att_chn_params.conn = NULL;
+	BT_DBG("att_chn_params.conn set to NULL");
+}
+
+static inline void l2cap_chan_add(struct l2cap_conn *conn, struct sock *sk)
+{
+	struct l2cap_chan_list *l = &conn->chan_list;
+	write_lock_bh(&l->lock);
+	__l2cap_chan_add(conn, sk);
+	write_unlock_bh(&l->lock);
+}
+
 /* ---- Socket interface ---- */
 
 /* Find socket with psm and source bdaddr.
  * Returns closest match.
  */
-static struct l2cap_chan *l2cap_global_chan_by_psm(int state, __le16 psm, bdaddr_t *src)
+static struct sock *l2cap_get_sock_by_psm(int state, __le16 psm, bdaddr_t *src)
 {
-	struct l2cap_chan *c, *c1 = NULL;
-
-	read_lock(&chan_list_lock);
+	struct sock *sk = NULL, *sk1 = NULL;
+	struct hlist_node *node;
 
-	list_for_each_entry(c, &chan_list, global_l) {
-		struct sock *sk = c->sk;
+	read_lock(&l2cap_sk_list.lock);
 
-		if (state && c->state != state)
+	sk_for_each(sk, node, &l2cap_sk_list.head) {
+		if (state && sk->sk_state != state)
 			continue;
 
-		if (c->psm == psm) {
+		if (l2cap_pi(sk)->psm == psm) {
 			/* Exact match. */
-			if (!bacmp(&bt_sk(sk)->src, src)) {
-				read_unlock(&chan_list_lock);
-				return c;
-			}
+			if (!bacmp(&bt_sk(sk)->src, src))
+				break;
 
 			/* Closest match */
 			if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))
-				c1 = c;
+				sk1 = sk;
 		}
 	}
 
-	read_unlock(&chan_list_lock);
+	read_unlock(&l2cap_sk_list.lock);
 
-	return c1;
+	return node ? sk : sk1;
 }
 
-int l2cap_chan_connect(struct l2cap_chan *chan, __le16 psm, u16 cid, bdaddr_t *dst)
+int l2cap_do_connect(struct sock *sk)
 {
-	struct sock *sk = chan->sk;
 	bdaddr_t *src = &bt_sk(sk)->src;
+	bdaddr_t *dst = &bt_sk(sk)->dst;
 	struct l2cap_conn *conn;
 	struct hci_conn *hcon;
 	struct hci_dev *hdev;
@@ -1148,125 +1274,104 @@ int l2cap_chan_connect(struct l2cap_chan *chan, __le16 psm, u16 cid, bdaddr_t *d
 	int err;
 
 	BT_DBG("%s -> %s psm 0x%2.2x", batostr(src), batostr(dst),
-							chan->psm);
+							l2cap_pi(sk)->psm);
 
 	hdev = hci_get_route(dst, src);
 	if (!hdev)
 		return -EHOSTUNREACH;
 
-	hci_dev_lock(hdev);
-
-	lock_sock(sk);
-
-	/* PSM must be odd and lsb of upper byte must be 0 */
-	if ((__le16_to_cpu(psm) & 0x0101) != 0x0001 && !cid &&
-					chan->chan_type != L2CAP_CHAN_RAW) {
-		err = -EINVAL;
-		goto done;
-	}
-
-	if (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED && !(psm || cid)) {
-		err = -EINVAL;
-		goto done;
-	}
-
-	switch (chan->mode) {
-	case L2CAP_MODE_BASIC:
-		break;
-	case L2CAP_MODE_ERTM:
-	case L2CAP_MODE_STREAMING:
-		if (!disable_ertm)
-			break;
-		/* fall through */
-	default:
-		err = -ENOTSUPP;
-		goto done;
-	}
-
-	switch (sk->sk_state) {
-	case BT_CONNECT:
-	case BT_CONNECT2:
-	case BT_CONFIG:
-		/* Already connecting */
-		err = 0;
-		goto done;
-
-	case BT_CONNECTED:
-		/* Already connected */
-		err = -EISCONN;
-		goto done;
-
-	case BT_OPEN:
-	case BT_BOUND:
-		/* Can connect */
-		break;
-
-	default:
-		err = -EBADFD;
-		goto done;
-	}
+	hci_dev_lock_bh(hdev);
 
-	/* Set destination address and psm */
-	bacpy(&bt_sk(sk)->dst, dst);
-	chan->psm = psm;
-	chan->dcid = cid;
+	auth_type = l2cap_get_auth_type(sk);
 
-	auth_type = l2cap_get_auth_type(chan);
+	if (l2cap_pi(sk)->fixed_channel) {
+		/* Fixed channels piggyback on existing ACL connections */
+		hcon = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
+		if (!hcon || !hcon->l2cap_data) {
+			err = -ENOTCONN;
+			goto done;
+		}
 
-	if (chan->dcid == L2CAP_CID_LE_DATA)
-		hcon = hci_connect(hdev, LE_LINK, 0, dst,
-					chan->sec_level, auth_type);
-	else
-		hcon = hci_connect(hdev, ACL_LINK, 0, dst,
-					chan->sec_level, auth_type);
+		conn = hcon->l2cap_data;
+	} else {
+		if (l2cap_pi(sk)->dcid == L2CAP_CID_LE_DATA)
+			hcon = hci_le_connect(hdev, 0, dst,
+					l2cap_pi(sk)->sec_level, auth_type,
+					&bt_sk(sk)->le_params);
+		else
+			hcon = hci_connect(hdev, ACL_LINK, 0, dst,
+					l2cap_pi(sk)->sec_level, auth_type);
 
-	if (IS_ERR(hcon)) {
-		err = PTR_ERR(hcon);
-		goto done;
-	}
+		if (IS_ERR(hcon)) {
+			err = PTR_ERR(hcon);
+			goto done;
+		}
 
-	conn = l2cap_conn_add(hcon, 0);
-	if (!conn) {
-		hci_conn_put(hcon);
-		err = -ENOMEM;
-		goto done;
+		conn = l2cap_conn_add(hcon, 0);
+		if (!conn) {
+			hci_conn_put(hcon);
+			err = -ENOMEM;
+			goto done;
+		}
 	}
 
 	/* Update source addr of the socket */
 	bacpy(src, conn->src);
 
-	l2cap_chan_add(conn, chan);
+	l2cap_chan_add(conn, sk);
 
-	l2cap_state_change(chan, BT_CONNECT);
-	__set_chan_timer(chan, sk->sk_sndtimeo);
-
-	if (hcon->state == BT_CONNECTED) {
-		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {
-			__clear_chan_timer(chan);
-			if (l2cap_chan_check_security(chan))
-				l2cap_state_change(chan, BT_CONNECTED);
+	if ((l2cap_pi(sk)->fixed_channel) ||
+			(l2cap_pi(sk)->dcid == L2CAP_CID_LE_DATA &&
+				hcon->state == BT_CONNECTED)) {
+		sk->sk_state = BT_CONNECTED;
+		sk->sk_state_change(sk);
+	} else {
+		sk->sk_state = BT_CONNECT;
+		/* If we have valid LE Params, let timeout override default */
+		if (l2cap_pi(sk)->dcid == L2CAP_CID_LE_DATA &&
+			l2cap_sock_le_params_valid(&bt_sk(sk)->le_params)) {
+			u16 timeout = bt_sk(sk)->le_params.conn_timeout;
+
+			if (timeout)
+				l2cap_sock_set_timer(sk,
+						msecs_to_jiffies(timeout*1000));
 		} else
-			l2cap_do_start(chan);
+			l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
+
+		sk->sk_state_change(sk);
+
+		if (hcon->state == BT_CONNECTED) {
+			if (sk->sk_type != SOCK_SEQPACKET &&
+				sk->sk_type != SOCK_STREAM) {
+				l2cap_sock_clear_timer(sk);
+				if (l2cap_check_security(sk)) {
+					sk->sk_state = BT_CONNECTED;
+					sk->sk_state_change(sk);
+				}
+			} else
+				l2cap_do_start(sk);
+		}
 	}
 
 	err = 0;
 
 done:
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 	return err;
 }
 
 int __l2cap_wait_ack(struct sock *sk)
 {
-	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	DECLARE_WAITQUEUE(wait, current);
 	int err = 0;
 	int timeo = HZ/5;
 
 	add_wait_queue(sk_sleep(sk), &wait);
-	set_current_state(TASK_INTERRUPTIBLE);
-	while (chan->unacked_frames > 0 && chan->conn) {
+	while (l2cap_pi(sk)->unacked_frames > 0 && l2cap_pi(sk)->conn &&
+		atomic_read(&l2cap_pi(sk)->ertm_queued)) {
+		set_current_state(TASK_INTERRUPTIBLE);
+
 		if (!timeo)
 			timeo = HZ/5;
 
@@ -1278,7 +1383,6 @@ int __l2cap_wait_ack(struct sock *sk)
 		release_sock(sk);
 		timeo = schedule_timeout(timeo);
 		lock_sock(sk);
-		set_current_state(TASK_INTERRUPTIBLE);
 
 		err = sock_error(sk);
 		if (err)
@@ -1289,291 +1393,340 @@ int __l2cap_wait_ack(struct sock *sk)
 	return err;
 }
 
-static void l2cap_monitor_timeout(struct work_struct *work)
+static void l2cap_ertm_tx_worker(struct work_struct *work)
 {
-	struct l2cap_chan *chan = container_of(work, struct l2cap_chan,
-							monitor_timer.work);
-	struct sock *sk = chan->sk;
-
-	BT_DBG("chan %p", chan);
+	struct l2cap_pinfo *pi =
+		container_of(work, struct l2cap_pinfo, tx_work);
+	struct sock *sk = (struct sock *)pi;
+	BT_DBG("%p", pi);
 
 	lock_sock(sk);
-	if (chan->retry_count >= chan->remote_max_tx) {
-		l2cap_send_disconn_req(chan->conn, chan, ECONNABORTED);
-		release_sock(sk);
-		return;
-	}
-
-	chan->retry_count++;
-	__set_monitor_timer(chan);
-
-	l2cap_send_rr_or_rnr(chan, L2CAP_CTRL_POLL);
+	l2cap_ertm_send(sk);
 	release_sock(sk);
+	sock_put(sk);
 }
 
-static void l2cap_retrans_timeout(struct work_struct *work)
+static void l2cap_skb_destructor(struct sk_buff *skb)
 {
-	struct l2cap_chan *chan = container_of(work, struct l2cap_chan,
-							retrans_timer.work);
-	struct sock *sk = chan->sk;
-
-	BT_DBG("chan %p", chan);
-
-	lock_sock(sk);
-	chan->retry_count = 1;
-	__set_monitor_timer(chan);
+	struct sock *sk = skb->sk;
+	int queued;
+	int keep_sk = 0;
 
-	set_bit(CONN_WAIT_F, &chan->conn_state);
+	queued = atomic_sub_return(1, &l2cap_pi(sk)->ertm_queued);
+	if (queued < L2CAP_MIN_ERTM_QUEUED)
+		keep_sk = queue_work(_l2cap_wq, &l2cap_pi(sk)->tx_work);
 
-	l2cap_send_rr_or_rnr(chan, L2CAP_CTRL_POLL);
-	release_sock(sk);
+	if (!keep_sk)
+		sock_put(sk);
 }
 
-static void l2cap_drop_acked_frames(struct l2cap_chan *chan)
+void l2cap_do_send(struct sock *sk, struct sk_buff *skb)
 {
-	struct sk_buff *skb;
-
-	while ((skb = skb_peek(&chan->tx_q)) &&
-			chan->unacked_frames) {
-		if (bt_cb(skb)->tx_seq == chan->expected_ack_seq)
-			break;
-
-		skb = skb_dequeue(&chan->tx_q);
-		kfree_skb(skb);
-
-		chan->unacked_frames--;
-	}
-
-	if (!chan->unacked_frames)
-		__clear_retrans_timer(chan);
-}
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
 
-static void l2cap_streaming_send(struct l2cap_chan *chan)
-{
-	struct sk_buff *skb;
-	u32 control;
-	u16 fcs;
+	BT_DBG("sk %p, skb %p len %d", sk, skb, skb->len);
 
-	while ((skb = skb_dequeue(&chan->tx_q))) {
-		control = __get_control(chan, skb->data + L2CAP_HDR_SIZE);
-		control |= __set_txseq(chan, chan->next_tx_seq);
-		__put_control(chan, control, skb->data + L2CAP_HDR_SIZE);
+	if (pi->ampcon && (pi->amp_move_state == L2CAP_AMP_STATE_STABLE ||
+			pi->amp_move_state == L2CAP_AMP_STATE_WAIT_PREPARE)) {
+		BT_DBG("Sending on AMP connection %p %p",
+			pi->ampcon, pi->ampchan);
+		if (pi->ampchan)
+			hci_send_acl(pi->ampcon, pi->ampchan, skb,
+					ACL_COMPLETE);
+		else
+			kfree_skb(skb);
+	} else {
+		u16 flags;
 
-		if (chan->fcs == L2CAP_FCS_CRC16) {
-			fcs = crc16(0, (u8 *)skb->data,
-						skb->len - L2CAP_FCS_SIZE);
-			put_unaligned_le16(fcs,
-					skb->data + skb->len - L2CAP_FCS_SIZE);
+		if (!(pi->conn)) {
+			kfree_skb(skb);
+			return;
 		}
 
-		l2cap_do_send(chan, skb);
+		bt_cb(skb)->force_active = pi->force_active;
+		BT_DBG("Sending on BR/EDR connection %p", pi->conn->hcon);
 
-		chan->next_tx_seq = __next_seq(chan, chan->next_tx_seq);
+		if (lmp_no_flush_capable(pi->conn->hcon->hdev) &&
+			!l2cap_pi(sk)->flushable)
+			flags = ACL_START_NO_FLUSH;
+		else
+			flags = ACL_START;
+
+		hci_send_acl(pi->conn->hcon, NULL, skb, flags);
 	}
 }
 
-static void l2cap_retransmit_one_frame(struct l2cap_chan *chan, u16 tx_seq)
+int l2cap_ertm_send(struct sock *sk)
 {
 	struct sk_buff *skb, *tx_skb;
-	u16 fcs;
-	u32 control;
-
-	skb = skb_peek(&chan->tx_q);
-	if (!skb)
-		return;
-
-	while (bt_cb(skb)->tx_seq != tx_seq) {
-		if (skb_queue_is_last(&chan->tx_q, skb))
-			return;
-
-		skb = skb_queue_next(&chan->tx_q, skb);
-	}
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	struct bt_l2cap_control *control;
+	int sent = 0;
 
-	if (chan->remote_max_tx &&
-			bt_cb(skb)->retries == chan->remote_max_tx) {
-		l2cap_send_disconn_req(chan->conn, chan, ECONNABORTED);
-		return;
-	}
+	BT_DBG("sk %p", sk);
 
-	tx_skb = skb_clone(skb, GFP_ATOMIC);
-	bt_cb(skb)->retries++;
+	if (sk->sk_state != BT_CONNECTED)
+		return -ENOTCONN;
 
-	control = __get_control(chan, tx_skb->data + L2CAP_HDR_SIZE);
-	control &= __get_sar_mask(chan);
+	if (pi->conn_state & L2CAP_CONN_REMOTE_BUSY)
+		return 0;
 
-	if (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))
-		control |= __set_ctrl_final(chan);
+	if (pi->amp_move_state != L2CAP_AMP_STATE_STABLE &&
+			pi->amp_move_state != L2CAP_AMP_STATE_WAIT_PREPARE)
+		return 0;
 
-	control |= __set_reqseq(chan, chan->buffer_seq);
-	control |= __set_txseq(chan, tx_seq);
+	while (sk->sk_send_head && (pi->unacked_frames < pi->remote_tx_win) &&
+		atomic_read(&pi->ertm_queued) < L2CAP_MAX_ERTM_QUEUED &&
+		(pi->tx_state == L2CAP_ERTM_TX_STATE_XMIT)) {
 
-	__put_control(chan, control, tx_skb->data + L2CAP_HDR_SIZE);
+		skb = sk->sk_send_head;
 
-	if (chan->fcs == L2CAP_FCS_CRC16) {
-		fcs = crc16(0, (u8 *)tx_skb->data,
-						tx_skb->len - L2CAP_FCS_SIZE);
-		put_unaligned_le16(fcs,
-				tx_skb->data + tx_skb->len - L2CAP_FCS_SIZE);
-	}
+		bt_cb(skb)->retries = 1;
+		control = &bt_cb(skb)->control;
 
-	l2cap_do_send(chan, tx_skb);
-}
+		if (pi->conn_state & L2CAP_CONN_SEND_FBIT) {
+			control->final = 1;
+			pi->conn_state &= ~L2CAP_CONN_SEND_FBIT;
+		}
+		control->reqseq = pi->buffer_seq;
+		pi->last_acked_seq = pi->buffer_seq;
+		control->txseq = pi->next_tx_seq;
 
-static int l2cap_ertm_send(struct l2cap_chan *chan)
-{
-	struct sk_buff *skb, *tx_skb;
-	u16 fcs;
-	u32 control;
-	int nsent = 0;
+		if (pi->extended_control) {
+			put_unaligned_le32(__pack_extended_control(control),
+					skb->data + L2CAP_HDR_SIZE);
+		} else {
+			put_unaligned_le16(__pack_enhanced_control(control),
+					skb->data + L2CAP_HDR_SIZE);
+		}
 
-	if (chan->state != BT_CONNECTED)
-		return -ENOTCONN;
+		if (pi->fcs == L2CAP_FCS_CRC16)
+			apply_fcs(skb);
 
-	while ((skb = chan->tx_send_head) && (!l2cap_tx_window_full(chan))) {
+		/* Clone after data has been modified. Data is assumed to be
+		   read-only (for locking purposes) on cloned sk_buffs.
+		 */
+		tx_skb = skb_clone(skb, GFP_ATOMIC);
 
-		if (chan->remote_max_tx &&
-				bt_cb(skb)->retries == chan->remote_max_tx) {
-			l2cap_send_disconn_req(chan->conn, chan, ECONNABORTED);
+		if (!tx_skb)
 			break;
-		}
 
-		tx_skb = skb_clone(skb, GFP_ATOMIC);
+		sock_hold(sk);
+		tx_skb->sk = sk;
+		tx_skb->destructor = l2cap_skb_destructor;
+		atomic_inc(&pi->ertm_queued);
 
-		bt_cb(skb)->retries++;
+		l2cap_ertm_start_retrans_timer(pi);
 
-		control = __get_control(chan, tx_skb->data + L2CAP_HDR_SIZE);
-		control &= __get_sar_mask(chan);
+		pi->next_tx_seq = __next_seq(pi->next_tx_seq, pi);
+		pi->unacked_frames += 1;
+		pi->frames_sent += 1;
+		sent += 1;
 
-		if (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))
-			control |= __set_ctrl_final(chan);
+		if (skb_queue_is_last(TX_QUEUE(sk), skb))
+			sk->sk_send_head = NULL;
+		else
+			sk->sk_send_head = skb_queue_next(TX_QUEUE(sk), skb);
 
-		control |= __set_reqseq(chan, chan->buffer_seq);
-		control |= __set_txseq(chan, chan->next_tx_seq);
+		l2cap_do_send(sk, tx_skb);
+		BT_DBG("Sent txseq %d", (int)control->txseq);
+	}
 
-		__put_control(chan, control, tx_skb->data + L2CAP_HDR_SIZE);
+	BT_DBG("Sent %d, %d unacked, %d in ERTM queue, %d in HCI queue", sent,
+		(int) pi->unacked_frames, skb_queue_len(TX_QUEUE(sk)),
+		atomic_read(&pi->ertm_queued));
 
-		if (chan->fcs == L2CAP_FCS_CRC16) {
-			fcs = crc16(0, (u8 *)skb->data,
-						tx_skb->len - L2CAP_FCS_SIZE);
-			put_unaligned_le16(fcs, skb->data +
-						tx_skb->len - L2CAP_FCS_SIZE);
-		}
+	return sent;
+}
 
-		l2cap_do_send(chan, tx_skb);
+int l2cap_strm_tx(struct sock *sk, struct sk_buff_head *skbs)
+{
+	struct sk_buff *skb;
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	struct bt_l2cap_control *control;
+	int sent = 0;
 
-		__set_retrans_timer(chan);
+	BT_DBG("sk %p, skbs %p", sk, skbs);
 
-		bt_cb(skb)->tx_seq = chan->next_tx_seq;
+	if (sk->sk_state != BT_CONNECTED)
+		return -ENOTCONN;
 
-		chan->next_tx_seq = __next_seq(chan, chan->next_tx_seq);
+	if (pi->amp_move_state != L2CAP_AMP_STATE_STABLE &&
+			pi->amp_move_state != L2CAP_AMP_STATE_WAIT_PREPARE)
+		return 0;
 
-		if (bt_cb(skb)->retries == 1)
-			chan->unacked_frames++;
+	skb_queue_splice_tail_init(skbs, TX_QUEUE(sk));
 
-		chan->frames_sent++;
+	BT_DBG("skb queue empty 0x%2.2x", skb_queue_empty(TX_QUEUE(sk)));
+	while (!skb_queue_empty(TX_QUEUE(sk))) {
 
-		if (skb_queue_is_last(&chan->tx_q, skb))
-			chan->tx_send_head = NULL;
-		else
-			chan->tx_send_head = skb_queue_next(&chan->tx_q, skb);
+		skb = skb_dequeue(TX_QUEUE(sk));
 
-		nsent++;
-	}
+		BT_DBG("skb %p", skb);
 
-	return nsent;
-}
+		bt_cb(skb)->retries = 1;
+		control = &bt_cb(skb)->control;
 
-static int l2cap_retransmit_frames(struct l2cap_chan *chan)
-{
-	int ret;
+		BT_DBG("control %p", control);
 
-	if (!skb_queue_empty(&chan->tx_q))
-		chan->tx_send_head = chan->tx_q.next;
+		control->reqseq = 0;
+		control->txseq = pi->next_tx_seq;
 
-	chan->next_tx_seq = chan->expected_ack_seq;
-	ret = l2cap_ertm_send(chan);
-	return ret;
-}
+		if (pi->extended_control) {
+			put_unaligned_le32(__pack_extended_control(control),
+					skb->data + L2CAP_HDR_SIZE);
+		} else {
+			put_unaligned_le16(__pack_enhanced_control(control),
+					skb->data + L2CAP_HDR_SIZE);
+		}
 
-static void l2cap_send_ack(struct l2cap_chan *chan)
-{
-	u32 control = 0;
+		if (pi->fcs == L2CAP_FCS_CRC16)
+			apply_fcs(skb);
 
-	control |= __set_reqseq(chan, chan->buffer_seq);
+		l2cap_do_send(sk, skb);
 
-	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
-		control |= __set_ctrl_super(chan, L2CAP_SUPER_RNR);
-		set_bit(CONN_RNR_SENT, &chan->conn_state);
-		l2cap_send_sframe(chan, control);
-		return;
+		BT_DBG("Sent txseq %d", (int)control->txseq);
+
+		pi->next_tx_seq = __next_seq(pi->next_tx_seq, pi);
+		pi->frames_sent += 1;
+		sent += 1;
 	}
 
-	if (l2cap_ertm_send(chan) > 0)
-		return;
+	BT_DBG("Sent %d", sent);
 
-	control |= __set_ctrl_super(chan, L2CAP_SUPER_RR);
-	l2cap_send_sframe(chan, control);
+	return 0;
 }
 
-static void l2cap_send_srejtail(struct l2cap_chan *chan)
+static int memcpy_fromkvec(unsigned char *kdata, struct kvec *iv, int len)
 {
-	struct srej_list *tail;
-	u32 control;
-
-	control = __set_ctrl_super(chan, L2CAP_SUPER_SREJ);
-	control |= __set_ctrl_final(chan);
-
-	tail = list_entry((&chan->srej_l)->prev, struct srej_list, list);
-	control |= __set_reqseq(chan, tail->tx_seq);
+	while (len > 0) {
+		if (iv->iov_len) {
+			int copy = min_t(unsigned int, len, iv->iov_len);
+			memcpy(kdata, iv->iov_base, copy);
+			len -= copy;
+			kdata += copy;
+			iv->iov_base += copy;
+			iv->iov_len -= copy;
+		}
+		iv++;
+	}
 
-	l2cap_send_sframe(chan, control);
+	return 0;
 }
 
-static inline int l2cap_skbuff_fromiovec(struct sock *sk, struct msghdr *msg, int len, int count, struct sk_buff *skb)
+static inline int l2cap_skbuff_fromiovec(struct sock *sk, struct msghdr *msg,
+					int len, int count, struct sk_buff *skb,
+					int reseg)
 {
-	struct l2cap_conn *conn = l2cap_pi(sk)->chan->conn;
+	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
 	struct sk_buff **frag;
+	struct sk_buff *final;
 	int err, sent = 0;
 
-	if (memcpy_fromiovec(skb_put(skb, count), msg->msg_iov, count))
+	BT_DBG("sk %p, msg %p, len %d, count %d, skb %p", sk,
+		msg, (int)len, (int)count, skb);
+
+	if (!conn)
+		return -ENOTCONN;
+
+	/* When resegmenting, data is copied from kernel space */
+	if (reseg) {
+		err = memcpy_fromkvec(skb_put(skb, count),
+				(struct kvec *) msg->msg_iov, count);
+	} else {
+		err = memcpy_fromiovec(skb_put(skb, count), msg->msg_iov,
+					count);
+	}
+
+	if (err)
 		return -EFAULT;
 
 	sent += count;
 	len  -= count;
+	final = skb;
 
 	/* Continuation fragments (no L2CAP header) */
 	frag = &skb_shinfo(skb)->frag_list;
 	while (len) {
+		int skblen;
 		count = min_t(unsigned int, conn->mtu, len);
 
-		*frag = bt_skb_send_alloc(sk, count, msg->msg_flags & MSG_DONTWAIT, &err);
+		/* Add room for the FCS if it fits */
+		if (bt_cb(skb)->control.fcs == L2CAP_FCS_CRC16 &&
+			len + L2CAP_FCS_SIZE <= conn->mtu)
+			skblen = count + L2CAP_FCS_SIZE;
+		else
+			skblen = count;
+
+		/* Don't use bt_skb_send_alloc() while resegmenting, since
+		 * it is not ok to block.
+		 */
+		if (reseg) {
+			*frag = bt_skb_alloc(skblen, GFP_ATOMIC);
+			if (*frag)
+				skb_set_owner_w(*frag, sk);
+		} else {
+			*frag = bt_skb_send_alloc(sk, skblen,
+					msg->msg_flags & MSG_DONTWAIT, &err);
+		}
+
 		if (!*frag)
-			return err;
-		if (memcpy_fromiovec(skb_put(*frag, count), msg->msg_iov, count))
 			return -EFAULT;
 
-		(*frag)->priority = skb->priority;
+		/* When resegmenting, data is copied from kernel space */
+		if (reseg) {
+			err = memcpy_fromkvec(skb_put(*frag, count),
+						(struct kvec *) msg->msg_iov,
+						count);
+		} else {
+			err = memcpy_fromiovec(skb_put(*frag, count),
+						msg->msg_iov, count);
+		}
+
+		if (err)
+			return -EFAULT;
 
 		sent += count;
 		len  -= count;
 
+		final = *frag;
+
 		frag = &(*frag)->next;
 	}
 
+	if (bt_cb(skb)->control.fcs == L2CAP_FCS_CRC16) {
+		if (skb_tailroom(final) < L2CAP_FCS_SIZE) {
+			if (reseg) {
+				*frag = bt_skb_alloc(L2CAP_FCS_SIZE,
+						GFP_ATOMIC);
+				if (*frag)
+					skb_set_owner_w(*frag, sk);
+			} else {
+				*frag = bt_skb_send_alloc(sk, L2CAP_FCS_SIZE,
+						msg->msg_flags & MSG_DONTWAIT,
+						&err);
+			}
+
+			if (!*frag)
+				return -EFAULT;
+
+			final = *frag;
+		}
+
+		skb_put(final, L2CAP_FCS_SIZE);
+	}
+
 	return sent;
 }
 
-static struct sk_buff *l2cap_create_connless_pdu(struct l2cap_chan *chan,
-						struct msghdr *msg, size_t len,
-						u32 priority)
+struct sk_buff *l2cap_create_connless_pdu(struct sock *sk, struct msghdr *msg, size_t len)
 {
-	struct sock *sk = chan->sk;
-	struct l2cap_conn *conn = chan->conn;
+	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
 	struct sk_buff *skb;
-	int err, count, hlen = L2CAP_HDR_SIZE + L2CAP_PSMLEN_SIZE;
+	int err, count, hlen = L2CAP_HDR_SIZE + 2;
 	struct l2cap_hdr *lh;
 
-	BT_DBG("sk %p len %d priority %u", sk, (int)len, priority);
+	BT_DBG("sk %p len %d", sk, (int)len);
 
 	count = min_t(unsigned int, (conn->mtu - hlen), len);
 	skb = bt_skb_send_alloc(sk, count + hlen,
@@ -1581,15 +1734,13 @@ static struct sk_buff *l2cap_create_connless_pdu(struct l2cap_chan *chan,
 	if (!skb)
 		return ERR_PTR(err);
 
-	skb->priority = priority;
-
 	/* Create L2CAP header */
 	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(chan->dcid);
+	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
 	lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));
-	put_unaligned_le16(chan->psm, skb_put(skb, 2));
+	put_unaligned_le16(l2cap_pi(sk)->psm, skb_put(skb, 2));
 
-	err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb);
+	err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb, 0);
 	if (unlikely(err < 0)) {
 		kfree_skb(skb);
 		return ERR_PTR(err);
@@ -1597,12 +1748,9 @@ static struct sk_buff *l2cap_create_connless_pdu(struct l2cap_chan *chan,
 	return skb;
 }
 
-static struct sk_buff *l2cap_create_basic_pdu(struct l2cap_chan *chan,
-						struct msghdr *msg, size_t len,
-						u32 priority)
+struct sk_buff *l2cap_create_basic_pdu(struct sock *sk, struct msghdr *msg, size_t len)
 {
-	struct sock *sk = chan->sk;
-	struct l2cap_conn *conn = chan->conn;
+	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
 	struct sk_buff *skb;
 	int err, count, hlen = L2CAP_HDR_SIZE;
 	struct l2cap_hdr *lh;
@@ -1615,14 +1763,12 @@ static struct sk_buff *l2cap_create_basic_pdu(struct l2cap_chan *chan,
 	if (!skb)
 		return ERR_PTR(err);
 
-	skb->priority = priority;
-
 	/* Create L2CAP header */
 	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(chan->dcid);
+	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
 	lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));
 
-	err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb);
+	err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb, 0);
 	if (unlikely(err < 0)) {
 		kfree_skb(skb);
 		return ERR_PTR(err);
@@ -1630,1707 +1776,3919 @@ static struct sk_buff *l2cap_create_basic_pdu(struct l2cap_chan *chan,
 	return skb;
 }
 
-static struct sk_buff *l2cap_create_iframe_pdu(struct l2cap_chan *chan,
-						struct msghdr *msg, size_t len,
-						u32 control, u16 sdulen)
+struct sk_buff *l2cap_create_iframe_pdu(struct sock *sk,
+					struct msghdr *msg, size_t len,
+					u16 sdulen, int reseg)
 {
-	struct sock *sk = chan->sk;
-	struct l2cap_conn *conn = chan->conn;
 	struct sk_buff *skb;
 	int err, count, hlen;
+	int reserve = 0;
 	struct l2cap_hdr *lh;
+	u8 fcs = l2cap_pi(sk)->fcs;
 
-	BT_DBG("sk %p len %d", sk, (int)len);
-
-	if (!conn)
-		return ERR_PTR(-ENOTCONN);
-
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		hlen = L2CAP_EXT_HDR_SIZE;
+	if (l2cap_pi(sk)->extended_control)
+		hlen = L2CAP_EXTENDED_HDR_SIZE;
 	else
-		hlen = L2CAP_ENH_HDR_SIZE;
+		hlen = L2CAP_ENHANCED_HDR_SIZE;
 
 	if (sdulen)
 		hlen += L2CAP_SDULEN_SIZE;
 
-	if (chan->fcs == L2CAP_FCS_CRC16)
+	if (fcs == L2CAP_FCS_CRC16)
 		hlen += L2CAP_FCS_SIZE;
 
-	count = min_t(unsigned int, (conn->mtu - hlen), len);
-	skb = bt_skb_send_alloc(sk, count + hlen,
-			msg->msg_flags & MSG_DONTWAIT, &err);
+	BT_DBG("sk %p, msg %p, len %d, sdulen %d, hlen %d",
+		sk, msg, (int)len, (int)sdulen, hlen);
+
+	count = min_t(unsigned int, (l2cap_pi(sk)->conn->mtu - hlen), len);
+
+	/* Allocate extra headroom for Qualcomm PAL.  This is only
+	 * necessary in two places (here and when creating sframes)
+	 * because only unfragmented iframes and sframes are sent
+	 * using AMP controllers.
+	 */
+	if (l2cap_pi(sk)->ampcon &&
+			l2cap_pi(sk)->ampcon->hdev->manufacturer == 0x001d)
+		reserve = BT_SKB_RESERVE_80211;
+
+	/* Don't use bt_skb_send_alloc() while resegmenting, since
+	 * it is not ok to block.
+	 */
+	if (reseg) {
+		skb = bt_skb_alloc(count + hlen + reserve, GFP_ATOMIC);
+		if (skb)
+			skb_set_owner_w(skb, sk);
+	} else {
+		skb = bt_skb_send_alloc(sk, count + hlen + reserve,
+					msg->msg_flags & MSG_DONTWAIT, &err);
+	}
 	if (!skb)
 		return ERR_PTR(err);
 
+	if (reserve)
+		skb_reserve(skb, reserve);
+
+	bt_cb(skb)->control.fcs = fcs;
+
 	/* Create L2CAP header */
 	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(chan->dcid);
-	lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));
+	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
+	lh->len = cpu_to_le16(len + hlen - L2CAP_HDR_SIZE);
 
-	__put_control(chan, control, skb_put(skb, __ctrl_size(chan)));
+	/* Control header is populated later */
+	if (l2cap_pi(sk)->extended_control)
+		put_unaligned_le32(0, skb_put(skb, 4));
+	else
+		put_unaligned_le16(0, skb_put(skb, 2));
 
 	if (sdulen)
 		put_unaligned_le16(sdulen, skb_put(skb, L2CAP_SDULEN_SIZE));
 
-	err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb);
+	err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb, reseg);
 	if (unlikely(err < 0)) {
+		BT_DBG("err %d", err);
 		kfree_skb(skb);
 		return ERR_PTR(err);
 	}
 
-	if (chan->fcs == L2CAP_FCS_CRC16)
-		put_unaligned_le16(0, skb_put(skb, L2CAP_FCS_SIZE));
-
 	bt_cb(skb)->retries = 0;
 	return skb;
 }
 
-static int l2cap_sar_segment_sdu(struct l2cap_chan *chan, struct msghdr *msg, size_t len)
+static void l2cap_ertm_process_reqseq(struct sock *sk, u16 reqseq)
 {
-	struct sk_buff *skb;
-	struct sk_buff_head sar_queue;
-	u32 control;
-	size_t size = 0;
+	struct l2cap_pinfo *pi;
+	struct sk_buff *acked_skb;
+	u16 ackseq;
 
-	skb_queue_head_init(&sar_queue);
-	control = __set_ctrl_sar(chan, L2CAP_SAR_START);
-	skb = l2cap_create_iframe_pdu(chan, msg, chan->remote_mps, control, len);
-	if (IS_ERR(skb))
-		return PTR_ERR(skb);
+	BT_DBG("sk %p, reqseq %d", sk, (int) reqseq);
 
-	__skb_queue_tail(&sar_queue, skb);
-	len -= chan->remote_mps;
-	size += chan->remote_mps;
+	pi = l2cap_pi(sk);
 
-	while (len > 0) {
-		size_t buflen;
+	if (pi->unacked_frames == 0 || reqseq == pi->expected_ack_seq)
+		return;
 
-		if (len > chan->remote_mps) {
-			control = __set_ctrl_sar(chan, L2CAP_SAR_CONTINUE);
-			buflen = chan->remote_mps;
-		} else {
-			control = __set_ctrl_sar(chan, L2CAP_SAR_END);
-			buflen = len;
-		}
+	BT_DBG("expected_ack_seq %d, unacked_frames %d",
+		(int) pi->expected_ack_seq, (int) pi->unacked_frames);
 
-		skb = l2cap_create_iframe_pdu(chan, msg, buflen, control, 0);
-		if (IS_ERR(skb)) {
-			skb_queue_purge(&sar_queue);
-			return PTR_ERR(skb);
-		}
+	for (ackseq = pi->expected_ack_seq; ackseq != reqseq;
+		ackseq = __next_seq(ackseq, pi)) {
 
-		__skb_queue_tail(&sar_queue, skb);
-		len -= buflen;
-		size += buflen;
+		acked_skb = l2cap_ertm_seq_in_queue(TX_QUEUE(sk), ackseq);
+		if (acked_skb) {
+			skb_unlink(acked_skb, TX_QUEUE(sk));
+			kfree_skb(acked_skb);
+			pi->unacked_frames--;
+		}
 	}
-	skb_queue_splice_tail(&sar_queue, &chan->tx_q);
-	if (chan->tx_send_head == NULL)
-		chan->tx_send_head = sar_queue.next;
 
-	return size;
+	pi->expected_ack_seq = reqseq;
+
+	if (pi->unacked_frames == 0)
+		l2cap_ertm_stop_retrans_timer(pi);
+
+	BT_DBG("unacked_frames %d", (int) pi->unacked_frames);
 }
 
-int l2cap_chan_send(struct l2cap_chan *chan, struct msghdr *msg, size_t len,
-								u32 priority)
+static struct sk_buff *l2cap_create_sframe_pdu(struct sock *sk, u32 control)
 {
 	struct sk_buff *skb;
-	u32 control;
-	int err;
+	int len;
+	int reserve = 0;
+	struct l2cap_hdr *lh;
 
-	/* Connectionless channel */
-	if (chan->chan_type == L2CAP_CHAN_CONN_LESS) {
-		skb = l2cap_create_connless_pdu(chan, msg, len, priority);
-		if (IS_ERR(skb))
-			return PTR_ERR(skb);
+	if (l2cap_pi(sk)->extended_control)
+		len = L2CAP_EXTENDED_HDR_SIZE;
+	else
+		len = L2CAP_ENHANCED_HDR_SIZE;
 
-		l2cap_do_send(chan, skb);
-		return len;
-	}
+	if (l2cap_pi(sk)->fcs == L2CAP_FCS_CRC16)
+		len += L2CAP_FCS_SIZE;
 
-	switch (chan->mode) {
-	case L2CAP_MODE_BASIC:
-		/* Check outgoing MTU */
-		if (len > chan->omtu)
-			return -EMSGSIZE;
+	/* Allocate extra headroom for Qualcomm PAL */
+	if (l2cap_pi(sk)->ampcon &&
+			l2cap_pi(sk)->ampcon->hdev->manufacturer == 0x001d)
+		reserve = BT_SKB_RESERVE_80211;
 
-		/* Create a basic PDU */
-		skb = l2cap_create_basic_pdu(chan, msg, len, priority);
-		if (IS_ERR(skb))
-			return PTR_ERR(skb);
+	skb = bt_skb_alloc(len + reserve, GFP_ATOMIC);
 
-		l2cap_do_send(chan, skb);
-		err = len;
-		break;
+	if (!skb)
+		return ERR_PTR(-ENOMEM);
 
-	case L2CAP_MODE_ERTM:
-	case L2CAP_MODE_STREAMING:
-		/* Entire SDU fits into one PDU */
-		if (len <= chan->remote_mps) {
-			control = __set_ctrl_sar(chan, L2CAP_SAR_UNSEGMENTED);
-			skb = l2cap_create_iframe_pdu(chan, msg, len, control,
-									0);
-			if (IS_ERR(skb))
-				return PTR_ERR(skb);
+	if (reserve)
+		skb_reserve(skb, reserve);
 
-			__skb_queue_tail(&chan->tx_q, skb);
+	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
+	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
+	lh->len = cpu_to_le16(len - L2CAP_HDR_SIZE);
 
-			if (chan->tx_send_head == NULL)
-				chan->tx_send_head = skb;
+	if (l2cap_pi(sk)->extended_control)
+		put_unaligned_le32(control, skb_put(skb, 4));
+	else
+		put_unaligned_le16(control, skb_put(skb, 2));
 
-		} else {
-			/* Segment SDU into multiples PDUs */
-			err = l2cap_sar_segment_sdu(chan, msg, len);
-			if (err < 0)
-				return err;
-		}
+	if (l2cap_pi(sk)->fcs == L2CAP_FCS_CRC16) {
+		u16 fcs = crc16(0, (u8 *) skb->data, skb->len);
+		put_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));
+	}
 
-		if (chan->mode == L2CAP_MODE_STREAMING) {
-			l2cap_streaming_send(chan);
-			err = len;
-			break;
-		}
+	return skb;
+}
 
-		if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&
-				test_bit(CONN_WAIT_F, &chan->conn_state)) {
-			err = len;
-			break;
-		}
+static void l2cap_ertm_send_sframe(struct sock *sk,
+				struct bt_l2cap_control *control)
+{
+	struct l2cap_pinfo *pi;
+	struct sk_buff *skb;
+	u32 control_field;
 
-		err = l2cap_ertm_send(chan);
-		if (err >= 0)
-			err = len;
+	BT_DBG("sk %p, control %p", sk, control);
 
-		break;
+	if (control->frame_type != 's')
+		return;
 
-	default:
-		BT_DBG("bad state %1.1x", chan->mode);
-		err = -EBADFD;
+	pi = l2cap_pi(sk);
+
+	if (pi->amp_move_state != L2CAP_AMP_STATE_STABLE &&
+		pi->amp_move_state != L2CAP_AMP_STATE_WAIT_PREPARE &&
+		pi->amp_move_state != L2CAP_AMP_STATE_RESEGMENT) {
+		BT_DBG("AMP error - attempted S-Frame send during AMP move");
+		return;
 	}
 
-	return err;
+	if ((pi->conn_state & L2CAP_CONN_SEND_FBIT) && !control->poll) {
+		control->final = 1;
+		pi->conn_state &= ~L2CAP_CONN_SEND_FBIT;
+	}
+
+	if (control->super == L2CAP_SFRAME_RR)
+		pi->conn_state &= ~L2CAP_CONN_SENT_RNR;
+	else if (control->super == L2CAP_SFRAME_RNR)
+		pi->conn_state |= L2CAP_CONN_SENT_RNR;
+
+	if (control->super != L2CAP_SFRAME_SREJ) {
+		pi->last_acked_seq = control->reqseq;
+		l2cap_ertm_stop_ack_timer(pi);
+	}
+
+	BT_DBG("reqseq %d, final %d, poll %d, super %d", (int) control->reqseq,
+		(int) control->final, (int) control->poll,
+		(int) control->super);
+
+	if (pi->extended_control)
+		control_field = __pack_extended_control(control);
+	else
+		control_field = __pack_enhanced_control(control);
+
+	skb = l2cap_create_sframe_pdu(sk, control_field);
+	if (!IS_ERR(skb))
+		l2cap_do_send(sk, skb);
 }
 
-/* Copy frame to all raw sockets on that connection */
-static void l2cap_raw_recv(struct l2cap_conn *conn, struct sk_buff *skb)
+static void l2cap_ertm_send_ack(struct sock *sk)
 {
-	struct sk_buff *nskb;
-	struct l2cap_chan *chan;
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	struct bt_l2cap_control control;
+	u16 frames_to_ack = __delta_seq(pi->buffer_seq, pi->last_acked_seq, pi);
+	int threshold;
 
-	BT_DBG("conn %p", conn);
+	BT_DBG("sk %p", sk);
+	BT_DBG("last_acked_seq %d, buffer_seq %d", (int)pi->last_acked_seq,
+		(int)pi->buffer_seq);
 
-	rcu_read_lock();
+	memset(&control, 0, sizeof(control));
+	control.frame_type = 's';
 
-	list_for_each_entry_rcu(chan, &conn->chan_l, list) {
-		struct sock *sk = chan->sk;
-		if (chan->chan_type != L2CAP_CHAN_RAW)
-			continue;
+	if ((pi->conn_state & L2CAP_CONN_LOCAL_BUSY) &&
+		pi->rx_state == L2CAP_ERTM_RX_STATE_RECV) {
+		l2cap_ertm_stop_ack_timer(pi);
+		control.super = L2CAP_SFRAME_RNR;
+		control.reqseq = pi->buffer_seq;
+		l2cap_ertm_send_sframe(sk, &control);
+	} else {
+		if (!(pi->conn_state & L2CAP_CONN_REMOTE_BUSY)) {
+			l2cap_ertm_send(sk);
+			/* If any i-frames were sent, they included an ack */
+			if (pi->buffer_seq == pi->last_acked_seq)
+				frames_to_ack = 0;
+		}
 
-		/* Don't send frame to the socket it came from */
-		if (skb->sk == sk)
-			continue;
-		nskb = skb_clone(skb, GFP_ATOMIC);
-		if (!nskb)
-			continue;
+		/* Ack now if the window is 3/4ths full.
+		 * Calculate without mul or div
+		 */
+		threshold = pi->ack_win;
+		threshold += threshold << 1;
+		threshold >>= 2;
+
+		BT_DBG("frames_to_ack %d, threshold %d", (int)frames_to_ack,
+			threshold);
+
+		if (frames_to_ack >= threshold) {
+			l2cap_ertm_stop_ack_timer(pi);
+			control.super = L2CAP_SFRAME_RR;
+			control.reqseq = pi->buffer_seq;
+			l2cap_ertm_send_sframe(sk, &control);
+			frames_to_ack = 0;
+		}
 
-		if (chan->ops->recv(chan->data, nskb))
-			kfree_skb(nskb);
+		if (frames_to_ack)
+			l2cap_ertm_start_ack_timer(pi);
 	}
-
-	rcu_read_unlock();
 }
 
-/* ---- L2CAP signalling commands ---- */
-static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,
-				u8 code, u8 ident, u16 dlen, void *data)
+static void l2cap_ertm_send_rr_or_rnr(struct sock *sk, bool poll)
 {
-	struct sk_buff *skb, **frag;
-	struct l2cap_cmd_hdr *cmd;
-	struct l2cap_hdr *lh;
-	int len, count;
-
-	BT_DBG("conn %p, code 0x%2.2x, ident 0x%2.2x, len %d",
-			conn, code, ident, dlen);
+	struct l2cap_pinfo *pi;
+	struct bt_l2cap_control control;
 
-	len = L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE + dlen;
-	count = min_t(unsigned int, conn->mtu, len);
+	BT_DBG("sk %p, poll %d", sk, (int) poll);
 
-	skb = bt_skb_alloc(count, GFP_ATOMIC);
-	if (!skb)
-		return NULL;
+	pi = l2cap_pi(sk);
 
-	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->len = cpu_to_le16(L2CAP_CMD_HDR_SIZE + dlen);
+	memset(&control, 0, sizeof(control));
+	control.frame_type = 's';
+	control.poll = poll;
 
-	if (conn->hcon->type == LE_LINK)
-		lh->cid = cpu_to_le16(L2CAP_CID_LE_SIGNALING);
+	if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY)
+		control.super = L2CAP_SFRAME_RNR;
 	else
-		lh->cid = cpu_to_le16(L2CAP_CID_SIGNALING);
+		control.super = L2CAP_SFRAME_RR;
 
-	cmd = (struct l2cap_cmd_hdr *) skb_put(skb, L2CAP_CMD_HDR_SIZE);
-	cmd->code  = code;
-	cmd->ident = ident;
-	cmd->len   = cpu_to_le16(dlen);
+	control.reqseq = pi->buffer_seq;
+	l2cap_ertm_send_sframe(sk, &control);
+}
 
-	if (dlen) {
-		count -= L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE;
-		memcpy(skb_put(skb, count), data, count);
-		data += count;
+static void l2cap_ertm_send_i_or_rr_or_rnr(struct sock *sk)
+{
+	struct l2cap_pinfo *pi;
+	struct bt_l2cap_control control;
+
+	BT_DBG("sk %p", sk);
+
+	pi = l2cap_pi(sk);
+
+	memset(&control, 0, sizeof(control));
+	control.frame_type = 's';
+	control.final = 1;
+	control.reqseq = pi->buffer_seq;
+	pi->conn_state |= L2CAP_CONN_SEND_FBIT;
+
+	if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
+		control.super = L2CAP_SFRAME_RNR;
+		l2cap_ertm_send_sframe(sk, &control);
 	}
 
-	len -= skb->len;
+	if ((pi->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
+		(pi->unacked_frames > 0))
+		l2cap_ertm_start_retrans_timer(pi);
 
-	/* Continuation fragments (no L2CAP header) */
-	frag = &skb_shinfo(skb)->frag_list;
-	while (len) {
-		count = min_t(unsigned int, conn->mtu, len);
+	pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
 
-		*frag = bt_skb_alloc(count, GFP_ATOMIC);
-		if (!*frag)
-			goto fail;
+	/* Send pending iframes */
+	l2cap_ertm_send(sk);
 
-		memcpy(skb_put(*frag, count), data, count);
+	if (pi->conn_state & L2CAP_CONN_SEND_FBIT) {
+		/* F-bit wasn't sent in an s-frame or i-frame yet, so
+		 * send it now.
+		 */
+		control.super = L2CAP_SFRAME_RR;
+		l2cap_ertm_send_sframe(sk, &control);
+	}
+}
 
-		len  -= count;
-		data += count;
+static void l2cap_ertm_send_srej(struct sock *sk, u16 txseq)
+{
+	struct bt_l2cap_control control;
+	struct l2cap_pinfo *pi;
+	u16 seq;
 
-		frag = &(*frag)->next;
+	BT_DBG("sk %p, txseq %d", sk, (int)txseq);
+
+	pi = l2cap_pi(sk);
+	memset(&control, 0, sizeof(control));
+	control.frame_type = 's';
+	control.super = L2CAP_SFRAME_SREJ;
+
+	for (seq = pi->expected_tx_seq; seq != txseq;
+		seq = __next_seq(seq, pi)) {
+		if (!l2cap_ertm_seq_in_queue(SREJ_QUEUE(pi), seq)) {
+			control.reqseq = seq;
+			l2cap_ertm_send_sframe(sk, &control);
+			l2cap_seq_list_append(&pi->srej_list, seq);
+		}
 	}
 
-	return skb;
+	pi->expected_tx_seq = __next_seq(txseq, pi);
+}
 
-fail:
-	kfree_skb(skb);
-	return NULL;
+static void l2cap_ertm_send_srej_tail(struct sock *sk)
+{
+	struct bt_l2cap_control control;
+	struct l2cap_pinfo *pi;
+
+	BT_DBG("sk %p", sk);
+
+	pi = l2cap_pi(sk);
+
+	if (pi->srej_list.tail == L2CAP_SEQ_LIST_CLEAR)
+		return;
+
+	memset(&control, 0, sizeof(control));
+	control.frame_type = 's';
+	control.super = L2CAP_SFRAME_SREJ;
+	control.reqseq = pi->srej_list.tail;
+	l2cap_ertm_send_sframe(sk, &control);
 }
 
-static inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen, unsigned long *val)
+static void l2cap_ertm_send_srej_list(struct sock *sk, u16 txseq)
 {
-	struct l2cap_conf_opt *opt = *ptr;
-	int len;
+	struct bt_l2cap_control control;
+	struct l2cap_pinfo *pi;
+	u16 initial_head;
+	u16 seq;
 
-	len = L2CAP_CONF_OPT_SIZE + opt->len;
-	*ptr += len;
+	BT_DBG("sk %p, txseq %d", sk, (int) txseq);
 
-	*type = opt->type;
-	*olen = opt->len;
+	pi = l2cap_pi(sk);
+	memset(&control, 0, sizeof(control));
+	control.frame_type = 's';
+	control.super = L2CAP_SFRAME_SREJ;
 
-	switch (opt->len) {
-	case 1:
-		*val = *((u8 *) opt->val);
-		break;
+	/* Capture initial list head to allow only one pass through the list. */
+	initial_head = pi->srej_list.head;
 
-	case 2:
-		*val = get_unaligned_le16(opt->val);
-		break;
+	do {
+		seq = l2cap_seq_list_pop(&pi->srej_list);
+		if ((seq == txseq) || (seq == L2CAP_SEQ_LIST_CLEAR))
+			break;
 
-	case 4:
-		*val = get_unaligned_le32(opt->val);
-		break;
+		control.reqseq = seq;
+		l2cap_ertm_send_sframe(sk, &control);
+		l2cap_seq_list_append(&pi->srej_list, seq);
+	} while (pi->srej_list.head != initial_head);
+}
 
-	default:
-		*val = (unsigned long) opt->val;
-		break;
-	}
+static void l2cap_ertm_abort_rx_srej_sent(struct sock *sk)
+{
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	BT_DBG("sk %p", sk);
 
-	BT_DBG("type 0x%2.2x len %d val 0x%lx", *type, opt->len, *val);
-	return len;
+	pi->expected_tx_seq = pi->buffer_seq;
+	l2cap_seq_list_clear(&l2cap_pi(sk)->srej_list);
+	skb_queue_purge(SREJ_QUEUE(sk));
+	pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
 }
 
-static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)
+static int l2cap_ertm_tx_state_xmit(struct sock *sk,
+				struct bt_l2cap_control *control,
+				struct sk_buff_head *skbs, u8 event)
 {
-	struct l2cap_conf_opt *opt = *ptr;
+	struct l2cap_pinfo *pi;
+	int err = 0;
 
-	BT_DBG("type 0x%2.2x len %d val 0x%lx", type, len, val);
+	BT_DBG("sk %p, control %p, skbs %p, event %d", sk, control, skbs,
+		(int)event);
+	pi = l2cap_pi(sk);
 
-	opt->type = type;
-	opt->len  = len;
+	switch (event) {
+	case L2CAP_ERTM_EVENT_DATA_REQUEST:
+		if (sk->sk_send_head == NULL)
+			sk->sk_send_head = skb_peek(skbs);
 
-	switch (len) {
-	case 1:
-		*((u8 *) opt->val)  = val;
+		skb_queue_splice_tail_init(skbs, TX_QUEUE(sk));
+		l2cap_ertm_send(sk);
 		break;
+	case L2CAP_ERTM_EVENT_LOCAL_BUSY_DETECTED:
+		BT_DBG("Enter LOCAL_BUSY");
+		pi->conn_state |= L2CAP_CONN_LOCAL_BUSY;
+
+		if (pi->rx_state == L2CAP_ERTM_RX_STATE_SREJ_SENT) {
+			/* The SREJ_SENT state must be aborted if we are to
+			 * enter the LOCAL_BUSY state.
+			 */
+			l2cap_ertm_abort_rx_srej_sent(sk);
+		}
 
-	case 2:
-		put_unaligned_le16(val, opt->val);
-		break;
+		l2cap_ertm_send_ack(sk);
 
-	case 4:
-		put_unaligned_le32(val, opt->val);
 		break;
+	case L2CAP_ERTM_EVENT_LOCAL_BUSY_CLEAR:
+		BT_DBG("Exit LOCAL_BUSY");
+		pi->conn_state &= ~L2CAP_CONN_LOCAL_BUSY;
+
+		if (pi->amp_move_state == L2CAP_AMP_STATE_WAIT_LOCAL_BUSY) {
+			if (pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
+				pi->amp_move_state =
+					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP;
+				l2cap_send_move_chan_cfm(pi->conn, pi,
+						pi->scid,
+						L2CAP_MOVE_CHAN_CONFIRMED);
+				l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
+			} else if (pi->amp_move_role ==
+					L2CAP_AMP_MOVE_RESPONDER) {
+				pi->amp_move_state =
+					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM;
+				l2cap_send_move_chan_rsp(pi->conn,
+						pi->amp_move_cmd_ident,
+						pi->dcid,
+						L2CAP_MOVE_CHAN_SUCCESS);
+			}
+			break;
+		}
+
+		if (pi->amp_move_role == L2CAP_AMP_MOVE_NONE &&
+			(pi->conn_state & L2CAP_CONN_SENT_RNR)) {
+			struct bt_l2cap_control local_control;
 
+			memset(&local_control, 0, sizeof(local_control));
+			local_control.frame_type = 's';
+			local_control.super = L2CAP_SFRAME_RR;
+			local_control.poll = 1;
+			local_control.reqseq = pi->buffer_seq;
+			l2cap_ertm_send_sframe(sk, &local_control);
+
+			pi->retry_count = 1;
+			l2cap_ertm_start_monitor_timer(pi);
+			pi->tx_state = L2CAP_ERTM_TX_STATE_WAIT_F;
+		}
+		break;
+	case L2CAP_ERTM_EVENT_RECV_REQSEQ_AND_FBIT:
+		l2cap_ertm_process_reqseq(sk, control->reqseq);
+		break;
+	case L2CAP_ERTM_EVENT_EXPLICIT_POLL:
+		l2cap_ertm_send_rr_or_rnr(sk, 1);
+		pi->retry_count = 1;
+		l2cap_ertm_start_monitor_timer(pi);
+		l2cap_ertm_stop_ack_timer(pi);
+		pi->tx_state = L2CAP_ERTM_TX_STATE_WAIT_F;
+		break;
+	case L2CAP_ERTM_EVENT_RETRANS_TIMER_EXPIRES:
+		l2cap_ertm_send_rr_or_rnr(sk, 1);
+		pi->retry_count = 1;
+		l2cap_ertm_start_monitor_timer(pi);
+		pi->tx_state = L2CAP_ERTM_TX_STATE_WAIT_F;
+		break;
+	case L2CAP_ERTM_EVENT_RECV_FBIT:
+		/* Nothing to process */
+		break;
 	default:
-		memcpy(opt->val, (void *) val, len);
 		break;
 	}
 
-	*ptr += L2CAP_CONF_OPT_SIZE + len;
+	return err;
 }
 
-static void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan)
+static int l2cap_ertm_tx_state_wait_f(struct sock *sk,
+				struct bt_l2cap_control *control,
+				struct sk_buff_head *skbs, u8 event)
 {
-	struct l2cap_conf_efs efs;
+	struct l2cap_pinfo *pi;
+	int err = 0;
 
-	switch (chan->mode) {
-	case L2CAP_MODE_ERTM:
-		efs.id		= chan->local_id;
-		efs.stype	= chan->local_stype;
-		efs.msdu	= cpu_to_le16(chan->local_msdu);
-		efs.sdu_itime	= cpu_to_le32(chan->local_sdu_itime);
-		efs.acc_lat	= cpu_to_le32(L2CAP_DEFAULT_ACC_LAT);
-		efs.flush_to	= cpu_to_le32(L2CAP_DEFAULT_FLUSH_TO);
-		break;
+	BT_DBG("sk %p, control %p, skbs %p, event %d", sk, control, skbs,
+		(int)event);
+	pi = l2cap_pi(sk);
 
-	case L2CAP_MODE_STREAMING:
-		efs.id		= 1;
-		efs.stype	= L2CAP_SERV_BESTEFFORT;
-		efs.msdu	= cpu_to_le16(chan->local_msdu);
-		efs.sdu_itime	= cpu_to_le32(chan->local_sdu_itime);
-		efs.acc_lat	= 0;
-		efs.flush_to	= 0;
+	switch (event) {
+	case L2CAP_ERTM_EVENT_DATA_REQUEST:
+		if (sk->sk_send_head == NULL)
+			sk->sk_send_head = skb_peek(skbs);
+		/* Queue data, but don't send. */
+		skb_queue_splice_tail_init(skbs, TX_QUEUE(sk));
 		break;
+	case L2CAP_ERTM_EVENT_LOCAL_BUSY_DETECTED:
+		BT_DBG("Enter LOCAL_BUSY");
+		pi->conn_state |= L2CAP_CONN_LOCAL_BUSY;
+
+		if (pi->rx_state == L2CAP_ERTM_RX_STATE_SREJ_SENT) {
+			/* The SREJ_SENT state must be aborted if we are to
+			 * enter the LOCAL_BUSY state.
+			 */
+			l2cap_ertm_abort_rx_srej_sent(sk);
+		}
+
+		l2cap_ertm_send_ack(sk);
 
+		break;
+	case L2CAP_ERTM_EVENT_LOCAL_BUSY_CLEAR:
+		BT_DBG("Exit LOCAL_BUSY");
+		pi->conn_state &= ~L2CAP_CONN_LOCAL_BUSY;
+
+		if (pi->conn_state & L2CAP_CONN_SENT_RNR) {
+			struct bt_l2cap_control local_control;
+			memset(&local_control, 0, sizeof(local_control));
+			local_control.frame_type = 's';
+			local_control.super = L2CAP_SFRAME_RR;
+			local_control.poll = 1;
+			local_control.reqseq = pi->buffer_seq;
+			l2cap_ertm_send_sframe(sk, &local_control);
+
+			pi->retry_count = 1;
+			l2cap_ertm_start_monitor_timer(pi);
+			pi->tx_state = L2CAP_ERTM_TX_STATE_WAIT_F;
+		}
+		break;
+	case L2CAP_ERTM_EVENT_RECV_REQSEQ_AND_FBIT:
+		l2cap_ertm_process_reqseq(sk, control->reqseq);
+
+		/* Fall through */
+
+	case L2CAP_ERTM_EVENT_RECV_FBIT:
+		if (control && control->final) {
+			l2cap_ertm_stop_monitor_timer(pi);
+			if (pi->unacked_frames > 0)
+				l2cap_ertm_start_retrans_timer(pi);
+			pi->retry_count = 0;
+			pi->tx_state = L2CAP_ERTM_TX_STATE_XMIT;
+			BT_DBG("recv fbit tx_state 0x2.2%x", pi->tx_state);
+		}
+		break;
+	case L2CAP_ERTM_EVENT_EXPLICIT_POLL:
+		/* Ignore */
+		break;
+	case L2CAP_ERTM_EVENT_MONITOR_TIMER_EXPIRES:
+		if ((pi->max_tx == 0) || (pi->retry_count < pi->max_tx)) {
+			l2cap_ertm_send_rr_or_rnr(sk, 1);
+			l2cap_ertm_start_monitor_timer(pi);
+			pi->retry_count += 1;
+		} else
+			l2cap_send_disconn_req(pi->conn, sk, ECONNABORTED);
+		break;
 	default:
-		return;
+		break;
 	}
 
-	l2cap_add_conf_opt(ptr, L2CAP_CONF_EFS, sizeof(efs),
-							(unsigned long) &efs);
+	return err;
 }
 
-static void l2cap_ack_timeout(struct work_struct *work)
+int l2cap_ertm_tx(struct sock *sk, struct bt_l2cap_control *control,
+			struct sk_buff_head *skbs, u8 event)
 {
-	struct l2cap_chan *chan = container_of(work, struct l2cap_chan,
-							ack_timer.work);
+	struct l2cap_pinfo *pi;
+	int err = 0;
 
-	BT_DBG("chan %p", chan);
+	BT_DBG("sk %p, control %p, skbs %p, event %d, state %d",
+		sk, control, skbs, (int)event, l2cap_pi(sk)->tx_state);
+
+	pi = l2cap_pi(sk);
 
-	lock_sock(chan->sk);
-	l2cap_send_ack(chan);
-	release_sock(chan->sk);
+	switch (pi->tx_state) {
+	case L2CAP_ERTM_TX_STATE_XMIT:
+		err = l2cap_ertm_tx_state_xmit(sk, control, skbs, event);
+		break;
+	case L2CAP_ERTM_TX_STATE_WAIT_F:
+		err = l2cap_ertm_tx_state_wait_f(sk, control, skbs, event);
+		break;
+	default:
+		/* Ignore event */
+		break;
+	}
+
+	return err;
 }
 
-static inline void l2cap_ertm_init(struct l2cap_chan *chan)
+int l2cap_segment_sdu(struct sock *sk, struct sk_buff_head* seg_queue,
+			struct msghdr *msg, size_t len, int reseg)
 {
-	chan->expected_ack_seq = 0;
-	chan->unacked_frames = 0;
-	chan->buffer_seq = 0;
-	chan->num_acked = 0;
-	chan->frames_sent = 0;
+	struct sk_buff *skb;
+	u16 sdu_len;
+	size_t pdu_len;
+	int err = 0;
+	u8 sar;
 
-	INIT_DELAYED_WORK(&chan->retrans_timer, l2cap_retrans_timeout);
-	INIT_DELAYED_WORK(&chan->monitor_timer, l2cap_monitor_timeout);
-	INIT_DELAYED_WORK(&chan->ack_timer, l2cap_ack_timeout);
+	BT_DBG("sk %p, msg %p, len %d", sk, msg, (int)len);
 
-	skb_queue_head_init(&chan->srej_q);
+	/* It is critical that ERTM PDUs fit in a single HCI fragment,
+	 * so fragmented skbs are not used.  The HCI layer's handling
+	 * of fragmented skbs is not compatible with ERTM's queueing.
+	 */
 
-	INIT_LIST_HEAD(&chan->srej_l);
-}
+	/* PDU size is derived from the HCI MTU */
+	pdu_len = l2cap_pi(sk)->conn->mtu;
 
-static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)
-{
-	switch (mode) {
-	case L2CAP_MODE_STREAMING:
-	case L2CAP_MODE_ERTM:
-		if (l2cap_mode_supported(mode, remote_feat_mask))
-			return mode;
-		/* fall through */
-	default:
-		return L2CAP_MODE_BASIC;
-	}
-}
+	/* Constrain BR/EDR PDU size to fit within the largest radio packet */
+	if (!l2cap_pi(sk)->ampcon)
+		pdu_len = min_t(size_t, pdu_len, L2CAP_BREDR_MAX_PAYLOAD);
 
-static inline bool __l2cap_ews_supported(struct l2cap_chan *chan)
-{
-	return enable_hs && chan->conn->feat_mask & L2CAP_FEAT_EXT_WINDOW;
-}
+	/* Adjust for largest possible L2CAP overhead. */
+	pdu_len -= L2CAP_EXTENDED_HDR_SIZE + L2CAP_FCS_SIZE;
 
-static inline bool __l2cap_efs_supported(struct l2cap_chan *chan)
-{
-	return enable_hs && chan->conn->feat_mask & L2CAP_FEAT_EXT_FLOW;
-}
+	/* Remote device may have requested smaller PDUs */
+	pdu_len = min_t(size_t, pdu_len, l2cap_pi(sk)->remote_mps);
 
-static inline void l2cap_txwin_setup(struct l2cap_chan *chan)
-{
-	if (chan->tx_win > L2CAP_DEFAULT_TX_WINDOW &&
-						__l2cap_ews_supported(chan)) {
-		/* use extended control field */
-		set_bit(FLAG_EXT_CTRL, &chan->flags);
-		chan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;
+	if (len <= pdu_len) {
+		sar = L2CAP_SAR_UNSEGMENTED;
+		sdu_len = 0;
+		pdu_len = len;
 	} else {
-		chan->tx_win = min_t(u16, chan->tx_win,
-						L2CAP_DEFAULT_TX_WINDOW);
-		chan->tx_win_max = L2CAP_DEFAULT_TX_WINDOW;
+		sar = L2CAP_SAR_START;
+		sdu_len = len;
+		pdu_len -= L2CAP_SDULEN_SIZE;
 	}
-}
 
-static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)
-{
-	struct l2cap_conf_req *req = data;
-	struct l2cap_conf_rfc rfc = { .mode = chan->mode };
-	void *ptr = req->data;
-	u16 size;
+	while (len) {
+		skb = l2cap_create_iframe_pdu(sk, msg, pdu_len, sdu_len, reseg);
 
-	BT_DBG("chan %p", chan);
+		BT_DBG("iframe skb %p", skb);
 
-	if (chan->num_conf_req || chan->num_conf_rsp)
-		goto done;
+		if (IS_ERR(skb)) {
+			__skb_queue_purge(seg_queue);
+			return PTR_ERR(skb);
+		}
 
-	switch (chan->mode) {
-	case L2CAP_MODE_STREAMING:
-	case L2CAP_MODE_ERTM:
-		if (test_bit(CONF_STATE2_DEVICE, &chan->conf_state))
-			break;
+		bt_cb(skb)->control.sar = sar;
+		__skb_queue_tail(seg_queue, skb);
 
-		if (__l2cap_efs_supported(chan))
-			set_bit(FLAG_EFS_ENABLE, &chan->flags);
+		len -= pdu_len;
+		if (sdu_len) {
+			sdu_len = 0;
+			pdu_len += L2CAP_SDULEN_SIZE;
+		}
 
-		/* fall through */
-	default:
-		chan->mode = l2cap_select_mode(rfc.mode, chan->conn->feat_mask);
-		break;
+		if (len <= pdu_len) {
+			sar = L2CAP_SAR_END;
+			pdu_len = len;
+		} else {
+			sar = L2CAP_SAR_CONTINUE;
+		}
 	}
 
-done:
-	if (chan->imtu != L2CAP_DEFAULT_MTU)
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu);
-
-	switch (chan->mode) {
-	case L2CAP_MODE_BASIC:
-		if (!(chan->conn->feat_mask & L2CAP_FEAT_ERTM) &&
-				!(chan->conn->feat_mask & L2CAP_FEAT_STREAMING))
-			break;
-
-		rfc.mode            = L2CAP_MODE_BASIC;
-		rfc.txwin_size      = 0;
-		rfc.max_transmit    = 0;
-		rfc.retrans_timeout = 0;
-		rfc.monitor_timeout = 0;
-		rfc.max_pdu_size    = 0;
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
-							(unsigned long) &rfc);
-		break;
-
-	case L2CAP_MODE_ERTM:
-		rfc.mode            = L2CAP_MODE_ERTM;
-		rfc.max_transmit    = chan->max_tx;
-		rfc.retrans_timeout = 0;
-		rfc.monitor_timeout = 0;
+	return err;
+}
 
-		size = min_t(u16, L2CAP_DEFAULT_MAX_PDU_SIZE, chan->conn->mtu -
-						L2CAP_EXT_HDR_SIZE -
-						L2CAP_SDULEN_SIZE -
-						L2CAP_FCS_SIZE);
-		rfc.max_pdu_size = cpu_to_le16(size);
+static inline int is_initial_frame(u8 sar)
+{
+	return (sar == L2CAP_SAR_UNSEGMENTED ||
+		sar == L2CAP_SAR_START);
+}
 
-		l2cap_txwin_setup(chan);
+static inline int l2cap_skbuff_to_kvec(struct sk_buff *skb, struct kvec *iv,
+					size_t veclen)
+{
+	struct sk_buff *frag_iter;
 
-		rfc.txwin_size = min_t(u16, chan->tx_win,
-						L2CAP_DEFAULT_TX_WINDOW);
+	BT_DBG("skb %p (len %d), iv %p", skb, (int)skb->len, iv);
 
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
-							(unsigned long) &rfc);
+	if (iv->iov_len + skb->len > veclen)
+		return -ENOMEM;
 
-		if (test_bit(FLAG_EFS_ENABLE, &chan->flags))
-			l2cap_add_opt_efs(&ptr, chan);
+	memcpy(iv->iov_base + iv->iov_len, skb->data, skb->len);
+	iv->iov_len += skb->len;
 
-		if (!(chan->conn->feat_mask & L2CAP_FEAT_FCS))
-			break;
+	skb_walk_frags(skb, frag_iter) {
+		if (iv->iov_len + skb->len > veclen)
+			return -ENOMEM;
 
-		if (chan->fcs == L2CAP_FCS_NONE ||
-				test_bit(CONF_NO_FCS_RECV, &chan->conf_state)) {
-			chan->fcs = L2CAP_FCS_NONE;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, chan->fcs);
-		}
+		BT_DBG("Copying %d bytes", (int)frag_iter->len);
+		memcpy(iv->iov_base + iv->iov_len, frag_iter->data,
+			frag_iter->len);
+		iv->iov_len += frag_iter->len;
+	}
 
-		if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,
-								chan->tx_win);
-		break;
+	return 0;
+}
 
-	case L2CAP_MODE_STREAMING:
-		rfc.mode            = L2CAP_MODE_STREAMING;
-		rfc.txwin_size      = 0;
-		rfc.max_transmit    = 0;
-		rfc.retrans_timeout = 0;
-		rfc.monitor_timeout = 0;
+int l2cap_resegment_queue(struct sock *sk, struct sk_buff_head *queue)
+{
+	void *buf;
+	int buflen;
+	int err = 0;
+	struct sk_buff *skb;
+	struct msghdr msg;
+	struct kvec iv;
+	struct sk_buff_head old_frames;
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
 
-		size = min_t(u16, L2CAP_DEFAULT_MAX_PDU_SIZE, chan->conn->mtu -
-						L2CAP_EXT_HDR_SIZE -
-						L2CAP_SDULEN_SIZE -
-						L2CAP_FCS_SIZE);
-		rfc.max_pdu_size = cpu_to_le16(size);
+	BT_DBG("sk %p", sk);
 
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
-							(unsigned long) &rfc);
+	if (skb_queue_empty(queue))
+		return 0;
 
-		if (test_bit(FLAG_EFS_ENABLE, &chan->flags))
-			l2cap_add_opt_efs(&ptr, chan);
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = (struct iovec *) &iv;
 
-		if (!(chan->conn->feat_mask & L2CAP_FEAT_FCS))
-			break;
+	buflen = pi->omtu + L2CAP_FCS_SIZE;
+	buf = kzalloc(buflen, GFP_TEMPORARY);
 
-		if (chan->fcs == L2CAP_FCS_NONE ||
-				test_bit(CONF_NO_FCS_RECV, &chan->conf_state)) {
-			chan->fcs = L2CAP_FCS_NONE;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, chan->fcs);
-		}
-		break;
+	if (!buf) {
+		BT_DBG("Could not allocate resegmentation buffer");
+		return -ENOMEM;
 	}
 
-	req->dcid  = cpu_to_le16(chan->dcid);
-	req->flags = cpu_to_le16(0);
+	/* Move current frames off the original queue */
+	__skb_queue_head_init(&old_frames);
+	skb_queue_splice_tail_init(queue, &old_frames);
 
-	return ptr - data;
-}
+	while (!skb_queue_empty(&old_frames)) {
+		struct sk_buff_head current_sdu;
+		u8 original_sar;
 
-static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)
-{
-	struct l2cap_conf_rsp *rsp = data;
-	void *ptr = rsp->data;
-	void *req = chan->conf_req;
-	int len = chan->conf_len;
-	int type, hint, olen;
-	unsigned long val;
-	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
-	struct l2cap_conf_efs efs;
-	u8 remote_efs = 0;
-	u16 mtu = L2CAP_DEFAULT_MTU;
-	u16 result = L2CAP_CONF_SUCCESS;
-	u16 size;
+		/* Reassemble each SDU from one or more PDUs */
 
-	BT_DBG("chan %p", chan);
+		iv.iov_base = buf;
+		iv.iov_len = 0;
 
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&req, &type, &olen, &val);
+		skb = skb_peek(&old_frames);
+		original_sar = bt_cb(skb)->control.sar;
 
-		hint  = type & L2CAP_CONF_HINT;
-		type &= L2CAP_CONF_MASK;
+		__skb_unlink(skb, &old_frames);
 
-		switch (type) {
-		case L2CAP_CONF_MTU:
-			mtu = val;
-			break;
+		/* Append data to SDU */
+		if (pi->extended_control)
+			skb_pull(skb, L2CAP_EXTENDED_HDR_SIZE);
+		else
+			skb_pull(skb, L2CAP_ENHANCED_HDR_SIZE);
 
-		case L2CAP_CONF_FLUSH_TO:
-			chan->flush_to = val;
-			break;
+		if (original_sar == L2CAP_SAR_START)
+			skb_pull(skb, L2CAP_SDULEN_SIZE);
 
-		case L2CAP_CONF_QOS:
-			break;
+		err = l2cap_skbuff_to_kvec(skb, &iv, buflen);
 
-		case L2CAP_CONF_RFC:
-			if (olen == sizeof(rfc))
-				memcpy(&rfc, (void *) val, olen);
-			break;
+		if (bt_cb(skb)->control.fcs == L2CAP_FCS_CRC16)
+			iv.iov_len -= L2CAP_FCS_SIZE;
 
-		case L2CAP_CONF_FCS:
-			if (val == L2CAP_FCS_NONE)
-				set_bit(CONF_NO_FCS_RECV, &chan->conf_state);
-			break;
+		/* Free skb */
+		kfree_skb(skb);
 
-		case L2CAP_CONF_EFS:
-			remote_efs = 1;
-			if (olen == sizeof(efs))
-				memcpy(&efs, (void *) val, olen);
+		if (err)
 			break;
 
-		case L2CAP_CONF_EWS:
-			if (!enable_hs)
-				return -ECONNREFUSED;
-
-			set_bit(FLAG_EXT_CTRL, &chan->flags);
-			set_bit(CONF_EWS_RECV, &chan->conf_state);
-			chan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;
-			chan->remote_tx_win = val;
-			break;
+		while (!skb_queue_empty(&old_frames) && !err) {
+			/* Check next frame */
+			skb = skb_peek(&old_frames);
 
-		default:
-			if (hint)
+			if (is_initial_frame(bt_cb(skb)->control.sar))
 				break;
 
-			result = L2CAP_CONF_UNKNOWN;
-			*((u8 *) ptr++) = type;
-			break;
-		}
-	}
-
-	if (chan->num_conf_rsp || chan->num_conf_req > 1)
-		goto done;
-
-	switch (chan->mode) {
-	case L2CAP_MODE_STREAMING:
-	case L2CAP_MODE_ERTM:
-		if (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) {
-			chan->mode = l2cap_select_mode(rfc.mode,
-					chan->conn->feat_mask);
-			break;
-		}
+			__skb_unlink(skb, &old_frames);
 
-		if (remote_efs) {
-			if (__l2cap_efs_supported(chan))
-				set_bit(FLAG_EFS_ENABLE, &chan->flags);
+			/* Append data to SDU */
+			if (pi->extended_control)
+				skb_pull(skb, L2CAP_EXTENDED_HDR_SIZE);
 			else
-				return -ECONNREFUSED;
-		}
-
-		if (chan->mode != rfc.mode)
-			return -ECONNREFUSED;
-
-		break;
-	}
+				skb_pull(skb, L2CAP_ENHANCED_HDR_SIZE);
 
-done:
-	if (chan->mode != rfc.mode) {
-		result = L2CAP_CONF_UNACCEPT;
-		rfc.mode = chan->mode;
-
-		if (chan->num_conf_rsp == 1)
-			return -ECONNREFUSED;
+			if (bt_cb(skb)->control.sar == L2CAP_SAR_START)
+				skb_pull(skb, L2CAP_SDULEN_SIZE);
 
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-	}
+			err = l2cap_skbuff_to_kvec(skb, &iv, buflen);
 
-	if (result == L2CAP_CONF_SUCCESS) {
-		/* Configure output options and let the other side know
-		 * which ones we don't like. */
+			if (bt_cb(skb)->control.fcs == L2CAP_FCS_CRC16)
+				iv.iov_len -= L2CAP_FCS_SIZE;
 
-		if (mtu < L2CAP_DEFAULT_MIN_MTU)
-			result = L2CAP_CONF_UNACCEPT;
-		else {
-			chan->omtu = mtu;
-			set_bit(CONF_MTU_DONE, &chan->conf_state);
+			/* Free skb */
+			kfree_skb(skb);
 		}
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu);
 
-		if (remote_efs) {
-			if (chan->local_stype != L2CAP_SERV_NOTRAFIC &&
-					efs.stype != L2CAP_SERV_NOTRAFIC &&
-					efs.stype != chan->local_stype) {
+		if (err)
+			break;
 
-				result = L2CAP_CONF_UNACCEPT;
+		/* Segment data */
+
+		__skb_queue_head_init(&current_sdu);
+
+		/* skbs for the SDU were just freed, but the
+		 * resegmenting process could produce more, smaller
+		 * skbs due to smaller PDUs and reduced HCI MTU.  The
+		 * overhead from the sk_buff structs could put us over
+		 * the sk_sndbuf limit.
+		 *
+		 * Since this code is running in response to a
+		 * received poll/final packet, it cannot block.
+		 * Therefore, memory allocation needs to be allowed by
+		 * falling back to bt_skb_alloc() (with
+		 * skb_set_owner_w() to maintain sk_wmem_alloc
+		 * correctly).
+		 */
+		msg.msg_iovlen = iv.iov_len;
+		err = l2cap_segment_sdu(sk, &current_sdu, &msg,
+					msg.msg_iovlen, 1);
+
+		if (err || skb_queue_empty(&current_sdu)) {
+			BT_DBG("Error %d resegmenting data for socket %p",
+				err, sk);
+			__skb_queue_purge(&current_sdu);
+			break;
+		}
 
-				if (chan->num_conf_req >= 1)
-					return -ECONNREFUSED;
+		/* Fix up first PDU SAR bits */
+		if (!is_initial_frame(original_sar)) {
+			BT_DBG("Changing SAR bits, %d PDUs",
+				skb_queue_len(&current_sdu));
+			skb = skb_peek(&current_sdu);
 
-				l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,
-							sizeof(efs),
-							(unsigned long) &efs);
+			if (skb_queue_len(&current_sdu) == 1) {
+				/* Change SAR from 'unsegmented' to 'end' */
+				bt_cb(skb)->control.sar = L2CAP_SAR_END;
 			} else {
-				/* Send PENDING Conf Rsp */
-				result = L2CAP_CONF_PENDING;
-				set_bit(CONF_LOC_CONF_PEND, &chan->conf_state);
+				struct l2cap_hdr *lh;
+				size_t hdrlen;
+
+				/* Change SAR from 'start' to 'continue' */
+				bt_cb(skb)->control.sar = L2CAP_SAR_CONTINUE;
+
+				/* Start frames contain 2 bytes for
+				 * sdulen and continue frames don't.
+				 * Must rewrite header to eliminate
+				 * sdulen and then adjust l2cap frame
+				 * length.
+				 */
+				if (pi->extended_control)
+					hdrlen = L2CAP_EXTENDED_HDR_SIZE;
+				else
+					hdrlen = L2CAP_ENHANCED_HDR_SIZE;
+
+				memmove(skb->data + L2CAP_SDULEN_SIZE,
+					skb->data, hdrlen);
+				skb_pull(skb, L2CAP_SDULEN_SIZE);
+				lh = (struct l2cap_hdr *)skb->data;
+				lh->len = cpu_to_le16(le16_to_cpu(lh->len) -
+							L2CAP_SDULEN_SIZE);
 			}
 		}
 
-		switch (rfc.mode) {
-		case L2CAP_MODE_BASIC:
-			chan->fcs = L2CAP_FCS_NONE;
-			set_bit(CONF_MODE_DONE, &chan->conf_state);
-			break;
-
-		case L2CAP_MODE_ERTM:
-			if (!test_bit(CONF_EWS_RECV, &chan->conf_state))
-				chan->remote_tx_win = rfc.txwin_size;
-			else
-				rfc.txwin_size = L2CAP_DEFAULT_TX_WINDOW;
-
-			chan->remote_max_tx = rfc.max_transmit;
-
-			size = min_t(u16, le16_to_cpu(rfc.max_pdu_size),
-						chan->conn->mtu -
-						L2CAP_EXT_HDR_SIZE -
-						L2CAP_SDULEN_SIZE -
-						L2CAP_FCS_SIZE);
-			rfc.max_pdu_size = cpu_to_le16(size);
-			chan->remote_mps = size;
+		/* Add to queue */
+		skb_queue_splice_tail(&current_sdu, queue);
+	}
 
-			rfc.retrans_timeout =
-				le16_to_cpu(L2CAP_DEFAULT_RETRANS_TO);
-			rfc.monitor_timeout =
-				le16_to_cpu(L2CAP_DEFAULT_MONITOR_TO);
+	__skb_queue_purge(&old_frames);
+	if (err)
+		__skb_queue_purge(queue);
 
-			set_bit(CONF_MODE_DONE, &chan->conf_state);
+	kfree(buf);
 
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
+	BT_DBG("Queue resegmented, err=%d", err);
+	return err;
+}
 
-			if (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {
-				chan->remote_id = efs.id;
-				chan->remote_stype = efs.stype;
-				chan->remote_msdu = le16_to_cpu(efs.msdu);
-				chan->remote_flush_to =
-						le32_to_cpu(efs.flush_to);
-				chan->remote_acc_lat =
-						le32_to_cpu(efs.acc_lat);
-				chan->remote_sdu_itime =
-					le32_to_cpu(efs.sdu_itime);
-				l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,
-					sizeof(efs), (unsigned long) &efs);
-			}
-			break;
+static void l2cap_resegment_worker(struct work_struct *work)
+{
+	int err = 0;
+	struct l2cap_resegment_work *seg_work =
+		container_of(work, struct l2cap_resegment_work, work);
+	struct sock *sk = seg_work->sk;
 
-		case L2CAP_MODE_STREAMING:
-			size = min_t(u16, le16_to_cpu(rfc.max_pdu_size),
-						chan->conn->mtu -
-						L2CAP_EXT_HDR_SIZE -
-						L2CAP_SDULEN_SIZE -
-						L2CAP_FCS_SIZE);
-			rfc.max_pdu_size = cpu_to_le16(size);
-			chan->remote_mps = size;
+	kfree(seg_work);
 
-			set_bit(CONF_MODE_DONE, &chan->conf_state);
+	BT_DBG("sk %p", sk);
+	lock_sock(sk);
 
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
+	if (l2cap_pi(sk)->amp_move_state != L2CAP_AMP_STATE_RESEGMENT) {
+		release_sock(sk);
+		sock_put(sk);
+		return;
+	}
 
-			break;
+	err = l2cap_resegment_queue(sk, TX_QUEUE(sk));
 
-		default:
-			result = L2CAP_CONF_UNACCEPT;
+	l2cap_pi(sk)->amp_move_state = L2CAP_AMP_STATE_STABLE;
 
-			memset(&rfc, 0, sizeof(rfc));
-			rfc.mode = chan->mode;
-		}
+	if (skb_queue_empty(TX_QUEUE(sk)))
+		sk->sk_send_head = NULL;
+	else
+		sk->sk_send_head = skb_peek(TX_QUEUE(sk));
 
-		if (result == L2CAP_CONF_SUCCESS)
-			set_bit(CONF_OUTPUT_DONE, &chan->conf_state);
-	}
-	rsp->scid   = cpu_to_le16(chan->dcid);
-	rsp->result = cpu_to_le16(result);
-	rsp->flags  = cpu_to_le16(0x0000);
+	if (err)
+		l2cap_send_disconn_req(l2cap_pi(sk)->conn, sk, ECONNRESET);
+	else
+		l2cap_ertm_send(sk);
 
-	return ptr - data;
+	release_sock(sk);
+	sock_put(sk);
 }
 
-static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len, void *data, u16 *result)
+static int l2cap_setup_resegment(struct sock *sk)
 {
-	struct l2cap_conf_req *req = data;
-	void *ptr = req->data;
-	int type, olen;
-	unsigned long val;
-	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
-	struct l2cap_conf_efs efs;
-
-	BT_DBG("chan %p, rsp %p, len %d, req %p", chan, rsp, len, data);
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
-
-		switch (type) {
-		case L2CAP_CONF_MTU:
-			if (val < L2CAP_DEFAULT_MIN_MTU) {
-				*result = L2CAP_CONF_UNACCEPT;
-				chan->imtu = L2CAP_DEFAULT_MIN_MTU;
-			} else
-				chan->imtu = val;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu);
-			break;
-
-		case L2CAP_CONF_FLUSH_TO:
-			chan->flush_to = val;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,
-							2, chan->flush_to);
-			break;
-
-		case L2CAP_CONF_RFC:
-			if (olen == sizeof(rfc))
-				memcpy(&rfc, (void *)val, olen);
-
-			if (test_bit(CONF_STATE2_DEVICE, &chan->conf_state) &&
-							rfc.mode != chan->mode)
-				return -ECONNREFUSED;
-
-			chan->fcs = 0;
+	struct l2cap_resegment_work *seg_work;
 
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-			break;
+	BT_DBG("sk %p", sk);
 
-		case L2CAP_CONF_EWS:
-			chan->tx_win = min_t(u16, val,
-						L2CAP_DEFAULT_EXT_WINDOW);
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,
-							chan->tx_win);
-			break;
+	if (skb_queue_empty(TX_QUEUE(sk)))
+		return 0;
 
-		case L2CAP_CONF_EFS:
-			if (olen == sizeof(efs))
-				memcpy(&efs, (void *)val, olen);
+	seg_work = kzalloc(sizeof(*seg_work), GFP_ATOMIC);
+	if (!seg_work)
+		return -ENOMEM;
 
-			if (chan->local_stype != L2CAP_SERV_NOTRAFIC &&
-					efs.stype != L2CAP_SERV_NOTRAFIC &&
-					efs.stype != chan->local_stype)
-				return -ECONNREFUSED;
+	INIT_WORK(&seg_work->work, l2cap_resegment_worker);
+	sock_hold(sk);
+	seg_work->sk = sk;
 
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,
-					sizeof(efs), (unsigned long) &efs);
-			break;
-		}
+	if (!queue_work(_l2cap_wq, &seg_work->work)) {
+		kfree(seg_work);
+		sock_put(sk);
+		return -ENOMEM;
 	}
 
-	if (chan->mode == L2CAP_MODE_BASIC && chan->mode != rfc.mode)
-		return -ECONNREFUSED;
-
-	chan->mode = rfc.mode;
-
-	if (*result == L2CAP_CONF_SUCCESS || *result == L2CAP_CONF_PENDING) {
-		switch (rfc.mode) {
-		case L2CAP_MODE_ERTM:
-			chan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
-			chan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
-			chan->mps    = le16_to_cpu(rfc.max_pdu_size);
-
-			if (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {
-				chan->local_msdu = le16_to_cpu(efs.msdu);
-				chan->local_sdu_itime =
-						le32_to_cpu(efs.sdu_itime);
-				chan->local_acc_lat = le32_to_cpu(efs.acc_lat);
-				chan->local_flush_to =
-						le32_to_cpu(efs.flush_to);
-			}
-			break;
+	l2cap_pi(sk)->amp_move_state = L2CAP_AMP_STATE_RESEGMENT;
 
-		case L2CAP_MODE_STREAMING:
-			chan->mps    = le16_to_cpu(rfc.max_pdu_size);
-		}
-	}
+	return 0;
+}
 
-	req->dcid   = cpu_to_le16(chan->dcid);
-	req->flags  = cpu_to_le16(0x0000);
+static inline int l2cap_rmem_available(struct sock *sk)
+{
+	BT_DBG("sk_rmem_alloc %d, sk_rcvbuf %d",
+		atomic_read(&sk->sk_rmem_alloc), sk->sk_rcvbuf);
+	return atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf / 3;
+}
 
-	return ptr - data;
+static inline int l2cap_rmem_full(struct sock *sk)
+{
+	BT_DBG("sk_rmem_alloc %d, sk_rcvbuf %d",
+		atomic_read(&sk->sk_rmem_alloc), sk->sk_rcvbuf);
+	return atomic_read(&sk->sk_rmem_alloc) > (2 * sk->sk_rcvbuf) / 3;
 }
 
-static int l2cap_build_conf_rsp(struct l2cap_chan *chan, void *data, u16 result, u16 flags)
+void l2cap_amp_move_init(struct sock *sk)
 {
-	struct l2cap_conf_rsp *rsp = data;
-	void *ptr = rsp->data;
+	BT_DBG("sk %p", sk);
 
-	BT_DBG("chan %p", chan);
+	if (!l2cap_pi(sk)->conn)
+		return;
 
-	rsp->scid   = cpu_to_le16(chan->dcid);
-	rsp->result = cpu_to_le16(result);
-	rsp->flags  = cpu_to_le16(flags);
+	if (!(l2cap_pi(sk)->conn->fc_mask & L2CAP_FC_A2MP) || !enable_hs)
+		return;
 
-	return ptr - data;
+	if (l2cap_pi(sk)->amp_id == 0) {
+		if (l2cap_pi(sk)->amp_pref != BT_AMP_POLICY_PREFER_AMP)
+			return;
+		l2cap_pi(sk)->amp_move_role = L2CAP_AMP_MOVE_INITIATOR;
+		l2cap_pi(sk)->amp_move_state = L2CAP_AMP_STATE_WAIT_PREPARE;
+		amp_create_physical(l2cap_pi(sk)->conn, sk);
+	} else {
+		l2cap_pi(sk)->amp_move_role = L2CAP_AMP_MOVE_INITIATOR;
+		l2cap_pi(sk)->amp_move_state =
+					L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS;
+		l2cap_pi(sk)->amp_move_id = 0;
+		l2cap_amp_move_setup(sk);
+		l2cap_send_move_chan_req(l2cap_pi(sk)->conn,
+					l2cap_pi(sk), l2cap_pi(sk)->scid, 0);
+		l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
+	}
 }
 
-void __l2cap_connect_rsp_defer(struct l2cap_chan *chan)
+static void l2cap_chan_ready(struct sock *sk)
 {
-	struct l2cap_conn_rsp rsp;
-	struct l2cap_conn *conn = chan->conn;
-	u8 buf[128];
+	struct sock *parent = bt_sk(sk)->parent;
 
-	rsp.scid   = cpu_to_le16(chan->dcid);
-	rsp.dcid   = cpu_to_le16(chan->scid);
-	rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
-	rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-	l2cap_send_cmd(conn, chan->ident,
-				L2CAP_CONN_RSP, sizeof(rsp), &rsp);
+	BT_DBG("sk %p, parent %p", sk, parent);
 
-	if (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))
-		return;
+	l2cap_pi(sk)->conf_state = 0;
+	l2cap_sock_clear_timer(sk);
 
-	l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-			l2cap_build_conf_req(chan, buf), buf);
-	chan->num_conf_req++;
+	if (!parent) {
+		/* Outgoing channel.
+		 * Wake up socket sleeping on connect.
+		 */
+		sk->sk_state = BT_CONNECTED;
+		sk->sk_state_change(sk);
+	} else {
+		/* Incoming channel.
+		 * Wake up socket sleeping on accept.
+		 */
+		parent->sk_data_ready(parent, 0);
+	}
 }
 
-static void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)
+/* Copy frame to all raw sockets on that connection */
+static void l2cap_raw_recv(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	int type, olen;
-	unsigned long val;
-	struct l2cap_conf_rfc rfc;
-
-	BT_DBG("chan %p, rsp %p, len %d", chan, rsp, len);
+	struct l2cap_chan_list *l = &conn->chan_list;
+	struct sk_buff *nskb;
+	struct sock *sk;
 
-	if ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))
-		return;
+	BT_DBG("conn %p", conn);
 
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
+	read_lock(&l->lock);
+	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
+		if (sk->sk_type != SOCK_RAW)
+			continue;
 
-		switch (type) {
-		case L2CAP_CONF_RFC:
+		/* Don't send frame to the socket it came from */
+		if (skb->sk == sk)
+			continue;
+		nskb = skb_clone(skb, GFP_ATOMIC);
+		if (!nskb)
+			continue;
+
+		if (sock_queue_rcv_skb(sk, nskb))
+			kfree_skb(nskb);
+	}
+	read_unlock(&l->lock);
+}
+
+/* ---- L2CAP signalling commands ---- */
+static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,
+				u8 code, u8 ident, u16 dlen, void *data)
+{
+	struct sk_buff *skb, **frag;
+	struct l2cap_cmd_hdr *cmd;
+	struct l2cap_hdr *lh;
+	int len, count;
+	unsigned int mtu = conn->hcon->hdev->acl_mtu;
+
+	BT_DBG("conn %p, code 0x%2.2x, ident 0x%2.2x, len %d",
+			conn, code, ident, dlen);
+
+	len = L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE + dlen;
+	count = min_t(unsigned int, mtu, len);
+
+	skb = bt_skb_alloc(count, GFP_ATOMIC);
+	if (!skb)
+		return NULL;
+
+	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
+	lh->len = cpu_to_le16(L2CAP_CMD_HDR_SIZE + dlen);
+
+	if (conn->hcon->type == LE_LINK)
+		lh->cid = cpu_to_le16(L2CAP_CID_LE_SIGNALING);
+	else
+		lh->cid = cpu_to_le16(L2CAP_CID_SIGNALING);
+
+	cmd = (struct l2cap_cmd_hdr *) skb_put(skb, L2CAP_CMD_HDR_SIZE);
+	cmd->code  = code;
+	cmd->ident = ident;
+	cmd->len   = cpu_to_le16(dlen);
+
+	if (dlen) {
+		count -= L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE;
+		memcpy(skb_put(skb, count), data, count);
+		data += count;
+	}
+
+	len -= skb->len;
+
+	/* Continuation fragments (no L2CAP header) */
+	frag = &skb_shinfo(skb)->frag_list;
+	while (len) {
+		count = min_t(unsigned int, mtu, len);
+
+		*frag = bt_skb_alloc(count, GFP_ATOMIC);
+		if (!*frag)
+			goto fail;
+
+		memcpy(skb_put(*frag, count), data, count);
+
+		len  -= count;
+		data += count;
+
+		frag = &(*frag)->next;
+	}
+
+	return skb;
+
+fail:
+	kfree_skb(skb);
+	return NULL;
+}
+
+static inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen, unsigned long *val)
+{
+	struct l2cap_conf_opt *opt = *ptr;
+	int len;
+
+	len = L2CAP_CONF_OPT_SIZE + opt->len;
+	*ptr += len;
+
+	*type = opt->type;
+	*olen = opt->len;
+
+	switch (opt->len) {
+	case 1:
+		*val = *((u8 *) opt->val);
+		break;
+
+	case 2:
+		*val = get_unaligned_le16(opt->val);
+		break;
+
+	case 4:
+		*val = get_unaligned_le32(opt->val);
+		break;
+
+	default:
+		*val = (unsigned long) opt->val;
+		break;
+	}
+
+	BT_DBG("type 0x%2.2x len %d val 0x%lx", *type, opt->len, *val);
+	return len;
+}
+
+static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)
+{
+	struct l2cap_conf_opt *opt = *ptr;
+
+	BT_DBG("type 0x%2.2x len %d val 0x%lx", type, len, val);
+
+	opt->type = type;
+	opt->len  = len;
+
+	switch (len) {
+	case 1:
+		*((u8 *) opt->val)  = val;
+		break;
+
+	case 2:
+		put_unaligned_le16(val, opt->val);
+		break;
+
+	case 4:
+		put_unaligned_le32(val, opt->val);
+		break;
+
+	default:
+		memcpy(opt->val, (void *) val, len);
+		break;
+	}
+
+	*ptr += L2CAP_CONF_OPT_SIZE + len;
+}
+
+static void l2cap_ertm_ack_timeout(struct work_struct *work)
+{
+	struct delayed_work *delayed =
+		container_of(work, struct delayed_work, work);
+	struct l2cap_pinfo *pi =
+		container_of(delayed, struct l2cap_pinfo, ack_work);
+	struct sock *sk = (struct sock *)pi;
+	u16 frames_to_ack;
+
+	BT_DBG("sk %p", sk);
+
+	if (!sk)
+		return;
+
+	lock_sock(sk);
+
+	if (!l2cap_pi(sk)->conn) {
+		release_sock(sk);
+		return;
+	}
+
+	frames_to_ack = __delta_seq(l2cap_pi(sk)->buffer_seq,
+				    l2cap_pi(sk)->last_acked_seq,
+				    l2cap_pi(sk));
+
+	if (frames_to_ack)
+		l2cap_ertm_send_rr_or_rnr(sk, 0);
+
+	release_sock(sk);
+}
+
+static void l2cap_ertm_retrans_timeout(struct work_struct *work)
+{
+	struct delayed_work *delayed =
+		container_of(work, struct delayed_work, work);
+	struct l2cap_pinfo *pi =
+		container_of(delayed, struct l2cap_pinfo, retrans_work);
+	struct sock *sk = (struct sock *)pi;
+
+	BT_DBG("sk %p", sk);
+
+	if (!sk)
+		return;
+
+	lock_sock(sk);
+
+	if (!l2cap_pi(sk)->conn) {
+		release_sock(sk);
+		return;
+	}
+
+	l2cap_ertm_tx(sk, 0, 0, L2CAP_ERTM_EVENT_RETRANS_TIMER_EXPIRES);
+	release_sock(sk);
+}
+
+static void l2cap_ertm_monitor_timeout(struct work_struct *work)
+{
+	struct delayed_work *delayed =
+		container_of(work, struct delayed_work, work);
+	struct l2cap_pinfo *pi =
+		container_of(delayed, struct l2cap_pinfo, monitor_work);
+	struct sock *sk = (struct sock *)pi;
+
+	BT_DBG("sk %p", sk);
+
+	if (!sk)
+		return;
+
+	lock_sock(sk);
+
+	if (!l2cap_pi(sk)->conn) {
+		release_sock(sk);
+		return;
+	}
+
+	l2cap_ertm_tx(sk, 0, 0, L2CAP_ERTM_EVENT_MONITOR_TIMER_EXPIRES);
+
+	release_sock(sk);
+}
+
+static inline void l2cap_ertm_init(struct sock *sk)
+{
+	l2cap_pi(sk)->next_tx_seq = 0;
+	l2cap_pi(sk)->expected_tx_seq = 0;
+	l2cap_pi(sk)->expected_ack_seq = 0;
+	l2cap_pi(sk)->unacked_frames = 0;
+	l2cap_pi(sk)->buffer_seq = 0;
+	l2cap_pi(sk)->frames_sent = 0;
+	l2cap_pi(sk)->last_acked_seq = 0;
+	l2cap_pi(sk)->sdu = NULL;
+	l2cap_pi(sk)->sdu_last_frag = NULL;
+	l2cap_pi(sk)->sdu_len = 0;
+	atomic_set(&l2cap_pi(sk)->ertm_queued, 0);
+
+	l2cap_pi(sk)->rx_state = L2CAP_ERTM_RX_STATE_RECV;
+	l2cap_pi(sk)->tx_state = L2CAP_ERTM_TX_STATE_XMIT;
+
+	BT_DBG("tx_state 0x2.2%x rx_state 0x2.2%x", l2cap_pi(sk)->tx_state,
+		l2cap_pi(sk)->rx_state);
+
+	l2cap_pi(sk)->amp_id = 0;
+	l2cap_pi(sk)->amp_move_state = L2CAP_AMP_STATE_STABLE;
+	l2cap_pi(sk)->amp_move_role = L2CAP_AMP_MOVE_NONE;
+	l2cap_pi(sk)->amp_move_reqseq = 0;
+	l2cap_pi(sk)->amp_move_event = 0;
+
+	INIT_DELAYED_WORK(&l2cap_pi(sk)->ack_work, l2cap_ertm_ack_timeout);
+	INIT_DELAYED_WORK(&l2cap_pi(sk)->retrans_work,
+			l2cap_ertm_retrans_timeout);
+	INIT_DELAYED_WORK(&l2cap_pi(sk)->monitor_work,
+			l2cap_ertm_monitor_timeout);
+	INIT_WORK(&l2cap_pi(sk)->tx_work, l2cap_ertm_tx_worker);
+	skb_queue_head_init(SREJ_QUEUE(sk));
+	skb_queue_head_init(TX_QUEUE(sk));
+
+	l2cap_seq_list_init(&l2cap_pi(sk)->srej_list, l2cap_pi(sk)->tx_win);
+	l2cap_seq_list_init(&l2cap_pi(sk)->retrans_list,
+			l2cap_pi(sk)->remote_tx_win);
+}
+
+void l2cap_ertm_destruct(struct sock *sk)
+{
+	l2cap_seq_list_free(&l2cap_pi(sk)->srej_list);
+	l2cap_seq_list_free(&l2cap_pi(sk)->retrans_list);
+}
+
+void l2cap_ertm_shutdown(struct sock *sk)
+{
+	l2cap_ertm_stop_ack_timer(l2cap_pi(sk));
+	l2cap_ertm_stop_retrans_timer(l2cap_pi(sk));
+	l2cap_ertm_stop_monitor_timer(l2cap_pi(sk));
+}
+
+void l2cap_ertm_recv_done(struct sock *sk)
+{
+	lock_sock(sk);
+
+	if (l2cap_pi(sk)->mode != L2CAP_MODE_ERTM ||
+			sk->sk_state != BT_CONNECTED) {
+		release_sock(sk);
+		return;
+	}
+
+	/* Consume any queued incoming frames and update local busy status */
+	if (l2cap_pi(sk)->rx_state == L2CAP_ERTM_RX_STATE_SREJ_SENT &&
+			l2cap_ertm_rx_queued_iframes(sk))
+		l2cap_send_disconn_req(l2cap_pi(sk)->conn, sk, ECONNRESET);
+	else if ((l2cap_pi(sk)->conn_state & L2CAP_CONN_LOCAL_BUSY) &&
+			l2cap_rmem_available(sk))
+		l2cap_ertm_tx(sk, 0, 0, L2CAP_ERTM_EVENT_LOCAL_BUSY_CLEAR);
+
+	release_sock(sk);
+}
+
+static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)
+{
+	switch (mode) {
+	case L2CAP_MODE_STREAMING:
+	case L2CAP_MODE_ERTM:
+		if (l2cap_mode_supported(mode, remote_feat_mask))
+			return mode;
+		/* fall through */
+	default:
+		return L2CAP_MODE_BASIC;
+	}
+}
+
+static void l2cap_setup_txwin(struct l2cap_pinfo *pi)
+{
+	if (pi->tx_win > L2CAP_TX_WIN_MAX_ENHANCED &&
+		(pi->conn->feat_mask & L2CAP_FEAT_EXT_WINDOW)) {
+		pi->tx_win_max = L2CAP_TX_WIN_MAX_EXTENDED;
+		pi->extended_control = 1;
+	} else {
+		if (pi->tx_win > L2CAP_TX_WIN_MAX_ENHANCED)
+			pi->tx_win = L2CAP_TX_WIN_MAX_ENHANCED;
+
+		pi->tx_win_max = L2CAP_TX_WIN_MAX_ENHANCED;
+		pi->extended_control = 0;
+	}
+	pi->ack_win = pi->tx_win;
+}
+
+static void l2cap_aggregate_fs(struct hci_ext_fs *cur,
+		struct hci_ext_fs *new,
+		struct hci_ext_fs *agg)
+{
+	*agg = *cur;
+	if ((cur->max_sdu != 0xFFFF) && (cur->sdu_arr_time != 0xFFFFFFFF)) {
+		/* current flow spec has known rate */
+		if ((new->max_sdu == 0xFFFF) ||
+				(new->sdu_arr_time == 0xFFFFFFFF)) {
+			/* new fs has unknown rate, so aggregate is unknown */
+			agg->max_sdu = 0xFFFF;
+			agg->sdu_arr_time = 0xFFFFFFFF;
+		} else {
+			/* new fs has known rate, so aggregate is known */
+			u64 cur_rate;
+			u64 new_rate;
+			cur_rate = cur->max_sdu * 1000000ULL;
+			if (cur->sdu_arr_time)
+				cur_rate = div_u64(cur_rate, cur->sdu_arr_time);
+			new_rate = new->max_sdu * 1000000ULL;
+			if (new->sdu_arr_time)
+				new_rate = div_u64(new_rate, new->sdu_arr_time);
+			cur_rate = cur_rate + new_rate;
+			if (cur_rate)
+				agg->sdu_arr_time = div64_u64(
+					agg->max_sdu * 1000000ULL, cur_rate);
+		}
+	}
+}
+
+static int l2cap_aggregate(struct hci_chan *chan, struct l2cap_pinfo *pi)
+{
+	struct hci_ext_fs tx_fs;
+	struct hci_ext_fs rx_fs;
+
+	BT_DBG("chan %p", chan);
+
+	if (((chan->tx_fs.max_sdu == 0xFFFF) ||
+			(chan->tx_fs.sdu_arr_time == 0xFFFFFFFF)) &&
+			((chan->rx_fs.max_sdu == 0xFFFF) ||
+			(chan->rx_fs.sdu_arr_time == 0xFFFFFFFF)))
+		return 0;
+
+	l2cap_aggregate_fs(&chan->tx_fs,
+				(struct hci_ext_fs *) &pi->local_fs, &tx_fs);
+	l2cap_aggregate_fs(&chan->rx_fs,
+				(struct hci_ext_fs *) &pi->remote_fs, &rx_fs);
+	hci_chan_modify(chan, &tx_fs, &rx_fs);
+	return 1;
+}
+
+static void l2cap_deaggregate_fs(struct hci_ext_fs *cur,
+		struct hci_ext_fs *old,
+		struct hci_ext_fs *agg)
+{
+	*agg = *cur;
+	if ((cur->max_sdu != 0xFFFF) && (cur->sdu_arr_time != 0xFFFFFFFF)) {
+		u64 cur_rate;
+		u64 old_rate;
+		cur_rate = cur->max_sdu * 1000000ULL;
+		if (cur->sdu_arr_time)
+			cur_rate = div_u64(cur_rate, cur->sdu_arr_time);
+		old_rate = old->max_sdu * 1000000ULL;
+		if (old->sdu_arr_time)
+			old_rate = div_u64(old_rate, old->sdu_arr_time);
+		cur_rate = cur_rate - old_rate;
+		if (cur_rate)
+			agg->sdu_arr_time = div64_u64(
+				agg->max_sdu * 1000000ULL, cur_rate);
+	}
+}
+
+static int l2cap_deaggregate(struct hci_chan *chan, struct l2cap_pinfo *pi)
+{
+	struct hci_ext_fs tx_fs;
+	struct hci_ext_fs rx_fs;
+
+	BT_DBG("chan %p", chan);
+
+	if (((chan->tx_fs.max_sdu == 0xFFFF) ||
+			(chan->tx_fs.sdu_arr_time == 0xFFFFFFFF)) &&
+			((chan->rx_fs.max_sdu == 0xFFFF) ||
+			(chan->rx_fs.sdu_arr_time == 0xFFFFFFFF)))
+		return 0;
+
+	l2cap_deaggregate_fs(&chan->tx_fs,
+				(struct hci_ext_fs *) &pi->local_fs, &tx_fs);
+	l2cap_deaggregate_fs(&chan->rx_fs,
+				(struct hci_ext_fs *) &pi->remote_fs, &rx_fs);
+	hci_chan_modify(chan, &tx_fs, &rx_fs);
+	return 1;
+}
+
+static struct hci_chan *l2cap_chan_admit(u8 amp_id, struct sock *sk)
+{
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	struct hci_dev *hdev;
+	struct hci_conn *hcon;
+	struct hci_chan *chan;
+
+	hdev = hci_dev_get(amp_id);
+	if (!hdev)
+		return NULL;
+
+	BT_DBG("hdev %s", hdev->name);
+
+	hcon = hci_conn_hash_lookup_ba(hdev, ACL_LINK, pi->conn->dst);
+	if (!hcon) {
+		chan = NULL;
+		goto done;
+	}
+
+	chan = hci_chan_list_lookup_id(hdev, hcon->handle);
+	if (chan) {
+		l2cap_aggregate(chan, pi);
+		sock_hold(sk);
+		chan->l2cap_sk = sk;
+		hci_chan_hold(chan);
+		pi->ampchan = chan;
+		goto done;
+	}
+
+	chan = hci_chan_add(hdev);
+	if (chan) {
+		chan->conn = hcon;
+		sock_hold(sk);
+		chan->l2cap_sk = sk;
+		hci_chan_hold(chan);
+		pi->ampchan = chan;
+		hci_chan_create(chan,
+			(struct hci_ext_fs *) &pi->local_fs,
+			(struct hci_ext_fs *) &pi->remote_fs);
+	}
+done:
+	hci_dev_put(hdev);
+	return chan;
+}
+
+static void l2cap_get_ertm_timeouts(struct l2cap_conf_rfc *rfc,
+						struct l2cap_pinfo *pi)
+{
+	if (pi->amp_id && pi->ampcon) {
+		u64 ertm_to = pi->ampcon->hdev->amp_be_flush_to;
+
+		/* Class 1 devices have must have ERTM timeouts
+		 * exceeding the Link Supervision Timeout.  The
+		 * default Link Supervision Timeout for AMP
+		 * controllers is 10 seconds.
+		 *
+		 * Class 1 devices use 0xffffffff for their
+		 * best-effort flush timeout, so the clamping logic
+		 * will result in a timeout that meets the above
+		 * requirement.  ERTM timeouts are 16-bit values, so
+		 * the maximum timeout is 65.535 seconds.
+		 */
+
+		/* Convert timeout to milliseconds and round */
+		ertm_to = div_u64(ertm_to + 999, 1000);
+
+		/* This is the recommended formula for class 2 devices
+		 * that start ERTM timers when packets are sent to the
+		 * controller.
+		 */
+		ertm_to = 3 * ertm_to + 500;
+
+		if (ertm_to > 0xffff)
+			ertm_to = 0xffff;
+
+		rfc->retrans_timeout = cpu_to_le16((u16) ertm_to);
+		rfc->monitor_timeout = rfc->retrans_timeout;
+	} else {
+		rfc->retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);
+		rfc->monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);
+	}
+}
+
+int l2cap_build_conf_req(struct sock *sk, void *data)
+{
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	struct l2cap_conf_req *req = data;
+	struct l2cap_conf_rfc rfc = { .mode = pi->mode };
+	void *ptr = req->data;
+
+	BT_DBG("sk %p mode %d", sk, pi->mode);
+
+	if (pi->num_conf_req || pi->num_conf_rsp)
+		goto done;
+
+	switch (pi->mode) {
+	case L2CAP_MODE_STREAMING:
+	case L2CAP_MODE_ERTM:
+		if (pi->conf_state & L2CAP_CONF_STATE2_DEVICE)
+			break;
+
+		/* fall through */
+	default:
+		pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);
+		break;
+	}
+
+done:
+	if (pi->imtu != L2CAP_DEFAULT_MTU)
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);
+
+	switch (pi->mode) {
+	case L2CAP_MODE_BASIC:
+		if (!(pi->conn->feat_mask & L2CAP_FEAT_ERTM) &&
+				!(pi->conn->feat_mask & L2CAP_FEAT_STREAMING))
+			break;
+		rfc.txwin_size      = 0;
+		rfc.max_transmit    = 0;
+		rfc.retrans_timeout = 0;
+		rfc.monitor_timeout = 0;
+		rfc.max_pdu_size    = 0;
+
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
+							(unsigned long) &rfc);
+		break;
+
+	case L2CAP_MODE_ERTM:
+		l2cap_setup_txwin(pi);
+		if (pi->tx_win > L2CAP_TX_WIN_MAX_ENHANCED)
+			rfc.txwin_size = L2CAP_TX_WIN_MAX_ENHANCED;
+		else
+			rfc.txwin_size = pi->tx_win;
+		rfc.max_transmit = pi->max_tx;
+		rfc.max_pdu_size = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
+		l2cap_get_ertm_timeouts(&rfc, pi);
+
+		if (L2CAP_DEFAULT_MAX_PDU_SIZE > pi->imtu)
+			rfc.max_pdu_size = cpu_to_le16(pi->imtu);
+
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
+							(unsigned long) &rfc);
+
+		if ((pi->conn->feat_mask & L2CAP_FEAT_EXT_WINDOW) &&
+			pi->extended_control) {
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_WINDOW, 2,
+					pi->tx_win);
+		}
+
+		if (pi->amp_id) {
+			/* default best effort extended flow spec */
+			struct l2cap_conf_ext_fs fs = {1, 1, 0xFFFF,
+					0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_FS,
+				sizeof(fs), (unsigned long) &fs);
+		}
+
+		if (!(pi->conn->feat_mask & L2CAP_FEAT_FCS))
+			break;
+
+		if (pi->fcs == L2CAP_FCS_NONE ||
+				pi->conf_state & L2CAP_CONF_NO_FCS_RECV) {
+			pi->fcs = L2CAP_FCS_NONE;
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, pi->fcs);
+		}
+		break;
+
+	case L2CAP_MODE_STREAMING:
+		l2cap_setup_txwin(pi);
+		rfc.txwin_size      = 0;
+		rfc.max_transmit    = 0;
+		rfc.retrans_timeout = 0;
+		rfc.monitor_timeout = 0;
+		rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
+		if (L2CAP_DEFAULT_MAX_PDU_SIZE > pi->imtu)
+			rfc.max_pdu_size = cpu_to_le16(pi->imtu);
+
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
+							(unsigned long) &rfc);
+
+		if ((pi->conn->feat_mask & L2CAP_FEAT_EXT_WINDOW) &&
+			pi->extended_control) {
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_WINDOW, 2, 0);
+		}
+
+		if (!(pi->conn->feat_mask & L2CAP_FEAT_FCS))
+			break;
+
+		if (pi->fcs == L2CAP_FCS_NONE ||
+				pi->conf_state & L2CAP_CONF_NO_FCS_RECV) {
+			pi->fcs = L2CAP_FCS_NONE;
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, pi->fcs);
+		}
+		break;
+	}
+
+	req->dcid  = cpu_to_le16(pi->dcid);
+	req->flags = cpu_to_le16(0);
+
+	return ptr - data;
+}
+
+
+static int l2cap_build_amp_reconf_req(struct sock *sk, void *data)
+{
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	struct l2cap_conf_req *req = data;
+	struct l2cap_conf_rfc rfc = { .mode = pi->mode };
+	void *ptr = req->data;
+
+	BT_DBG("sk %p", sk);
+
+	switch (pi->mode) {
+	case L2CAP_MODE_ERTM:
+		rfc.mode            = L2CAP_MODE_ERTM;
+		rfc.txwin_size      = pi->tx_win;
+		rfc.max_transmit    = pi->max_tx;
+		rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
+		l2cap_get_ertm_timeouts(&rfc, pi);
+		if (L2CAP_DEFAULT_MAX_PDU_SIZE > pi->imtu)
+			rfc.max_pdu_size = cpu_to_le16(pi->imtu);
+
+		break;
+
+	default:
+		return -ECONNREFUSED;
+	}
+
+	l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
+						(unsigned long) &rfc);
+
+	if (pi->conn->feat_mask & L2CAP_FEAT_FCS) {
+		/* TODO assign fcs for br/edr based on socket config option */
+		/* FCS is not used with AMP because it is redundant - lower
+		 * layers already include a checksum. */
+		if (pi->amp_id)
+			pi->local_conf.fcs = L2CAP_FCS_NONE;
+		else
+			pi->local_conf.fcs = L2CAP_FCS_CRC16;
+
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, pi->local_conf.fcs);
+		pi->fcs = pi->local_conf.fcs | pi->remote_conf.fcs;
+	}
+
+	req->dcid  = cpu_to_le16(pi->dcid);
+	req->flags = cpu_to_le16(0);
+
+	return ptr - data;
+}
+
+static int l2cap_parse_conf_req(struct sock *sk, void *data)
+{
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	struct l2cap_conf_rsp *rsp = data;
+	void *ptr = rsp->data;
+	void *req = pi->conf_req;
+	int len = pi->conf_len;
+	int type, hint, olen;
+	unsigned long val;
+	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
+	struct l2cap_conf_ext_fs fs;
+	u16 mtu = L2CAP_DEFAULT_MTU;
+	u16 result = L2CAP_CONF_SUCCESS;
+
+	BT_DBG("sk %p", sk);
+
+	if (pi->omtu > mtu)
+		mtu = pi->omtu;
+
+	while (len >= L2CAP_CONF_OPT_SIZE) {
+		len -= l2cap_get_conf_opt(&req, &type, &olen, &val);
+
+		hint  = type & L2CAP_CONF_HINT;
+		type &= L2CAP_CONF_MASK;
+
+		switch (type) {
+		case L2CAP_CONF_MTU:
+			mtu = val;
+			break;
+
+		case L2CAP_CONF_FLUSH_TO:
+			pi->flush_to = val;
+			if (pi->conf_state & L2CAP_CONF_LOCKSTEP)
+				result = L2CAP_CONF_UNACCEPT;
+			else
+				pi->remote_conf.flush_to = val;
+			break;
+
+		case L2CAP_CONF_QOS:
+			if (pi->conf_state & L2CAP_CONF_LOCKSTEP)
+				result = L2CAP_CONF_UNACCEPT;
+			break;
+
+		case L2CAP_CONF_RFC:
+			if (olen == sizeof(rfc))
+				memcpy(&rfc, (void *) val, olen);
+			break;
+
+		case L2CAP_CONF_FCS:
+			if (val == L2CAP_FCS_NONE)
+				pi->conf_state |= L2CAP_CONF_NO_FCS_RECV;
+			pi->remote_conf.fcs = val;
+			break;
+
+		case L2CAP_CONF_EXT_FS:
+			if (olen == sizeof(fs)) {
+				pi->conf_state |= L2CAP_CONF_EFS_RECV;
+				if (!(pi->conf_state & L2CAP_CONF_LOCKSTEP)) {
+					result = L2CAP_CONF_UNACCEPT;
+					break;
+				}
+				memcpy(&fs, (void *) val, olen);
+				if (fs.type != L2CAP_SERVICE_BEST_EFFORT) {
+					result = L2CAP_CONF_FLOW_SPEC_REJECT;
+					break;
+				}
+				pi->remote_conf.flush_to =
+						le32_to_cpu(fs.flush_to);
+				pi->remote_fs.id = fs.id;
+				pi->remote_fs.type = fs.type;
+				pi->remote_fs.max_sdu =
+						le16_to_cpu(fs.max_sdu);
+				pi->remote_fs.sdu_arr_time =
+						le32_to_cpu(fs.sdu_arr_time);
+				pi->remote_fs.acc_latency =
+						le32_to_cpu(fs.acc_latency);
+				pi->remote_fs.flush_to =
+						le32_to_cpu(fs.flush_to);
+			}
+			break;
+
+		case L2CAP_CONF_EXT_WINDOW:
+			pi->extended_control = 1;
+			pi->remote_tx_win = val;
+			pi->tx_win_max = L2CAP_TX_WIN_MAX_EXTENDED;
+			pi->conf_state |= L2CAP_CONF_EXT_WIN_RECV;
+			break;
+
+		default:
+			if (hint)
+				break;
+
+			result = L2CAP_CONF_UNKNOWN;
+			*((u8 *) ptr++) = type;
+			break;
+		}
+	}
+
+	if (pi->num_conf_rsp || pi->num_conf_req > 1)
+		goto done;
+
+	switch (pi->mode) {
+	case L2CAP_MODE_STREAMING:
+	case L2CAP_MODE_ERTM:
+		if (!(pi->conf_state & L2CAP_CONF_STATE2_DEVICE)) {
+			pi->mode = l2cap_select_mode(rfc.mode,
+					pi->conn->feat_mask);
+			break;
+		}
+
+		if (pi->mode != rfc.mode)
+			return -ECONNREFUSED;
+
+		break;
+	}
+
+done:
+	if (pi->mode != rfc.mode) {
+		result = L2CAP_CONF_UNACCEPT;
+		rfc.mode = pi->mode;
+		if (mtu > L2CAP_DEFAULT_MTU)
+			pi->omtu = mtu;
+
+		if (pi->num_conf_rsp == 1)
+			return -ECONNREFUSED;
+
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
+					sizeof(rfc), (unsigned long) &rfc);
+	}
+
+
+	if ((pi->conf_state & L2CAP_CONF_LOCKSTEP) &&
+			!(pi->conf_state & L2CAP_CONF_EFS_RECV))
+		return -ECONNREFUSED;
+
+	if (result == L2CAP_CONF_SUCCESS) {
+		/* Configure output options and let the other side know
+		 * which ones we don't like. */
+
+		if (mtu < L2CAP_DEFAULT_MIN_MTU) {
+			result = L2CAP_CONF_UNACCEPT;
+			pi->omtu = L2CAP_DEFAULT_MIN_MTU;
+		} else {
+			pi->omtu = mtu;
+			pi->conf_state |= L2CAP_CONF_MTU_DONE;
+		}
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);
+
+		switch (rfc.mode) {
+		case L2CAP_MODE_BASIC:
+			pi->fcs = L2CAP_FCS_NONE;
+			pi->conf_state |= L2CAP_CONF_MODE_DONE;
+			break;
+
+		case L2CAP_MODE_ERTM:
+			if (!(pi->conf_state & L2CAP_CONF_EXT_WIN_RECV))
+				pi->remote_tx_win = rfc.txwin_size;
+			pi->remote_max_tx = rfc.max_transmit;
+			pi->remote_mps = le16_to_cpu(rfc.max_pdu_size);
+			l2cap_get_ertm_timeouts(&rfc, pi);
+
+			pi->conf_state |= L2CAP_CONF_MODE_DONE;
+
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
+					sizeof(rfc), (unsigned long) &rfc);
+
+			if (pi->conf_state & L2CAP_CONF_LOCKSTEP)
+				l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_FS,
+					sizeof(fs), (unsigned long) &fs);
+
+			break;
+
+		case L2CAP_MODE_STREAMING:
+			pi->remote_mps = le16_to_cpu(rfc.max_pdu_size);
+
+			pi->conf_state |= L2CAP_CONF_MODE_DONE;
+
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
+					sizeof(rfc), (unsigned long) &rfc);
+
+			break;
+
+		default:
+			result = L2CAP_CONF_UNACCEPT;
+
+			memset(&rfc, 0, sizeof(rfc));
+			rfc.mode = pi->mode;
+		}
+
+		if (pi->conf_state & L2CAP_CONF_LOCKSTEP &&
+				!(pi->conf_state & L2CAP_CONF_PEND_SENT)) {
+			pi->conf_state |= L2CAP_CONF_PEND_SENT;
+			result = L2CAP_CONF_PENDING;
+
+			if (pi->conf_state & L2CAP_CONF_LOCKSTEP_PEND &&
+					pi->amp_id) {
+				struct hci_chan *chan;
+				/* Trigger logical link creation only on AMP */
+
+				chan = l2cap_chan_admit(pi->amp_id, sk);
+				if (!chan)
+					return -ECONNREFUSED;
+
+				if (chan->state == BT_CONNECTED)
+					l2cap_create_cfm(chan, 0);
+			}
+		}
+
+		if (result == L2CAP_CONF_SUCCESS)
+			pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;
+	}
+	rsp->scid   = cpu_to_le16(pi->dcid);
+	rsp->result = cpu_to_le16(result);
+	rsp->flags  = cpu_to_le16(0x0000);
+
+	return ptr - data;
+}
+
+static int l2cap_parse_amp_move_reconf_req(struct sock *sk, void *data)
+{
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	struct l2cap_conf_rsp *rsp = data;
+	void *ptr = rsp->data;
+	void *req = pi->conf_req;
+	int len = pi->conf_len;
+	int type, hint, olen;
+	unsigned long val;
+	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
+	struct l2cap_conf_ext_fs fs;
+	u16 mtu = pi->omtu;
+	u16 tx_win = pi->remote_tx_win;
+	u16 result = L2CAP_CONF_SUCCESS;
+
+	BT_DBG("sk %p", sk);
+
+	while (len >= L2CAP_CONF_OPT_SIZE) {
+		len -= l2cap_get_conf_opt(&req, &type, &olen, &val);
+
+		hint  = type & L2CAP_CONF_HINT;
+		type &= L2CAP_CONF_MASK;
+
+		switch (type) {
+		case L2CAP_CONF_MTU:
+			mtu = val;
+			break;
+
+		case L2CAP_CONF_FLUSH_TO:
+			if (pi->amp_move_id)
+				result = L2CAP_CONF_UNACCEPT;
+			else
+				pi->remote_conf.flush_to = val;
+			break;
+
+		case L2CAP_CONF_QOS:
+			if (pi->amp_move_id)
+				result = L2CAP_CONF_UNACCEPT;
+			break;
+
+		case L2CAP_CONF_RFC:
+			if (olen == sizeof(rfc))
+				memcpy(&rfc, (void *) val, olen);
+			break;
+
+		case L2CAP_CONF_FCS:
+			pi->remote_conf.fcs = val;
+			break;
+
+		case L2CAP_CONF_EXT_FS:
+			if (olen == sizeof(fs)) {
+				memcpy(&fs, (void *) val, olen);
+				if (fs.type != L2CAP_SERVICE_BEST_EFFORT)
+					result = L2CAP_CONF_FLOW_SPEC_REJECT;
+				else {
+					pi->remote_conf.flush_to =
+						le32_to_cpu(fs.flush_to);
+				}
+			}
+			break;
+
+		case L2CAP_CONF_EXT_WINDOW:
+			tx_win = val;
+			break;
+
+		default:
+			if (hint)
+				break;
+
+			result = L2CAP_CONF_UNKNOWN;
+			*((u8 *) ptr++) = type;
+			break;
+			}
+	}
+
+	BT_DBG("result 0x%2.2x cur mode 0x%2.2x req  mode 0x%2.2x",
+		result, pi->mode, rfc.mode);
+
+	if (pi->mode != rfc.mode || rfc.mode == L2CAP_MODE_BASIC)
+		result = L2CAP_CONF_UNACCEPT;
+
+	if (result == L2CAP_CONF_SUCCESS) {
+		/* Configure output options and let the other side know
+		 * which ones we don't like. */
+
+		/* Don't allow mtu to decrease. */
+		if (mtu < pi->omtu)
+			result = L2CAP_CONF_UNACCEPT;
+
+		BT_DBG("mtu %d omtu %d", mtu, pi->omtu);
+
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);
+
+		/* Don't allow extended transmit window to change. */
+		if (tx_win != pi->remote_tx_win) {
+			result = L2CAP_CONF_UNACCEPT;
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_WINDOW, 2,
+					pi->remote_tx_win);
+		}
+
+		pi->remote_mps = rfc.max_pdu_size;
+
+		if (rfc.mode == L2CAP_MODE_ERTM) {
+			l2cap_get_ertm_timeouts(&rfc, pi);
+		} else {
+			rfc.retrans_timeout = 0;
+			rfc.monitor_timeout = 0;
+		}
+
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
+					sizeof(rfc), (unsigned long) &rfc);
+	}
+
+	if (result != L2CAP_CONF_SUCCESS)
+		goto done;
+
+	pi->fcs = pi->remote_conf.fcs | pi->local_conf.fcs;
+
+	if (pi->rx_state == L2CAP_ERTM_RX_STATE_WAIT_F_FLAG)
+		pi->flush_to = pi->remote_conf.flush_to;
+
+done:
+	rsp->scid   = cpu_to_le16(pi->dcid);
+	rsp->result = cpu_to_le16(result);
+	rsp->flags  = cpu_to_le16(0x0000);
+
+	return ptr - data;
+}
+
+static int l2cap_parse_conf_rsp(struct sock *sk, void *rsp, int len, void *data, u16 *result)
+{
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	struct l2cap_conf_req *req = data;
+	void *ptr = req->data;
+	int type, olen;
+	unsigned long val;
+	struct l2cap_conf_rfc rfc;
+
+	BT_DBG("sk %p, rsp %p, len %d, req %p", sk, rsp, len, data);
+
+	/* Initialize rfc in case no rfc option is received */
+	rfc.mode = pi->mode;
+	rfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);
+	rfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);
+	rfc.max_pdu_size = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
+
+	while (len >= L2CAP_CONF_OPT_SIZE) {
+		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
+
+		switch (type) {
+		case L2CAP_CONF_MTU:
+			if (val < L2CAP_DEFAULT_MIN_MTU) {
+				*result = L2CAP_CONF_UNACCEPT;
+				pi->imtu = L2CAP_DEFAULT_MIN_MTU;
+			} else
+				pi->imtu = val;
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);
+			break;
+
+		case L2CAP_CONF_FLUSH_TO:
+			pi->flush_to = val;
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,
+							2, pi->flush_to);
+			break;
+
+		case L2CAP_CONF_RFC:
+			if (olen == sizeof(rfc))
+				memcpy(&rfc, (void *)val, olen);
+
+			if ((pi->conf_state & L2CAP_CONF_STATE2_DEVICE) &&
+							rfc.mode != pi->mode)
+				return -ECONNREFUSED;
+
+			pi->fcs = 0;
+
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
+					sizeof(rfc), (unsigned long) &rfc);
+			break;
+
+		case L2CAP_CONF_EXT_WINDOW:
+			pi->ack_win = min_t(u16, val, pi->ack_win);
+
+			l2cap_add_conf_opt(&ptr, L2CAP_CONF_EXT_WINDOW,
+					2, pi->tx_win);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	if (pi->mode == L2CAP_MODE_BASIC && pi->mode != rfc.mode)
+		return -ECONNREFUSED;
+
+	pi->mode = rfc.mode;
+
+	if (*result == L2CAP_CONF_SUCCESS) {
+		switch (rfc.mode) {
+		case L2CAP_MODE_ERTM:
+			pi->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
+			pi->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
+			pi->mps    = le16_to_cpu(rfc.max_pdu_size);
+			if (!pi->extended_control) {
+				pi->ack_win = min_t(u16, pi->ack_win,
+						    rfc.txwin_size);
+			}
+			break;
+		case L2CAP_MODE_STREAMING:
+			pi->mps    = le16_to_cpu(rfc.max_pdu_size);
+		}
+	}
+
+	req->dcid   = cpu_to_le16(pi->dcid);
+	req->flags  = cpu_to_le16(0x0000);
+
+	return ptr - data;
+}
+
+static int l2cap_build_conf_rsp(struct sock *sk, void *data, u16 result, u16 flags)
+{
+	struct l2cap_conf_rsp *rsp = data;
+	void *ptr = rsp->data;
+
+	BT_DBG("sk %p", sk);
+
+	rsp->scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
+	rsp->result = cpu_to_le16(result);
+	rsp->flags  = cpu_to_le16(flags);
+
+	return ptr - data;
+}
+
+static void l2cap_conf_rfc_get(struct sock *sk, void *rsp, int len)
+{
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	int type, olen;
+	unsigned long val;
+	struct l2cap_conf_rfc rfc;
+	u16 txwin_ext = pi->ack_win;
+
+	BT_DBG("sk %p, rsp %p, len %d", sk, rsp, len);
+
+	/* Initialize rfc in case no rfc option is received */
+	rfc.mode = pi->mode;
+	rfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);
+	rfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);
+	rfc.max_pdu_size = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
+	rfc.txwin_size = min_t(u16, pi->ack_win, L2CAP_DEFAULT_TX_WINDOW);
+
+	if ((pi->mode != L2CAP_MODE_ERTM) && (pi->mode != L2CAP_MODE_STREAMING))
+		return;
+
+	while (len >= L2CAP_CONF_OPT_SIZE) {
+		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
+
+		switch (type) {
+		case L2CAP_CONF_RFC:
 			if (olen == sizeof(rfc))
 				memcpy(&rfc, (void *)val, olen);
+			break;
+		case L2CAP_CONF_EXT_WINDOW:
+			txwin_ext = val;
+			break;
+		}
+	}
+
+	switch (rfc.mode) {
+	case L2CAP_MODE_ERTM:
+		pi->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
+		pi->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
+		pi->mps    = le16_to_cpu(rfc.max_pdu_size);
+		if (pi->extended_control)
+			pi->ack_win = min_t(u16, pi->ack_win, txwin_ext);
+		else
+			pi->ack_win = min_t(u16, pi->ack_win, rfc.txwin_size);
+		break;
+	case L2CAP_MODE_STREAMING:
+		pi->mps    = le16_to_cpu(rfc.max_pdu_size);
+	}
+}
+
+static void l2cap_conf_ext_fs_get(struct sock *sk, void *rsp, int len)
+{
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	int type, olen;
+	unsigned long val;
+	struct l2cap_conf_ext_fs fs;
+
+	BT_DBG("sk %p, rsp %p, len %d", sk, rsp, len);
+
+	while (len >= L2CAP_CONF_OPT_SIZE) {
+		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
+		if ((type == L2CAP_CONF_EXT_FS) &&
+				(olen == sizeof(struct l2cap_conf_ext_fs))) {
+			memcpy(&fs, (void *)val, olen);
+			pi->local_fs.id = fs.id;
+			pi->local_fs.type = fs.type;
+			pi->local_fs.max_sdu = le16_to_cpu(fs.max_sdu);
+			pi->local_fs.sdu_arr_time =
+						le32_to_cpu(fs.sdu_arr_time);
+			pi->local_fs.acc_latency = le32_to_cpu(fs.acc_latency);
+			pi->local_fs.flush_to = le32_to_cpu(fs.flush_to);
+			break;
+		}
+	}
+
+}
+
+static int l2cap_finish_amp_move(struct sock *sk)
+{
+	struct l2cap_pinfo *pi;
+	int err;
+
+	BT_DBG("sk %p", sk);
+
+	pi = l2cap_pi(sk);
+
+	pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
+	pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
+
+	if (pi->ampcon)
+		pi->conn->mtu = pi->ampcon->hdev->acl_mtu;
+	else
+		pi->conn->mtu = pi->conn->hcon->hdev->acl_mtu;
+
+	err = l2cap_setup_resegment(sk);
+
+	return err;
+}
+
+static int l2cap_amp_move_reconf_rsp(struct sock *sk, void *rsp, int len,
+					u16 result)
+{
+	int err = 0;
+	struct l2cap_conf_rfc rfc = {.mode = L2CAP_MODE_BASIC};
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+
+	BT_DBG("sk %p, rsp %p, len %d, res 0x%2.2x", sk, rsp, len, result);
+
+	if (pi->reconf_state == L2CAP_RECONF_NONE)
+		return -ECONNREFUSED;
+
+	if (result == L2CAP_CONF_SUCCESS) {
+		while (len >= L2CAP_CONF_OPT_SIZE) {
+			int type, olen;
+			unsigned long val;
+
+			len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
+
+			if (type == L2CAP_CONF_RFC) {
+				if (olen == sizeof(rfc))
+					memcpy(&rfc, (void *)val, olen);
+
+				if (rfc.mode != pi->mode) {
+					l2cap_send_disconn_req(pi->conn, sk,
+								ECONNRESET);
+					return -ECONNRESET;
+				}
+
+				goto done;
+			}
+		}
+	}
+
+	BT_ERR("Expected RFC option was missing, using existing values");
+
+	rfc.mode = pi->mode;
+	rfc.retrans_timeout = cpu_to_le16(pi->retrans_timeout);
+	rfc.monitor_timeout = cpu_to_le16(pi->monitor_timeout);
+
+done:
+	l2cap_ertm_stop_ack_timer(pi);
+	l2cap_ertm_stop_retrans_timer(pi);
+	l2cap_ertm_stop_monitor_timer(pi);
+
+	pi->mps = le16_to_cpu(rfc.max_pdu_size);
+	if (pi->mode == L2CAP_MODE_ERTM) {
+		pi->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
+		pi->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
+	}
+
+	if (l2cap_pi(sk)->reconf_state == L2CAP_RECONF_ACC) {
+		l2cap_pi(sk)->reconf_state = L2CAP_RECONF_NONE;
+
+		/* Respond to poll */
+		err = l2cap_answer_move_poll(sk);
+	} else if (l2cap_pi(sk)->reconf_state == L2CAP_RECONF_INT) {
+		if (pi->mode == L2CAP_MODE_ERTM) {
+			l2cap_ertm_tx(sk, NULL, NULL,
+					L2CAP_ERTM_EVENT_EXPLICIT_POLL);
+			pi->rx_state = L2CAP_ERTM_RX_STATE_WAIT_F_FLAG;
+		}
+	}
+
+	return err;
+}
+
+
+static inline int l2cap_command_rej(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+{
+	struct l2cap_cmd_rej *rej = (struct l2cap_cmd_rej *) data;
+
+	if (rej->reason != 0x0000)
+		return 0;
+
+	if ((conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) &&
+					cmd->ident == conn->info_ident) {
+		del_timer(&conn->info_timer);
+
+		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
+		conn->info_ident = 0;
+
+		l2cap_conn_start(conn);
+	}
+
+	return 0;
+}
+
+static struct sock *l2cap_create_connect(struct l2cap_conn *conn,
+						struct l2cap_cmd_hdr *cmd,
+						u8 *data, u8 rsp_code,
+						u8 amp_id)
+{
+	struct l2cap_chan_list *list = &conn->chan_list;
+	struct l2cap_conn_req *req = (struct l2cap_conn_req *) data;
+	struct l2cap_conn_rsp rsp;
+	struct sock *parent, *sk = NULL;
+	int result, status = L2CAP_CS_NO_INFO;
+
+	u16 dcid = 0, scid = __le16_to_cpu(req->scid);
+	__le16 psm = req->psm;
+
+	BT_DBG("psm 0x%2.2x scid 0x%4.4x", psm, scid);
+
+	/* Check if we have socket listening on psm */
+	parent = l2cap_get_sock_by_psm(BT_LISTEN, psm, conn->src);
+	if (!parent) {
+		result = L2CAP_CR_BAD_PSM;
+		goto sendresp;
+	}
+
+	bh_lock_sock(parent);
+
+	/* Check if the ACL is secure enough (if not SDP) */
+	if (psm != cpu_to_le16(0x0001) &&
+				!hci_conn_check_link_mode(conn->hcon)) {
+		conn->disc_reason = 0x05;
+		result = L2CAP_CR_SEC_BLOCK;
+		goto response;
+	}
+
+	result = L2CAP_CR_NO_MEM;
+
+	/* Check for backlog size */
+	if (sk_acceptq_is_full(parent)) {
+		BT_DBG("backlog full %d", parent->sk_ack_backlog);
+		goto response;
+	}
+
+	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP, GFP_ATOMIC);
+	if (!sk)
+		goto response;
+
+	write_lock_bh(&list->lock);
+
+	/* Check if we already have channel with that dcid */
+	if (__l2cap_get_chan_by_dcid(list, scid)) {
+		write_unlock_bh(&list->lock);
+		sock_set_flag(sk, SOCK_ZAPPED);
+		l2cap_sock_kill(sk);
+		sk = NULL;
+		goto response;
+	}
+
+	hci_conn_hold(conn->hcon);
+
+	l2cap_sock_init(sk, parent);
+	bacpy(&bt_sk(sk)->src, conn->src);
+	bacpy(&bt_sk(sk)->dst, conn->dst);
+	l2cap_pi(sk)->psm  = psm;
+	l2cap_pi(sk)->dcid = scid;
+
+	bt_accept_enqueue(parent, sk);
+
+	__l2cap_chan_add(conn, sk);
+	dcid = l2cap_pi(sk)->scid;
+	l2cap_pi(sk)->amp_id = amp_id;
+
+	l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
+
+	l2cap_pi(sk)->ident = cmd->ident;
+
+	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE) {
+		if (l2cap_check_security(sk)) {
+			if (bt_sk(sk)->defer_setup) {
+				sk->sk_state = BT_CONNECT2;
+				result = L2CAP_CR_PEND;
+				status = L2CAP_CS_AUTHOR_PEND;
+				parent->sk_data_ready(parent, 0);
+			} else {
+				/* Force pending result for AMP controllers.
+				 * The connection will succeed after the
+				 * physical link is up. */
+				if (amp_id) {
+					sk->sk_state = BT_CONNECT2;
+					result = L2CAP_CR_PEND;
+				} else {
+					sk->sk_state = BT_CONFIG;
+					result = L2CAP_CR_SUCCESS;
+				}
+				status = L2CAP_CS_NO_INFO;
+			}
+		} else {
+			sk->sk_state = BT_CONNECT2;
+			result = L2CAP_CR_PEND;
+			status = L2CAP_CS_AUTHEN_PEND;
+		}
+	} else {
+		sk->sk_state = BT_CONNECT2;
+		result = L2CAP_CR_PEND;
+		status = L2CAP_CS_NO_INFO;
+	}
+
+	write_unlock_bh(&list->lock);
+
+response:
+	bh_unlock_sock(parent);
+
+sendresp:
+	rsp.scid   = cpu_to_le16(scid);
+	rsp.dcid   = cpu_to_le16(dcid);
+	rsp.result = cpu_to_le16(result);
+	rsp.status = cpu_to_le16(status);
+	l2cap_send_cmd(conn, cmd->ident, rsp_code, sizeof(rsp), &rsp);
+
+	if (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)) {
+		struct l2cap_info_req info;
+		info.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);
+
+		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;
+		conn->info_ident = l2cap_get_ident(conn);
+
+		mod_timer(&conn->info_timer, jiffies +
+					msecs_to_jiffies(L2CAP_INFO_TIMEOUT));
+
+		l2cap_send_cmd(conn, conn->info_ident,
+					L2CAP_INFO_REQ, sizeof(info), &info);
+	}
+
+	if (sk && !(l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT) &&
+				result == L2CAP_CR_SUCCESS) {
+		u8 buf[128];
+		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
+		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
+					l2cap_build_conf_req(sk, buf), buf);
+		l2cap_pi(sk)->num_conf_req++;
+	}
+
+	return sk;
+}
+
+static inline int l2cap_connect_req(struct l2cap_conn *conn,
+					struct l2cap_cmd_hdr *cmd, u8 *data)
+{
+	l2cap_create_connect(conn, cmd, data, L2CAP_CONN_RSP, 0);
+	return 0;
+}
+
+static inline int l2cap_connect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+{
+	struct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;
+	u16 scid, dcid, result, status;
+	struct sock *sk;
+	u8 req[128];
+
+	scid   = __le16_to_cpu(rsp->scid);
+	dcid   = __le16_to_cpu(rsp->dcid);
+	result = __le16_to_cpu(rsp->result);
+	status = __le16_to_cpu(rsp->status);
+
+	BT_DBG("dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x", dcid, scid, result, status);
+
+	if (scid) {
+		sk = l2cap_get_chan_by_scid(&conn->chan_list, scid);
+		if (!sk)
+			return -EFAULT;
+	} else {
+		sk = l2cap_get_chan_by_ident(&conn->chan_list, cmd->ident);
+		if (!sk)
+			return -EFAULT;
+	}
+
+	switch (result) {
+	case L2CAP_CR_SUCCESS:
+		sk->sk_state = BT_CONFIG;
+		l2cap_pi(sk)->ident = 0;
+		l2cap_pi(sk)->dcid = dcid;
+		l2cap_pi(sk)->conf_state &= ~L2CAP_CONF_CONNECT_PEND;
+
+		if (l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT)
+			break;
+
+		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
+
+		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
+					l2cap_build_conf_req(sk, req), req);
+		l2cap_pi(sk)->num_conf_req++;
+		break;
+
+	case L2CAP_CR_PEND:
+		l2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;
+		break;
+
+	default:
+		/* don't delete l2cap channel if sk is owned by user */
+		if (sock_owned_by_user(sk)) {
+			sk->sk_state = BT_DISCONN;
+			l2cap_sock_clear_timer(sk);
+			l2cap_sock_set_timer(sk, HZ / 5);
+			break;
+		}
+
+		l2cap_chan_del(sk, ECONNREFUSED);
+		break;
+	}
+
+	bh_unlock_sock(sk);
+	return 0;
+}
+
+static inline void set_default_fcs(struct l2cap_pinfo *pi)
+{
+	/* FCS is enabled only in ERTM or streaming mode, if one or both
+	 * sides request it.
+	 */
+	if (pi->mode != L2CAP_MODE_ERTM && pi->mode != L2CAP_MODE_STREAMING)
+		pi->fcs = L2CAP_FCS_NONE;
+	else if (!(pi->conf_state & L2CAP_CONF_NO_FCS_RECV))
+		pi->fcs = L2CAP_FCS_CRC16;
+}
+
+static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)
+{
+	struct l2cap_conf_req *req = (struct l2cap_conf_req *) data;
+	u16 dcid, flags;
+	u8 rspbuf[64];
+	struct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *) rspbuf;
+	struct sock *sk;
+	int len;
+	u8 amp_move_reconf = 0;
+
+	dcid  = __le16_to_cpu(req->dcid);
+	flags = __le16_to_cpu(req->flags);
+
+	BT_DBG("dcid 0x%4.4x flags 0x%2.2x", dcid, flags);
+
+	sk = l2cap_get_chan_by_scid(&conn->chan_list, dcid);
+	if (!sk)
+		return -ENOENT;
+
+	BT_DBG("sk_state 0x%2.2x rx_state 0x%2.2x "
+		"reconf_state 0x%2.2x amp_id 0x%2.2x amp_move_id 0x%2.2x",
+		sk->sk_state, l2cap_pi(sk)->rx_state,
+		l2cap_pi(sk)->reconf_state, l2cap_pi(sk)->amp_id,
+		l2cap_pi(sk)->amp_move_id);
+
+	/* Detect a reconfig request due to channel move between
+	 * BR/EDR and AMP
+	 */
+	if (sk->sk_state == BT_CONNECTED &&
+		l2cap_pi(sk)->rx_state ==
+			L2CAP_ERTM_RX_STATE_WAIT_P_FLAG_RECONFIGURE)
+		l2cap_pi(sk)->reconf_state = L2CAP_RECONF_ACC;
+
+	if (l2cap_pi(sk)->reconf_state != L2CAP_RECONF_NONE)
+		amp_move_reconf = 1;
+
+	if (sk->sk_state != BT_CONFIG && !amp_move_reconf) {
+		struct l2cap_cmd_rej rej;
+
+		rej.reason = cpu_to_le16(0x0002);
+		l2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,
+				sizeof(rej), &rej);
+		goto unlock;
+	}
+
+	/* Reject if config buffer is too small. */
+	len = cmd_len - sizeof(*req);
+	if (l2cap_pi(sk)->conf_len + len > sizeof(l2cap_pi(sk)->conf_req)) {
+		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
+				l2cap_build_conf_rsp(sk, rspbuf,
+					L2CAP_CONF_REJECT, flags), rspbuf);
+		goto unlock;
+	}
+
+	/* Store config. */
+	memcpy(l2cap_pi(sk)->conf_req + l2cap_pi(sk)->conf_len, req->data, len);
+	l2cap_pi(sk)->conf_len += len;
+
+	if (flags & 0x0001) {
+		/* Incomplete config. Send empty response. */
+		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
+				l2cap_build_conf_rsp(sk, rspbuf,
+					L2CAP_CONF_SUCCESS, 0x0001), rspbuf);
+		goto unlock;
+	}
+
+	/* Complete config. */
+	if (!amp_move_reconf)
+		len = l2cap_parse_conf_req(sk, rspbuf);
+	else
+		len = l2cap_parse_amp_move_reconf_req(sk, rspbuf);
+
+	if (len < 0) {
+		l2cap_send_disconn_req(conn, sk, ECONNRESET);
+		goto unlock;
+	}
+
+	l2cap_pi(sk)->conf_ident = cmd->ident;
+	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rspbuf);
+
+	if (l2cap_pi(sk)->conf_state & L2CAP_CONF_LOCKSTEP &&
+			rsp->result == cpu_to_le16(L2CAP_CONF_PENDING) &&
+			!l2cap_pi(sk)->amp_id) {
+		/* Send success response right after pending if using
+		 * lockstep config on BR/EDR
+		 */
+		rsp->result = cpu_to_le16(L2CAP_CONF_SUCCESS);
+		l2cap_pi(sk)->conf_state |= L2CAP_CONF_OUTPUT_DONE;
+		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rspbuf);
+	}
+
+	/* Reset config buffer. */
+	l2cap_pi(sk)->conf_len = 0;
+
+	if (amp_move_reconf)
+		goto unlock;
+
+	l2cap_pi(sk)->num_conf_rsp++;
+
+	if (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE))
+		goto unlock;
+
+	if (l2cap_pi(sk)->conf_state & L2CAP_CONF_INPUT_DONE) {
+		set_default_fcs(l2cap_pi(sk));
+
+		sk->sk_state = BT_CONNECTED;
+
+		if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM ||
+			l2cap_pi(sk)->mode == L2CAP_MODE_STREAMING)
+			l2cap_ertm_init(sk);
+
+		l2cap_chan_ready(sk);
+		goto unlock;
+	}
+
+	if (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT)) {
+		u8 buf[64];
+		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
+		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
+					l2cap_build_conf_req(sk, buf), buf);
+		l2cap_pi(sk)->num_conf_req++;
+	}
+
+unlock:
+	bh_unlock_sock(sk);
+	return 0;
+}
+
+static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+{
+	struct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;
+	u16 scid, flags, result;
+	struct sock *sk;
+	struct l2cap_pinfo *pi;
+	int len = cmd->len - sizeof(*rsp);
+
+	scid   = __le16_to_cpu(rsp->scid);
+	flags  = __le16_to_cpu(rsp->flags);
+	result = __le16_to_cpu(rsp->result);
+
+	BT_DBG("scid 0x%4.4x flags 0x%2.2x result 0x%2.2x",
+			scid, flags, result);
+
+	sk = l2cap_get_chan_by_scid(&conn->chan_list, scid);
+	if (!sk)
+		return 0;
+
+	pi = l2cap_pi(sk);
+
+	if (pi->reconf_state != L2CAP_RECONF_NONE)  {
+		l2cap_amp_move_reconf_rsp(sk, rsp->data, len, result);
+		goto done;
+	}
+
+	switch (result) {
+	case L2CAP_CONF_SUCCESS:
+		if (pi->conf_state & L2CAP_CONF_LOCKSTEP &&
+				!(pi->conf_state & L2CAP_CONF_LOCKSTEP_PEND)) {
+			/* Lockstep procedure requires a pending response
+			 * before success.
+			 */
+			l2cap_send_disconn_req(conn, sk, ECONNRESET);
+			goto done;
+		}
+
+		l2cap_conf_rfc_get(sk, rsp->data, len);
+		break;
+
+	case L2CAP_CONF_PENDING:
+		if (!(pi->conf_state & L2CAP_CONF_LOCKSTEP)) {
+			l2cap_send_disconn_req(conn, sk, ECONNRESET);
 			goto done;
 		}
+
+		l2cap_conf_rfc_get(sk, rsp->data, len);
+
+		pi->conf_state |= L2CAP_CONF_LOCKSTEP_PEND;
+
+		l2cap_conf_ext_fs_get(sk, rsp->data, len);
+
+		if (pi->amp_id && pi->conf_state & L2CAP_CONF_PEND_SENT) {
+			struct hci_chan *chan;
+
+			/* Already sent a 'pending' response, so set up
+			 * the logical link now
+			 */
+			chan = l2cap_chan_admit(pi->amp_id, sk);
+			if (!chan) {
+				l2cap_send_disconn_req(pi->conn, sk,
+							ECONNRESET);
+				goto done;
+			}
+
+			if (chan->state == BT_CONNECTED)
+				l2cap_create_cfm(chan, 0);
+		}
+
+		goto done;
+
+	case L2CAP_CONF_UNACCEPT:
+		if (pi->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {
+			char req[64];
+
+			if (len > sizeof(req) - sizeof(struct l2cap_conf_req)) {
+				l2cap_send_disconn_req(conn, sk, ECONNRESET);
+				goto done;
+			}
+
+			/* throw out any old stored conf requests */
+			result = L2CAP_CONF_SUCCESS;
+			len = l2cap_parse_conf_rsp(sk, rsp->data,
+							len, req, &result);
+			if (len < 0) {
+				l2cap_send_disconn_req(conn, sk, ECONNRESET);
+				goto done;
+			}
+
+			l2cap_send_cmd(conn, l2cap_get_ident(conn),
+						L2CAP_CONF_REQ, len, req);
+			pi->num_conf_req++;
+			if (result != L2CAP_CONF_SUCCESS)
+				goto done;
+			break;
+		}
+
+	default:
+		sk->sk_err = ECONNRESET;
+		l2cap_sock_set_timer(sk, HZ * 5);
+		l2cap_send_disconn_req(conn, sk, ECONNRESET);
+		goto done;
 	}
 
-	/* Use sane default values in case a misbehaving remote device
-	 * did not send an RFC option.
-	 */
-	rfc.mode = chan->mode;
-	rfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);
-	rfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);
-	rfc.max_pdu_size = cpu_to_le16(chan->imtu);
+	if (flags & 0x01)
+		goto done;
 
-	BT_ERR("Expected RFC option was not found, using defaults");
+	pi->conf_state |= L2CAP_CONF_INPUT_DONE;
 
-done:
-	switch (rfc.mode) {
-	case L2CAP_MODE_ERTM:
-		chan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
-		chan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
-		chan->mps    = le16_to_cpu(rfc.max_pdu_size);
-		break;
-	case L2CAP_MODE_STREAMING:
-		chan->mps    = le16_to_cpu(rfc.max_pdu_size);
+	if (pi->conf_state & L2CAP_CONF_OUTPUT_DONE) {
+		set_default_fcs(pi);
+
+		sk->sk_state = BT_CONNECTED;
+
+		if (pi->mode == L2CAP_MODE_ERTM ||
+			pi->mode == L2CAP_MODE_STREAMING)
+			l2cap_ertm_init(sk);
+
+		l2cap_chan_ready(sk);
 	}
+
+done:
+	bh_unlock_sock(sk);
+	return 0;
 }
 
-static inline int l2cap_command_rej(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_disconnect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_cmd_rej_unk *rej = (struct l2cap_cmd_rej_unk *) data;
+	struct l2cap_disconn_req *req = (struct l2cap_disconn_req *) data;
+	struct l2cap_disconn_rsp rsp;
+	u16 dcid, scid;
+	struct sock *sk;
+
+	scid = __le16_to_cpu(req->scid);
+	dcid = __le16_to_cpu(req->dcid);
+
+	BT_DBG("scid 0x%4.4x dcid 0x%4.4x", scid, dcid);
 
-	if (rej->reason != L2CAP_REJ_NOT_UNDERSTOOD)
+	sk = l2cap_get_chan_by_scid(&conn->chan_list, dcid);
+	if (!sk)
 		return 0;
 
-	if ((conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) &&
-					cmd->ident == conn->info_ident) {
-		cancel_delayed_work(&conn->info_timer);
+	rsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);
+	rsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);
+	l2cap_send_cmd(conn, cmd->ident, L2CAP_DISCONN_RSP, sizeof(rsp), &rsp);
 
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-		conn->info_ident = 0;
+	/* Only do cleanup if a disconnect request was not sent already */
+	if (sk->sk_state != BT_DISCONN) {
+		sk->sk_shutdown = SHUTDOWN_MASK;
 
-		l2cap_conn_start(conn);
+		sk->sk_send_head = NULL;
+		skb_queue_purge(TX_QUEUE(sk));
+
+		if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM) {
+			skb_queue_purge(SREJ_QUEUE(sk));
+
+			__cancel_delayed_work(&l2cap_pi(sk)->ack_work);
+			__cancel_delayed_work(&l2cap_pi(sk)->retrans_work);
+			__cancel_delayed_work(&l2cap_pi(sk)->monitor_work);
+		}
 	}
 
+	/* don't delete l2cap channel if sk is owned by user */
+	if (sock_owned_by_user(sk)) {
+		sk->sk_state = BT_DISCONN;
+		l2cap_sock_clear_timer(sk);
+		l2cap_sock_set_timer(sk, HZ / 5);
+		bh_unlock_sock(sk);
+		return 0;
+	}
+
+	l2cap_chan_del(sk, ECONNRESET);
+
+	bh_unlock_sock(sk);
+
+	l2cap_sock_kill(sk);
 	return 0;
 }
 
-static inline int l2cap_connect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_disconnect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_conn_req *req = (struct l2cap_conn_req *) data;
-	struct l2cap_conn_rsp rsp;
-	struct l2cap_chan *chan = NULL, *pchan;
-	struct sock *parent, *sk = NULL;
-	int result, status = L2CAP_CS_NO_INFO;
+	struct l2cap_disconn_rsp *rsp = (struct l2cap_disconn_rsp *) data;
+	u16 dcid, scid;
+	struct sock *sk;
 
-	u16 dcid = 0, scid = __le16_to_cpu(req->scid);
-	__le16 psm = req->psm;
+	scid = __le16_to_cpu(rsp->scid);
+	dcid = __le16_to_cpu(rsp->dcid);
 
-	BT_DBG("psm 0x%2.2x scid 0x%4.4x", psm, scid);
+	BT_DBG("dcid 0x%4.4x scid 0x%4.4x", dcid, scid);
 
-	/* Check if we have socket listening on psm */
-	pchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, conn->src);
-	if (!pchan) {
-		result = L2CAP_CR_BAD_PSM;
-		goto sendresp;
+	sk = l2cap_get_chan_by_scid(&conn->chan_list, scid);
+	if (!sk)
+		return 0;
+
+	/* don't delete l2cap channel if sk is owned by user */
+	if (sock_owned_by_user(sk)) {
+		sk->sk_state = BT_DISCONN;
+		l2cap_sock_clear_timer(sk);
+		l2cap_sock_set_timer(sk, HZ / 5);
+		bh_unlock_sock(sk);
+		return 0;
 	}
 
-	parent = pchan->sk;
+	l2cap_chan_del(sk, 0);
+	bh_unlock_sock(sk);
 
-	lock_sock(parent);
+	l2cap_sock_kill(sk);
+	return 0;
+}
 
-	/* Check if the ACL is secure enough (if not SDP) */
-	if (psm != cpu_to_le16(0x0001) &&
-				!hci_conn_check_link_mode(conn->hcon)) {
-		conn->disc_reason = HCI_ERROR_AUTH_FAILURE;
-		result = L2CAP_CR_SEC_BLOCK;
-		goto response;
+static inline int l2cap_information_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+{
+	struct l2cap_info_req *req = (struct l2cap_info_req *) data;
+	u16 type;
+
+	type = __le16_to_cpu(req->type);
+
+	BT_DBG("type 0x%4.4x", type);
+
+	if (type == L2CAP_IT_FEAT_MASK) {
+		u8 buf[8];
+		u32 feat_mask = l2cap_feat_mask;
+		struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;
+		rsp->type   = cpu_to_le16(L2CAP_IT_FEAT_MASK);
+		rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);
+		if (!disable_ertm)
+			feat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING
+				| L2CAP_FEAT_FCS | L2CAP_FEAT_EXT_WINDOW;
+		put_unaligned_le32(feat_mask, rsp->data);
+		l2cap_send_cmd(conn, cmd->ident,
+					L2CAP_INFO_RSP, sizeof(buf), buf);
+	} else if (type == L2CAP_IT_FIXED_CHAN) {
+		u8 buf[12];
+		u8 fc_mask = l2cap_fc_mask;
+		struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;
+		rsp->type   = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
+		rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);
+		if (enable_hs)
+			fc_mask |= L2CAP_FC_A2MP;
+		memset(rsp->data, 0, 8);
+		rsp->data[0] = fc_mask;
+		l2cap_send_cmd(conn, cmd->ident,
+					L2CAP_INFO_RSP, sizeof(buf), buf);
+	} else {
+		struct l2cap_info_rsp rsp;
+		rsp.type   = cpu_to_le16(type);
+		rsp.result = cpu_to_le16(L2CAP_IR_NOTSUPP);
+		l2cap_send_cmd(conn, cmd->ident,
+					L2CAP_INFO_RSP, sizeof(rsp), &rsp);
+	}
+
+	return 0;
+}
+
+static inline int l2cap_information_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+{
+	struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) data;
+	u16 type, result;
+
+	type   = __le16_to_cpu(rsp->type);
+	result = __le16_to_cpu(rsp->result);
+
+	BT_DBG("type 0x%4.4x result 0x%2.2x", type, result);
+
+	/* L2CAP Info req/rsp are unbound to channels, add extra checks */
+	if (cmd->ident != conn->info_ident ||
+			conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)
+		return 0;
+
+	del_timer(&conn->info_timer);
+
+	if (result != L2CAP_IR_SUCCESS) {
+		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
+		conn->info_ident = 0;
+
+		l2cap_conn_start(conn);
+
+		return 0;
 	}
 
-	result = L2CAP_CR_NO_MEM;
+	if (type == L2CAP_IT_FEAT_MASK) {
+		conn->feat_mask = get_unaligned_le32(rsp->data);
 
-	/* Check for backlog size */
-	if (sk_acceptq_is_full(parent)) {
-		BT_DBG("backlog full %d", parent->sk_ack_backlog);
-		goto response;
-	}
+		if (conn->feat_mask & L2CAP_FEAT_FIXED_CHAN) {
+			struct l2cap_info_req req;
+			req.type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
 
-	chan = pchan->ops->new_connection(pchan->data);
-	if (!chan)
-		goto response;
+			conn->info_ident = l2cap_get_ident(conn);
+
+			l2cap_send_cmd(conn, conn->info_ident,
+					L2CAP_INFO_REQ, sizeof(req), &req);
+		} else {
+			conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
+			conn->info_ident = 0;
 
-	sk = chan->sk;
+			l2cap_conn_start(conn);
+		}
+	} else if (type == L2CAP_IT_FIXED_CHAN) {
+		conn->fc_mask = rsp->data[0];
+		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
+		conn->info_ident = 0;
 
-	/* Check if we already have channel with that dcid */
-	if (__l2cap_get_chan_by_dcid(conn, scid)) {
-		sock_set_flag(sk, SOCK_ZAPPED);
-		chan->ops->close(chan->data);
-		goto response;
+		l2cap_conn_start(conn);
 	}
 
-	hci_conn_hold(conn->hcon);
-
-	bacpy(&bt_sk(sk)->src, conn->src);
-	bacpy(&bt_sk(sk)->dst, conn->dst);
-	chan->psm  = psm;
-	chan->dcid = scid;
+	return 0;
+}
 
-	bt_accept_enqueue(parent, sk);
+static void l2cap_send_move_chan_req(struct l2cap_conn *conn,
+			struct l2cap_pinfo *pi, u16 icid, u8 dest_amp_id)
+{
+	struct l2cap_move_chan_req req;
+	u8 ident;
 
-	l2cap_chan_add(conn, chan);
+	BT_DBG("pi %p, icid %d, dest_amp_id %d", pi, (int) icid,
+		(int) dest_amp_id);
 
-	dcid = chan->scid;
+	ident = l2cap_get_ident(conn);
+	if (pi)
+		pi->ident = ident;
 
-	__set_chan_timer(chan, sk->sk_sndtimeo);
+	req.icid = cpu_to_le16(icid);
+	req.dest_amp_id = dest_amp_id;
 
-	chan->ident = cmd->ident;
+	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_REQ, sizeof(req), &req);
+}
 
-	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE) {
-		if (l2cap_chan_check_security(chan)) {
-			if (bt_sk(sk)->defer_setup) {
-				l2cap_state_change(chan, BT_CONNECT2);
-				result = L2CAP_CR_PEND;
-				status = L2CAP_CS_AUTHOR_PEND;
-				parent->sk_data_ready(parent, 0);
-			} else {
-				l2cap_state_change(chan, BT_CONFIG);
-				result = L2CAP_CR_SUCCESS;
-				status = L2CAP_CS_NO_INFO;
-			}
-		} else {
-			l2cap_state_change(chan, BT_CONNECT2);
-			result = L2CAP_CR_PEND;
-			status = L2CAP_CS_AUTHEN_PEND;
-		}
-	} else {
-		l2cap_state_change(chan, BT_CONNECT2);
-		result = L2CAP_CR_PEND;
-		status = L2CAP_CS_NO_INFO;
-	}
+static void l2cap_send_move_chan_rsp(struct l2cap_conn *conn, u8 ident,
+				u16 icid, u16 result)
+{
+	struct l2cap_move_chan_rsp rsp;
 
-response:
-	release_sock(parent);
+	BT_DBG("icid %d, result %d", (int) icid, (int) result);
 
-sendresp:
-	rsp.scid   = cpu_to_le16(scid);
-	rsp.dcid   = cpu_to_le16(dcid);
+	rsp.icid = cpu_to_le16(icid);
 	rsp.result = cpu_to_le16(result);
-	rsp.status = cpu_to_le16(status);
-	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONN_RSP, sizeof(rsp), &rsp);
 
-	if (result == L2CAP_CR_PEND && status == L2CAP_CS_NO_INFO) {
-		struct l2cap_info_req info;
-		info.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);
+	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_RSP, sizeof(rsp), &rsp);
+}
 
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;
-		conn->info_ident = l2cap_get_ident(conn);
+static void l2cap_send_move_chan_cfm(struct l2cap_conn *conn,
+				struct l2cap_pinfo *pi, u16 icid, u16 result)
+{
+	struct l2cap_move_chan_cfm cfm;
+	u8 ident;
 
-		schedule_delayed_work(&conn->info_timer,
-					msecs_to_jiffies(L2CAP_INFO_TIMEOUT));
+	BT_DBG("icid %d, result %d", (int) icid, (int) result);
 
-		l2cap_send_cmd(conn, conn->info_ident,
-					L2CAP_INFO_REQ, sizeof(info), &info);
-	}
+	ident = l2cap_get_ident(conn);
+	if (pi)
+		pi->ident = ident;
 
-	if (chan && !test_bit(CONF_REQ_SENT, &chan->conf_state) &&
-				result == L2CAP_CR_SUCCESS) {
-		u8 buf[128];
-		set_bit(CONF_REQ_SENT, &chan->conf_state);
-		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-					l2cap_build_conf_req(chan, buf), buf);
-		chan->num_conf_req++;
-	}
+	cfm.icid = cpu_to_le16(icid);
+	cfm.result = cpu_to_le16(result);
 
-	return 0;
+	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM, sizeof(cfm), &cfm);
 }
 
-static inline int l2cap_connect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+static void l2cap_send_move_chan_cfm_rsp(struct l2cap_conn *conn, u8 ident,
+					u16 icid)
 {
-	struct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;
-	u16 scid, dcid, result, status;
-	struct l2cap_chan *chan;
+	struct l2cap_move_chan_cfm_rsp rsp;
+
+	BT_DBG("icid %d", (int) icid);
+
+	rsp.icid = cpu_to_le16(icid);
+	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM_RSP, sizeof(rsp), &rsp);
+}
+
+static inline int l2cap_create_channel_req(struct l2cap_conn *conn,
+					struct l2cap_cmd_hdr *cmd, u8 *data)
+{
+	struct l2cap_create_chan_req *req =
+		(struct l2cap_create_chan_req *) data;
 	struct sock *sk;
-	u8 req[128];
+	u16 psm, scid;
 
-	scid   = __le16_to_cpu(rsp->scid);
-	dcid   = __le16_to_cpu(rsp->dcid);
-	result = __le16_to_cpu(rsp->result);
-	status = __le16_to_cpu(rsp->status);
+	psm = le16_to_cpu(req->psm);
+	scid = le16_to_cpu(req->scid);
 
-	BT_DBG("dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x", dcid, scid, result, status);
+	BT_DBG("psm %d, scid %d, amp_id %d", (int) psm, (int) scid,
+		(int) req->amp_id);
 
-	if (scid) {
-		chan = l2cap_get_chan_by_scid(conn, scid);
-		if (!chan)
-			return -EFAULT;
-	} else {
-		chan = l2cap_get_chan_by_ident(conn, cmd->ident);
-		if (!chan)
-			return -EFAULT;
-	}
+	if (req->amp_id) {
+		struct hci_dev *hdev;
 
-	sk = chan->sk;
+		/* Validate AMP controller id */
+		hdev = hci_dev_get(req->amp_id);
+		if (!hdev || !test_bit(HCI_UP, &hdev->flags)) {
+			struct l2cap_create_chan_rsp rsp;
 
-	switch (result) {
-	case L2CAP_CR_SUCCESS:
-		l2cap_state_change(chan, BT_CONFIG);
-		chan->ident = 0;
-		chan->dcid = dcid;
-		clear_bit(CONF_CONNECT_PEND, &chan->conf_state);
+			rsp.dcid = 0;
+			rsp.scid = cpu_to_le16(scid);
+			rsp.result = L2CAP_CREATE_CHAN_REFUSED_CONTROLLER;
+			rsp.status = L2CAP_CREATE_CHAN_STATUS_NONE;
 
-		if (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))
-			break;
+			l2cap_send_cmd(conn, cmd->ident, L2CAP_CREATE_CHAN_RSP,
+				       sizeof(rsp), &rsp);
 
-		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-					l2cap_build_conf_req(chan, req), req);
-		chan->num_conf_req++;
-		break;
+			if (hdev)
+				hci_dev_put(hdev);
 
-	case L2CAP_CR_PEND:
-		set_bit(CONF_CONNECT_PEND, &chan->conf_state);
-		break;
+			return 0;
+		}
 
-	default:
-		l2cap_chan_del(chan, ECONNREFUSED);
-		break;
+		hci_dev_put(hdev);
 	}
 
-	release_sock(sk);
+	sk = l2cap_create_connect(conn, cmd, data, L2CAP_CREATE_CHAN_RSP,
+					req->amp_id);
+
+	if (sk)
+		l2cap_pi(sk)->conf_state |= L2CAP_CONF_LOCKSTEP;
+
+	if (sk && req->amp_id &&
+			(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE))
+		amp_accept_physical(conn, req->amp_id, sk);
+
 	return 0;
 }
 
-static inline void set_default_fcs(struct l2cap_chan *chan)
+static inline int l2cap_create_channel_rsp(struct l2cap_conn *conn,
+					struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	/* FCS is enabled only in ERTM or streaming mode, if one or both
-	 * sides request it.
-	 */
-	if (chan->mode != L2CAP_MODE_ERTM && chan->mode != L2CAP_MODE_STREAMING)
-		chan->fcs = L2CAP_FCS_NONE;
-	else if (!test_bit(CONF_NO_FCS_RECV, &chan->conf_state))
-		chan->fcs = L2CAP_FCS_CRC16;
+	BT_DBG("conn %p", conn);
+
+	return l2cap_connect_rsp(conn, cmd, data);
 }
 
-static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)
+static inline int l2cap_move_channel_req(struct l2cap_conn *conn,
+					struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_conf_req *req = (struct l2cap_conf_req *) data;
-	u16 dcid, flags;
-	u8 rsp[64];
-	struct l2cap_chan *chan;
+	struct l2cap_move_chan_req *req = (struct l2cap_move_chan_req *) data;
 	struct sock *sk;
-	int len;
-
-	dcid  = __le16_to_cpu(req->dcid);
-	flags = __le16_to_cpu(req->flags);
+	struct l2cap_pinfo *pi;
+	u16 icid = 0;
+	u16 result = L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED;
 
-	BT_DBG("dcid 0x%4.4x flags 0x%2.2x", dcid, flags);
+	icid = le16_to_cpu(req->icid);
 
-	chan = l2cap_get_chan_by_scid(conn, dcid);
-	if (!chan)
-		return -ENOENT;
+	BT_DBG("icid %d, dest_amp_id %d", (int) icid, (int) req->dest_amp_id);
 
-	sk = chan->sk;
+	read_lock(&conn->chan_list.lock);
+	sk = __l2cap_get_chan_by_dcid(&conn->chan_list, icid);
+	read_unlock(&conn->chan_list.lock);
 
-	if (chan->state != BT_CONFIG && chan->state != BT_CONNECT2) {
-		struct l2cap_cmd_rej_cid rej;
+	if (!sk)
+		goto send_move_response;
 
-		rej.reason = cpu_to_le16(L2CAP_REJ_INVALID_CID);
-		rej.scid = cpu_to_le16(chan->scid);
-		rej.dcid = cpu_to_le16(chan->dcid);
+	lock_sock(sk);
+	pi = l2cap_pi(sk);
 
-		l2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,
-				sizeof(rej), &rej);
-		goto unlock;
+	if (pi->scid < L2CAP_CID_DYN_START ||
+		(pi->mode != L2CAP_MODE_ERTM &&
+		 pi->mode != L2CAP_MODE_STREAMING)) {
+		goto send_move_response;
 	}
 
-	/* Reject if config buffer is too small. */
-	len = cmd_len - sizeof(*req);
-	if (len < 0 || chan->conf_len + len > sizeof(chan->conf_req)) {
-		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
-				l2cap_build_conf_rsp(chan, rsp,
-					L2CAP_CONF_REJECT, flags), rsp);
-		goto unlock;
+	if (pi->amp_id == req->dest_amp_id) {
+		result = L2CAP_MOVE_CHAN_REFUSED_SAME_ID;
+		goto send_move_response;
 	}
 
-	/* Store config. */
-	memcpy(chan->conf_req + chan->conf_len, req->data, len);
-	chan->conf_len += len;
-
-	if (flags & 0x0001) {
-		/* Incomplete config. Send empty response. */
-		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
-				l2cap_build_conf_rsp(chan, rsp,
-					L2CAP_CONF_SUCCESS, 0x0001), rsp);
-		goto unlock;
-	}
+	if (req->dest_amp_id) {
+		struct hci_dev *hdev;
+		hdev = hci_dev_get(req->dest_amp_id);
+		if (!hdev || !test_bit(HCI_UP, &hdev->flags)) {
+			if (hdev)
+				hci_dev_put(hdev);
 
-	/* Complete config. */
-	len = l2cap_parse_conf_req(chan, rsp);
-	if (len < 0) {
-		l2cap_send_disconn_req(conn, chan, ECONNRESET);
-		goto unlock;
+			result = L2CAP_MOVE_CHAN_REFUSED_CONTROLLER;
+			goto send_move_response;
+		}
+		hci_dev_put(hdev);
 	}
 
-	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);
-	chan->num_conf_rsp++;
-
-	/* Reset config buffer. */
-	chan->conf_len = 0;
-
-	if (!test_bit(CONF_OUTPUT_DONE, &chan->conf_state))
-		goto unlock;
-
-	if (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {
-		set_default_fcs(chan);
-
-		l2cap_state_change(chan, BT_CONNECTED);
-
-		chan->next_tx_seq = 0;
-		chan->expected_tx_seq = 0;
-		skb_queue_head_init(&chan->tx_q);
-		if (chan->mode == L2CAP_MODE_ERTM)
-			l2cap_ertm_init(chan);
-
-		l2cap_chan_ready(sk);
-		goto unlock;
+	if (((pi->amp_move_state != L2CAP_AMP_STATE_STABLE &&
+		pi->amp_move_state != L2CAP_AMP_STATE_WAIT_PREPARE) ||
+		pi->amp_move_role != L2CAP_AMP_MOVE_NONE) &&
+		bacmp(conn->src, conn->dst) > 0) {
+		result = L2CAP_MOVE_CHAN_REFUSED_COLLISION;
+		goto send_move_response;
 	}
 
-	if (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {
-		u8 buf[64];
-		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-					l2cap_build_conf_req(chan, buf), buf);
-		chan->num_conf_req++;
+	if (pi->amp_pref == BT_AMP_POLICY_REQUIRE_BR_EDR) {
+		result = L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED;
+		goto send_move_response;
 	}
 
-	/* Got Conf Rsp PENDING from remote side and asume we sent
-	   Conf Rsp PENDING in the code above */
-	if (test_bit(CONF_REM_CONF_PEND, &chan->conf_state) &&
-			test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {
+	pi->amp_move_cmd_ident = cmd->ident;
+	pi->amp_move_role = L2CAP_AMP_MOVE_RESPONDER;
+	l2cap_amp_move_setup(sk);
+	pi->amp_move_id = req->dest_amp_id;
+	icid = pi->dcid;
 
-		/* check compatibility */
+	if (req->dest_amp_id == 0) {
+		/* Moving to BR/EDR */
+		if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
+			pi->amp_move_state = L2CAP_AMP_STATE_WAIT_LOCAL_BUSY;
+			result = L2CAP_MOVE_CHAN_PENDING;
+		} else {
+			pi->amp_move_state = L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM;
+			result = L2CAP_MOVE_CHAN_SUCCESS;
+		}
+	} else {
+		pi->amp_move_state = L2CAP_AMP_STATE_WAIT_PREPARE;
+		amp_accept_physical(pi->conn, req->dest_amp_id, sk);
+		result = L2CAP_MOVE_CHAN_PENDING;
+	}
 
-		clear_bit(CONF_LOC_CONF_PEND, &chan->conf_state);
-		set_bit(CONF_OUTPUT_DONE, &chan->conf_state);
+send_move_response:
+	l2cap_send_move_chan_rsp(conn, cmd->ident, icid, result);
 
-		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
-					l2cap_build_conf_rsp(chan, rsp,
-					L2CAP_CONF_SUCCESS, 0x0000), rsp);
-	}
+	if (sk)
+		release_sock(sk);
 
-unlock:
-	release_sock(sk);
 	return 0;
 }
 
-static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_move_channel_rsp(struct l2cap_conn *conn,
+					struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;
-	u16 scid, flags, result;
-	struct l2cap_chan *chan;
+	struct l2cap_move_chan_rsp *rsp = (struct l2cap_move_chan_rsp *) data;
 	struct sock *sk;
-	int len = cmd->len - sizeof(*rsp);
-
-	scid   = __le16_to_cpu(rsp->scid);
-	flags  = __le16_to_cpu(rsp->flags);
-	result = __le16_to_cpu(rsp->result);
-
-	BT_DBG("scid 0x%4.4x flags 0x%2.2x result 0x%2.2x",
-			scid, flags, result);
+	struct l2cap_pinfo *pi;
+	u16 icid, result;
 
-	chan = l2cap_get_chan_by_scid(conn, scid);
-	if (!chan)
-		return 0;
+	icid = le16_to_cpu(rsp->icid);
+	result = le16_to_cpu(rsp->result);
 
-	sk = chan->sk;
+	BT_DBG("icid %d, result %d", (int) icid, (int) result);
 
 	switch (result) {
-	case L2CAP_CONF_SUCCESS:
-		l2cap_conf_rfc_get(chan, rsp->data, len);
-		clear_bit(CONF_REM_CONF_PEND, &chan->conf_state);
-		break;
-
-	case L2CAP_CONF_PENDING:
-		set_bit(CONF_REM_CONF_PEND, &chan->conf_state);
-
-		if (test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {
-			char buf[64];
+	case L2CAP_MOVE_CHAN_SUCCESS:
+	case L2CAP_MOVE_CHAN_PENDING:
+		read_lock(&conn->chan_list.lock);
+		sk = __l2cap_get_chan_by_scid(&conn->chan_list, icid);
+		read_unlock(&conn->chan_list.lock);
+
+		if (!sk) {
+			l2cap_send_move_chan_cfm(conn, NULL, icid,
+						L2CAP_MOVE_CHAN_UNCONFIRMED);
+			break;
+		}
 
-			len = l2cap_parse_conf_rsp(chan, rsp->data, len,
-								buf, &result);
-			if (len < 0) {
-				l2cap_send_disconn_req(conn, chan, ECONNRESET);
-				goto done;
+		lock_sock(sk);
+		pi = l2cap_pi(sk);
+
+		l2cap_sock_clear_timer(sk);
+		if (result == L2CAP_MOVE_CHAN_PENDING)
+			l2cap_sock_set_timer(sk, L2CAP_MOVE_ERTX_TIMEOUT);
+
+		if (pi->amp_move_state ==
+				L2CAP_AMP_STATE_WAIT_LOGICAL_COMPLETE) {
+			/* Move confirm will be sent when logical link
+			 * is complete.
+			 */
+			pi->amp_move_state =
+				L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM;
+		} else if (pi->amp_move_state ==
+				L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS) {
+			if (result == L2CAP_MOVE_CHAN_PENDING) {
+				break;
+			} else if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
+				pi->amp_move_state =
+					L2CAP_AMP_STATE_WAIT_LOCAL_BUSY;
+			} else {
+				/* Logical link is up or moving to BR/EDR,
+				 * proceed with move */
+				pi->amp_move_state =
+					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP;
+				l2cap_send_move_chan_cfm(conn, pi, pi->scid,
+						L2CAP_MOVE_CHAN_CONFIRMED);
+				l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
+			}
+		} else if (pi->amp_move_state ==
+				L2CAP_AMP_STATE_WAIT_MOVE_RSP) {
+			struct l2cap_conf_ext_fs default_fs = {1, 1, 0xFFFF,
+					0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
+			struct hci_chan *chan;
+			/* Moving to AMP */
+			if (result == L2CAP_MOVE_CHAN_SUCCESS) {
+				/* Remote is ready, send confirm immediately
+				 * after logical link is ready
+				 */
+				pi->amp_move_state =
+					L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM;
+			} else {
+				/* Both logical link and move success
+				 * are required to confirm
+				 */
+				pi->amp_move_state =
+					L2CAP_AMP_STATE_WAIT_LOGICAL_COMPLETE;
+			}
+			pi->remote_fs = default_fs;
+			pi->local_fs = default_fs;
+			chan = l2cap_chan_admit(pi->amp_move_id, sk);
+			if (!chan) {
+				/* Logical link not available */
+				l2cap_send_move_chan_cfm(conn, pi, pi->scid,
+						L2CAP_MOVE_CHAN_UNCONFIRMED);
+				break;
 			}
 
-			/* check compatibility */
-
-			clear_bit(CONF_LOC_CONF_PEND, &chan->conf_state);
-			set_bit(CONF_OUTPUT_DONE, &chan->conf_state);
-
-			l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
-						l2cap_build_conf_rsp(chan, buf,
-						L2CAP_CONF_SUCCESS, 0x0000), buf);
-		}
-		goto done;
-
-	case L2CAP_CONF_UNACCEPT:
-		if (chan->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {
-			char req[64];
+			if (chan->state == BT_CONNECTED) {
+				/* Logical link is already ready to go */
+				pi->ampcon = chan->conn;
+				pi->ampcon->l2cap_data = pi->conn;
+				if (result == L2CAP_MOVE_CHAN_SUCCESS) {
+					/* Can confirm now */
+					l2cap_send_move_chan_cfm(conn, pi,
+						pi->scid,
+						L2CAP_MOVE_CHAN_CONFIRMED);
+				} else {
+					/* Now only need move success
+					 * required to confirm
+					 */
+					pi->amp_move_state =
+					L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS;
+				}
 
-			if (len > sizeof(req) - sizeof(struct l2cap_conf_req)) {
-				l2cap_send_disconn_req(conn, chan, ECONNRESET);
-				goto done;
+				l2cap_create_cfm(chan, 0);
 			}
+		} else {
+			/* Any other amp move state means the move failed. */
+			pi->amp_move_id = pi->amp_id;
+			pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
+			l2cap_amp_move_revert(sk);
+			pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
+			l2cap_send_move_chan_cfm(conn, pi, pi->scid,
+						L2CAP_MOVE_CHAN_UNCONFIRMED);
+			l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
+		}
+		break;
+	default:
+		/* Failed (including collision case) */
+		read_lock(&conn->chan_list.lock);
+		sk = __l2cap_get_chan_by_ident(&conn->chan_list, cmd->ident);
+		read_unlock(&conn->chan_list.lock);
+
+		if (!sk) {
+			/* Could not locate channel, icid is best guess */
+			l2cap_send_move_chan_cfm(conn, NULL, icid,
+						L2CAP_MOVE_CHAN_UNCONFIRMED);
+			break;
+		}
 
-			/* throw out any old stored conf requests */
-			result = L2CAP_CONF_SUCCESS;
-			len = l2cap_parse_conf_rsp(chan, rsp->data, len,
-								req, &result);
-			if (len < 0) {
-				l2cap_send_disconn_req(conn, chan, ECONNRESET);
-				goto done;
+		lock_sock(sk);
+		pi = l2cap_pi(sk);
+
+		l2cap_sock_clear_timer(sk);
+
+		if (pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
+			if (result == L2CAP_MOVE_CHAN_REFUSED_COLLISION)
+				pi->amp_move_role = L2CAP_AMP_MOVE_RESPONDER;
+			else {
+				/* Cleanup - cancel move */
+				pi->amp_move_id = pi->amp_id;
+				pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
+				l2cap_amp_move_revert(sk);
+				pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
 			}
-
-			l2cap_send_cmd(conn, l2cap_get_ident(conn),
-						L2CAP_CONF_REQ, len, req);
-			chan->num_conf_req++;
-			if (result != L2CAP_CONF_SUCCESS)
-				goto done;
-			break;
 		}
 
-	default:
-		sk->sk_err = ECONNRESET;
-		__set_chan_timer(chan,
-				msecs_to_jiffies(L2CAP_DISC_REJ_TIMEOUT));
-		l2cap_send_disconn_req(conn, chan, ECONNRESET);
-		goto done;
+		l2cap_send_move_chan_cfm(conn, pi, pi->scid,
+					L2CAP_MOVE_CHAN_UNCONFIRMED);
+		l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
+		break;
 	}
 
-	if (flags & 0x01)
-		goto done;
-
-	set_bit(CONF_INPUT_DONE, &chan->conf_state);
-
-	if (test_bit(CONF_OUTPUT_DONE, &chan->conf_state)) {
-		set_default_fcs(chan);
-
-		l2cap_state_change(chan, BT_CONNECTED);
-		chan->next_tx_seq = 0;
-		chan->expected_tx_seq = 0;
-		skb_queue_head_init(&chan->tx_q);
-		if (chan->mode ==  L2CAP_MODE_ERTM)
-			l2cap_ertm_init(chan);
-
-		l2cap_chan_ready(sk);
-	}
+	if (sk)
+		release_sock(sk);
 
-done:
-	release_sock(sk);
 	return 0;
 }
 
-static inline int l2cap_disconnect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_move_channel_confirm(struct l2cap_conn *conn,
+					struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_disconn_req *req = (struct l2cap_disconn_req *) data;
-	struct l2cap_disconn_rsp rsp;
-	u16 dcid, scid;
-	struct l2cap_chan *chan;
+	struct l2cap_move_chan_cfm *cfm = (struct l2cap_move_chan_cfm *) data;
 	struct sock *sk;
+	struct l2cap_pinfo *pi;
+	u16 icid, result;
 
-	scid = __le16_to_cpu(req->scid);
-	dcid = __le16_to_cpu(req->dcid);
+	icid = le16_to_cpu(cfm->icid);
+	result = le16_to_cpu(cfm->result);
 
-	BT_DBG("scid 0x%4.4x dcid 0x%4.4x", scid, dcid);
+	BT_DBG("icid %d, result %d", (int) icid, (int) result);
 
-	chan = l2cap_get_chan_by_scid(conn, dcid);
-	if (!chan)
-		return 0;
+	read_lock(&conn->chan_list.lock);
+	sk = __l2cap_get_chan_by_dcid(&conn->chan_list, icid);
+	read_unlock(&conn->chan_list.lock);
 
-	sk = chan->sk;
+	if (!sk) {
+		BT_DBG("Bad channel (%d)", (int) icid);
+		goto send_move_confirm_response;
+	}
 
-	rsp.dcid = cpu_to_le16(chan->scid);
-	rsp.scid = cpu_to_le16(chan->dcid);
-	l2cap_send_cmd(conn, cmd->ident, L2CAP_DISCONN_RSP, sizeof(rsp), &rsp);
+	lock_sock(sk);
+	pi = l2cap_pi(sk);
+
+	if (pi->amp_move_state == L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM) {
+		pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
+		if (result == L2CAP_MOVE_CHAN_CONFIRMED) {
+			pi->amp_id = pi->amp_move_id;
+			if (!pi->amp_id && pi->ampchan) {
+				struct hci_chan *ampchan = pi->ampchan;
+				struct hci_conn *ampcon = pi->ampcon;
+				/* Have moved off of AMP, free the channel */
+				pi->ampchan = NULL;
+				pi->ampcon = NULL;
+				if (hci_chan_put(ampchan))
+					ampcon->l2cap_data = NULL;
+				else
+					l2cap_deaggregate(ampchan, pi);
+			}
+			l2cap_amp_move_success(sk);
+		} else {
+			pi->amp_move_id = pi->amp_id;
+			l2cap_amp_move_revert(sk);
+		}
+		pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
+	} else if (pi->amp_move_state ==
+			L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM) {
+		BT_DBG("Bad AMP_MOVE_STATE (%d)", pi->amp_move_state);
+	}
 
-	sk->sk_shutdown = SHUTDOWN_MASK;
+send_move_confirm_response:
+	l2cap_send_move_chan_cfm_rsp(conn, cmd->ident, icid);
 
-	l2cap_chan_del(chan, ECONNRESET);
-	release_sock(sk);
+	if (sk)
+		release_sock(sk);
 
-	chan->ops->close(chan->data);
 	return 0;
 }
 
-static inline int l2cap_disconnect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+static inline int l2cap_move_channel_confirm_rsp(struct l2cap_conn *conn,
+					struct l2cap_cmd_hdr *cmd, u8 *data)
 {
-	struct l2cap_disconn_rsp *rsp = (struct l2cap_disconn_rsp *) data;
-	u16 dcid, scid;
-	struct l2cap_chan *chan;
+	struct l2cap_move_chan_cfm_rsp *rsp =
+		(struct l2cap_move_chan_cfm_rsp *) data;
 	struct sock *sk;
+	struct l2cap_pinfo *pi;
 
-	scid = __le16_to_cpu(rsp->scid);
-	dcid = __le16_to_cpu(rsp->dcid);
+	u16 icid;
 
-	BT_DBG("dcid 0x%4.4x scid 0x%4.4x", dcid, scid);
+	icid = le16_to_cpu(rsp->icid);
+
+	BT_DBG("icid %d", (int) icid);
+
+	read_lock(&conn->chan_list.lock);
+	sk = __l2cap_get_chan_by_scid(&conn->chan_list, icid);
+	read_unlock(&conn->chan_list.lock);
 
-	chan = l2cap_get_chan_by_scid(conn, scid);
-	if (!chan)
+	if (!sk)
 		return 0;
 
-	sk = chan->sk;
+	lock_sock(sk);
+	pi = l2cap_pi(sk);
+
+	l2cap_sock_clear_timer(sk);
+
+	if (pi->amp_move_state ==
+			L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP) {
+		pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
+		pi->amp_id = pi->amp_move_id;
+
+		if (!pi->amp_id && pi->ampchan) {
+			struct hci_chan *ampchan = pi->ampchan;
+			struct hci_conn *ampcon = pi->ampcon;
+			/* Have moved off of AMP, free the channel */
+			pi->ampchan = NULL;
+			pi->ampcon = NULL;
+			if (hci_chan_put(ampchan))
+				ampcon->l2cap_data = NULL;
+			else
+				l2cap_deaggregate(ampchan, pi);
+		}
+
+		l2cap_amp_move_success(sk);
+
+		pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
+	}
 
-	l2cap_chan_del(chan, 0);
 	release_sock(sk);
 
-	chan->ops->close(chan->data);
 	return 0;
 }
 
-static inline int l2cap_information_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+static void l2cap_amp_signal_worker(struct work_struct *work)
 {
-	struct l2cap_info_req *req = (struct l2cap_info_req *) data;
-	u16 type;
+	int err = 0;
+	struct l2cap_amp_signal_work *ampwork =
+		container_of(work, struct l2cap_amp_signal_work, work);
 
-	type = __le16_to_cpu(req->type);
+	switch (ampwork->cmd.code) {
+	case L2CAP_MOVE_CHAN_REQ:
+		err = l2cap_move_channel_req(ampwork->conn, &ampwork->cmd,
+						ampwork->data);
+		break;
 
-	BT_DBG("type 0x%4.4x", type);
+	case L2CAP_MOVE_CHAN_RSP:
+		err = l2cap_move_channel_rsp(ampwork->conn, &ampwork->cmd,
+						ampwork->data);
+		break;
 
-	if (type == L2CAP_IT_FEAT_MASK) {
-		u8 buf[8];
-		u32 feat_mask = l2cap_feat_mask;
-		struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;
-		rsp->type   = cpu_to_le16(L2CAP_IT_FEAT_MASK);
-		rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);
-		if (!disable_ertm)
-			feat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING
-							 | L2CAP_FEAT_FCS;
-		if (enable_hs)
-			feat_mask |= L2CAP_FEAT_EXT_FLOW
-						| L2CAP_FEAT_EXT_WINDOW;
+	case L2CAP_MOVE_CHAN_CFM:
+		err = l2cap_move_channel_confirm(ampwork->conn, &ampwork->cmd,
+						ampwork->data);
+		break;
 
-		put_unaligned_le32(feat_mask, rsp->data);
-		l2cap_send_cmd(conn, cmd->ident,
-					L2CAP_INFO_RSP, sizeof(buf), buf);
-	} else if (type == L2CAP_IT_FIXED_CHAN) {
-		u8 buf[12];
-		struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;
+	case L2CAP_MOVE_CHAN_CFM_RSP:
+		err = l2cap_move_channel_confirm_rsp(ampwork->conn,
+						&ampwork->cmd, ampwork->data);
+		break;
 
-		if (enable_hs)
-			l2cap_fixed_chan[0] |= L2CAP_FC_A2MP;
-		else
-			l2cap_fixed_chan[0] &= ~L2CAP_FC_A2MP;
+	default:
+		BT_ERR("Unknown signaling command 0x%2.2x", ampwork->cmd.code);
+		err = -EINVAL;
+		break;
+	}
 
-		rsp->type   = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
-		rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);
-		memcpy(rsp->data, l2cap_fixed_chan, sizeof(l2cap_fixed_chan));
-		l2cap_send_cmd(conn, cmd->ident,
-					L2CAP_INFO_RSP, sizeof(buf), buf);
-	} else {
-		struct l2cap_info_rsp rsp;
-		rsp.type   = cpu_to_le16(type);
-		rsp.result = cpu_to_le16(L2CAP_IR_NOTSUPP);
-		l2cap_send_cmd(conn, cmd->ident,
-					L2CAP_INFO_RSP, sizeof(rsp), &rsp);
+	if (err) {
+		struct l2cap_cmd_rej rej;
+		BT_DBG("error %d", err);
+
+		/* In this context, commands are only rejected with
+		 * "command not understood", code 0.
+		 */
+		rej.reason = cpu_to_le16(0);
+		l2cap_send_cmd(ampwork->conn, ampwork->cmd.ident,
+				L2CAP_COMMAND_REJ, sizeof(rej), &rej);
 	}
 
-	return 0;
+	kfree_skb(ampwork->skb);
+	kfree(ampwork);
 }
 
-static inline int l2cap_information_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
+void l2cap_amp_physical_complete(int result, u8 local_id, u8 remote_id,
+				struct sock *sk)
 {
-	struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) data;
-	u16 type, result;
-
-	type   = __le16_to_cpu(rsp->type);
-	result = __le16_to_cpu(rsp->result);
+	struct l2cap_pinfo *pi;
 
-	BT_DBG("type 0x%4.4x result 0x%2.2x", type, result);
-
-	/* L2CAP Info req/rsp are unbound to channels, add extra checks */
-	if (cmd->ident != conn->info_ident ||
-			conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)
-		return 0;
-
-	cancel_delayed_work(&conn->info_timer);
-
-	if (result != L2CAP_IR_SUCCESS) {
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-		conn->info_ident = 0;
+	BT_DBG("result %d, local_id %d, remote_id %d, sk %p", result,
+		(int) local_id, (int) remote_id, sk);
 
-		l2cap_conn_start(conn);
+	lock_sock(sk);
 
-		return 0;
+	if (sk->sk_state == BT_DISCONN || sk->sk_state == BT_CLOSED) {
+		release_sock(sk);
+		return;
 	}
 
-	if (type == L2CAP_IT_FEAT_MASK) {
-		conn->feat_mask = get_unaligned_le32(rsp->data);
-
-		if (conn->feat_mask & L2CAP_FEAT_FIXED_CHAN) {
-			struct l2cap_info_req req;
-			req.type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
+	pi = l2cap_pi(sk);
 
-			conn->info_ident = l2cap_get_ident(conn);
+	if (sk->sk_state != BT_CONNECTED) {
+		if (bt_sk(sk)->parent) {
+			struct l2cap_conn_rsp rsp;
+			char buf[128];
+			rsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);
+			rsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);
+
+			/* Incoming channel on AMP */
+			if (result == L2CAP_CREATE_CHAN_SUCCESS) {
+				/* Send successful response */
+				rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
+				rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
+			} else {
+				/* Send negative response */
+				rsp.result = cpu_to_le16(L2CAP_CR_NO_MEM);
+				rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
+			}
 
-			l2cap_send_cmd(conn, conn->info_ident,
-					L2CAP_INFO_REQ, sizeof(req), &req);
+			l2cap_send_cmd(pi->conn, pi->ident,
+					L2CAP_CREATE_CHAN_RSP,
+					sizeof(rsp), &rsp);
+
+			if (result == L2CAP_CREATE_CHAN_SUCCESS) {
+				sk->sk_state = BT_CONFIG;
+				pi->conf_state |= L2CAP_CONF_REQ_SENT;
+				l2cap_send_cmd(pi->conn,
+					l2cap_get_ident(pi->conn),
+					L2CAP_CONF_REQ,
+					l2cap_build_conf_req(sk, buf), buf);
+				l2cap_pi(sk)->num_conf_req++;
+			}
 		} else {
-			conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-			conn->info_ident = 0;
-
-			l2cap_conn_start(conn);
+			/* Outgoing channel on AMP */
+			if (result != L2CAP_CREATE_CHAN_SUCCESS) {
+				/* Revert to BR/EDR connect */
+				l2cap_send_conn_req(sk);
+			} else {
+				pi->amp_id = local_id;
+				l2cap_send_create_chan_req(sk, remote_id);
+			}
+		}
+	} else if (result == L2CAP_MOVE_CHAN_SUCCESS &&
+		pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
+		l2cap_amp_move_setup(sk);
+		pi->amp_move_id = local_id;
+		pi->amp_move_state = L2CAP_AMP_STATE_WAIT_MOVE_RSP;
+
+		l2cap_send_move_chan_req(pi->conn, pi, pi->scid, remote_id);
+		l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
+	} else if (result == L2CAP_MOVE_CHAN_SUCCESS &&
+		pi->amp_move_role == L2CAP_AMP_MOVE_RESPONDER) {
+		struct hci_chan *chan;
+		struct l2cap_conf_ext_fs default_fs = {1, 1, 0xFFFF,
+				0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
+		pi->remote_fs = default_fs;
+		pi->local_fs = default_fs;
+		chan = l2cap_chan_admit(local_id, sk);
+		if (chan) {
+			if (chan->state == BT_CONNECTED) {
+				/* Logical link is ready to go */
+				pi->ampcon = chan->conn;
+				pi->ampcon->l2cap_data = pi->conn;
+				pi->amp_move_state =
+					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM;
+				l2cap_send_move_chan_rsp(pi->conn,
+					pi->amp_move_cmd_ident, pi->dcid,
+					L2CAP_MOVE_CHAN_SUCCESS);
+
+				l2cap_create_cfm(chan, 0);
+			} else {
+				/* Wait for logical link to be ready */
+				pi->amp_move_state =
+					L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM;
+			}
+		} else {
+			/* Logical link not available */
+			l2cap_send_move_chan_rsp(pi->conn,
+				pi->amp_move_cmd_ident, pi->dcid,
+				L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED);
+		}
+	} else {
+		BT_DBG("result %d, role %d, local_busy %d", result,
+			(int) pi->amp_move_role,
+			(int) ((pi->conn_state & L2CAP_CONN_LOCAL_BUSY) != 0));
+
+		if (pi->amp_move_role == L2CAP_AMP_MOVE_RESPONDER) {
+			if (result == -EINVAL)
+				l2cap_send_move_chan_rsp(pi->conn,
+					pi->amp_move_cmd_ident, pi->dcid,
+					L2CAP_MOVE_CHAN_REFUSED_CONTROLLER);
+			else
+				l2cap_send_move_chan_rsp(pi->conn,
+					pi->amp_move_cmd_ident, pi->dcid,
+					L2CAP_MOVE_CHAN_REFUSED_NOT_ALLOWED);
 		}
-	} else if (type == L2CAP_IT_FIXED_CHAN) {
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-		conn->info_ident = 0;
 
-		l2cap_conn_start(conn);
+		pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
+		pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
+
+		if ((l2cap_pi(sk)->conn_state & L2CAP_CONN_LOCAL_BUSY) &&
+			l2cap_rmem_available(sk))
+			l2cap_ertm_tx(sk, 0, 0,
+					L2CAP_ERTM_EVENT_LOCAL_BUSY_CLEAR);
+
+		/* Restart data transmission */
+		l2cap_ertm_send(sk);
 	}
 
-	return 0;
+	release_sock(sk);
 }
 
-static inline int l2cap_create_channel_req(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, u16 cmd_len,
-					void *data)
+static void l2cap_logical_link_complete(struct hci_chan *chan, u8 status)
 {
-	struct l2cap_create_chan_req *req = data;
-	struct l2cap_create_chan_rsp rsp;
-	u16 psm, scid;
-
-	if (cmd_len != sizeof(*req))
-		return -EPROTO;
-
-	if (!enable_hs)
-		return -EINVAL;
+	struct l2cap_pinfo *pi;
+	struct sock *sk;
+	struct hci_chan *ampchan;
+	struct hci_conn *ampcon;
 
-	psm = le16_to_cpu(req->psm);
-	scid = le16_to_cpu(req->scid);
+	BT_DBG("status %d, chan %p, conn %p", (int) status, chan, chan->conn);
 
-	BT_DBG("psm %d, scid %d, amp_id %d", psm, scid, req->amp_id);
+	sk = chan->l2cap_sk;
+	chan->l2cap_sk = NULL;
 
-	/* Placeholder: Always reject */
-	rsp.dcid = 0;
-	rsp.scid = cpu_to_le16(scid);
-	rsp.result = L2CAP_CR_NO_MEM;
-	rsp.status = L2CAP_CS_NO_INFO;
+	BT_DBG("sk %p", sk);
 
-	l2cap_send_cmd(conn, cmd->ident, L2CAP_CREATE_CHAN_RSP,
-		       sizeof(rsp), &rsp);
+	lock_sock(sk);
 
-	return 0;
-}
+	if (sk->sk_state != BT_CONNECTED && !l2cap_pi(sk)->amp_id) {
+		release_sock(sk);
+		return;
+	}
 
-static inline int l2cap_create_channel_rsp(struct l2cap_conn *conn,
-					struct l2cap_cmd_hdr *cmd, void *data)
-{
-	BT_DBG("conn %p", conn);
+	pi = l2cap_pi(sk);
 
-	return l2cap_connect_rsp(conn, cmd, data);
-}
+	if ((!status) && (chan != NULL)) {
+		pi->ampcon = chan->conn;
+		pi->ampcon->l2cap_data = pi->conn;
 
-static void l2cap_send_move_chan_rsp(struct l2cap_conn *conn, u8 ident,
-							u16 icid, u16 result)
-{
-	struct l2cap_move_chan_rsp rsp;
+		BT_DBG("amp_move_state %d", pi->amp_move_state);
 
-	BT_DBG("icid %d, result %d", icid, result);
+		if (sk->sk_state != BT_CONNECTED) {
+			struct l2cap_conf_rsp rsp;
 
-	rsp.icid = cpu_to_le16(icid);
-	rsp.result = cpu_to_le16(result);
+			/* Must use spinlock to prevent concurrent
+			 * execution of l2cap_config_rsp()
+			 */
+			bh_lock_sock(sk);
+			l2cap_send_cmd(pi->conn, pi->conf_ident, L2CAP_CONF_RSP,
+					l2cap_build_conf_rsp(sk, &rsp,
+						L2CAP_CONF_SUCCESS, 0), &rsp);
+			pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;
 
-	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_RSP, sizeof(rsp), &rsp);
-}
+			if (l2cap_pi(sk)->conf_state & L2CAP_CONF_INPUT_DONE) {
+				set_default_fcs(l2cap_pi(sk));
 
-static void l2cap_send_move_chan_cfm(struct l2cap_conn *conn,
-				struct l2cap_chan *chan, u16 icid, u16 result)
-{
-	struct l2cap_move_chan_cfm cfm;
-	u8 ident;
+				sk->sk_state = BT_CONNECTED;
 
-	BT_DBG("icid %d, result %d", icid, result);
+				if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM ||
+				    l2cap_pi(sk)->mode == L2CAP_MODE_STREAMING)
+					l2cap_ertm_init(sk);
 
-	ident = l2cap_get_ident(conn);
-	if (chan)
-		chan->ident = ident;
+				l2cap_chan_ready(sk);
+			}
+			bh_unlock_sock(sk);
+		} else if (pi->amp_move_state ==
+				L2CAP_AMP_STATE_WAIT_LOGICAL_COMPLETE) {
+			/* Move confirm will be sent after a success
+			 * response is received
+			 */
+			pi->amp_move_state =
+				L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS;
+		} else if (pi->amp_move_state ==
+				L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM) {
+			if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY)
+				pi->amp_move_state =
+					L2CAP_AMP_STATE_WAIT_LOCAL_BUSY;
+			else if (pi->amp_move_role ==
+					L2CAP_AMP_MOVE_INITIATOR) {
+				pi->amp_move_state =
+					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP;
+				l2cap_send_move_chan_cfm(pi->conn, pi, pi->scid,
+					L2CAP_MOVE_CHAN_SUCCESS);
+				l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
+			} else if (pi->amp_move_role ==
+					L2CAP_AMP_MOVE_RESPONDER) {
+				pi->amp_move_state =
+					L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM;
+				l2cap_send_move_chan_rsp(pi->conn,
+					pi->amp_move_cmd_ident, pi->dcid,
+					L2CAP_MOVE_CHAN_SUCCESS);
+			}
+		} else if ((pi->amp_move_state !=
+				L2CAP_AMP_STATE_WAIT_MOVE_RSP_SUCCESS) &&
+			(pi->amp_move_state !=
+				L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM) &&
+			(pi->amp_move_state !=
+				L2CAP_AMP_STATE_WAIT_MOVE_CONFIRM_RSP)) {
+			/* Move was not in expected state, free the channel */
+			ampchan = pi->ampchan;
+			ampcon = pi->ampcon;
+			pi->ampchan = NULL;
+			pi->ampcon = NULL;
+			if (ampchan) {
+				if (hci_chan_put(ampchan))
+					ampcon->l2cap_data = NULL;
+				else
+					l2cap_deaggregate(ampchan, pi);
+			}
+			pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
+		}
+	} else {
+		/* Logical link setup failed. */
+
+		if (sk->sk_state != BT_CONNECTED)
+			l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
+		else if (pi->amp_move_role == L2CAP_AMP_MOVE_RESPONDER) {
+			l2cap_amp_move_revert(sk);
+			l2cap_pi(sk)->amp_move_role = L2CAP_AMP_MOVE_NONE;
+			pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
+			l2cap_send_move_chan_rsp(pi->conn,
+					pi->amp_move_cmd_ident, pi->dcid,
+					L2CAP_MOVE_CHAN_REFUSED_CONFIG);
+		} else if (pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
+			if ((pi->amp_move_state ==
+				L2CAP_AMP_STATE_WAIT_LOGICAL_COMPLETE) ||
+				(pi->amp_move_state ==
+				    L2CAP_AMP_STATE_WAIT_LOGICAL_CONFIRM)) {
+				/* Remote has only sent pending or
+				 * success responses, clean up
+				 */
+				l2cap_amp_move_revert(sk);
+				l2cap_pi(sk)->amp_move_role =
+					L2CAP_AMP_MOVE_NONE;
+				pi->amp_move_state = L2CAP_AMP_STATE_STABLE;
+			}
 
-	cfm.icid = cpu_to_le16(icid);
-	cfm.result = cpu_to_le16(result);
+			/* Other amp move states imply that the move
+			 * has already aborted
+			 */
+			l2cap_send_move_chan_cfm(pi->conn, pi, pi->scid,
+						L2CAP_MOVE_CHAN_UNCONFIRMED);
+			l2cap_sock_set_timer(sk, L2CAP_MOVE_TIMEOUT);
+		}
+		ampchan = pi->ampchan;
+		ampcon = pi->ampcon;
+		pi->ampchan = NULL;
+		pi->ampcon = NULL;
+		if (ampchan) {
+			if (hci_chan_put(ampchan))
+				ampcon->l2cap_data = NULL;
+			else
+				l2cap_deaggregate(ampchan, pi);
+		}
+	}
 
-	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM, sizeof(cfm), &cfm);
+	release_sock(sk);
 }
 
-static void l2cap_send_move_chan_cfm_rsp(struct l2cap_conn *conn, u8 ident,
-								u16 icid)
+static void l2cap_logical_link_worker(struct work_struct *work)
 {
-	struct l2cap_move_chan_cfm_rsp rsp;
-
-	BT_DBG("icid %d", icid);
+	struct l2cap_logical_link_work *log_link_work =
+		container_of(work, struct l2cap_logical_link_work, work);
+	struct sock *sk = log_link_work->chan->l2cap_sk;
 
-	rsp.icid = cpu_to_le16(icid);
-	l2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM_RSP, sizeof(rsp), &rsp);
+	if (sk) {
+		l2cap_logical_link_complete(log_link_work->chan,
+							log_link_work->status);
+		sock_put(sk);
+	}
+	hci_chan_put(log_link_work->chan);
+	kfree(log_link_work);
 }
 
-static inline int l2cap_move_channel_req(struct l2cap_conn *conn,
-			struct l2cap_cmd_hdr *cmd, u16 cmd_len, void *data)
+static int l2cap_create_cfm(struct hci_chan *chan, u8 status)
 {
-	struct l2cap_move_chan_req *req = data;
-	u16 icid = 0;
-	u16 result = L2CAP_MR_NOT_ALLOWED;
+	struct l2cap_logical_link_work *amp_work;
 
-	if (cmd_len != sizeof(*req))
-		return -EPROTO;
+	if (!chan->l2cap_sk) {
+		BT_ERR("Expected l2cap_sk to point to connecting socket");
+		return -EFAULT;
+	}
 
-	icid = le16_to_cpu(req->icid);
+	amp_work = kzalloc(sizeof(*amp_work), GFP_ATOMIC);
+	if (!amp_work) {
+		sock_put(chan->l2cap_sk);
+		return -ENOMEM;
+	}
 
-	BT_DBG("icid %d, dest_amp_id %d", icid, req->dest_amp_id);
+	INIT_WORK(&amp_work->work, l2cap_logical_link_worker);
+	amp_work->chan = chan;
+	amp_work->status = status;
 
-	if (!enable_hs)
-		return -EINVAL;
+	hci_chan_hold(chan);
 
-	/* Placeholder: Always refuse */
-	l2cap_send_move_chan_rsp(conn, cmd->ident, icid, result);
+	if (!queue_work(_l2cap_wq, &amp_work->work)) {
+		kfree(amp_work);
+		sock_put(chan->l2cap_sk);
+		hci_chan_put(chan);
+		return -ENOMEM;
+	}
 
 	return 0;
 }
 
-static inline int l2cap_move_channel_rsp(struct l2cap_conn *conn,
-			struct l2cap_cmd_hdr *cmd, u16 cmd_len, void *data)
+int l2cap_modify_cfm(struct hci_chan *chan, u8 status)
 {
-	struct l2cap_move_chan_rsp *rsp = data;
-	u16 icid, result;
-
-	if (cmd_len != sizeof(*rsp))
-		return -EPROTO;
-
-	icid = le16_to_cpu(rsp->icid);
-	result = le16_to_cpu(rsp->result);
+	struct l2cap_conn *conn = chan->conn->l2cap_data;
 
-	BT_DBG("icid %d, result %d", icid, result);
-
-	/* Placeholder: Always unconfirmed */
-	l2cap_send_move_chan_cfm(conn, NULL, icid, L2CAP_MC_UNCONFIRMED);
+	BT_DBG("chan %p conn %p status %d", chan, conn, status);
 
+	/* TODO: if failed status restore previous fs */
 	return 0;
 }
 
-static inline int l2cap_move_channel_confirm(struct l2cap_conn *conn,
-			struct l2cap_cmd_hdr *cmd, u16 cmd_len, void *data)
+int l2cap_destroy_cfm(struct hci_chan *chan, u8 reason)
 {
-	struct l2cap_move_chan_cfm *cfm = data;
-	u16 icid, result;
+	struct l2cap_chan_list *l;
+	struct l2cap_conn *conn = chan->conn->l2cap_data;
+	struct sock *sk;
 
-	if (cmd_len != sizeof(*cfm))
-		return -EPROTO;
+	BT_DBG("chan %p conn %p", chan, conn);
 
-	icid = le16_to_cpu(cfm->icid);
-	result = le16_to_cpu(cfm->result);
+	if (!conn)
+		return 0;
 
-	BT_DBG("icid %d, result %d", icid, result);
+	l = &conn->chan_list;
 
-	l2cap_send_move_chan_cfm_rsp(conn, cmd->ident, icid);
+	read_lock(&l->lock);
+
+	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
+		bh_lock_sock(sk);
+		/* TODO MM/PK - What to do if connection is LOCAL_BUSY?  */
+		if (l2cap_pi(sk)->ampchan == chan) {
+			struct hci_conn *ampcon = l2cap_pi(sk)->ampcon;
+			l2cap_pi(sk)->ampchan = NULL;
+			l2cap_pi(sk)->ampcon = NULL;
+			if (hci_chan_put(chan))
+				ampcon->l2cap_data = NULL;
+			else
+				l2cap_deaggregate(chan, l2cap_pi(sk));
+
+			l2cap_amp_move_init(sk);
+		}
+		bh_unlock_sock(sk);
+	}
+
+	read_unlock(&l->lock);
 
 	return 0;
+
+
 }
 
-static inline int l2cap_move_channel_confirm_rsp(struct l2cap_conn *conn,
-			struct l2cap_cmd_hdr *cmd, u16 cmd_len, void *data)
+static int l2cap_sig_amp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd,
+			u8 *data, struct sk_buff *skb)
 {
-	struct l2cap_move_chan_cfm_rsp *rsp = data;
-	u16 icid;
+	struct l2cap_amp_signal_work *amp_work;
 
-	if (cmd_len != sizeof(*rsp))
-		return -EPROTO;
+	amp_work = kzalloc(sizeof(*amp_work), GFP_ATOMIC);
+	if (!amp_work)
+		return -ENOMEM;
 
-	icid = le16_to_cpu(rsp->icid);
+	INIT_WORK(&amp_work->work, l2cap_amp_signal_worker);
+	amp_work->conn = conn;
+	amp_work->cmd = *cmd;
+	amp_work->data = data;
+	amp_work->skb = skb_clone(skb, GFP_ATOMIC);
+	if (!amp_work->skb) {
+		kfree(amp_work);
+		return -ENOMEM;
+	}
 
-	BT_DBG("icid %d", icid);
+	if (!queue_work(_l2cap_wq, &amp_work->work)) {
+		kfree_skb(amp_work->skb);
+		kfree(amp_work);
+		return -ENOMEM;
+	}
 
 	return 0;
 }
@@ -3362,7 +5720,8 @@ static inline int l2cap_conn_param_update_req(struct l2cap_conn *conn,
 	struct hci_conn *hcon = conn->hcon;
 	struct l2cap_conn_param_update_req *req;
 	struct l2cap_conn_param_update_rsp rsp;
-	u16 min, max, latency, to_multiplier, cmd_len;
+	struct sock *sk;
+	u16 min, max, latency, timeout, cmd_len;
 	int err;
 
 	if (!(hcon->link_mode & HCI_LM_MASTER))
@@ -3372,34 +5731,39 @@ static inline int l2cap_conn_param_update_req(struct l2cap_conn *conn,
 	if (cmd_len != sizeof(struct l2cap_conn_param_update_req))
 		return -EPROTO;
 
-	req = (struct l2cap_conn_param_update_req *) data;
-	min		= __le16_to_cpu(req->min);
-	max		= __le16_to_cpu(req->max);
-	latency		= __le16_to_cpu(req->latency);
-	to_multiplier	= __le16_to_cpu(req->to_multiplier);
+	memset(&rsp, 0, sizeof(rsp));
+	rsp.result = cpu_to_le16(L2CAP_CONN_PARAM_REJECTED);
 
-	BT_DBG("min 0x%4.4x max 0x%4.4x latency: 0x%4.4x Timeout: 0x%4.4x",
-						min, max, latency, to_multiplier);
+	sk = l2cap_find_sock_by_fixed_cid_and_dir(4, conn->src, conn->dst, 0);
 
-	memset(&rsp, 0, sizeof(rsp));
+	if (sk && !bt_sk(sk)->le_params.prohibit_remote_chg) {
+		req = (struct l2cap_conn_param_update_req *) data;
+		min = __le16_to_cpu(req->min);
+		max = __le16_to_cpu(req->max);
+		latency = __le16_to_cpu(req->latency);
+		timeout = __le16_to_cpu(req->to_multiplier);
 
-	err = l2cap_check_conn_param(min, max, latency, to_multiplier);
-	if (err)
-		rsp.result = cpu_to_le16(L2CAP_CONN_PARAM_REJECTED);
-	else
-		rsp.result = cpu_to_le16(L2CAP_CONN_PARAM_ACCEPTED);
+		err = l2cap_check_conn_param(min, max, latency, timeout);
+		if (!err) {
+			rsp.result = cpu_to_le16(L2CAP_CONN_PARAM_ACCEPTED);
+			hci_le_conn_update(hcon, min, max, latency, timeout);
+			bt_sk(sk)->le_params.interval_min = min;
+			bt_sk(sk)->le_params.interval_max = max;
+			bt_sk(sk)->le_params.latency = latency;
+			bt_sk(sk)->le_params.supervision_timeout = timeout;
+		}
+	}
 
 	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONN_PARAM_UPDATE_RSP,
 							sizeof(rsp), &rsp);
 
-	if (!err)
-		hci_le_conn_update(hcon, min, max, latency, to_multiplier);
 
 	return 0;
 }
 
 static inline int l2cap_bredr_sig_cmd(struct l2cap_conn *conn,
-			struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)
+			struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data,
+			struct sk_buff *skb)
 {
 	int err = 0;
 
@@ -3448,7 +5812,7 @@ static inline int l2cap_bredr_sig_cmd(struct l2cap_conn *conn,
 		break;
 
 	case L2CAP_CREATE_CHAN_REQ:
-		err = l2cap_create_channel_req(conn, cmd, cmd_len, data);
+		err = l2cap_create_channel_req(conn, cmd, data);
 		break;
 
 	case L2CAP_CREATE_CHAN_RSP:
@@ -3456,21 +5820,11 @@ static inline int l2cap_bredr_sig_cmd(struct l2cap_conn *conn,
 		break;
 
 	case L2CAP_MOVE_CHAN_REQ:
-		err = l2cap_move_channel_req(conn, cmd, cmd_len, data);
-		break;
-
 	case L2CAP_MOVE_CHAN_RSP:
-		err = l2cap_move_channel_rsp(conn, cmd, cmd_len, data);
-		break;
-
 	case L2CAP_MOVE_CHAN_CFM:
-		err = l2cap_move_channel_confirm(conn, cmd, cmd_len, data);
-		break;
-
 	case L2CAP_MOVE_CHAN_CFM_RSP:
-		err = l2cap_move_channel_confirm_rsp(conn, cmd, cmd_len, data);
+		err = l2cap_sig_amp(conn, cmd, data, skb);
 		break;
-
 	default:
 		BT_ERR("Unknown BR/EDR signaling command 0x%2.2x", cmd->code);
 		err = -EINVAL;
@@ -3527,15 +5881,16 @@ static inline void l2cap_sig_channel(struct l2cap_conn *conn,
 		if (conn->hcon->type == LE_LINK)
 			err = l2cap_le_sig_cmd(conn, &cmd, data);
 		else
-			err = l2cap_bredr_sig_cmd(conn, &cmd, cmd_len, data);
+			err = l2cap_bredr_sig_cmd(conn, &cmd, cmd_len,
+							data, skb);
 
 		if (err) {
-			struct l2cap_cmd_rej_unk rej;
+			struct l2cap_cmd_rej rej;
 
 			BT_ERR("Wrong link type (%d)", err);
 
 			/* FIXME: Map err to a valid reason */
-			rej.reason = cpu_to_le16(L2CAP_REJ_NOT_UNDERSTOOD);
+			rej.reason = cpu_to_le16(0);
 			l2cap_send_cmd(conn, cmd.ident, L2CAP_COMMAND_REJ, sizeof(rej), &rej);
 		}
 
@@ -3546,94 +5901,183 @@ static inline void l2cap_sig_channel(struct l2cap_conn *conn,
 	kfree_skb(skb);
 }
 
-static int l2cap_check_fcs(struct l2cap_chan *chan,  struct sk_buff *skb)
+static int l2cap_check_fcs(struct l2cap_pinfo *pi,  struct sk_buff *skb)
 {
 	u16 our_fcs, rcv_fcs;
 	int hdr_size;
 
-	if (test_bit(FLAG_EXT_CTRL, &chan->flags))
-		hdr_size = L2CAP_EXT_HDR_SIZE;
+	if (pi->extended_control)
+		hdr_size = L2CAP_EXTENDED_HDR_SIZE;
 	else
-		hdr_size = L2CAP_ENH_HDR_SIZE;
+		hdr_size = L2CAP_ENHANCED_HDR_SIZE;
 
-	if (chan->fcs == L2CAP_FCS_CRC16) {
+	if (pi->fcs == L2CAP_FCS_CRC16) {
 		skb_trim(skb, skb->len - L2CAP_FCS_SIZE);
 		rcv_fcs = get_unaligned_le16(skb->data + skb->len);
 		our_fcs = crc16(0, skb->data - hdr_size, skb->len + hdr_size);
 
-		if (our_fcs != rcv_fcs)
+		if (our_fcs != rcv_fcs) {
+			BT_DBG("Bad FCS");
 			return -EBADMSG;
+		}
 	}
 	return 0;
 }
 
-static inline void l2cap_send_i_or_rr_or_rnr(struct l2cap_chan *chan)
+static void l2cap_ertm_pass_to_tx(struct sock *sk,
+				struct bt_l2cap_control *control)
+{
+	BT_DBG("sk %p, control %p", sk, control);
+	l2cap_ertm_tx(sk, control, 0, L2CAP_ERTM_EVENT_RECV_REQSEQ_AND_FBIT);
+}
+
+static void l2cap_ertm_pass_to_tx_fbit(struct sock *sk,
+				struct bt_l2cap_control *control)
+{
+	BT_DBG("sk %p, control %p", sk, control);
+	l2cap_ertm_tx(sk, control, 0, L2CAP_ERTM_EVENT_RECV_FBIT);
+}
+
+static void l2cap_ertm_resend(struct sock *sk)
 {
-	u32 control = 0;
+	struct bt_l2cap_control control;
+	struct l2cap_pinfo *pi;
+	struct sk_buff *skb;
+	struct sk_buff *tx_skb;
+	u16 seq;
 
-	chan->frames_sent = 0;
+	BT_DBG("sk %p", sk);
 
-	control |= __set_reqseq(chan, chan->buffer_seq);
+	pi = l2cap_pi(sk);
 
-	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
-		control |= __set_ctrl_super(chan, L2CAP_SUPER_RNR);
-		l2cap_send_sframe(chan, control);
-		set_bit(CONN_RNR_SENT, &chan->conn_state);
-	}
+	if (pi->conn_state & L2CAP_CONN_REMOTE_BUSY)
+		return;
+
+	if (pi->amp_move_state != L2CAP_AMP_STATE_STABLE &&
+			pi->amp_move_state != L2CAP_AMP_STATE_WAIT_PREPARE)
+		return;
+
+	while (pi->retrans_list.head != L2CAP_SEQ_LIST_CLEAR) {
+		seq = l2cap_seq_list_pop(&pi->retrans_list);
 
-	if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))
-		l2cap_retransmit_frames(chan);
+		skb = l2cap_ertm_seq_in_queue(TX_QUEUE(sk), seq);
+		if (!skb) {
+			BT_DBG("Error: Can't retransmit seq %d, frame missing",
+				(int) seq);
+			continue;
+		}
+
+		bt_cb(skb)->retries += 1;
+		control = bt_cb(skb)->control;
+
+		if ((pi->max_tx != 0) && (bt_cb(skb)->retries > pi->max_tx)) {
+			BT_DBG("Retry limit exceeded (%d)", (int) pi->max_tx);
+			l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
+			l2cap_seq_list_clear(&pi->retrans_list);
+			break;
+		}
+
+		control.reqseq = pi->buffer_seq;
+		if (pi->conn_state & L2CAP_CONN_SEND_FBIT) {
+			control.final = 1;
+			pi->conn_state &= ~L2CAP_CONN_SEND_FBIT;
+		} else {
+			control.final = 0;
+		}
+
+		if (skb_cloned(skb)) {
+			/* Cloned sk_buffs are read-only, so we need a
+			 * writeable copy
+			 */
+			tx_skb = skb_copy(skb, GFP_ATOMIC);
+		} else {
+			tx_skb = skb_clone(skb, GFP_ATOMIC);
+		}
+
+		if (!tx_skb) {
+			l2cap_seq_list_clear(&pi->retrans_list);
+			break;
+		}
+
+		/* Update skb contents */
+		if (pi->extended_control) {
+			put_unaligned_le32(__pack_extended_control(&control),
+					tx_skb->data + L2CAP_HDR_SIZE);
+		} else {
+			put_unaligned_le16(__pack_enhanced_control(&control),
+					tx_skb->data + L2CAP_HDR_SIZE);
+		}
+
+		if (pi->fcs == L2CAP_FCS_CRC16)
+			apply_fcs(tx_skb);
+
+		sock_hold(sk);
+		tx_skb->sk = sk;
+		tx_skb->destructor = l2cap_skb_destructor;
+		atomic_inc(&pi->ertm_queued);
 
-	l2cap_ertm_send(chan);
+		l2cap_do_send(sk, tx_skb);
 
-	if (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state) &&
-			chan->frames_sent == 0) {
-		control |= __set_ctrl_super(chan, L2CAP_SUPER_RR);
-		l2cap_send_sframe(chan, control);
+		BT_DBG("Resent txseq %d", (int)control.txseq);
+
+		pi->last_acked_seq = pi->buffer_seq;
 	}
 }
 
-static int l2cap_add_to_srej_queue(struct l2cap_chan *chan, struct sk_buff *skb, u16 tx_seq, u8 sar)
+static inline void l2cap_ertm_retransmit(struct sock *sk,
+					struct bt_l2cap_control *control)
+{
+	BT_DBG("sk %p, control %p", sk, control);
+
+	l2cap_seq_list_append(&l2cap_pi(sk)->retrans_list, control->reqseq);
+	l2cap_ertm_resend(sk);
+}
+
+static void l2cap_ertm_retransmit_all(struct sock *sk,
+				struct bt_l2cap_control *control)
 {
-	struct sk_buff *next_skb;
-	int tx_seq_offset, next_tx_seq_offset;
+	struct l2cap_pinfo *pi;
+	struct sk_buff *skb;
 
-	bt_cb(skb)->tx_seq = tx_seq;
-	bt_cb(skb)->sar = sar;
+	BT_DBG("sk %p, control %p", sk, control);
 
-	next_skb = skb_peek(&chan->srej_q);
+	pi = l2cap_pi(sk);
 
-	tx_seq_offset = __seq_offset(chan, tx_seq, chan->buffer_seq);
+	if (control->poll)
+		pi->conn_state |= L2CAP_CONN_SEND_FBIT;
 
-	while (next_skb) {
-		if (bt_cb(next_skb)->tx_seq == tx_seq)
-			return -EINVAL;
+	l2cap_seq_list_clear(&pi->retrans_list);
 
-		next_tx_seq_offset = __seq_offset(chan,
-				bt_cb(next_skb)->tx_seq, chan->buffer_seq);
+	if (pi->conn_state & L2CAP_CONN_REMOTE_BUSY)
+		return;
 
-		if (next_tx_seq_offset > tx_seq_offset) {
-			__skb_queue_before(&chan->srej_q, next_skb, skb);
-			return 0;
+	if (pi->unacked_frames) {
+		skb_queue_walk(TX_QUEUE(sk), skb) {
+			if ((bt_cb(skb)->control.txseq == control->reqseq) ||
+				skb == sk->sk_send_head)
+				break;
 		}
 
-		if (skb_queue_is_last(&chan->srej_q, next_skb))
-			next_skb = NULL;
-		else
-			next_skb = skb_queue_next(&chan->srej_q, next_skb);
-	}
+		skb_queue_walk_from(TX_QUEUE(sk), skb) {
+			if (skb == sk->sk_send_head)
+				break;
 
-	__skb_queue_tail(&chan->srej_q, skb);
+			l2cap_seq_list_append(&pi->retrans_list,
+					bt_cb(skb)->control.txseq);
+		}
 
-	return 0;
+		l2cap_ertm_resend(sk);
+	}
 }
 
-static void append_skb_frag(struct sk_buff *skb,
+static inline void append_skb_frag(struct sk_buff *skb,
 			struct sk_buff *new_frag, struct sk_buff **last_frag)
 {
 	/* skb->len reflects data in skb as well as all fragments
-	 * skb->data_len reflects only data in fragments
+	   skb->data_len reflects only data in fragments
 	 */
+	BT_DBG("skb %p, new_frag %p, *last_frag %p", skb, new_frag, *last_frag);
+
 	if (!skb_has_frag_list(skb))
 		skb_shinfo(skb)->frag_list = new_frag;
 
@@ -3647,656 +6091,1147 @@ static void append_skb_frag(struct sk_buff *skb,
 	skb->truesize += new_frag->truesize;
 }
 
-static int l2cap_reassemble_sdu(struct l2cap_chan *chan, struct sk_buff *skb, u32 control)
+static int l2cap_ertm_rx_expected_iframe(struct sock *sk,
+			struct bt_l2cap_control *control, struct sk_buff *skb)
 {
+	struct l2cap_pinfo *pi;
 	int err = -EINVAL;
 
-	switch (__get_ctrl_sar(chan, control)) {
+	BT_DBG("sk %p, control %p, skb %p len %d truesize %d", sk, control,
+		skb, skb->len, skb->truesize);
+
+	if (!control)
+		return err;
+
+	pi = l2cap_pi(sk);
+
+	BT_DBG("type %c, sar %d, txseq %d, reqseq %d, final %d",
+		control->frame_type, control->sar, control->txseq,
+		control->reqseq, control->final);
+
+	switch (control->sar) {
 	case L2CAP_SAR_UNSEGMENTED:
-		if (chan->sdu)
-			break;
+		if (pi->sdu) {
+			BT_DBG("Unexpected unsegmented PDU during reassembly");
+			kfree_skb(pi->sdu);
+			pi->sdu = NULL;
+			pi->sdu_last_frag = NULL;
+			pi->sdu_len = 0;
+		}
 
-		err = chan->ops->recv(chan->data, skb);
+		BT_DBG("Unsegmented");
+		err = sock_queue_rcv_skb(sk, skb);
 		break;
 
 	case L2CAP_SAR_START:
-		if (chan->sdu)
-			break;
+		if (pi->sdu) {
+			BT_DBG("Unexpected start PDU during reassembly");
+			kfree_skb(pi->sdu);
+		}
 
-		chan->sdu_len = get_unaligned_le16(skb->data);
-		skb_pull(skb, L2CAP_SDULEN_SIZE);
+		pi->sdu_len = get_unaligned_le16(skb->data);
+		skb_pull(skb, 2);
 
-		if (chan->sdu_len > chan->imtu) {
+		if (pi->sdu_len > pi->imtu) {
 			err = -EMSGSIZE;
 			break;
 		}
 
-		if (skb->len >= chan->sdu_len)
+		if (skb->len >= pi->sdu_len)
 			break;
 
-		chan->sdu = skb;
-		chan->sdu_last_frag = skb;
+		pi->sdu = skb;
+		pi->sdu_last_frag = skb;
+
+		BT_DBG("Start");
 
 		skb = NULL;
 		err = 0;
 		break;
 
 	case L2CAP_SAR_CONTINUE:
-		if (!chan->sdu)
+		if (!pi->sdu)
 			break;
 
-		append_skb_frag(chan->sdu, skb,
-				&chan->sdu_last_frag);
+		append_skb_frag(pi->sdu, skb,
+				&pi->sdu_last_frag);
 		skb = NULL;
 
-		if (chan->sdu->len >= chan->sdu_len)
+		if (pi->sdu->len >= pi->sdu_len)
 			break;
 
+		BT_DBG("Continue, reassembled %d", pi->sdu->len);
+
 		err = 0;
 		break;
 
 	case L2CAP_SAR_END:
-		if (!chan->sdu)
+		if (!pi->sdu)
 			break;
 
-		append_skb_frag(chan->sdu, skb,
-				&chan->sdu_last_frag);
+		append_skb_frag(pi->sdu, skb,
+				&pi->sdu_last_frag);
 		skb = NULL;
 
-		if (chan->sdu->len != chan->sdu_len)
+		if (pi->sdu->len != pi->sdu_len)
 			break;
 
-		err = chan->ops->recv(chan->data, chan->sdu);
+		BT_DBG("End, reassembled %d", pi->sdu->len);
+		/* If the sender used tiny PDUs, the rcv queuing could fail.
+		 * Applications that have issues here should use a larger
+		 * sk_rcvbuf.
+		 */
+		err = sock_queue_rcv_skb(sk, pi->sdu);
 
 		if (!err) {
 			/* Reassembly complete */
-			chan->sdu = NULL;
-			chan->sdu_last_frag = NULL;
-			chan->sdu_len = 0;
+			pi->sdu = NULL;
+			pi->sdu_last_frag = NULL;
+			pi->sdu_len = 0;
 		}
 		break;
+
+	default:
+		BT_DBG("Bad SAR value");
+		break;
 	}
 
 	if (err) {
-		kfree_skb(skb);
-		kfree_skb(chan->sdu);
-		chan->sdu = NULL;
-		chan->sdu_last_frag = NULL;
-		chan->sdu_len = 0;
+		BT_DBG("Reassembly error %d, sk_rcvbuf %d, sk_rmem_alloc %d",
+			err, sk->sk_rcvbuf, atomic_read(&sk->sk_rmem_alloc));
+		if (pi->sdu) {
+			kfree_skb(pi->sdu);
+			pi->sdu = NULL;
+		}
+		pi->sdu_last_frag = NULL;
+		pi->sdu_len = 0;
+		if (skb)
+			kfree_skb(skb);
 	}
 
+	/* Update local busy state */
+	if (!(pi->conn_state & L2CAP_CONN_LOCAL_BUSY) && l2cap_rmem_full(sk))
+		l2cap_ertm_tx(sk, 0, 0, L2CAP_ERTM_EVENT_LOCAL_BUSY_DETECTED);
+
 	return err;
 }
 
-static void l2cap_ertm_enter_local_busy(struct l2cap_chan *chan)
+static int l2cap_ertm_rx_queued_iframes(struct sock *sk)
 {
-	u32 control;
+	int err = 0;
+	/* Pass sequential frames to l2cap_ertm_rx_expected_iframe()
+	 * until a gap is encountered.
+	 */
 
-	BT_DBG("chan %p, Enter local busy", chan);
+	struct l2cap_pinfo *pi;
 
-	set_bit(CONN_LOCAL_BUSY, &chan->conn_state);
+	BT_DBG("sk %p", sk);
+	pi = l2cap_pi(sk);
 
-	control = __set_reqseq(chan, chan->buffer_seq);
-	control |= __set_ctrl_super(chan, L2CAP_SUPER_RNR);
-	l2cap_send_sframe(chan, control);
+	while (l2cap_rmem_available(sk)) {
+		struct sk_buff *skb;
+		BT_DBG("Searching for skb with txseq %d (queue len %d)",
+			(int) pi->buffer_seq, skb_queue_len(SREJ_QUEUE(sk)));
 
-	set_bit(CONN_RNR_SENT, &chan->conn_state);
+		skb = l2cap_ertm_seq_in_queue(SREJ_QUEUE(sk), pi->buffer_seq);
+
+		if (!skb)
+			break;
+
+		skb_unlink(skb, SREJ_QUEUE(sk));
+		pi->buffer_seq = __next_seq(pi->buffer_seq, pi);
+		err = l2cap_ertm_rx_expected_iframe(sk,
+						&bt_cb(skb)->control, skb);
+		if (err)
+			break;
+	}
+
+	if (skb_queue_empty(SREJ_QUEUE(sk))) {
+		pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
+		l2cap_ertm_send_ack(sk);
+	}
 
-	__clear_ack_timer(chan);
+	return err;
 }
 
-static void l2cap_ertm_exit_local_busy(struct l2cap_chan *chan)
+static void l2cap_ertm_handle_srej(struct sock *sk,
+				struct bt_l2cap_control *control)
 {
-	u32 control;
+	struct l2cap_pinfo *pi;
+	struct sk_buff *skb;
 
-	if (!test_bit(CONN_RNR_SENT, &chan->conn_state))
-		goto done;
+	BT_DBG("sk %p, control %p", sk, control);
 
-	control = __set_reqseq(chan, chan->buffer_seq);
-	control |= __set_ctrl_poll(chan);
-	control |= __set_ctrl_super(chan, L2CAP_SUPER_RR);
-	l2cap_send_sframe(chan, control);
-	chan->retry_count = 1;
+	pi = l2cap_pi(sk);
 
-	__clear_retrans_timer(chan);
-	__set_monitor_timer(chan);
+	if (control->reqseq == pi->next_tx_seq) {
+		BT_DBG("Invalid reqseq %d, disconnecting",
+			(int) control->reqseq);
+		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
+		return;
+	}
 
-	set_bit(CONN_WAIT_F, &chan->conn_state);
+	skb = l2cap_ertm_seq_in_queue(TX_QUEUE(sk), control->reqseq);
 
-done:
-	clear_bit(CONN_LOCAL_BUSY, &chan->conn_state);
-	clear_bit(CONN_RNR_SENT, &chan->conn_state);
+	if (skb == NULL) {
+		BT_DBG("Seq %d not available for retransmission",
+			(int) control->reqseq);
+		return;
+	}
 
-	BT_DBG("chan %p, Exit local busy", chan);
-}
+	if ((pi->max_tx != 0) && (bt_cb(skb)->retries >= pi->max_tx)) {
+		BT_DBG("Retry limit exceeded (%d)", (int) pi->max_tx);
+		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
+		return;
+	}
 
-void l2cap_chan_busy(struct l2cap_chan *chan, int busy)
-{
-	if (chan->mode == L2CAP_MODE_ERTM) {
-		if (busy)
-			l2cap_ertm_enter_local_busy(chan);
-		else
-			l2cap_ertm_exit_local_busy(chan);
+	pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
+
+	if (control->poll) {
+		l2cap_ertm_pass_to_tx(sk, control);
+
+		pi->conn_state |= L2CAP_CONN_SEND_FBIT;
+		l2cap_ertm_retransmit(sk, control);
+		l2cap_ertm_send(sk);
+
+		if (pi->tx_state == L2CAP_ERTM_TX_STATE_WAIT_F) {
+			pi->conn_state |= L2CAP_CONN_SREJ_ACT;
+			pi->srej_save_reqseq = control->reqseq;
+		}
+	} else {
+		l2cap_ertm_pass_to_tx_fbit(sk, control);
+
+		if (control->final) {
+			if ((pi->conn_state & L2CAP_CONN_SREJ_ACT) &&
+				(pi->srej_save_reqseq == control->reqseq)) {
+				pi->conn_state &= ~L2CAP_CONN_SREJ_ACT;
+			} else {
+				l2cap_ertm_retransmit(sk, control);
+			}
+		} else {
+			l2cap_ertm_retransmit(sk, control);
+			if (pi->tx_state == L2CAP_ERTM_TX_STATE_WAIT_F) {
+				pi->conn_state |= L2CAP_CONN_SREJ_ACT;
+				pi->srej_save_reqseq = control->reqseq;
+			}
+		}
 	}
 }
 
-static void l2cap_check_srej_gap(struct l2cap_chan *chan, u16 tx_seq)
+static void l2cap_ertm_handle_rej(struct sock *sk,
+				struct bt_l2cap_control *control)
 {
+	struct l2cap_pinfo *pi;
 	struct sk_buff *skb;
-	u32 control;
 
-	while ((skb = skb_peek(&chan->srej_q)) &&
-			!test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
-		int err;
+	BT_DBG("sk %p, control %p", sk, control);
 
-		if (bt_cb(skb)->tx_seq != tx_seq)
-			break;
+	pi = l2cap_pi(sk);
 
-		skb = skb_dequeue(&chan->srej_q);
-		control = __set_ctrl_sar(chan, bt_cb(skb)->sar);
-		err = l2cap_reassemble_sdu(chan, skb, control);
+	if (control->reqseq == pi->next_tx_seq) {
+		BT_DBG("Invalid reqseq %d, disconnecting",
+			(int) control->reqseq);
+		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
+		return;
+	}
 
-		if (err < 0) {
-			l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
-			break;
-		}
+	skb = l2cap_ertm_seq_in_queue(TX_QUEUE(sk), control->reqseq);
 
-		chan->buffer_seq_srej = __next_seq(chan, chan->buffer_seq_srej);
-		tx_seq = __next_seq(chan, tx_seq);
+	if (pi->max_tx && skb && bt_cb(skb)->retries >= pi->max_tx) {
+		BT_DBG("Retry limit exceeded (%d)", (int) pi->max_tx);
+		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
+		return;
 	}
-}
 
-static void l2cap_resend_srejframe(struct l2cap_chan *chan, u16 tx_seq)
-{
-	struct srej_list *l, *tmp;
-	u32 control;
+	pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
 
-	list_for_each_entry_safe(l, tmp, &chan->srej_l, list) {
-		if (l->tx_seq == tx_seq) {
-			list_del(&l->list);
-			kfree(l);
-			return;
-		}
-		control = __set_ctrl_super(chan, L2CAP_SUPER_SREJ);
-		control |= __set_reqseq(chan, l->tx_seq);
-		l2cap_send_sframe(chan, control);
-		list_del(&l->list);
-		list_add_tail(&l->list, &chan->srej_l);
+	l2cap_ertm_pass_to_tx(sk, control);
+
+	if (control->final) {
+		if (pi->conn_state & L2CAP_CONN_REJ_ACT)
+			pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
+		else
+			l2cap_ertm_retransmit_all(sk, control);
+	} else {
+		l2cap_ertm_retransmit_all(sk, control);
+		l2cap_ertm_send(sk);
+		if (pi->tx_state == L2CAP_ERTM_TX_STATE_WAIT_F)
+			pi->conn_state |= L2CAP_CONN_REJ_ACT;
 	}
 }
 
-static int l2cap_send_srejframe(struct l2cap_chan *chan, u16 tx_seq)
+static u8 l2cap_ertm_classify_txseq(struct sock *sk, u16 txseq)
 {
-	struct srej_list *new;
-	u32 control;
+	struct l2cap_pinfo *pi;
 
-	while (tx_seq != chan->expected_tx_seq) {
-		control = __set_ctrl_super(chan, L2CAP_SUPER_SREJ);
-		control |= __set_reqseq(chan, chan->expected_tx_seq);
-		l2cap_send_sframe(chan, control);
+	BT_DBG("sk %p, txseq %d", sk, (int)txseq);
+	pi = l2cap_pi(sk);
 
-		new = kzalloc(sizeof(struct srej_list), GFP_ATOMIC);
-		if (!new)
-			return -ENOMEM;
+	BT_DBG("last_acked_seq %d, expected_tx_seq %d", (int)pi->last_acked_seq,
+		(int)pi->expected_tx_seq);
+
+	if (pi->rx_state == L2CAP_ERTM_RX_STATE_SREJ_SENT) {
+		if (__delta_seq(txseq, pi->last_acked_seq, pi) >= pi->tx_win) {
+			/* See notes below regarding "double poll" and
+			 * invalid packets.
+			 */
+			if (pi->tx_win <= ((pi->tx_win_max + 1) >> 1)) {
+				BT_DBG("Invalid/Ignore - txseq outside "
+					"tx window after SREJ sent");
+				return L2CAP_ERTM_TXSEQ_INVALID_IGNORE;
+			} else {
+				BT_DBG("Invalid - bad txseq within tx "
+					"window after SREJ sent");
+				return L2CAP_ERTM_TXSEQ_INVALID;
+			}
+		}
 
-		new->tx_seq = chan->expected_tx_seq;
+		if (pi->srej_list.head == txseq) {
+			BT_DBG("Expected SREJ");
+			return L2CAP_ERTM_TXSEQ_EXPECTED_SREJ;
+		}
 
-		chan->expected_tx_seq = __next_seq(chan, chan->expected_tx_seq);
+		if (l2cap_ertm_seq_in_queue(SREJ_QUEUE(sk), txseq)) {
+			BT_DBG("Duplicate SREJ - txseq already stored");
+			return L2CAP_ERTM_TXSEQ_DUPLICATE_SREJ;
+		}
 
-		list_add_tail(&new->list, &chan->srej_l);
+		if (l2cap_seq_list_contains(&pi->srej_list, txseq)) {
+			BT_DBG("Unexpected SREJ - txseq not requested "
+				"with SREJ");
+			return L2CAP_ERTM_TXSEQ_UNEXPECTED_SREJ;
+		}
 	}
 
-	chan->expected_tx_seq = __next_seq(chan, chan->expected_tx_seq);
+	if (pi->expected_tx_seq == txseq) {
+		if (__delta_seq(txseq, pi->last_acked_seq, pi) >= pi->tx_win) {
+			BT_DBG("Invalid - txseq outside tx window");
+			return L2CAP_ERTM_TXSEQ_INVALID;
+		} else {
+			BT_DBG("Expected");
+			return L2CAP_ERTM_TXSEQ_EXPECTED;
+		}
+	}
 
-	return 0;
+	if (__delta_seq(txseq, pi->last_acked_seq, pi) <
+		__delta_seq(pi->expected_tx_seq, pi->last_acked_seq, pi)) {
+		BT_DBG("Duplicate - expected_tx_seq later than txseq");
+		return L2CAP_ERTM_TXSEQ_DUPLICATE;
+	}
+
+	if (__delta_seq(txseq, pi->last_acked_seq, pi) >= pi->tx_win) {
+		/* A source of invalid packets is a "double poll" condition,
+		 * where delays cause us to send multiple poll packets.  If
+		 * the remote stack receives and processes both polls,
+		 * sequence numbers can wrap around in such a way that a
+		 * resent frame has a sequence number that looks like new data
+		 * with a sequence gap.  This would trigger an erroneous SREJ
+		 * request.
+		 *
+		 * Fortunately, this is impossible with a tx window that's
+		 * less than half of the maximum sequence number, which allows
+		 * invalid frames to be safely ignored.
+		 *
+		 * With tx window sizes greater than half of the tx window
+		 * maximum, the frame is invalid and cannot be ignored.  This
+		 * causes a disconnect.
+		 */
+
+		if (pi->tx_win <= ((pi->tx_win_max + 1) >> 1)) {
+			BT_DBG("Invalid/Ignore - txseq outside tx window");
+			return L2CAP_ERTM_TXSEQ_INVALID_IGNORE;
+		} else {
+			BT_DBG("Invalid - txseq outside tx window");
+			return L2CAP_ERTM_TXSEQ_INVALID;
+		}
+	} else {
+		BT_DBG("Unexpected - txseq indicates missing frames");
+		return L2CAP_ERTM_TXSEQ_UNEXPECTED;
+	}
 }
 
-static inline int l2cap_data_channel_iframe(struct l2cap_chan *chan, u32 rx_control, struct sk_buff *skb)
+static int l2cap_ertm_rx_state_recv(struct sock *sk,
+				struct bt_l2cap_control *control,
+				struct sk_buff *skb, u8 event)
 {
-	u16 tx_seq = __get_txseq(chan, rx_control);
-	u16 req_seq = __get_reqseq(chan, rx_control);
-	u8 sar = __get_ctrl_sar(chan, rx_control);
-	int tx_seq_offset, expected_tx_seq_offset;
-	int num_to_ack = (chan->tx_win/6) + 1;
+	struct l2cap_pinfo *pi;
 	int err = 0;
+	bool skb_in_use = 0;
 
-	BT_DBG("chan %p len %d tx_seq %d rx_control 0x%8.8x", chan, skb->len,
-							tx_seq, rx_control);
-
-	if (__is_ctrl_final(chan, rx_control) &&
-			test_bit(CONN_WAIT_F, &chan->conn_state)) {
-		__clear_monitor_timer(chan);
-		if (chan->unacked_frames > 0)
-			__set_retrans_timer(chan);
-		clear_bit(CONN_WAIT_F, &chan->conn_state);
-	}
+	BT_DBG("sk %p, control %p, skb %p, event %d", sk, control, skb,
+		(int)event);
+	pi = l2cap_pi(sk);
 
-	chan->expected_ack_seq = req_seq;
-	l2cap_drop_acked_frames(chan);
+	switch (event) {
+	case L2CAP_ERTM_EVENT_RECV_IFRAME:
+		switch (l2cap_ertm_classify_txseq(sk, control->txseq)) {
+		case L2CAP_ERTM_TXSEQ_EXPECTED:
+			l2cap_ertm_pass_to_tx(sk, control);
 
-	tx_seq_offset = __seq_offset(chan, tx_seq, chan->buffer_seq);
+			if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
+				BT_DBG("Busy, discarding expected seq %d",
+					control->txseq);
+				break;
+			}
 
-	/* invalid tx_seq */
-	if (tx_seq_offset >= chan->tx_win) {
-		l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
-		goto drop;
-	}
+			pi->expected_tx_seq = __next_seq(control->txseq, pi);
+			pi->buffer_seq = pi->expected_tx_seq;
+			skb_in_use = 1;
 
-	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state))
-		goto drop;
+			err = l2cap_ertm_rx_expected_iframe(sk, control, skb);
+			if (err)
+				break;
 
-	if (tx_seq == chan->expected_tx_seq)
-		goto expected;
+			if (control->final) {
+				if (pi->conn_state & L2CAP_CONN_REJ_ACT)
+					pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
+				else {
+					control->final = 0;
+					l2cap_ertm_retransmit_all(sk, control);
+					l2cap_ertm_send(sk);
+				}
+			}
 
-	if (test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
-		struct srej_list *first;
+			if (!(pi->conn_state & L2CAP_CONN_LOCAL_BUSY))
+				l2cap_ertm_send_ack(sk);
+			break;
+		case L2CAP_ERTM_TXSEQ_UNEXPECTED:
+			l2cap_ertm_pass_to_tx(sk, control);
+
+			/* Can't issue SREJ frames in the local busy state.
+			 * Drop this frame, it will be seen as missing
+			 * when local busy is exited.
+			 */
+			if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
+				BT_DBG("Busy, discarding unexpected seq %d",
+					control->txseq);
+				break;
+			}
 
-		first = list_first_entry(&chan->srej_l,
-				struct srej_list, list);
-		if (tx_seq == first->tx_seq) {
-			l2cap_add_to_srej_queue(chan, skb, tx_seq, sar);
-			l2cap_check_srej_gap(chan, tx_seq);
+			/* There was a gap in the sequence, so an SREJ
+			 * must be sent for each missing frame.  The
+			 * current frame is stored for later use.
+			 */
+			skb_queue_tail(SREJ_QUEUE(sk), skb);
+			skb_in_use = 1;
+			BT_DBG("Queued %p (queue len %d)", skb,
+			       skb_queue_len(SREJ_QUEUE(sk)));
 
-			list_del(&first->list);
-			kfree(first);
+			pi->conn_state &= ~L2CAP_CONN_SREJ_ACT;
+			l2cap_seq_list_clear(&pi->srej_list);
+			l2cap_ertm_send_srej(sk, control->txseq);
 
-			if (list_empty(&chan->srej_l)) {
-				chan->buffer_seq = chan->buffer_seq_srej;
-				clear_bit(CONN_SREJ_SENT, &chan->conn_state);
-				l2cap_send_ack(chan);
-				BT_DBG("chan %p, Exit SREJ_SENT", chan);
+			pi->rx_state = L2CAP_ERTM_RX_STATE_SREJ_SENT;
+			break;
+		case L2CAP_ERTM_TXSEQ_DUPLICATE:
+			l2cap_ertm_pass_to_tx(sk, control);
+			break;
+		case L2CAP_ERTM_TXSEQ_INVALID_IGNORE:
+			break;
+		case L2CAP_ERTM_TXSEQ_INVALID:
+		default:
+			l2cap_send_disconn_req(l2cap_pi(sk)->conn, sk,
+					ECONNRESET);
+			break;
+		}
+		break;
+	case L2CAP_ERTM_EVENT_RECV_RR:
+		l2cap_ertm_pass_to_tx(sk, control);
+		if (control->final) {
+			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
+
+			if (pi->conn_state & L2CAP_CONN_REJ_ACT)
+				pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
+			else if (pi->amp_move_state == L2CAP_AMP_STATE_STABLE ||
+				pi->amp_move_state ==
+						L2CAP_AMP_STATE_WAIT_PREPARE) {
+				control->final = 0;
+				l2cap_ertm_retransmit_all(sk, control);
 			}
+
+			l2cap_ertm_send(sk);
+		} else if (control->poll) {
+			l2cap_ertm_send_i_or_rr_or_rnr(sk);
 		} else {
-			struct srej_list *l;
+			if ((pi->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
+				pi->unacked_frames)
+				l2cap_ertm_start_retrans_timer(pi);
+			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
+			l2cap_ertm_send(sk);
+		}
+		break;
+	case L2CAP_ERTM_EVENT_RECV_RNR:
+		pi->conn_state |= L2CAP_CONN_REMOTE_BUSY;
+		l2cap_ertm_pass_to_tx(sk, control);
+		if (control && control->poll) {
+			pi->conn_state |= L2CAP_CONN_SEND_FBIT;
+			l2cap_ertm_send_rr_or_rnr(sk, 0);
+		}
+		l2cap_ertm_stop_retrans_timer(pi);
+		l2cap_seq_list_clear(&pi->retrans_list);
+		break;
+	case L2CAP_ERTM_EVENT_RECV_REJ:
+		l2cap_ertm_handle_rej(sk, control);
+		break;
+	case L2CAP_ERTM_EVENT_RECV_SREJ:
+		l2cap_ertm_handle_srej(sk, control);
+		break;
+	default:
+		break;
+	}
 
-			/* duplicated tx_seq */
-			if (l2cap_add_to_srej_queue(chan, skb, tx_seq, sar) < 0)
-				goto drop;
+	if (skb && !skb_in_use) {
+		BT_DBG("Freeing %p", skb);
+		kfree_skb(skb);
+	}
 
-			list_for_each_entry(l, &chan->srej_l, list) {
-				if (l->tx_seq == tx_seq) {
-					l2cap_resend_srejframe(chan, tx_seq);
-					return 0;
-				}
+	return err;
+}
+
+static int l2cap_ertm_rx_state_srej_sent(struct sock *sk,
+					struct bt_l2cap_control *control,
+					struct sk_buff *skb, u8 event)
+{
+	struct l2cap_pinfo *pi;
+	int err = 0;
+	u16 txseq = control->txseq;
+	bool skb_in_use = 0;
+
+	BT_DBG("sk %p, control %p, skb %p, event %d", sk, control, skb,
+		(int)event);
+	pi = l2cap_pi(sk);
+
+	switch (event) {
+	case L2CAP_ERTM_EVENT_RECV_IFRAME:
+		switch (l2cap_ertm_classify_txseq(sk, txseq)) {
+		case L2CAP_ERTM_TXSEQ_EXPECTED:
+			/* Keep frame for reassembly later */
+			l2cap_ertm_pass_to_tx(sk, control);
+			skb_queue_tail(SREJ_QUEUE(sk), skb);
+			skb_in_use = 1;
+			BT_DBG("Queued %p (queue len %d)", skb,
+			       skb_queue_len(SREJ_QUEUE(sk)));
+
+			pi->expected_tx_seq = __next_seq(txseq, pi);
+			break;
+		case L2CAP_ERTM_TXSEQ_EXPECTED_SREJ:
+			l2cap_seq_list_pop(&pi->srej_list);
+
+			l2cap_ertm_pass_to_tx(sk, control);
+			skb_queue_tail(SREJ_QUEUE(sk), skb);
+			skb_in_use = 1;
+			BT_DBG("Queued %p (queue len %d)", skb,
+			       skb_queue_len(SREJ_QUEUE(sk)));
+
+			err = l2cap_ertm_rx_queued_iframes(sk);
+			if (err)
+				break;
+
+			break;
+		case L2CAP_ERTM_TXSEQ_UNEXPECTED:
+			/* Got a frame that can't be reassembled yet.
+			 * Save it for later, and send SREJs to cover
+			 * the missing frames.
+			 */
+			skb_queue_tail(SREJ_QUEUE(sk), skb);
+			skb_in_use = 1;
+			BT_DBG("Queued %p (queue len %d)", skb,
+			       skb_queue_len(SREJ_QUEUE(sk)));
+
+			l2cap_ertm_pass_to_tx(sk, control);
+			l2cap_ertm_send_srej(sk, control->txseq);
+			break;
+		case L2CAP_ERTM_TXSEQ_UNEXPECTED_SREJ:
+			/* This frame was requested with an SREJ, but
+			 * some expected retransmitted frames are
+			 * missing.  Request retransmission of missing
+			 * SREJ'd frames.
+			 */
+			skb_queue_tail(SREJ_QUEUE(sk), skb);
+			skb_in_use = 1;
+			BT_DBG("Queued %p (queue len %d)", skb,
+			       skb_queue_len(SREJ_QUEUE(sk)));
+
+			l2cap_ertm_pass_to_tx(sk, control);
+			l2cap_ertm_send_srej_list(sk, control->txseq);
+			break;
+		case L2CAP_ERTM_TXSEQ_DUPLICATE_SREJ:
+			/* We've already queued this frame.  Drop this copy. */
+			l2cap_ertm_pass_to_tx(sk, control);
+			break;
+		case L2CAP_ERTM_TXSEQ_DUPLICATE:
+			/* Expecting a later sequence number, so this frame
+			 * was already received.  Ignore it completely.
+			 */
+			break;
+		case L2CAP_ERTM_TXSEQ_INVALID_IGNORE:
+			break;
+		case L2CAP_ERTM_TXSEQ_INVALID:
+		default:
+			l2cap_send_disconn_req(l2cap_pi(sk)->conn, sk,
+					ECONNRESET);
+			break;
+		}
+		break;
+	case L2CAP_ERTM_EVENT_RECV_RR:
+		l2cap_ertm_pass_to_tx(sk, control);
+		if (control->final) {
+			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
+
+			if (pi->conn_state & L2CAP_CONN_REJ_ACT)
+				pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
+			else {
+				control->final = 0;
+				l2cap_ertm_retransmit_all(sk, control);
 			}
 
-			err = l2cap_send_srejframe(chan, tx_seq);
-			if (err < 0) {
-				l2cap_send_disconn_req(chan->conn, chan, -err);
-				return err;
+			l2cap_ertm_send(sk);
+		} else if (control->poll) {
+			if ((pi->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
+				pi->unacked_frames) {
+				l2cap_ertm_start_retrans_timer(pi);
+			}
+			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
+			pi->conn_state |= L2CAP_CONN_SEND_FBIT;
+			l2cap_ertm_send_srej_tail(sk);
+		} else {
+			if ((pi->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
+				pi->unacked_frames) {
+				l2cap_ertm_start_retrans_timer(pi);
 			}
+			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
+			l2cap_ertm_send_ack(sk);
+		}
+		break;
+	case L2CAP_ERTM_EVENT_RECV_RNR:
+		pi->conn_state |= L2CAP_CONN_REMOTE_BUSY;
+		l2cap_ertm_pass_to_tx(sk, control);
+		if (control->poll)
+			l2cap_ertm_send_srej_tail(sk);
+		else {
+			struct bt_l2cap_control rr_control;
+			memset(&rr_control, 0, sizeof(rr_control));
+			rr_control.frame_type = 's';
+			rr_control.super = L2CAP_SFRAME_RR;
+			rr_control.reqseq = pi->buffer_seq;
+			l2cap_ertm_send_sframe(sk, &rr_control);
 		}
-	} else {
-		expected_tx_seq_offset = __seq_offset(chan,
-				chan->expected_tx_seq, chan->buffer_seq);
-
-		/* duplicated tx_seq */
-		if (tx_seq_offset < expected_tx_seq_offset)
-			goto drop;
 
-		set_bit(CONN_SREJ_SENT, &chan->conn_state);
+		break;
+	case L2CAP_ERTM_EVENT_RECV_REJ:
+		l2cap_ertm_handle_rej(sk, control);
+		break;
+	case L2CAP_ERTM_EVENT_RECV_SREJ:
+		l2cap_ertm_handle_srej(sk, control);
+		break;
+	}
 
-		BT_DBG("chan %p, Enter SREJ", chan);
+	if (skb && !skb_in_use) {
+		BT_DBG("Freeing %p", skb);
+		kfree_skb(skb);
+	}
 
-		INIT_LIST_HEAD(&chan->srej_l);
-		chan->buffer_seq_srej = chan->buffer_seq;
+	return err;
+}
 
-		__skb_queue_head_init(&chan->srej_q);
-		l2cap_add_to_srej_queue(chan, skb, tx_seq, sar);
+static int l2cap_ertm_rx_state_amp_move(struct sock *sk,
+					struct bt_l2cap_control *control,
+					struct sk_buff *skb, u8 event)
+{
+	struct l2cap_pinfo *pi;
+	int err = 0;
+	bool skb_in_use = 0;
 
-		set_bit(CONN_SEND_PBIT, &chan->conn_state);
+	BT_DBG("sk %p, control %p, skb %p, event %d", sk, control, skb,
+		(int)event);
+	pi = l2cap_pi(sk);
 
-		err = l2cap_send_srejframe(chan, tx_seq);
-		if (err < 0) {
-			l2cap_send_disconn_req(chan->conn, chan, -err);
-			return err;
-		}
+	/* Only handle expected frames, to avoid state changes. */
 
-		__clear_ack_timer(chan);
-	}
-	return 0;
+	switch (event) {
+	case L2CAP_ERTM_EVENT_RECV_IFRAME:
+		if (l2cap_ertm_classify_txseq(sk, control->txseq) ==
+				L2CAP_ERTM_TXSEQ_EXPECTED) {
+			l2cap_ertm_pass_to_tx(sk, control);
 
-expected:
-	chan->expected_tx_seq = __next_seq(chan, chan->expected_tx_seq);
+			if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
+				BT_DBG("Busy, discarding expected seq %d",
+					control->txseq);
+				break;
+			}
 
-	if (test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
-		bt_cb(skb)->tx_seq = tx_seq;
-		bt_cb(skb)->sar = sar;
-		__skb_queue_tail(&chan->srej_q, skb);
-		return 0;
-	}
+			pi->expected_tx_seq = __next_seq(control->txseq, pi);
+			pi->buffer_seq = pi->expected_tx_seq;
+			skb_in_use = 1;
 
-	err = l2cap_reassemble_sdu(chan, skb, rx_control);
-	chan->buffer_seq = __next_seq(chan, chan->buffer_seq);
+			err = l2cap_ertm_rx_expected_iframe(sk, control, skb);
+			if (err)
+				break;
 
-	if (err < 0) {
-		l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
-		return err;
+			if (control->final) {
+				if (pi->conn_state & L2CAP_CONN_REJ_ACT)
+					pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
+				else
+					control->final = 0;
+			}
+		}
+		break;
+	case L2CAP_ERTM_EVENT_RECV_RR:
+	case L2CAP_ERTM_EVENT_RECV_RNR:
+	case L2CAP_ERTM_EVENT_RECV_REJ:
+		l2cap_ertm_process_reqseq(sk, control->reqseq);
+		break;
+	case L2CAP_ERTM_EVENT_RECV_SREJ:
+		/* Ignore */
+		break;
+	default:
+		break;
 	}
 
-	if (__is_ctrl_final(chan, rx_control)) {
-		if (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))
-			l2cap_retransmit_frames(chan);
+	if (skb && !skb_in_use) {
+		BT_DBG("Freeing %p", skb);
+		kfree_skb(skb);
 	}
 
+	return err;
+}
+
+static int l2cap_answer_move_poll(struct sock *sk)
+{
+	struct l2cap_pinfo *pi;
+	struct bt_l2cap_control control;
+	int err = 0;
 
-	chan->num_acked = (chan->num_acked + 1) % num_to_ack;
-	if (chan->num_acked == num_to_ack - 1)
-		l2cap_send_ack(chan);
-	else
-		__set_ack_timer(chan);
+	BT_DBG("sk %p", sk);
 
-	return 0;
+	pi = l2cap_pi(sk);
 
-drop:
-	kfree_skb(skb);
-	return 0;
-}
+	l2cap_ertm_process_reqseq(sk, pi->amp_move_reqseq);
 
-static inline void l2cap_data_channel_rrframe(struct l2cap_chan *chan, u32 rx_control)
-{
-	BT_DBG("chan %p, req_seq %d ctrl 0x%8.8x", chan,
-				__get_reqseq(chan, rx_control), rx_control);
+	if (!skb_queue_empty(TX_QUEUE(sk)))
+		sk->sk_send_head = skb_peek(TX_QUEUE(sk));
+	else
+		sk->sk_send_head = NULL;
 
-	chan->expected_ack_seq = __get_reqseq(chan, rx_control);
-	l2cap_drop_acked_frames(chan);
+	/* Rewind next_tx_seq to the point expected
+	 * by the receiver.
+	 */
+	pi->next_tx_seq = pi->amp_move_reqseq;
+	pi->unacked_frames = 0;
 
-	if (__is_ctrl_poll(chan, rx_control)) {
-		set_bit(CONN_SEND_FBIT, &chan->conn_state);
-		if (test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
-			if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&
-					(chan->unacked_frames > 0))
-				__set_retrans_timer(chan);
+	err = l2cap_finish_amp_move(sk);
 
-			clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
-			l2cap_send_srejtail(chan);
-		} else {
-			l2cap_send_i_or_rr_or_rnr(chan);
-		}
+	if (err)
+		return err;
 
-	} else if (__is_ctrl_final(chan, rx_control)) {
-		clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
+	pi->conn_state |= L2CAP_CONN_SEND_FBIT;
+	l2cap_ertm_send_i_or_rr_or_rnr(sk);
 
-		if (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))
-			l2cap_retransmit_frames(chan);
+	memset(&control, 0, sizeof(control));
+	control.reqseq = pi->amp_move_reqseq;
 
-	} else {
-		if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&
-				(chan->unacked_frames > 0))
-			__set_retrans_timer(chan);
+	if (pi->amp_move_event == L2CAP_ERTM_EVENT_RECV_IFRAME)
+		err = -EPROTO;
+	else
+		err = l2cap_ertm_rx_state_recv(sk, &control, NULL,
+					pi->amp_move_event);
 
-		clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
-		if (test_bit(CONN_SREJ_SENT, &chan->conn_state))
-			l2cap_send_ack(chan);
-		else
-			l2cap_ertm_send(chan);
-	}
+	return err;
 }
 
-static inline void l2cap_data_channel_rejframe(struct l2cap_chan *chan, u32 rx_control)
+static void l2cap_amp_move_setup(struct sock *sk)
 {
-	u16 tx_seq = __get_reqseq(chan, rx_control);
-
-	BT_DBG("chan %p, req_seq %d ctrl 0x%8.8x", chan, tx_seq, rx_control);
+	struct l2cap_pinfo *pi;
+	struct sk_buff *skb;
 
-	clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
+	BT_DBG("sk %p", sk);
 
-	chan->expected_ack_seq = tx_seq;
-	l2cap_drop_acked_frames(chan);
+	pi = l2cap_pi(sk);
 
-	if (__is_ctrl_final(chan, rx_control)) {
-		if (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))
-			l2cap_retransmit_frames(chan);
-	} else {
-		l2cap_retransmit_frames(chan);
+	l2cap_ertm_stop_ack_timer(pi);
+	l2cap_ertm_stop_retrans_timer(pi);
+	l2cap_ertm_stop_monitor_timer(pi);
 
-		if (test_bit(CONN_WAIT_F, &chan->conn_state))
-			set_bit(CONN_REJ_ACT, &chan->conn_state);
+	pi->retry_count = 0;
+	skb_queue_walk(TX_QUEUE(sk), skb) {
+		if (bt_cb(skb)->retries)
+			bt_cb(skb)->retries = 1;
+		else
+			break;
 	}
-}
-static inline void l2cap_data_channel_srejframe(struct l2cap_chan *chan, u32 rx_control)
-{
-	u16 tx_seq = __get_reqseq(chan, rx_control);
-
-	BT_DBG("chan %p, req_seq %d ctrl 0x%8.8x", chan, tx_seq, rx_control);
 
-	clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
+	pi->expected_tx_seq = pi->buffer_seq;
 
-	if (__is_ctrl_poll(chan, rx_control)) {
-		chan->expected_ack_seq = tx_seq;
-		l2cap_drop_acked_frames(chan);
+	pi->conn_state &= ~(L2CAP_CONN_REJ_ACT | L2CAP_CONN_SREJ_ACT);
+	l2cap_seq_list_clear(&pi->retrans_list);
+	l2cap_seq_list_clear(&l2cap_pi(sk)->srej_list);
+	skb_queue_purge(SREJ_QUEUE(sk));
 
-		set_bit(CONN_SEND_FBIT, &chan->conn_state);
-		l2cap_retransmit_one_frame(chan, tx_seq);
+	pi->tx_state = L2CAP_ERTM_TX_STATE_XMIT;
+	pi->rx_state = L2CAP_ERTM_RX_STATE_AMP_MOVE;
 
-		l2cap_ertm_send(chan);
+	BT_DBG("tx_state 0x2.2%x rx_state  0x2.2%x", pi->tx_state,
+		pi->rx_state);
 
-		if (test_bit(CONN_WAIT_F, &chan->conn_state)) {
-			chan->srej_save_reqseq = tx_seq;
-			set_bit(CONN_SREJ_ACT, &chan->conn_state);
-		}
-	} else if (__is_ctrl_final(chan, rx_control)) {
-		if (test_bit(CONN_SREJ_ACT, &chan->conn_state) &&
-				chan->srej_save_reqseq == tx_seq)
-			clear_bit(CONN_SREJ_ACT, &chan->conn_state);
-		else
-			l2cap_retransmit_one_frame(chan, tx_seq);
-	} else {
-		l2cap_retransmit_one_frame(chan, tx_seq);
-		if (test_bit(CONN_WAIT_F, &chan->conn_state)) {
-			chan->srej_save_reqseq = tx_seq;
-			set_bit(CONN_SREJ_ACT, &chan->conn_state);
-		}
-	}
+	pi->conn_state |= L2CAP_CONN_REMOTE_BUSY;
 }
 
-static inline void l2cap_data_channel_rnrframe(struct l2cap_chan *chan, u32 rx_control)
+static void l2cap_amp_move_revert(struct sock *sk)
 {
-	u16 tx_seq = __get_reqseq(chan, rx_control);
+	struct l2cap_pinfo *pi;
 
-	BT_DBG("chan %p, req_seq %d ctrl 0x%8.8x", chan, tx_seq, rx_control);
+	BT_DBG("sk %p", sk);
 
-	set_bit(CONN_REMOTE_BUSY, &chan->conn_state);
-	chan->expected_ack_seq = tx_seq;
-	l2cap_drop_acked_frames(chan);
+	pi = l2cap_pi(sk);
 
-	if (__is_ctrl_poll(chan, rx_control))
-		set_bit(CONN_SEND_FBIT, &chan->conn_state);
+	if (pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
+		l2cap_ertm_tx(sk, NULL, NULL, L2CAP_ERTM_EVENT_EXPLICIT_POLL);
+		pi->rx_state = L2CAP_ERTM_RX_STATE_WAIT_F_FLAG;
+	} else if (pi->amp_move_role == L2CAP_AMP_MOVE_RESPONDER)
+		pi->rx_state = L2CAP_ERTM_RX_STATE_WAIT_P_FLAG;
+}
 
-	if (!test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
-		__clear_retrans_timer(chan);
-		if (__is_ctrl_poll(chan, rx_control))
-			l2cap_send_rr_or_rnr(chan, L2CAP_CTRL_FINAL);
-		return;
-	}
+static int l2cap_amp_move_reconf(struct sock *sk)
+{
+	struct l2cap_pinfo *pi;
+	u8 buf[64];
+	int err = 0;
 
-	if (__is_ctrl_poll(chan, rx_control)) {
-		l2cap_send_srejtail(chan);
-	} else {
-		rx_control = __set_ctrl_super(chan, L2CAP_SUPER_RR);
-		l2cap_send_sframe(chan, rx_control);
-	}
+	BT_DBG("sk %p", sk);
+
+	pi = l2cap_pi(sk);
+
+	l2cap_send_cmd(pi->conn, l2cap_get_ident(pi->conn), L2CAP_CONF_REQ,
+				l2cap_build_amp_reconf_req(sk, buf), buf);
+	return err;
 }
 
-static inline int l2cap_data_channel_sframe(struct l2cap_chan *chan, u32 rx_control, struct sk_buff *skb)
+static void l2cap_amp_move_success(struct sock *sk)
 {
-	BT_DBG("chan %p rx_control 0x%8.8x len %d", chan, rx_control, skb->len);
-
-	if (__is_ctrl_final(chan, rx_control) &&
-			test_bit(CONN_WAIT_F, &chan->conn_state)) {
-		__clear_monitor_timer(chan);
-		if (chan->unacked_frames > 0)
-			__set_retrans_timer(chan);
-		clear_bit(CONN_WAIT_F, &chan->conn_state);
-	}
+	struct l2cap_pinfo *pi;
 
-	switch (__get_ctrl_super(chan, rx_control)) {
-	case L2CAP_SUPER_RR:
-		l2cap_data_channel_rrframe(chan, rx_control);
-		break;
+	BT_DBG("sk %p", sk);
 
-	case L2CAP_SUPER_REJ:
-		l2cap_data_channel_rejframe(chan, rx_control);
-		break;
+	pi = l2cap_pi(sk);
 
-	case L2CAP_SUPER_SREJ:
-		l2cap_data_channel_srejframe(chan, rx_control);
-		break;
+	if (pi->amp_move_role == L2CAP_AMP_MOVE_INITIATOR) {
+		int err = 0;
+		/* Send reconfigure request */
+		if (pi->mode == L2CAP_MODE_ERTM) {
+			pi->reconf_state = L2CAP_RECONF_INT;
+			if (enable_reconfig)
+				err = l2cap_amp_move_reconf(sk);
 
-	case L2CAP_SUPER_RNR:
-		l2cap_data_channel_rnrframe(chan, rx_control);
-		break;
+			if (err || !enable_reconfig) {
+				pi->reconf_state = L2CAP_RECONF_NONE;
+				l2cap_ertm_tx(sk, NULL, NULL,
+						L2CAP_ERTM_EVENT_EXPLICIT_POLL);
+				pi->rx_state = L2CAP_ERTM_RX_STATE_WAIT_F_FLAG;
+			}
+		} else
+			pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
+	} else if (pi->amp_move_role == L2CAP_AMP_MOVE_RESPONDER) {
+		if (pi->mode == L2CAP_MODE_ERTM)
+			pi->rx_state =
+				L2CAP_ERTM_RX_STATE_WAIT_P_FLAG_RECONFIGURE;
+		else
+			pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
 	}
+}
 
-	kfree_skb(skb);
-	return 0;
+static inline bool __valid_reqseq(struct l2cap_pinfo *pi, u16 reqseq)
+{
+	/* Make sure reqseq is for a packet that has been sent but not acked */
+	u16 unacked = __delta_seq(pi->next_tx_seq, pi->expected_ack_seq, pi);
+	return __delta_seq(pi->next_tx_seq, reqseq, pi) <= unacked;
 }
 
-static int l2cap_ertm_data_rcv(struct sock *sk, struct sk_buff *skb)
+static int l2cap_strm_rx(struct sock *sk, struct bt_l2cap_control *control,
+			struct sk_buff *skb)
 {
-	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
-	u32 control;
-	u16 req_seq;
-	int len, next_tx_seq_offset, req_seq_offset;
+	struct l2cap_pinfo *pi;
+	int err = 0;
 
-	control = __get_control(chan, skb->data);
-	skb_pull(skb, __ctrl_size(chan));
-	len = skb->len;
+	BT_DBG("sk %p, control %p, skb %p, state %d",
+		sk, control, skb, l2cap_pi(sk)->rx_state);
 
-	/*
-	 * We can just drop the corrupted I-frame here.
-	 * Receiver will miss it and start proper recovery
-	 * procedures and ask retransmission.
-	 */
-	if (l2cap_check_fcs(chan, skb))
-		goto drop;
+	pi = l2cap_pi(sk);
 
-	if (__is_sar_start(chan, control) && !__is_sframe(chan, control))
-		len -= L2CAP_SDULEN_SIZE;
+	if (l2cap_ertm_classify_txseq(sk, control->txseq) ==
+		L2CAP_ERTM_TXSEQ_EXPECTED) {
+		l2cap_ertm_pass_to_tx(sk, control);
 
-	if (chan->fcs == L2CAP_FCS_CRC16)
-		len -= L2CAP_FCS_SIZE;
+		BT_DBG("buffer_seq %d->%d", pi->buffer_seq,
+			   __next_seq(pi->buffer_seq, pi));
 
-	if (len > chan->mps) {
-		l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
-		goto drop;
+		pi->buffer_seq = __next_seq(pi->buffer_seq, pi);
+
+		l2cap_ertm_rx_expected_iframe(sk, control, skb);
+	} else {
+		if (pi->sdu) {
+			kfree_skb(pi->sdu);
+			pi->sdu = NULL;
+		}
+		pi->sdu_last_frag = NULL;
+		pi->sdu_len = 0;
+
+		if (skb) {
+			BT_DBG("Freeing %p", skb);
+			kfree_skb(skb);
+		}
 	}
 
-	req_seq = __get_reqseq(chan, control);
+	pi->last_acked_seq = control->txseq;
+	pi->expected_tx_seq = __next_seq(control->txseq, pi);
 
-	req_seq_offset = __seq_offset(chan, req_seq, chan->expected_ack_seq);
+	return err;
+}
 
-	next_tx_seq_offset = __seq_offset(chan, chan->next_tx_seq,
-						chan->expected_ack_seq);
+static int l2cap_ertm_rx(struct sock *sk, struct bt_l2cap_control *control,
+			struct sk_buff *skb, u8 event)
+{
+	struct l2cap_pinfo *pi;
+	int err = 0;
 
-	/* check for invalid req-seq */
-	if (req_seq_offset > next_tx_seq_offset) {
-		l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
-		goto drop;
-	}
+	BT_DBG("sk %p, control %p, skb %p, event %d, state %d",
+		sk, control, skb, (int)event, l2cap_pi(sk)->rx_state);
 
-	if (!__is_sframe(chan, control)) {
-		if (len < 0) {
-			l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
-			goto drop;
-		}
+	pi = l2cap_pi(sk);
 
-		l2cap_data_channel_iframe(chan, control, skb);
-	} else {
-		if (len != 0) {
-			BT_ERR("%d", len);
-			l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
-			goto drop;
+	if (__valid_reqseq(pi, control->reqseq)) {
+		switch (pi->rx_state) {
+		case L2CAP_ERTM_RX_STATE_RECV:
+			err = l2cap_ertm_rx_state_recv(sk, control, skb, event);
+			break;
+		case L2CAP_ERTM_RX_STATE_SREJ_SENT:
+			err = l2cap_ertm_rx_state_srej_sent(sk, control, skb,
+							event);
+			break;
+		case L2CAP_ERTM_RX_STATE_AMP_MOVE:
+			err = l2cap_ertm_rx_state_amp_move(sk, control, skb,
+							event);
+			break;
+		case L2CAP_ERTM_RX_STATE_WAIT_F_FLAG:
+			if (control->final) {
+				pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
+				pi->amp_move_role = L2CAP_AMP_MOVE_NONE;
+
+				pi->rx_state = L2CAP_ERTM_RX_STATE_RECV;
+				l2cap_ertm_process_reqseq(sk, control->reqseq);
+
+				if (!skb_queue_empty(TX_QUEUE(sk)))
+					sk->sk_send_head =
+						skb_peek(TX_QUEUE(sk));
+				else
+					sk->sk_send_head = NULL;
+
+				/* Rewind next_tx_seq to the point expected
+				 * by the receiver.
+				 */
+				pi->next_tx_seq = control->reqseq;
+				pi->unacked_frames = 0;
+
+				if (pi->ampcon)
+					pi->conn->mtu =
+						pi->ampcon->hdev->acl_mtu;
+				else
+					pi->conn->mtu =
+						pi->conn->hcon->hdev->acl_mtu;
+
+				err = l2cap_setup_resegment(sk);
+
+				if (err)
+					break;
+
+				err = l2cap_ertm_rx_state_recv(sk, control, skb,
+							event);
+			}
+			break;
+		case L2CAP_ERTM_RX_STATE_WAIT_P_FLAG:
+			if (control->poll) {
+				pi->amp_move_reqseq = control->reqseq;
+				pi->amp_move_event = event;
+				err = l2cap_answer_move_poll(sk);
+			}
+			break;
+		case L2CAP_ERTM_RX_STATE_WAIT_P_FLAG_RECONFIGURE:
+			if (control->poll) {
+				pi->amp_move_reqseq = control->reqseq;
+				pi->amp_move_event = event;
+
+				BT_DBG("amp_move_role 0x%2.2x, "
+					"reconf_state 0x%2.2x",
+					pi->amp_move_role, pi->reconf_state);
+
+				if (pi->reconf_state == L2CAP_RECONF_ACC)
+					err = l2cap_amp_move_reconf(sk);
+				else
+					err = l2cap_answer_move_poll(sk);
+			}
+			break;
+		default:
+			/* shut it down */
+			break;
 		}
-
-		l2cap_data_channel_sframe(chan, control, skb);
+	} else {
+		BT_DBG("Invalid reqseq %d (next_tx_seq %d, expected_ack_seq %d",
+			control->reqseq, pi->next_tx_seq, pi->expected_ack_seq);
+		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
 	}
 
-	return 0;
-
-drop:
-	kfree_skb(skb);
-	return 0;
+	return err;
 }
 
-static inline int l2cap_data_channel(struct l2cap_conn *conn, u16 cid, struct sk_buff *skb)
+void l2cap_fixed_channel_config(struct sock *sk, struct l2cap_options *opt)
 {
-	struct l2cap_chan *chan;
-	struct sock *sk = NULL;
-	u32 control;
-	u16 tx_seq;
-	int len;
+	lock_sock(sk);
 
-	chan = l2cap_get_chan_by_scid(conn, cid);
-	if (!chan) {
-		BT_DBG("unknown cid 0x%4.4x", cid);
-		goto drop;
-	}
+	l2cap_pi(sk)->fixed_channel = 1;
+
+	l2cap_pi(sk)->imtu = opt->imtu;
+	l2cap_pi(sk)->omtu = opt->omtu;
+	l2cap_pi(sk)->remote_mps = opt->omtu;
+	l2cap_pi(sk)->mps = opt->omtu;
+	l2cap_pi(sk)->flush_to = opt->flush_to;
+	l2cap_pi(sk)->mode = opt->mode;
+	l2cap_pi(sk)->fcs = opt->fcs;
+	l2cap_pi(sk)->max_tx = opt->max_tx;
+	l2cap_pi(sk)->remote_max_tx = opt->max_tx;
+	l2cap_pi(sk)->tx_win = opt->txwin_size;
+	l2cap_pi(sk)->remote_tx_win = opt->txwin_size;
+	l2cap_pi(sk)->retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;
+	l2cap_pi(sk)->monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;
+
+	if (opt->mode == L2CAP_MODE_ERTM ||
+		l2cap_pi(sk)->mode == L2CAP_MODE_STREAMING)
+		l2cap_ertm_init(sk);
+
+	release_sock(sk);
+
+	return;
+}
+
+static const u8 l2cap_ertm_rx_func_to_event[4] = {
+	L2CAP_ERTM_EVENT_RECV_RR, L2CAP_ERTM_EVENT_RECV_REJ,
+	L2CAP_ERTM_EVENT_RECV_RNR, L2CAP_ERTM_EVENT_RECV_SREJ
+};
 
-	sk = chan->sk;
+int l2cap_data_channel(struct sock *sk, struct sk_buff *skb)
+{
+	struct l2cap_pinfo *pi;
+	struct bt_l2cap_control *control;
+	u16 len;
+	u8 event;
+	pi = l2cap_pi(sk);
 
-	BT_DBG("chan %p, len %d", chan, skb->len);
+	BT_DBG("sk %p, len %d, mode %d", sk, skb->len, pi->mode);
 
-	if (chan->state != BT_CONNECTED)
+	if (sk->sk_state != BT_CONNECTED)
 		goto drop;
 
-	switch (chan->mode) {
+	switch (pi->mode) {
 	case L2CAP_MODE_BASIC:
 		/* If socket recv buffers overflows we drop data here
 		 * which is *bad* because L2CAP has to be reliable.
 		 * But we don't have any other choice. L2CAP doesn't
 		 * provide flow control mechanism. */
 
-		if (chan->imtu < skb->len)
+		if (pi->imtu < skb->len)
 			goto drop;
 
-		if (!chan->ops->recv(chan->data, skb))
+		if (!sock_queue_rcv_skb(sk, skb))
 			goto done;
 		break;
 
 	case L2CAP_MODE_ERTM:
-		l2cap_ertm_data_rcv(sk, skb);
-
-		goto done;
-
 	case L2CAP_MODE_STREAMING:
-		control = __get_control(chan, skb->data);
-		skb_pull(skb, __ctrl_size(chan));
+		control = &bt_cb(skb)->control;
+		if (pi->extended_control) {
+			__get_extended_control(get_unaligned_le32(skb->data),
+						control);
+			skb_pull(skb, 4);
+		} else {
+			__get_enhanced_control(get_unaligned_le16(skb->data),
+						control);
+			skb_pull(skb, 2);
+		}
+
 		len = skb->len;
 
-		if (l2cap_check_fcs(chan, skb))
+		if (l2cap_check_fcs(pi, skb))
 			goto drop;
 
-		if (__is_sar_start(chan, control))
-			len -= L2CAP_SDULEN_SIZE;
+		if ((control->frame_type == 'i') &&
+			(control->sar == L2CAP_SAR_START))
+			len -= 2;
 
-		if (chan->fcs == L2CAP_FCS_CRC16)
-			len -= L2CAP_FCS_SIZE;
+		if (pi->fcs == L2CAP_FCS_CRC16)
+			len -= 2;
 
-		if (len > chan->mps || len < 0 || __is_sframe(chan, control))
+		/*
+		 * We can just drop the corrupted I-frame here.
+		 * Receiver will miss it and start proper recovery
+		 * procedures and ask for retransmission.
+		 */
+		if (len > pi->mps) {
+			l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
 			goto drop;
+		}
 
-		tx_seq = __get_txseq(chan, control);
+		if (control->frame_type == 'i') {
 
-		if (chan->expected_tx_seq != tx_seq) {
-			/* Frame(s) missing - must discard partial SDU */
-			kfree_skb(chan->sdu);
-			chan->sdu = NULL;
-			chan->sdu_last_frag = NULL;
-			chan->sdu_len = 0;
+			int err;
 
-			/* TODO: Notify userland of missing data */
-		}
+			BT_DBG("iframe sar %d, reqseq %d, final %d, txseq %d",
+				control->sar, control->reqseq, control->final,
+				control->txseq);
+
+			/* Validate F-bit - F=0 always valid, F=1 only
+			 * valid in TX WAIT_F
+			 */
+			if (control->final && (pi->tx_state !=
+					L2CAP_ERTM_TX_STATE_WAIT_F))
+				goto drop;
+
+			if (pi->mode != L2CAP_MODE_STREAMING) {
+				event = L2CAP_ERTM_EVENT_RECV_IFRAME;
+				err = l2cap_ertm_rx(sk, control, skb, event);
+			} else
+				err = l2cap_strm_rx(sk, control, skb);
+			if (err)
+				l2cap_send_disconn_req(pi->conn, sk,
+						ECONNRESET);
+		} else {
+			/* Only I-frames are expected in streaming mode */
+			if (pi->mode == L2CAP_MODE_STREAMING)
+				goto drop;
+
+			BT_DBG("sframe reqseq %d, final %d, poll %d, super %d",
+				control->reqseq, control->final, control->poll,
+				control->super);
 
-		chan->expected_tx_seq = __next_seq(chan, tx_seq);
+			if (len != 0) {
+				l2cap_send_disconn_req(pi->conn, sk,
+						ECONNRESET);
+				goto drop;
+			}
+
+			/* Validate F and P bits */
+			if (control->final &&
+				((pi->tx_state != L2CAP_ERTM_TX_STATE_WAIT_F)
+					|| control->poll))
+				goto drop;
 
-		if (l2cap_reassemble_sdu(chan, skb, control) == -EMSGSIZE)
-			l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
+			event = l2cap_ertm_rx_func_to_event[control->super];
+			if (l2cap_ertm_rx(sk, control, skb, event))
+				l2cap_send_disconn_req(pi->conn, sk,
+						ECONNRESET);
+		}
 
 		goto done;
 
 	default:
-		BT_DBG("chan %p: bad mode 0x%2.2x", chan, chan->mode);
+		BT_DBG("sk %p: bad mode 0x%2.2x", sk, pi->mode);
 		break;
 	}
 
@@ -4304,34 +7239,35 @@ drop:
 	kfree_skb(skb);
 
 done:
-	if (sk)
-		release_sock(sk);
-
 	return 0;
 }
 
+void l2cap_recv_deferred_frame(struct sock *sk, struct sk_buff *skb)
+{
+	lock_sock(sk);
+	l2cap_data_channel(sk, skb);
+	release_sock(sk);
+}
+
 static inline int l2cap_conless_channel(struct l2cap_conn *conn, __le16 psm, struct sk_buff *skb)
 {
-	struct sock *sk = NULL;
-	struct l2cap_chan *chan;
+	struct sock *sk;
 
-	chan = l2cap_global_chan_by_psm(0, psm, conn->src);
-	if (!chan)
+	sk = l2cap_get_sock_by_psm(0, psm, conn->src);
+	if (!sk)
 		goto drop;
 
-	sk = chan->sk;
-
-	lock_sock(sk);
+	bh_lock_sock(sk);
 
 	BT_DBG("sk %p, len %d", sk, skb->len);
 
-	if (chan->state != BT_BOUND && chan->state != BT_CONNECTED)
+	if (sk->sk_state != BT_BOUND && sk->sk_state != BT_CONNECTED)
 		goto drop;
 
-	if (chan->imtu < skb->len)
+	if (l2cap_pi(sk)->imtu < skb->len)
 		goto drop;
 
-	if (!chan->ops->recv(chan->data, skb))
+	if (!sock_queue_rcv_skb(sk, skb))
 		goto done;
 
 drop:
@@ -4339,46 +7275,122 @@ drop:
 
 done:
 	if (sk)
-		release_sock(sk);
+		bh_unlock_sock(sk);
 	return 0;
 }
 
-static inline int l2cap_att_channel(struct l2cap_conn *conn, __le16 cid, struct sk_buff *skb)
+static inline int l2cap_att_channel(struct l2cap_conn *conn, __le16 cid,
+							struct sk_buff *skb)
 {
 	struct sock *sk = NULL;
-	struct l2cap_chan *chan;
+	struct sk_buff *skb_rsp;
+	struct l2cap_hdr *lh;
+	int dir;
+	struct work_struct *open_worker;
+	u8 err_rsp[] = {L2CAP_ATT_ERROR, 0x00, 0x00, 0x00,
+						L2CAP_ATT_NOT_SUPPORTED};
 
-	chan = l2cap_global_chan_by_scid(0, cid, conn->src);
-	if (!chan)
-		goto drop;
+	if (skb->data[0] == L2CAP_ATT_MTU_REQ) {
+		u8 mtu_rsp[] = {L2CAP_ATT_MTU_RSP, 23, 0};
 
-	sk = chan->sk;
+		skb_rsp = bt_skb_alloc(sizeof(mtu_rsp) + L2CAP_HDR_SIZE,
+								GFP_ATOMIC);
+		if (!skb_rsp)
+			goto drop;
 
-	lock_sock(sk);
+		lh = (struct l2cap_hdr *) skb_put(skb_rsp, L2CAP_HDR_SIZE);
+		lh->len = cpu_to_le16(sizeof(mtu_rsp));
+		lh->cid = cpu_to_le16(L2CAP_CID_LE_DATA);
+		memcpy(skb_put(skb_rsp, sizeof(mtu_rsp)), mtu_rsp,
+							sizeof(mtu_rsp));
+		hci_send_acl(conn->hcon, NULL, skb_rsp, 0);
 
-	BT_DBG("sk %p, len %d", sk, skb->len);
+		goto free_skb;
+	}
+
+	dir = (skb->data[0] & L2CAP_ATT_RESPONSE_BIT) ? 0 : 1;
+
+	sk = l2cap_find_sock_by_fixed_cid_and_dir(cid, conn->src,
+							conn->dst, dir);
 
-	if (chan->state != BT_BOUND && chan->state != BT_CONNECTED)
+	BT_DBG("sk %p, dir:%d", sk, dir);
+
+	if (!sk)
 		goto drop;
 
-	if (chan->imtu < skb->len)
+	bh_lock_sock(sk);
+
+	BT_DBG("sk %p, len %d", sk, skb->len);
+
+	if (sk->sk_state != BT_BOUND && sk->sk_state != BT_CONNECTED) {
+		att_chn_params.cid = cid;
+		att_chn_params.conn = conn;
+		att_chn_params.dir = dir;
+		att_chn_params.skb = skb;
+		open_worker = kzalloc(sizeof(*open_worker), GFP_ATOMIC);
+		if (!open_worker)
+			BT_ERR("Out of memory");
+		INIT_WORK(open_worker, l2cap_queue_acl_data);
+		schedule_work(open_worker);
+		goto done;
+	}
+
+	if (l2cap_pi(sk)->imtu < skb->len)
 		goto drop;
 
-	if (!chan->ops->recv(chan->data, skb))
+	if (!sock_queue_rcv_skb(sk, skb))
 		goto done;
 
 drop:
+	if (skb->data[0] != L2CAP_ATT_INDICATE)
+		goto not_indicate;
+
+	/* If this is an incoming Indication, we are required to confirm */
+
+	skb_rsp = bt_skb_alloc(sizeof(u8) + L2CAP_HDR_SIZE, GFP_ATOMIC);
+	if (!skb_rsp)
+		goto free_skb;
+
+	lh = (struct l2cap_hdr *) skb_put(skb_rsp, L2CAP_HDR_SIZE);
+	lh->len = cpu_to_le16(sizeof(u8));
+	lh->cid = cpu_to_le16(L2CAP_CID_LE_DATA);
+	err_rsp[0] = L2CAP_ATT_CONFIRM;
+	memcpy(skb_put(skb_rsp, sizeof(u8)), err_rsp, sizeof(u8));
+	hci_send_acl(conn->hcon, NULL, skb_rsp, 0);
+	goto free_skb;
+
+not_indicate:
+	if (skb->data[0] & L2CAP_ATT_RESPONSE_BIT ||
+			skb->data[0] == L2CAP_ATT_CONFIRM)
+		goto free_skb;
+
+	/* If this is an incoming PDU that requires a response, respond with
+	 * a generic error so remote device doesn't hang */
+
+	skb_rsp = bt_skb_alloc(sizeof(err_rsp) + L2CAP_HDR_SIZE, GFP_ATOMIC);
+	if (!skb_rsp)
+		goto free_skb;
+
+	lh = (struct l2cap_hdr *) skb_put(skb_rsp, L2CAP_HDR_SIZE);
+	lh->len = cpu_to_le16(sizeof(err_rsp));
+	lh->cid = cpu_to_le16(L2CAP_CID_LE_DATA);
+	err_rsp[1] = skb->data[0];
+	memcpy(skb_put(skb_rsp, sizeof(err_rsp)), err_rsp, sizeof(err_rsp));
+	hci_send_acl(conn->hcon, NULL, skb_rsp, 0);
+
+free_skb:
 	kfree_skb(skb);
 
 done:
 	if (sk)
-		release_sock(sk);
+		bh_unlock_sock(sk);
 	return 0;
 }
 
 static void l2cap_recv_frame(struct l2cap_conn *conn, struct sk_buff *skb)
 {
 	struct l2cap_hdr *lh = (void *) skb->data;
+	struct sock *sk;
 	u16 cid, len;
 	__le16 psm;
 
@@ -4411,207 +7423,246 @@ static void l2cap_recv_frame(struct l2cap_conn *conn, struct sk_buff *skb)
 
 	case L2CAP_CID_SMP:
 		if (smp_sig_channel(conn, skb))
-			l2cap_conn_del(conn->hcon, EACCES);
+			l2cap_conn_del(conn->hcon, EACCES, 0);
 		break;
 
 	default:
-		l2cap_data_channel(conn, cid, skb);
+		sk = l2cap_get_chan_by_scid(&conn->chan_list, cid);
+		if (sk) {
+			if (sock_owned_by_user(sk)) {
+				BT_DBG("backlog sk %p", sk);
+				if (sk_add_backlog(sk, skb))
+					kfree_skb(skb);
+			} else
+				l2cap_data_channel(sk, skb);
+
+			bh_unlock_sock(sk);
+		} else if ((cid == L2CAP_CID_A2MP) && enable_hs) {
+			BT_DBG("A2MP");
+			amp_conn_ind(conn->hcon, skb);
+		} else {
+			BT_DBG("unknown cid 0x%4.4x", cid);
+			kfree_skb(skb);
+		}
+
 		break;
 	}
 }
 
 /* ---- L2CAP interface with lower layer (HCI) ---- */
 
-int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr)
+static int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)
 {
 	int exact = 0, lm1 = 0, lm2 = 0;
-	struct l2cap_chan *c;
+	register struct sock *sk;
+	struct hlist_node *node;
+
+	if (type != ACL_LINK)
+		return 0;
 
 	BT_DBG("hdev %s, bdaddr %s", hdev->name, batostr(bdaddr));
 
 	/* Find listening sockets and check their link_mode */
-	read_lock(&chan_list_lock);
-	list_for_each_entry(c, &chan_list, global_l) {
-		struct sock *sk = c->sk;
-
-		if (c->state != BT_LISTEN)
+	read_lock(&l2cap_sk_list.lock);
+	sk_for_each(sk, node, &l2cap_sk_list.head) {
+		if (sk->sk_state != BT_LISTEN)
 			continue;
 
 		if (!bacmp(&bt_sk(sk)->src, &hdev->bdaddr)) {
 			lm1 |= HCI_LM_ACCEPT;
-			if (test_bit(FLAG_ROLE_SWITCH, &c->flags))
+			if (l2cap_pi(sk)->role_switch)
 				lm1 |= HCI_LM_MASTER;
 			exact++;
 		} else if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY)) {
 			lm2 |= HCI_LM_ACCEPT;
-			if (test_bit(FLAG_ROLE_SWITCH, &c->flags))
+			if (l2cap_pi(sk)->role_switch)
 				lm2 |= HCI_LM_MASTER;
 		}
 	}
-	read_unlock(&chan_list_lock);
+	read_unlock(&l2cap_sk_list.lock);
 
 	return exact ? lm1 : lm2;
 }
 
-int l2cap_connect_cfm(struct hci_conn *hcon, u8 status)
+static int l2cap_connect_cfm(struct hci_conn *hcon, u8 status)
 {
 	struct l2cap_conn *conn;
 
 	BT_DBG("hcon %p bdaddr %s status %d", hcon, batostr(&hcon->dst), status);
 
+	if (!(hcon->type == ACL_LINK || hcon->type == LE_LINK))
+		return -EINVAL;
+
 	if (!status) {
 		conn = l2cap_conn_add(hcon, status);
 		if (conn)
 			l2cap_conn_ready(conn);
 	} else
-		l2cap_conn_del(hcon, bt_to_errno(status));
+		l2cap_conn_del(hcon, bt_err(status), 0);
 
 	return 0;
 }
 
-int l2cap_disconn_ind(struct hci_conn *hcon)
+static int l2cap_disconn_ind(struct hci_conn *hcon)
 {
 	struct l2cap_conn *conn = hcon->l2cap_data;
 
 	BT_DBG("hcon %p", hcon);
 
-	if (!conn)
-		return HCI_ERROR_REMOTE_USER_TERM;
+	if (hcon->type != ACL_LINK || !conn)
+		return 0x13;
+
 	return conn->disc_reason;
 }
 
-int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason)
+static int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason, u8 is_process)
 {
 	BT_DBG("hcon %p reason %d", hcon, reason);
 
-	l2cap_conn_del(hcon, bt_to_errno(reason));
+	if (!(hcon->type == ACL_LINK || hcon->type == LE_LINK))
+		return -EINVAL;
+
+	l2cap_conn_del(hcon, bt_err(reason), is_process);
+
 	return 0;
 }
 
-static inline void l2cap_check_encryption(struct l2cap_chan *chan, u8 encrypt)
+static inline void l2cap_check_encryption(struct sock *sk, u8 encrypt)
 {
-	if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED)
+	if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM)
 		return;
 
 	if (encrypt == 0x00) {
-		if (chan->sec_level == BT_SECURITY_MEDIUM) {
-			__clear_chan_timer(chan);
-			__set_chan_timer(chan,
-					msecs_to_jiffies(L2CAP_ENC_TIMEOUT));
-		} else if (chan->sec_level == BT_SECURITY_HIGH)
-			l2cap_chan_close(chan, ECONNREFUSED);
+		if (l2cap_pi(sk)->sec_level == BT_SECURITY_MEDIUM) {
+			l2cap_sock_clear_timer(sk);
+			l2cap_sock_set_timer(sk, HZ * 5);
+		} else if (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH ||
+			l2cap_pi(sk)->sec_level == BT_SECURITY_VERY_HIGH)
+			__l2cap_sock_close(sk, ECONNREFUSED);
 	} else {
-		if (chan->sec_level == BT_SECURITY_MEDIUM)
-			__clear_chan_timer(chan);
+		if (l2cap_pi(sk)->sec_level == BT_SECURITY_MEDIUM)
+			l2cap_sock_clear_timer(sk);
 	}
 }
 
-int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)
+static int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)
 {
+	struct l2cap_chan_list *l;
 	struct l2cap_conn *conn = hcon->l2cap_data;
-	struct l2cap_chan *chan;
+	struct sock *sk;
+	int smp = 0;
 
 	if (!conn)
 		return 0;
 
-	BT_DBG("conn %p", conn);
-
-	if (hcon->type == LE_LINK) {
-		smp_distribute_keys(conn, 0);
-		cancel_delayed_work(&conn->security_timer);
-	}
+	l = &conn->chan_list;
 
-	rcu_read_lock();
+	BT_DBG("conn %p", conn);
 
-	list_for_each_entry_rcu(chan, &conn->chan_l, list) {
-		struct sock *sk = chan->sk;
+	read_lock(&l->lock);
 
+	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
 		bh_lock_sock(sk);
 
-		BT_DBG("chan->scid %d", chan->scid);
+		BT_DBG("sk->scid %d", l2cap_pi(sk)->scid);
 
-		if (chan->scid == L2CAP_CID_LE_DATA) {
+		if (l2cap_pi(sk)->scid == L2CAP_CID_LE_DATA) {
 			if (!status && encrypt) {
-				chan->sec_level = hcon->sec_level;
+				l2cap_pi(sk)->sec_level = hcon->sec_level;
 				l2cap_chan_ready(sk);
 			}
 
+			smp = 1;
 			bh_unlock_sock(sk);
 			continue;
 		}
 
-		if (test_bit(CONF_CONNECT_PEND, &chan->conf_state)) {
+		if (l2cap_pi(sk)->conf_state & L2CAP_CONF_CONNECT_PEND) {
 			bh_unlock_sock(sk);
 			continue;
 		}
 
-		if (!status && (chan->state == BT_CONNECTED ||
-						chan->state == BT_CONFIG)) {
-			l2cap_check_encryption(chan, encrypt);
+		if (!status && (sk->sk_state == BT_CONNECTED ||
+						sk->sk_state == BT_CONFIG)) {
+			l2cap_check_encryption(sk, encrypt);
 			bh_unlock_sock(sk);
 			continue;
 		}
 
-		if (chan->state == BT_CONNECT) {
+		if (sk->sk_state == BT_CONNECT) {
 			if (!status) {
-				struct l2cap_conn_req req;
-				req.scid = cpu_to_le16(chan->scid);
-				req.psm  = chan->psm;
-
-				chan->ident = l2cap_get_ident(conn);
-				set_bit(CONF_CONNECT_PEND, &chan->conf_state);
-
-				l2cap_send_cmd(conn, chan->ident,
-					L2CAP_CONN_REQ, sizeof(req), &req);
+				l2cap_pi(sk)->conf_state |=
+						L2CAP_CONF_CONNECT_PEND;
+				if ((l2cap_pi(sk)->amp_pref ==
+						BT_AMP_POLICY_PREFER_AMP) &&
+						enable_hs) {
+					amp_create_physical(l2cap_pi(sk)->conn,
+								sk);
+				} else
+					l2cap_send_conn_req(sk);
 			} else {
-				__clear_chan_timer(chan);
-				__set_chan_timer(chan,
-					msecs_to_jiffies(L2CAP_DISC_TIMEOUT));
+				l2cap_sock_clear_timer(sk);
+				l2cap_sock_set_timer(sk, HZ / 10);
 			}
-		} else if (chan->state == BT_CONNECT2) {
+		} else if (sk->sk_state == BT_CONNECT2) {
 			struct l2cap_conn_rsp rsp;
-			__u16 res, stat;
+			__u16 result;
 
 			if (!status) {
-				if (bt_sk(sk)->defer_setup) {
-					struct sock *parent = bt_sk(sk)->parent;
-					res = L2CAP_CR_PEND;
-					stat = L2CAP_CS_AUTHOR_PEND;
-					if (parent)
-						parent->sk_data_ready(parent, 0);
-				} else {
-					l2cap_state_change(chan, BT_CONFIG);
-					res = L2CAP_CR_SUCCESS;
-					stat = L2CAP_CS_NO_INFO;
+				if (l2cap_pi(sk)->amp_id) {
+					amp_accept_physical(conn,
+						l2cap_pi(sk)->amp_id, sk);
+					bh_unlock_sock(sk);
+					continue;
 				}
+
+				sk->sk_state = BT_CONFIG;
+				result = L2CAP_CR_SUCCESS;
 			} else {
-				l2cap_state_change(chan, BT_DISCONN);
-				__set_chan_timer(chan,
-					msecs_to_jiffies(L2CAP_DISC_TIMEOUT));
-				res = L2CAP_CR_SEC_BLOCK;
-				stat = L2CAP_CS_NO_INFO;
+				sk->sk_state = BT_DISCONN;
+				l2cap_sock_set_timer(sk, HZ / 10);
+				result = L2CAP_CR_SEC_BLOCK;
 			}
 
-			rsp.scid   = cpu_to_le16(chan->dcid);
-			rsp.dcid   = cpu_to_le16(chan->scid);
-			rsp.result = cpu_to_le16(res);
-			rsp.status = cpu_to_le16(stat);
-			l2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,
-							sizeof(rsp), &rsp);
+			rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
+			rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
+			rsp.result = cpu_to_le16(result);
+			rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
+			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
+					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
+
+			if (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT) &&
+				result == L2CAP_CR_SUCCESS) {
+				char buf[128];
+				l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
+				l2cap_send_cmd(conn, l2cap_get_ident(conn),
+					       L2CAP_CONF_REQ,
+					       l2cap_build_conf_req(sk, buf),
+					       buf);
+				l2cap_pi(sk)->num_conf_req++;
+			}
 		}
 
 		bh_unlock_sock(sk);
 	}
 
-	rcu_read_unlock();
+	read_unlock(&l->lock);
+
+	if (smp) {
+		del_timer(&hcon->smp_timer);
+		smp_link_encrypt_cmplt(conn, status, encrypt);
+	}
 
 	return 0;
 }
 
-int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)
+static int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)
 {
 	struct l2cap_conn *conn = hcon->l2cap_data;
 
+	if (!conn && hcon->hdev->dev_type != HCI_BREDR)
+		goto drop;
+
 	if (!conn)
 		conn = l2cap_conn_add(hcon, 0);
 
@@ -4620,10 +7671,8 @@ int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)
 
 	BT_DBG("conn %p len %d flags 0x%x", conn, skb->len, flags);
 
-	if (!(flags & ACL_CONT)) {
+	if (flags & ACL_START) {
 		struct l2cap_hdr *hdr;
-		struct l2cap_chan *chan;
-		u16 cid;
 		int len;
 
 		if (conn->rx_len) {
@@ -4643,7 +7692,6 @@ int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)
 
 		hdr = (struct l2cap_hdr *) skb->data;
 		len = __le16_to_cpu(hdr->len) + L2CAP_HDR_SIZE;
-		cid = __le16_to_cpu(hdr->cid);
 
 		if (len == skb->len) {
 			/* Complete frame received */
@@ -4651,6 +7699,14 @@ int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)
 			return 0;
 		}
 
+		if (flags & ACL_CONT) {
+			BT_ERR("Complete frame is incomplete "
+				"(len %d, expected len %d)",
+				skb->len, len);
+			l2cap_conn_unreliable(conn, ECOMM);
+			goto drop;
+		}
+
 		BT_DBG("Start: total len %d, frag len %d", len, skb->len);
 
 		if (skb->len > len) {
@@ -4660,22 +7716,6 @@ int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)
 			goto drop;
 		}
 
-		chan = l2cap_get_chan_by_scid(conn, cid);
-
-		if (chan && chan->sk) {
-			struct sock *sk = chan->sk;
-
-			if (chan->imtu < len - L2CAP_HDR_SIZE) {
-				BT_ERR("Frame exceeding recv MTU (len %d, "
-							"MTU %d)", len,
-							chan->imtu);
-				release_sock(sk);
-				l2cap_conn_unreliable(conn, ECOMM);
-				goto drop;
-			}
-			release_sock(sk);
-		}
-
 		/* Allocate skb for the complete frame (with header) */
 		conn->rx_skb = bt_skb_alloc(len, GFP_ATOMIC);
 		if (!conn->rx_skb)
@@ -4719,28 +7759,131 @@ drop:
 	return 0;
 }
 
+static void l2cap_set_acl_flushto(struct hci_conn *hcon, u16 flush_to)
+{
+	struct hci_cp_write_automatic_flush_timeout flush_tm;
+	if (hcon && hcon->hdev) {
+		flush_tm.handle = hcon->handle;
+		if (flush_to == L2CAP_DEFAULT_FLUSH_TO)
+			flush_to = 0;
+		flush_tm.timeout = (flush_to < L2CAP_MAX_FLUSH_TO) ?
+				flush_to : L2CAP_MAX_FLUSH_TO;
+		hci_send_cmd(hcon->hdev,
+			HCI_OP_WRITE_AUTOMATIC_FLUSH_TIMEOUT,
+			4, &(flush_tm));
+	}
+}
+
+static u16 l2cap_get_smallest_flushto(struct l2cap_chan_list *l)
+{
+	int ret_flush_to = L2CAP_DEFAULT_FLUSH_TO;
+	struct sock *s;
+	for (s = l->head; s; s = l2cap_pi(s)->next_c) {
+		if (l2cap_pi(s)->flush_to > 0 &&
+				l2cap_pi(s)->flush_to < ret_flush_to)
+			ret_flush_to = l2cap_pi(s)->flush_to;
+	}
+	return ret_flush_to;
+}
+
 static int l2cap_debugfs_show(struct seq_file *f, void *p)
 {
-	struct l2cap_chan *c;
+	struct sock *sk;
+	struct hlist_node *node;
 
-	read_lock(&chan_list_lock);
+	read_lock_bh(&l2cap_sk_list.lock);
 
-	list_for_each_entry(c, &chan_list, global_l) {
-		struct sock *sk = c->sk;
+	sk_for_each(sk, node, &l2cap_sk_list.head) {
+		struct l2cap_pinfo *pi = l2cap_pi(sk);
 
 		seq_printf(f, "%s %s %d %d 0x%4.4x 0x%4.4x %d %d %d %d\n",
 					batostr(&bt_sk(sk)->src),
 					batostr(&bt_sk(sk)->dst),
-					c->state, __le16_to_cpu(c->psm),
-					c->scid, c->dcid, c->imtu, c->omtu,
-					c->sec_level, c->mode);
-}
+					sk->sk_state, __le16_to_cpu(pi->psm),
+					pi->scid, pi->dcid,
+					pi->imtu, pi->omtu, pi->sec_level,
+					pi->mode);
+	}
 
-	read_unlock(&chan_list_lock);
+	read_unlock_bh(&l2cap_sk_list.lock);
 
 	return 0;
 }
 
+static void l2cap_queue_acl_data(struct work_struct *worker)
+{
+	struct sock *sk = NULL;
+	int attempts = 0;
+	struct sk_buff *skb_rsp;
+	struct l2cap_hdr *lh;
+	u8 err_rsp[] = {L2CAP_ATT_ERROR, 0x00, 0x00, 0x00,
+						L2CAP_ATT_NOT_SUPPORTED};
+
+	for (attempts = 0; attempts < 40; attempts++) {
+		msleep(50);
+		if (!att_chn_params.conn) {
+			BT_DBG("att_chn_params.conn is NULL");
+			return;
+		}
+		sk = l2cap_find_sock_by_fixed_cid_and_dir
+				(att_chn_params.cid,
+				att_chn_params.conn->src,
+				att_chn_params.conn->dst,
+				att_chn_params.dir);
+		bh_lock_sock(sk);
+		if (sk->sk_state == BT_CONNECTED) {
+			sock_queue_rcv_skb(sk, att_chn_params.skb);
+			if (sk)
+				bh_unlock_sock(sk);
+			return;
+		}
+		bh_unlock_sock(sk);
+	}
+	bh_lock_sock(sk);
+
+	if (att_chn_params.skb->data[0] != L2CAP_ATT_INDICATE)
+		goto not_indicate;
+
+	/* If this is an incoming Indication, we are required to confirm */
+	skb_rsp = bt_skb_alloc(sizeof(u8) + L2CAP_HDR_SIZE, GFP_ATOMIC);
+	if (!skb_rsp)
+		goto free_skb;
+
+	lh = (struct l2cap_hdr *) skb_put(skb_rsp, L2CAP_HDR_SIZE);
+	lh->len = cpu_to_le16(sizeof(u8));
+	lh->cid = cpu_to_le16(L2CAP_CID_LE_DATA);
+	err_rsp[0] = L2CAP_ATT_CONFIRM;
+	memcpy(skb_put(skb_rsp, sizeof(u8)), err_rsp, sizeof(u8));
+	hci_send_acl(att_chn_params.conn->hcon, NULL, skb_rsp, 0);
+	goto free_skb;
+
+not_indicate:
+	if (att_chn_params.skb->data[0] & L2CAP_ATT_RESPONSE_BIT ||
+			att_chn_params.skb->data[0] == L2CAP_ATT_CONFIRM)
+		goto free_skb;
+
+	/* If this is an incoming PDU that requires a response, respond with
+	 * a generic error so remote device doesn't hang */
+
+	skb_rsp = bt_skb_alloc(sizeof(err_rsp) + L2CAP_HDR_SIZE, GFP_ATOMIC);
+	if (!skb_rsp)
+		goto free_skb;
+
+	lh = (struct l2cap_hdr *) skb_put(skb_rsp, L2CAP_HDR_SIZE);
+	lh->len = cpu_to_le16(sizeof(err_rsp));
+	lh->cid = cpu_to_le16(L2CAP_CID_LE_DATA);
+	err_rsp[1] = att_chn_params.skb->data[0];
+	memcpy(skb_put(skb_rsp, sizeof(err_rsp)), err_rsp, sizeof(err_rsp));
+	hci_send_acl(att_chn_params.conn->hcon, NULL, skb_rsp, 0);
+
+free_skb:
+	kfree_skb(att_chn_params.skb);
+
+	if (sk)
+		bh_unlock_sock(sk);
+
+}
+
 static int l2cap_debugfs_open(struct inode *inode, struct file *file)
 {
 	return single_open(file, l2cap_debugfs_show, inode->i_private);
@@ -4755,6 +7898,20 @@ static const struct file_operations l2cap_debugfs_fops = {
 
 static struct dentry *l2cap_debugfs;
 
+static struct hci_proto l2cap_hci_proto = {
+	.name		= "L2CAP",
+	.id		= HCI_PROTO_L2CAP,
+	.connect_ind	= l2cap_connect_ind,
+	.connect_cfm	= l2cap_connect_cfm,
+	.disconn_ind	= l2cap_disconn_ind,
+	.disconn_cfm	= l2cap_disconn_cfm,
+	.security_cfm	= l2cap_security_cfm,
+	.recv_acldata	= l2cap_recv_acldata,
+	.create_cfm	= l2cap_create_cfm,
+	.modify_cfm	= l2cap_modify_cfm,
+	.destroy_cfm	= l2cap_destroy_cfm,
+};
+
 int __init l2cap_init(void)
 {
 	int err;
@@ -4763,6 +7920,19 @@ int __init l2cap_init(void)
 	if (err < 0)
 		return err;
 
+	_l2cap_wq = create_singlethread_workqueue("l2cap");
+	if (!_l2cap_wq) {
+		err = -ENOMEM;
+		goto error;
+	}
+
+	err = hci_register_proto(&l2cap_hci_proto);
+	if (err < 0) {
+		BT_ERR("L2CAP protocol registration failed");
+		bt_sock_unregister(BTPROTO_L2CAP);
+		goto error;
+	}
+
 	if (bt_debugfs) {
 		l2cap_debugfs = debugfs_create_file("l2cap", 0444,
 					bt_debugfs, NULL, &l2cap_debugfs_fops);
@@ -4770,14 +7940,39 @@ int __init l2cap_init(void)
 			BT_ERR("Failed to create L2CAP debug file");
 	}
 
+	if (amp_init() < 0) {
+		BT_ERR("AMP Manager initialization failed");
+		goto error;
+	}
+
 	return 0;
+
+error:
+	destroy_workqueue(_l2cap_wq);
+	l2cap_cleanup_sockets();
+	return err;
 }
 
 void l2cap_exit(void)
 {
+	amp_exit();
+
 	debugfs_remove(l2cap_debugfs);
+
+	flush_workqueue(_l2cap_wq);
+	destroy_workqueue(_l2cap_wq);
+
+	if (hci_unregister_proto(&l2cap_hci_proto) < 0)
+		BT_ERR("L2CAP protocol unregistration failed");
+
 	l2cap_cleanup_sockets();
 }
 
 module_param(disable_ertm, bool, 0644);
 MODULE_PARM_DESC(disable_ertm, "Disable enhanced retransmission mode");
+
+module_param(enable_hs, bool, 0644);
+MODULE_PARM_DESC(enable_hs, "Enable A2MP protocol");
+
+module_param(enable_reconfig, bool, 0644);
+MODULE_PARM_DESC(enable_reconfig, "Enable reconfig after initiating AMP move");
diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
old mode 100755
new mode 100644
index 93261d1..83087d1
--- a/net/bluetooth/l2cap_sock.c
+++ b/net/bluetooth/l2cap_sock.c
@@ -1,9 +1,8 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (C) 2000-2001 Qualcomm Incorporated
+   Copyright (c) 2000-2001, 2011-2012 The Linux Foundation.  All rights reserved.
    Copyright (C) 2009-2010 Gustavo F. Padovan <gustavo@padovan.org>
    Copyright (C) 2010 Google Inc.
-   Copyright (C) 2011 ProFUSION Embedded Systems
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -27,22 +26,107 @@
 
 /* Bluetooth L2CAP sockets. */
 
-#include <linux/security.h>
-#include <linux/export.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 #include <net/bluetooth/l2cap.h>
 #include <net/bluetooth/smp.h>
+#include <net/bluetooth/amp.h>
 
-static const struct proto_ops l2cap_sock_ops;
-static void l2cap_sock_init(struct sock *sk, struct sock *parent);
-static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio);
+/* ---- L2CAP timers ---- */
+static void l2cap_sock_timeout(unsigned long arg)
+{
+	struct sock *sk = (struct sock *) arg;
+	int reason;
+
+	BT_DBG("sock %p state %d", sk, sk->sk_state);
+
+	bh_lock_sock(sk);
+
+	if (sock_owned_by_user(sk)) {
+		/* sk is owned by user. Try again later */
+		l2cap_sock_set_timer(sk, HZ / 5);
+		bh_unlock_sock(sk);
+		sock_put(sk);
+		return;
+	}
+
+	if (sk->sk_state == BT_CONNECTED || sk->sk_state == BT_CONFIG)
+		reason = ECONNREFUSED;
+	else if (sk->sk_state == BT_CONNECT &&
+				l2cap_pi(sk)->sec_level != BT_SECURITY_SDP)
+		reason = ECONNREFUSED;
+	else
+		reason = ETIMEDOUT;
+
+	__l2cap_sock_close(sk, reason);
+
+	bh_unlock_sock(sk);
+
+	l2cap_sock_kill(sk);
+	sock_put(sk);
+}
+
+void l2cap_sock_set_timer(struct sock *sk, long timeout)
+{
+	BT_DBG("sk %p state %d timeout %ld", sk, sk->sk_state, timeout);
+	sk_reset_timer(sk, &sk->sk_timer, jiffies + timeout);
+}
+
+void l2cap_sock_clear_timer(struct sock *sk)
+{
+	BT_DBG("sock %p state %d", sk, sk->sk_state);
+	sk_stop_timer(sk, &sk->sk_timer);
+}
+
+int l2cap_sock_le_params_valid(struct bt_le_params *le_params)
+{
+	if (!le_params || le_params->latency > BT_LE_LATENCY_MAX ||
+			le_params->scan_window > BT_LE_SCAN_WINDOW_MAX ||
+			le_params->scan_interval < BT_LE_SCAN_INTERVAL_MIN ||
+			le_params->scan_window > le_params->scan_interval ||
+			le_params->interval_min < BT_LE_CONN_INTERVAL_MIN ||
+			le_params->interval_max > BT_LE_CONN_INTERVAL_MAX ||
+			le_params->interval_min > le_params->interval_max ||
+			le_params->supervision_timeout < BT_LE_SUP_TO_MIN ||
+			le_params->supervision_timeout > BT_LE_SUP_TO_MAX) {
+		return 0;
+	}
+
+	return 1;
+}
+
+int l2cap_sock_le_conn_update_params_valid(struct bt_le_params *le_params)
+{
+	if (!le_params || le_params->latency > BT_LE_LATENCY_MAX ||
+			le_params->interval_min < BT_LE_CONN_INTERVAL_MIN ||
+			le_params->interval_max > BT_LE_CONN_INTERVAL_MAX ||
+			le_params->interval_min > le_params->interval_max ||
+			le_params->supervision_timeout < BT_LE_SUP_TO_MIN ||
+			le_params->supervision_timeout > BT_LE_SUP_TO_MAX) {
+		return 0;
+	}
+
+	return 1;
+}
+
+static struct sock *__l2cap_get_sock_by_addr(__le16 psm, bdaddr_t *src)
+{
+	struct sock *sk;
+	struct hlist_node *node;
+	sk_for_each(sk, node, &l2cap_sk_list.head)
+		if (l2cap_pi(sk)->sport == psm && !bacmp(&bt_sk(sk)->src, src))
+			goto found;
+	sk = NULL;
+found:
+	return sk;
+}
 
 static int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
 {
 	struct sock *sk = sock->sk;
-	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct sockaddr_l2 la;
 	int len, err = 0;
 
@@ -81,22 +165,26 @@ static int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
 		}
 	}
 
-	if (la.l2_cid)
-		err = l2cap_add_scid(chan, la.l2_cid);
-	else
-		err = l2cap_add_psm(chan, &la.l2_bdaddr, la.l2_psm);
-
-	if (err < 0)
-		goto done;
+	write_lock_bh(&l2cap_sk_list.lock);
 
-	if (__le16_to_cpu(la.l2_psm) == 0x0001 ||
-				__le16_to_cpu(la.l2_psm) == 0x0003)
-		chan->sec_level = BT_SECURITY_SDP;
+	if (la.l2_psm && __l2cap_get_sock_by_addr(la.l2_psm, &la.l2_bdaddr)) {
+		err = -EADDRINUSE;
+	} else {
+		/* Save source address */
+		bacpy(&bt_sk(sk)->src, &la.l2_bdaddr);
+		l2cap_pi(sk)->psm   = la.l2_psm;
+		l2cap_pi(sk)->sport = la.l2_psm;
+		sk->sk_state = BT_BOUND;
+
+		if (__le16_to_cpu(la.l2_psm) == 0x0001 ||
+					__le16_to_cpu(la.l2_psm) == 0x0003)
+			l2cap_pi(sk)->sec_level = BT_SECURITY_SDP;
+	}
 
-	bacpy(&bt_sk(sk)->src, &la.l2_bdaddr);
+	if (la.l2_cid)
+		l2cap_pi(sk)->scid = la.l2_cid;
 
-	chan->state = BT_BOUND;
-	sk->sk_state = BT_BOUND;
+	write_unlock_bh(&l2cap_sk_list.lock);
 
 done:
 	release_sock(sk);
@@ -106,14 +194,14 @@ done:
 static int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)
 {
 	struct sock *sk = sock->sk;
-	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct sockaddr_l2 la;
 	int len, err = 0;
 
-	BT_DBG("sk %p", sk);
+	BT_DBG("sk %p type %d mode %d state %d", sk, sk->sk_type,
+		l2cap_pi(sk)->mode, sk->sk_state);
 
 	if (!addr || alen < sizeof(addr->sa_family) ||
-	    addr->sa_family != AF_BLUETOOTH)
+		addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
 	memset(&la, 0, sizeof(la));
@@ -123,22 +211,80 @@ static int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr, int al
 	if (la.l2_cid && la.l2_psm)
 		return -EINVAL;
 
-	err = l2cap_chan_connect(chan, la.l2_psm, la.l2_cid, &la.l2_bdaddr);
+	lock_sock(sk);
+
+	if ((sk->sk_type == SOCK_SEQPACKET || sk->sk_type == SOCK_STREAM)
+		&& !(la.l2_psm || la.l2_cid || l2cap_pi(sk)->fixed_channel)) {
+		err = -EINVAL;
+		goto done;
+	}
+
+	switch (l2cap_pi(sk)->mode) {
+	case L2CAP_MODE_BASIC:
+		break;
+	case L2CAP_MODE_ERTM:
+	case L2CAP_MODE_STREAMING:
+		if (!disable_ertm)
+			break;
+		/* fall through */
+	default:
+		err = -ENOTSUPP;
+		goto done;
+	}
+
+	switch (sk->sk_state) {
+	case BT_CONNECT:
+	case BT_CONNECT2:
+	case BT_CONFIG:
+		/* Already connecting */
+		goto wait;
+
+	case BT_CONNECTED:
+		/* Already connected */
+		err = -EISCONN;
+		goto done;
+
+	case BT_OPEN:
+	case BT_BOUND:
+		/* Can connect */
+		break;
+
+	default:
+		err = -EBADFD;
+		goto done;
+	}
+
+	/* PSM must be odd and lsb of upper byte must be 0 */
+	if ((__le16_to_cpu(la.l2_psm) & 0x0101) != 0x0001 &&
+		!l2cap_pi(sk)->fixed_channel &&
+				sk->sk_type != SOCK_RAW && !la.l2_cid) {
+		BT_DBG("Bad PSM 0x%x", (int)__le16_to_cpu(la.l2_psm));
+		err = -EINVAL;
+		goto done;
+	}
+
+	/* Set destination address and psm */
+	bacpy(&bt_sk(sk)->dst, &la.l2_bdaddr);
+	l2cap_pi(sk)->psm = la.l2_psm;
+	l2cap_pi(sk)->dcid = la.l2_cid;
+
+	err = l2cap_do_connect(sk);
 	if (err)
 		goto done;
 
+wait:
 	err = bt_sock_wait_state(sk, BT_CONNECTED,
 			sock_sndtimeo(sk, flags & O_NONBLOCK));
 done:
-	if (sock_owned_by_user(sk))
-		release_sock(sk);
+	if (err)
+		BT_ERR("failed %d", err);
+	release_sock(sk);
 	return err;
 }
 
 static int l2cap_sock_listen(struct socket *sock, int backlog)
 {
 	struct sock *sk = sock->sk;
-	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	int err = 0;
 
 	BT_DBG("sk %p backlog %d", sk, backlog);
@@ -151,7 +297,7 @@ static int l2cap_sock_listen(struct socket *sock, int backlog)
 		goto done;
 	}
 
-	switch (chan->mode) {
+	switch (l2cap_pi(sk)->mode) {
 	case L2CAP_MODE_BASIC:
 		break;
 	case L2CAP_MODE_ERTM:
@@ -164,10 +310,30 @@ static int l2cap_sock_listen(struct socket *sock, int backlog)
 		goto done;
 	}
 
+	if (!l2cap_pi(sk)->psm && !l2cap_pi(sk)->scid) {
+		bdaddr_t *src = &bt_sk(sk)->src;
+		u16 psm;
+
+		err = -EINVAL;
+
+		write_lock_bh(&l2cap_sk_list.lock);
+
+		for (psm = 0x1001; psm < 0x1100; psm += 2)
+			if (!__l2cap_get_sock_by_addr(cpu_to_le16(psm), src)) {
+				l2cap_pi(sk)->psm   = cpu_to_le16(psm);
+				l2cap_pi(sk)->sport = cpu_to_le16(psm);
+				err = 0;
+				break;
+			}
+
+		write_unlock_bh(&l2cap_sk_list.lock);
+
+		if (err < 0)
+			goto done;
+	}
+
 	sk->sk_max_ack_backlog = backlog;
 	sk->sk_ack_backlog = 0;
-
-	chan->state = BT_LISTEN;
 	sk->sk_state = BT_LISTEN;
 
 done:
@@ -184,26 +350,30 @@ static int l2cap_sock_accept(struct socket *sock, struct socket *newsock, int fl
 
 	lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
 
+	if (sk->sk_state != BT_LISTEN) {
+		err = -EBADFD;
+		goto done;
+	}
+
 	timeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);
 
 	BT_DBG("sk %p timeo %ld", sk, timeo);
 
 	/* Wait for an incoming connection. (wake-one). */
 	add_wait_queue_exclusive(sk_sleep(sk), &wait);
-	while (1) {
+	while (!(nsk = bt_accept_dequeue(sk, newsock))) {
 		set_current_state(TASK_INTERRUPTIBLE);
-
-		if (sk->sk_state != BT_LISTEN) {
-			err = -EBADFD;
+		if (!timeo) {
+			err = -EAGAIN;
 			break;
 		}
 
-		nsk = bt_accept_dequeue(sk, newsock);
-		if (nsk)
-			break;
+		release_sock(sk);
+		timeo = schedule_timeout(timeo);
+		lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
 
-		if (!timeo) {
-			err = -EAGAIN;
+		if (sk->sk_state != BT_LISTEN) {
+			err = -EBADFD;
 			break;
 		}
 
@@ -211,12 +381,8 @@ static int l2cap_sock_accept(struct socket *sock, struct socket *newsock, int fl
 			err = sock_intr_errno(timeo);
 			break;
 		}
-
-		release_sock(sk);
-		timeo = schedule_timeout(timeo);
-		lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
 	}
-	__set_current_state(TASK_RUNNING);
+	set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 
 	if (err)
@@ -235,7 +401,6 @@ static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *l
 {
 	struct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;
 	struct sock *sk = sock->sk;
-	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 
 	BT_DBG("sock %p, sk %p", sock, sk);
 
@@ -243,13 +408,13 @@ static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *l
 	*len = sizeof(struct sockaddr_l2);
 
 	if (peer) {
-		la->l2_psm = chan->psm;
+		la->l2_psm = l2cap_pi(sk)->psm;
 		bacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);
-		la->l2_cid = cpu_to_le16(chan->dcid);
+		la->l2_cid = cpu_to_le16(l2cap_pi(sk)->dcid);
 	} else {
-		la->l2_psm = chan->sport;
+		la->l2_psm = l2cap_pi(sk)->sport;
 		bacpy(&la->l2_bdaddr, &bt_sk(sk)->src);
-		la->l2_cid = cpu_to_le16(chan->scid);
+		la->l2_cid = cpu_to_le16(l2cap_pi(sk)->scid);
 	}
 
 	return 0;
@@ -258,7 +423,6 @@ static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *l
 static int l2cap_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)
 {
 	struct sock *sk = sock->sk;
-	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct l2cap_options opts;
 	struct l2cap_conninfo cinfo;
 	int len, err = 0;
@@ -274,13 +438,13 @@ static int l2cap_sock_getsockopt_old(struct socket *sock, int optname, char __us
 	switch (optname) {
 	case L2CAP_OPTIONS:
 		memset(&opts, 0, sizeof(opts));
-		opts.imtu     = chan->imtu;
-		opts.omtu     = chan->omtu;
-		opts.flush_to = chan->flush_to;
-		opts.mode     = chan->mode;
-		opts.fcs      = chan->fcs;
-		opts.max_tx   = chan->max_tx;
-		opts.txwin_size = chan->tx_win;
+		opts.imtu     = l2cap_pi(sk)->imtu;
+		opts.omtu     = l2cap_pi(sk)->omtu;
+		opts.flush_to = l2cap_pi(sk)->flush_to;
+		opts.mode     = l2cap_pi(sk)->mode;
+		opts.fcs      = l2cap_pi(sk)->fcs;
+		opts.max_tx   = l2cap_pi(sk)->max_tx;
+		opts.txwin_size = l2cap_pi(sk)->tx_win;
 
 		len = min_t(unsigned int, len, sizeof(opts));
 		if (copy_to_user(optval, (char *) &opts, len))
@@ -289,7 +453,7 @@ static int l2cap_sock_getsockopt_old(struct socket *sock, int optname, char __us
 		break;
 
 	case L2CAP_LM:
-		switch (chan->sec_level) {
+		switch (l2cap_pi(sk)->sec_level) {
 		case BT_SECURITY_LOW:
 			opt = L2CAP_LM_AUTH;
 			break;
@@ -305,12 +469,15 @@ static int l2cap_sock_getsockopt_old(struct socket *sock, int optname, char __us
 			break;
 		}
 
-		if (test_bit(FLAG_ROLE_SWITCH, &chan->flags))
+		if (l2cap_pi(sk)->role_switch)
 			opt |= L2CAP_LM_MASTER;
 
-		if (test_bit(FLAG_FORCE_RELIABLE, &chan->flags))
+		if (l2cap_pi(sk)->force_reliable)
 			opt |= L2CAP_LM_RELIABLE;
 
+		if (l2cap_pi(sk)->flushable)
+			opt |= L2CAP_LM_FLUSHABLE;
+
 		if (put_user(opt, (u32 __user *) optval))
 			err = -EFAULT;
 		break;
@@ -323,9 +490,8 @@ static int l2cap_sock_getsockopt_old(struct socket *sock, int optname, char __us
 			break;
 		}
 
-		memset(&cinfo, 0, sizeof(cinfo));
-		cinfo.hci_handle = chan->conn->hcon->handle;
-		memcpy(cinfo.dev_class, chan->conn->hcon->dev_class, 3);
+		cinfo.hci_handle = l2cap_pi(sk)->conn->hcon->handle;
+		memcpy(cinfo.dev_class, l2cap_pi(sk)->conn->hcon->dev_class, 3);
 
 		len = min_t(unsigned int, len, sizeof(cinfo));
 		if (copy_to_user(optval, (char *) &cinfo, len))
@@ -345,7 +511,6 @@ static int l2cap_sock_getsockopt_old(struct socket *sock, int optname, char __us
 static int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)
 {
 	struct sock *sk = sock->sk;
-	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct bt_security sec;
 	struct bt_power pwr;
 	int len, err = 0;
@@ -365,17 +530,19 @@ static int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, ch
 
 	switch (optname) {
 	case BT_SECURITY:
-		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&
-					chan->chan_type != L2CAP_CHAN_RAW) {
+		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
+				&& sk->sk_type != SOCK_RAW) {
 			err = -EINVAL;
 			break;
 		}
 
 		memset(&sec, 0, sizeof(sec));
-		sec.level = chan->sec_level;
+		sec.level = l2cap_pi(sk)->sec_level;
 
-		if (sk->sk_state == BT_CONNECTED)
-			sec.key_size = chan->conn->hcon->enc_key_size;
+		if (sk->sk_state == BT_CONNECTED) {
+			sec.key_size = l2cap_pi(sk)->conn->hcon->enc_key_size;
+			sec.level = l2cap_pi(sk)->conn->hcon->sec_level;
+		}
 
 		len = min_t(unsigned int, len, sizeof(sec));
 		if (copy_to_user(optval, (char *) &sec, len))
@@ -394,13 +561,6 @@ static int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, ch
 
 		break;
 
-	case BT_FLUSHABLE:
-		if (put_user(test_bit(FLAG_FLUSHABLE, &chan->flags),
-						(u32 __user *) optval))
-			err = -EFAULT;
-
-		break;
-
 	case BT_POWER:
 		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
 				&& sk->sk_type != SOCK_RAW) {
@@ -408,7 +568,7 @@ static int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, ch
 			break;
 		}
 
-		pwr.force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);
+		pwr.force_active = l2cap_pi(sk)->force_active;
 
 		len = min_t(unsigned int, len, sizeof(pwr));
 		if (copy_to_user(optval, (char *) &pwr, len))
@@ -416,13 +576,19 @@ static int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, ch
 
 		break;
 
-	case BT_CHANNEL_POLICY:
-		if (!enable_hs) {
-			err = -ENOPROTOOPT;
+	case BT_AMP_POLICY:
+		if (put_user(l2cap_pi(sk)->amp_pref, (u32 __user *) optval))
+			err = -EFAULT;
+		break;
+
+	case BT_LE_PARAMS:
+		if (l2cap_pi(sk)->scid != L2CAP_CID_LE_DATA) {
+			err = -EINVAL;
 			break;
 		}
 
-		if (put_user(chan->chan_policy, (u32 __user *) optval))
+		if (copy_to_user(optval, (char *) &bt_sk(sk)->le_params,
+						sizeof(bt_sk(sk)->le_params)))
 			err = -EFAULT;
 		break;
 
@@ -438,29 +604,30 @@ static int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, ch
 static int l2cap_sock_setsockopt_old(struct socket *sock, int optname, char __user *optval, unsigned int optlen)
 {
 	struct sock *sk = sock->sk;
-	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct l2cap_options opts;
-	int len, err = 0;
+	int len, le_sock, err = 0;
 	u32 opt;
 
 	BT_DBG("sk %p", sk);
 
 	lock_sock(sk);
 
+	le_sock = l2cap_pi(sk)->scid == L2CAP_CID_LE_DATA;
+
 	switch (optname) {
 	case L2CAP_OPTIONS:
-		if (sk->sk_state == BT_CONNECTED) {
+		if (sk->sk_state == BT_CONNECTED && !le_sock) {
 			err = -EINVAL;
 			break;
 		}
 
-		opts.imtu     = chan->imtu;
-		opts.omtu     = chan->omtu;
-		opts.flush_to = chan->flush_to;
-		opts.mode     = chan->mode;
-		opts.fcs      = chan->fcs;
-		opts.max_tx   = chan->max_tx;
-		opts.txwin_size = chan->tx_win;
+		opts.imtu     = l2cap_pi(sk)->imtu;
+		opts.omtu     = l2cap_pi(sk)->omtu;
+		opts.flush_to = l2cap_pi(sk)->flush_to;
+		opts.mode     = l2cap_pi(sk)->mode;
+		opts.fcs      = l2cap_pi(sk)->fcs;
+		opts.max_tx   = l2cap_pi(sk)->max_tx;
+		opts.txwin_size = l2cap_pi(sk)->tx_win;
 
 		len = min_t(unsigned int, sizeof(opts), optlen);
 		if (copy_from_user((char *) &opts, optval, len)) {
@@ -468,18 +635,39 @@ static int l2cap_sock_setsockopt_old(struct socket *sock, int optname, char __us
 			break;
 		}
 
-		if (opts.txwin_size > L2CAP_DEFAULT_EXT_WINDOW) {
+		if ((opts.imtu || opts.omtu) && le_sock &&
+				(sk->sk_state == BT_CONNECTED)) {
+			if (opts.imtu >= L2CAP_LE_DEFAULT_MTU)
+				l2cap_pi(sk)->imtu = opts.imtu;
+			if (opts.omtu >= L2CAP_LE_DEFAULT_MTU)
+				l2cap_pi(sk)->omtu = opts.omtu;
+			if (opts.imtu < L2CAP_LE_DEFAULT_MTU ||
+					opts.omtu < L2CAP_LE_DEFAULT_MTU)
+				err = -EINVAL;
+			break;
+		}
+
+		if (opts.txwin_size < 1 ||
+			opts.txwin_size > L2CAP_TX_WIN_MAX_EXTENDED) {
 			err = -EINVAL;
 			break;
 		}
 
-		chan->mode = opts.mode;
-		switch (chan->mode) {
+		l2cap_pi(sk)->mode = opts.mode;
+		switch (l2cap_pi(sk)->mode) {
 		case L2CAP_MODE_BASIC:
-			clear_bit(CONF_STATE2_DEVICE, &chan->conf_state);
+			l2cap_pi(sk)->conf_state &= ~L2CAP_CONF_STATE2_DEVICE;
 			break;
-		case L2CAP_MODE_ERTM:
 		case L2CAP_MODE_STREAMING:
+			if (!disable_ertm) {
+				/* No fallback to ERTM or Basic mode */
+				l2cap_pi(sk)->conf_state |=
+						L2CAP_CONF_STATE2_DEVICE;
+				break;
+			}
+			err = -EINVAL;
+			break;
+		case L2CAP_MODE_ERTM:
 			if (!disable_ertm)
 				break;
 			/* fall through */
@@ -488,11 +676,12 @@ static int l2cap_sock_setsockopt_old(struct socket *sock, int optname, char __us
 			break;
 		}
 
-		chan->imtu = opts.imtu;
-		chan->omtu = opts.omtu;
-		chan->fcs  = opts.fcs;
-		chan->max_tx = opts.max_tx;
-		chan->tx_win = opts.txwin_size;
+		l2cap_pi(sk)->imtu = opts.imtu;
+		l2cap_pi(sk)->omtu = opts.omtu;
+		l2cap_pi(sk)->fcs  = opts.fcs;
+		l2cap_pi(sk)->max_tx = opts.max_tx;
+		l2cap_pi(sk)->tx_win = opts.txwin_size;
+		l2cap_pi(sk)->flush_to = opts.flush_to;
 		break;
 
 	case L2CAP_LM:
@@ -502,21 +691,15 @@ static int l2cap_sock_setsockopt_old(struct socket *sock, int optname, char __us
 		}
 
 		if (opt & L2CAP_LM_AUTH)
-			chan->sec_level = BT_SECURITY_LOW;
+			l2cap_pi(sk)->sec_level = BT_SECURITY_LOW;
 		if (opt & L2CAP_LM_ENCRYPT)
-			chan->sec_level = BT_SECURITY_MEDIUM;
+			l2cap_pi(sk)->sec_level = BT_SECURITY_MEDIUM;
 		if (opt & L2CAP_LM_SECURE)
-			chan->sec_level = BT_SECURITY_HIGH;
+			l2cap_pi(sk)->sec_level = BT_SECURITY_HIGH;
 
-		if (opt & L2CAP_LM_MASTER)
-			set_bit(FLAG_ROLE_SWITCH, &chan->flags);
-		else
-			clear_bit(FLAG_ROLE_SWITCH, &chan->flags);
-
-		if (opt & L2CAP_LM_RELIABLE)
-			set_bit(FLAG_FORCE_RELIABLE, &chan->flags);
-		else
-			clear_bit(FLAG_FORCE_RELIABLE, &chan->flags);
+		l2cap_pi(sk)->role_switch    = (opt & L2CAP_LM_MASTER);
+		l2cap_pi(sk)->force_reliable = (opt & L2CAP_LM_RELIABLE);
+		l2cap_pi(sk)->flushable = (opt & L2CAP_LM_FLUSHABLE);
 		break;
 
 	default:
@@ -531,9 +714,9 @@ static int l2cap_sock_setsockopt_old(struct socket *sock, int optname, char __us
 static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)
 {
 	struct sock *sk = sock->sk;
-	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	struct bt_security sec;
 	struct bt_power pwr;
+	struct bt_le_params le_params;
 	struct l2cap_conn *conn;
 	int len, err = 0;
 	u32 opt;
@@ -550,8 +733,8 @@ static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, ch
 
 	switch (optname) {
 	case BT_SECURITY:
-		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&
-					chan->chan_type != L2CAP_CHAN_RAW) {
+		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
+				&& sk->sk_type != SOCK_RAW) {
 			err = -EINVAL;
 			break;
 		}
@@ -570,15 +753,10 @@ static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, ch
 			break;
 		}
 
-		chan->sec_level = sec.level;
-
-		if (!chan->conn)
-			break;
-
-		conn = chan->conn;
+		l2cap_pi(sk)->sec_level = sec.level;
 
-		/*change security for LE channels */
-		if (chan->scid == L2CAP_CID_LE_DATA) {
+		conn = l2cap_pi(sk)->conn;
+		if (conn && l2cap_pi(sk)->scid == L2CAP_CID_LE_DATA) {
 			if (!conn->hcon->out) {
 				err = -EINVAL;
 				break;
@@ -586,15 +764,9 @@ static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, ch
 
 			if (smp_conn_security(conn, sec.level))
 				break;
-			sk->sk_state = BT_CONFIG;
-			chan->state = BT_CONFIG;
 
-		/* or for ACL link, under defer_setup time */
-		} else if (sk->sk_state == BT_CONNECT2 &&
-					bt_sk(sk)->defer_setup) {
-			err = l2cap_chan_check_security(chan);
-		} else {
-			err = -EINVAL;
+			err = 0;
+			sk->sk_state = BT_CONFIG;
 		}
 		break;
 
@@ -612,77 +784,88 @@ static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, ch
 		bt_sk(sk)->defer_setup = opt;
 		break;
 
-	case BT_FLUSHABLE:
-		if (get_user(opt, (u32 __user *) optval)) {
-			err = -EFAULT;
+	case BT_POWER:
+		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
+				&& sk->sk_type != SOCK_RAW) {
+			err = -EINVAL;
 			break;
 		}
 
-		if (opt > BT_FLUSHABLE_ON) {
-			err = -EINVAL;
+		pwr.force_active = 1;
+
+		len = min_t(unsigned int, sizeof(pwr), optlen);
+		if (copy_from_user((char *) &pwr, optval, len)) {
+			err = -EFAULT;
 			break;
 		}
+		l2cap_pi(sk)->force_active = pwr.force_active;
+		break;
 
-		if (opt == BT_FLUSHABLE_OFF) {
-			struct l2cap_conn *conn = chan->conn;
-			/* proceed further only when we have l2cap_conn and
-			   No Flush support in the LM */
-			if (!conn || !lmp_no_flush_capable(conn->hcon->hdev)) {
-				err = -EINVAL;
-				break;
-			}
+	case BT_AMP_POLICY:
+		if (get_user(opt, (u32 __user *) optval)) {
+			err = -EFAULT;
+			break;
 		}
 
-		if (opt)
-			set_bit(FLAG_FLUSHABLE, &chan->flags);
-		else
-			clear_bit(FLAG_FLUSHABLE, &chan->flags);
-		break;
-
-	case BT_POWER:
-		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&
-					chan->chan_type != L2CAP_CHAN_RAW) {
+		if ((opt > BT_AMP_POLICY_PREFER_AMP) ||
+			((l2cap_pi(sk)->mode != L2CAP_MODE_ERTM) &&
+			 (l2cap_pi(sk)->mode != L2CAP_MODE_STREAMING))) {
 			err = -EINVAL;
 			break;
 		}
 
-		pwr.force_active = BT_POWER_FORCE_ACTIVE_ON;
+		l2cap_pi(sk)->amp_pref = (u8) opt;
+		BT_DBG("BT_AMP_POLICY now %d", opt);
 
-		len = min_t(unsigned int, sizeof(pwr), optlen);
-		if (copy_from_user((char *) &pwr, optval, len)) {
+		if ((sk->sk_state == BT_CONNECTED) &&
+			(l2cap_pi(sk)->amp_move_role == L2CAP_AMP_MOVE_NONE))
+			l2cap_amp_move_init(sk);
+
+		break;
+
+	case BT_FLUSHABLE:
+		if (get_user(opt, (u32 __user *) optval)) {
 			err = -EFAULT;
 			break;
 		}
+		l2cap_pi(sk)->flushable = opt;
 
-		if (pwr.force_active)
-			set_bit(FLAG_FORCE_ACTIVE, &chan->flags);
-		else
-			clear_bit(FLAG_FORCE_ACTIVE, &chan->flags);
 		break;
 
-	case BT_CHANNEL_POLICY:
-		if (!enable_hs) {
-			err = -ENOPROTOOPT;
+	case BT_LE_PARAMS:
+		if (l2cap_pi(sk)->scid != L2CAP_CID_LE_DATA) {
+			err = -EINVAL;
 			break;
 		}
 
-		if (get_user(opt, (u32 __user *) optval)) {
+		if (copy_from_user((char *) &le_params, optval,
+					sizeof(struct bt_le_params))) {
 			err = -EFAULT;
 			break;
 		}
 
-		if (opt > BT_CHANNEL_POLICY_AMP_PREFERRED) {
-			err = -EINVAL;
+		conn = l2cap_pi(sk)->conn;
+		if (!conn || !conn->hcon ||
+				l2cap_pi(sk)->scid != L2CAP_CID_LE_DATA) {
+			memcpy(&bt_sk(sk)->le_params, &le_params,
+							sizeof(le_params));
 			break;
 		}
 
-		if (chan->mode != L2CAP_MODE_ERTM &&
-				chan->mode != L2CAP_MODE_STREAMING) {
-			err = -EOPNOTSUPP;
+		if (!conn->hcon->out ||
+				!l2cap_sock_le_conn_update_params_valid(
+					&le_params)) {
+			err = -EINVAL;
 			break;
 		}
 
-		chan->chan_policy = (u8) opt;
+		memcpy(&bt_sk(sk)->le_params, &le_params, sizeof(le_params));
+
+		hci_le_conn_update(conn->hcon,
+				le_params.interval_min,
+				le_params.interval_max,
+				le_params.latency,
+				le_params.supervision_timeout);
 		break;
 
 	default:
@@ -697,8 +880,11 @@ static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, ch
 static int l2cap_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len)
 {
 	struct sock *sk = sock->sk;
-	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
+	struct l2cap_pinfo *pi = l2cap_pi(sk);
+	struct sk_buff *skb;
+	struct sk_buff_head seg_queue;
 	int err;
+	u8 amp_id;
 
 	BT_DBG("sock %p, sk %p", sock, sk);
 
@@ -712,12 +898,102 @@ static int l2cap_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct ms
 	lock_sock(sk);
 
 	if (sk->sk_state != BT_CONNECTED) {
-		release_sock(sk);
-		return -ENOTCONN;
+		err = -ENOTCONN;
+		goto done;
 	}
 
-	err = l2cap_chan_send(chan, msg, len, sk->sk_priority);
+	/* Connectionless channel */
+	if (sk->sk_type == SOCK_DGRAM) {
+		skb = l2cap_create_connless_pdu(sk, msg, len);
+		if (IS_ERR(skb)) {
+			err = PTR_ERR(skb);
+		} else {
+			l2cap_do_send(sk, skb);
+			err = len;
+		}
+		goto done;
+	}
+
+	switch (pi->mode) {
+	case L2CAP_MODE_BASIC:
+		/* Check outgoing MTU */
+		if (len > pi->omtu) {
+			err = -EMSGSIZE;
+			goto done;
+		}
+
+		/* Create a basic PDU */
+		skb = l2cap_create_basic_pdu(sk, msg, len);
+		if (IS_ERR(skb)) {
+			err = PTR_ERR(skb);
+			goto done;
+		}
+
+		l2cap_do_send(sk, skb);
+		err = len;
+		break;
+
+	case L2CAP_MODE_ERTM:
+	case L2CAP_MODE_STREAMING:
+
+		/* Check outgoing MTU */
+		if (len > pi->omtu) {
+			err = -EMSGSIZE;
+			goto done;
+		}
+
+		__skb_queue_head_init(&seg_queue);
+
+		/* Do segmentation before calling in to the state machine,
+		 * since it's possible to block while waiting for memory
+		 * allocation.
+		 */
+		amp_id = pi->amp_id;
+		err = l2cap_segment_sdu(sk, &seg_queue, msg, len, 0);
+
+		/* The socket lock is released while segmenting, so check
+		 * that the socket is still connected
+		 */
+		if (sk->sk_state != BT_CONNECTED) {
+			__skb_queue_purge(&seg_queue);
+			err = -ENOTCONN;
+		}
 
+		if (err) {
+			BT_DBG("Error %d, sk_sndbuf %d, sk_wmem_alloc %d",
+				err, sk->sk_sndbuf,
+				atomic_read(&sk->sk_wmem_alloc));
+			break;
+		}
+
+		if (pi->amp_id != amp_id) {
+			/* Channel moved while unlocked. Resegment. */
+			err = l2cap_resegment_queue(sk, &seg_queue);
+
+			if (err)
+				break;
+		}
+
+		if (pi->mode != L2CAP_MODE_STREAMING)
+			err = l2cap_ertm_tx(sk, 0, &seg_queue,
+				L2CAP_ERTM_EVENT_DATA_REQUEST);
+		else
+			err = l2cap_strm_tx(sk, &seg_queue);
+		if (!err)
+			err = len;
+
+		/* If the skbs were not queued for sending, they'll still be in
+		 * seg_queue and need to be purged.
+		 */
+		__skb_queue_purge(&seg_queue);
+		break;
+
+	default:
+		BT_DBG("bad state %1.1x", pi->mode);
+		err = -EBADFD;
+	}
+
+done:
 	release_sock(sk);
 	return err;
 }
@@ -725,16 +1001,43 @@ static int l2cap_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct ms
 static int l2cap_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len, int flags)
 {
 	struct sock *sk = sock->sk;
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
 	int err;
 
 	lock_sock(sk);
 
 	if (sk->sk_state == BT_CONNECT2 && bt_sk(sk)->defer_setup) {
+		struct l2cap_conn_rsp rsp;
+		struct l2cap_conn *conn = l2cap_pi(sk)->conn;
+		u8 buf[128];
+
+		if (l2cap_pi(sk)->amp_id) {
+			/* Physical link must be brought up before connection
+			 * completes.
+			 */
+			amp_accept_physical(conn, l2cap_pi(sk)->amp_id, sk);
+			release_sock(sk);
+			return 0;
+		}
+
 		sk->sk_state = BT_CONFIG;
-		pi->chan->state = BT_CONFIG;
 
-		__l2cap_connect_rsp_defer(pi->chan);
+		rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
+		rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
+		rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
+		rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
+		l2cap_send_cmd(l2cap_pi(sk)->conn, l2cap_pi(sk)->ident,
+					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
+
+		if (l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT) {
+			release_sock(sk);
+			return 0;
+		}
+
+		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
+		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
+				l2cap_build_conf_req(sk, buf), buf);
+		l2cap_pi(sk)->num_conf_req++;
+
 		release_sock(sk);
 		return 0;
 	}
@@ -746,39 +1049,16 @@ static int l2cap_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct ms
 	else
 		err = bt_sock_recvmsg(iocb, sock, msg, len, flags);
 
-	if (pi->chan->mode != L2CAP_MODE_ERTM)
-		return err;
-
-	/* Attempt to put pending rx data in the socket buffer */
+	if (err >= 0)
+		l2cap_ertm_recv_done(sk);
 
-	lock_sock(sk);
-
-	if (!test_bit(CONN_LOCAL_BUSY, &pi->chan->conn_state))
-		goto done;
-
-	if (pi->rx_busy_skb) {
-		if (!sock_queue_rcv_skb(sk, pi->rx_busy_skb))
-			pi->rx_busy_skb = NULL;
-		else
-			goto done;
-	}
-
-	/* Restore data flow when half of the receive buffer is
-	 * available.  This avoids resending large numbers of
-	 * frames.
-	 */
-	if (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf >> 1)
-		l2cap_chan_busy(pi->chan, 0);
-
-done:
-	release_sock(sk);
 	return err;
 }
 
 /* Kill socket (only if zapped and orphan)
  * Must be called on unlocked socket.
  */
-static void l2cap_sock_kill(struct sock *sk)
+void l2cap_sock_kill(struct sock *sk)
 {
 	if (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)
 		return;
@@ -786,16 +1066,95 @@ static void l2cap_sock_kill(struct sock *sk)
 	BT_DBG("sk %p state %d", sk, sk->sk_state);
 
 	/* Kill poor orphan */
-
-	l2cap_chan_put(l2cap_pi(sk)->chan);
+	bt_sock_unlink(&l2cap_sk_list, sk);
 	sock_set_flag(sk, SOCK_DEAD);
 	sock_put(sk);
 }
 
+/* Must be called on unlocked socket. */
+static void l2cap_sock_close(struct sock *sk)
+{
+	l2cap_sock_clear_timer(sk);
+	lock_sock(sk);
+	__l2cap_sock_close(sk, ECONNRESET);
+	release_sock(sk);
+	l2cap_sock_kill(sk);
+}
+
+static void l2cap_sock_cleanup_listen(struct sock *parent)
+{
+	struct sock *sk;
+
+	BT_DBG("parent %p", parent);
+
+	/* Close not yet accepted channels */
+	while ((sk = bt_accept_dequeue(parent, NULL)))
+		l2cap_sock_close(sk);
+
+	parent->sk_state = BT_CLOSED;
+	sock_set_flag(parent, SOCK_ZAPPED);
+}
+
+void __l2cap_sock_close(struct sock *sk, int reason)
+{
+	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
+
+	BT_DBG("sk %p state %d socket %p", sk, sk->sk_state, sk->sk_socket);
+
+	switch (sk->sk_state) {
+	case BT_LISTEN:
+		l2cap_sock_cleanup_listen(sk);
+		break;
+
+	case BT_CONNECTED:
+	case BT_CONFIG:
+		if ((sk->sk_type == SOCK_SEQPACKET ||
+					sk->sk_type == SOCK_STREAM) &&
+					conn->hcon->type == ACL_LINK) {
+			l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
+			l2cap_send_disconn_req(conn, sk, reason);
+		} else
+			l2cap_chan_del(sk, reason);
+		break;
+
+	case BT_CONNECT2:
+		if ((sk->sk_type == SOCK_SEQPACKET ||
+					sk->sk_type == SOCK_STREAM) &&
+					conn->hcon->type == ACL_LINK) {
+			struct l2cap_conn_rsp rsp;
+			__u16 result;
+
+			if (bt_sk(sk)->defer_setup)
+				result = L2CAP_CR_SEC_BLOCK;
+			else
+				result = L2CAP_CR_BAD_PSM;
+			sk->sk_state = BT_DISCONN;
+
+			rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
+			rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
+			rsp.result = cpu_to_le16(result);
+			rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
+			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
+					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
+		}
+
+		l2cap_chan_del(sk, reason);
+		break;
+
+	case BT_CONNECT:
+	case BT_DISCONN:
+		l2cap_chan_del(sk, reason);
+		break;
+
+	default:
+		sock_set_flag(sk, SOCK_ZAPPED);
+		break;
+	}
+}
+
 static int l2cap_sock_shutdown(struct socket *sock, int how)
 {
 	struct sock *sk = sock->sk;
-	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 	int err = 0;
 
 	BT_DBG("sock %p, sk %p", sock, sk);
@@ -805,11 +1164,15 @@ static int l2cap_sock_shutdown(struct socket *sock, int how)
 
 	lock_sock(sk);
 	if (!sk->sk_shutdown) {
-		if (chan->mode == L2CAP_MODE_ERTM)
+
+		if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM) {
 			err = __l2cap_wait_ack(sk);
+			l2cap_ertm_shutdown(sk);
+		}
 
 		sk->sk_shutdown = SHUTDOWN_MASK;
-		l2cap_chan_close(chan, 0);
+		l2cap_sock_clear_timer(sk);
+		__l2cap_sock_close(sk, 0);
 
 		if (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime)
 			err = bt_sock_wait_state(sk, BT_CLOSED,
@@ -826,6 +1189,7 @@ static int l2cap_sock_shutdown(struct socket *sock, int how)
 static int l2cap_sock_release(struct socket *sock)
 {
 	struct sock *sk = sock->sk;
+	struct sock *sk2 = NULL;
 	int err;
 
 	BT_DBG("sock %p, sk %p", sock, sk);
@@ -833,6 +1197,17 @@ static int l2cap_sock_release(struct socket *sock)
 	if (!sk)
 		return 0;
 
+	/* If this is an ATT socket, find it's matching server/client */
+	if (l2cap_pi(sk)->scid == L2CAP_CID_LE_DATA)
+		sk2 = l2cap_find_sock_by_fixed_cid_and_dir(L2CAP_CID_LE_DATA,
+					&bt_sk(sk)->src, &bt_sk(sk)->dst,
+					l2cap_pi(sk)->incoming ? 0 : 1);
+
+	/* If matching socket found, request tear down */
+	BT_DBG("sock:%p companion:%p", sk, sk2);
+	if (sk2)
+		l2cap_sock_set_timer(sk2, 1);
+
 	err = l2cap_sock_shutdown(sock, 2);
 
 	sock_orphan(sk);
@@ -840,149 +1215,87 @@ static int l2cap_sock_release(struct socket *sock)
 	return err;
 }
 
-static struct l2cap_chan *l2cap_sock_new_connection_cb(void *data)
-{
-	struct sock *sk, *parent = data;
-
-	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,
-								GFP_ATOMIC);
-	if (!sk)
-		return NULL;
-
-	bt_sock_reclassify_lock(sk, BTPROTO_L2CAP);
-
-	l2cap_sock_init(sk, parent);
-
-	return l2cap_pi(sk)->chan;
-}
-
-static int l2cap_sock_recv_cb(void *data, struct sk_buff *skb)
-{
-	int err;
-	struct sock *sk = data;
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-
-	if (pi->rx_busy_skb)
-		return -ENOMEM;
-
-	err = sock_queue_rcv_skb(sk, skb);
-
-	/* For ERTM, handle one skb that doesn't fit into the recv
-	 * buffer.  This is important to do because the data frames
-	 * have already been acked, so the skb cannot be discarded.
-	 *
-	 * Notify the l2cap core that the buffer is full, so the
-	 * LOCAL_BUSY state is entered and no more frames are
-	 * acked and reassembled until there is buffer space
-	 * available.
-	 */
-	if (err < 0 && pi->chan->mode == L2CAP_MODE_ERTM) {
-		pi->rx_busy_skb = skb;
-		l2cap_chan_busy(pi->chan, 1);
-		err = 0;
-	}
-
-	return err;
-}
-
-static void l2cap_sock_close_cb(void *data)
-{
-	struct sock *sk = data;
-
-	l2cap_sock_kill(sk);
-}
-
-static void l2cap_sock_state_change_cb(void *data, int state)
-{
-	struct sock *sk = data;
-
-	sk->sk_state = state;
-}
-
-static struct l2cap_ops l2cap_chan_ops = {
-	.name		= "L2CAP Socket Interface",
-	.new_connection	= l2cap_sock_new_connection_cb,
-	.recv		= l2cap_sock_recv_cb,
-	.close		= l2cap_sock_close_cb,
-	.state_change	= l2cap_sock_state_change_cb,
-};
-
 static void l2cap_sock_destruct(struct sock *sk)
 {
 	BT_DBG("sk %p", sk);
 
-	if (l2cap_pi(sk)->rx_busy_skb) {
-		kfree_skb(l2cap_pi(sk)->rx_busy_skb);
-		l2cap_pi(sk)->rx_busy_skb = NULL;
-	}
-
 	skb_queue_purge(&sk->sk_receive_queue);
 	skb_queue_purge(&sk->sk_write_queue);
+
+	l2cap_ertm_destruct(sk);
 }
 
-static void l2cap_sock_init(struct sock *sk, struct sock *parent)
+static void set_default_config(struct l2cap_conf_prm *conf_prm)
+{
+	conf_prm->fcs = L2CAP_FCS_CRC16;
+	conf_prm->flush_to = L2CAP_DEFAULT_FLUSH_TO;
+}
+
+void l2cap_sock_init(struct sock *sk, struct sock *parent)
 {
 	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct l2cap_chan *chan = pi->chan;
 
-	BT_DBG("sk %p", sk);
+	BT_DBG("sk %p parent %p", sk, parent);
 
 	if (parent) {
-		struct l2cap_chan *pchan = l2cap_pi(parent)->chan;
-
 		sk->sk_type = parent->sk_type;
+		sk->sk_rcvbuf = parent->sk_rcvbuf;
+		sk->sk_sndbuf = parent->sk_sndbuf;
 		bt_sk(sk)->defer_setup = bt_sk(parent)->defer_setup;
 
-		chan->chan_type = pchan->chan_type;
-		chan->imtu = pchan->imtu;
-		chan->omtu = pchan->omtu;
-		chan->conf_state = pchan->conf_state;
-		chan->mode = pchan->mode;
-		chan->fcs  = pchan->fcs;
-		chan->max_tx = pchan->max_tx;
-		chan->tx_win = pchan->tx_win;
-		chan->tx_win_max = pchan->tx_win_max;
-		chan->sec_level = pchan->sec_level;
-		chan->flags = pchan->flags;
-
-		security_sk_clone(parent, sk);
+		pi->imtu = l2cap_pi(parent)->imtu;
+		pi->omtu = l2cap_pi(parent)->omtu;
+		pi->conf_state = l2cap_pi(parent)->conf_state;
+		pi->mode = l2cap_pi(parent)->mode;
+		pi->fcs  = l2cap_pi(parent)->fcs;
+		pi->max_tx = l2cap_pi(parent)->max_tx;
+		pi->tx_win = l2cap_pi(parent)->tx_win;
+		pi->sec_level = l2cap_pi(parent)->sec_level;
+		pi->role_switch = l2cap_pi(parent)->role_switch;
+		pi->force_reliable = l2cap_pi(parent)->force_reliable;
+		pi->flushable = l2cap_pi(parent)->flushable;
+		pi->force_active = l2cap_pi(parent)->force_active;
+		pi->amp_pref = l2cap_pi(parent)->amp_pref;
 	} else {
-
-		switch (sk->sk_type) {
-		case SOCK_RAW:
-			chan->chan_type = L2CAP_CHAN_RAW;
-			break;
-		case SOCK_DGRAM:
-			chan->chan_type = L2CAP_CHAN_CONN_LESS;
-			break;
-		case SOCK_SEQPACKET:
-		case SOCK_STREAM:
-			chan->chan_type = L2CAP_CHAN_CONN_ORIENTED;
-			break;
-		}
-
-		chan->imtu = L2CAP_DEFAULT_MTU;
-		chan->omtu = 0;
+		pi->imtu = L2CAP_DEFAULT_MTU;
+		pi->omtu = 0;
 		if (!disable_ertm && sk->sk_type == SOCK_STREAM) {
-			chan->mode = L2CAP_MODE_ERTM;
-			set_bit(CONF_STATE2_DEVICE, &chan->conf_state);
+			pi->mode = L2CAP_MODE_ERTM;
+			pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;
 		} else {
-			chan->mode = L2CAP_MODE_BASIC;
+			pi->mode = L2CAP_MODE_BASIC;
 		}
-		chan->max_tx = L2CAP_DEFAULT_MAX_TX;
-		chan->fcs  = L2CAP_FCS_CRC16;
-		chan->tx_win = L2CAP_DEFAULT_TX_WINDOW;
-		chan->tx_win_max = L2CAP_DEFAULT_TX_WINDOW;
-		chan->sec_level = BT_SECURITY_LOW;
-		chan->flags = 0;
-		set_bit(FLAG_FORCE_ACTIVE, &chan->flags);
+		pi->reconf_state = L2CAP_RECONF_NONE;
+		pi->max_tx = L2CAP_DEFAULT_MAX_TX;
+		pi->fcs = L2CAP_FCS_CRC16;
+		pi->tx_win = L2CAP_DEFAULT_TX_WINDOW;
+		pi->sec_level = BT_SECURITY_LOW;
+		pi->role_switch = 0;
+		pi->force_reliable = 0;
+		pi->flushable = 0;
+		pi->force_active = 1;
+		pi->amp_pref = BT_AMP_POLICY_REQUIRE_BR_EDR;
 	}
 
 	/* Default config options */
-	chan->flush_to = L2CAP_DEFAULT_FLUSH_TO;
-
-	chan->data = sk;
-	chan->ops = &l2cap_chan_ops;
+	sk->sk_backlog_rcv = l2cap_data_channel;
+	pi->ampcon = NULL;
+	pi->ampchan = NULL;
+	pi->conf_len = 0;
+	pi->flush_to = L2CAP_DEFAULT_FLUSH_TO;
+	pi->scid = 0;
+	pi->dcid = 0;
+	pi->tx_win_max = L2CAP_TX_WIN_MAX_ENHANCED;
+	pi->ack_win = pi->tx_win;
+	pi->extended_control = 0;
+
+	pi->local_conf.fcs = pi->fcs;
+	pi->local_conf.flush_to = pi->flush_to;
+
+	set_default_config(&pi->remote_conf);
+
+	skb_queue_head_init(TX_QUEUE(sk));
+	skb_queue_head_init(SREJ_QUEUE(sk));
 }
 
 static struct proto l2cap_proto = {
@@ -991,10 +1304,9 @@ static struct proto l2cap_proto = {
 	.obj_size	= sizeof(struct l2cap_pinfo)
 };
 
-static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)
+struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)
 {
 	struct sock *sk;
-	struct l2cap_chan *chan;
 
 	sk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto);
 	if (!sk)
@@ -1011,14 +1323,9 @@ static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int p
 	sk->sk_protocol = proto;
 	sk->sk_state = BT_OPEN;
 
-	chan = l2cap_chan_create(sk);
-	if (!chan) {
-		l2cap_sock_kill(sk);
-		return NULL;
-	}
-
-	l2cap_pi(sk)->chan = chan;
+	setup_timer(&sk->sk_timer, l2cap_sock_timeout, (unsigned long) sk);
 
+	bt_sock_link(&l2cap_sk_list, sk);
 	return sk;
 }
 
@@ -1048,7 +1355,7 @@ static int l2cap_sock_create(struct net *net, struct socket *sock, int protocol,
 	return 0;
 }
 
-static const struct proto_ops l2cap_sock_ops = {
+const struct proto_ops l2cap_sock_ops = {
 	.family		= PF_BLUETOOTH,
 	.owner		= THIS_MODULE,
 	.release	= l2cap_sock_release,
diff --git a/net/bluetooth/lib.c b/net/bluetooth/lib.c
index 86a6bed..b826d1b 100644
--- a/net/bluetooth/lib.c
+++ b/net/bluetooth/lib.c
@@ -59,7 +59,7 @@ char *batostr(bdaddr_t *ba)
 EXPORT_SYMBOL(batostr);
 
 /* Bluetooth error codes to Unix errno mapping */
-int bt_to_errno(__u16 code)
+int bt_err(__u16 code)
 {
 	switch (code) {
 	case 0:
@@ -149,23 +149,4 @@ int bt_to_errno(__u16 code)
 		return ENOSYS;
 	}
 }
-EXPORT_SYMBOL(bt_to_errno);
-
-int bt_printk(const char *level, const char *format, ...)
-{
-	struct va_format vaf;
-	va_list args;
-	int r;
-
-	va_start(args, format);
-
-	vaf.fmt = format;
-	vaf.va = &args;
-
-	r = printk("%sBluetooth: %pV\n", level, &vaf);
-
-	va_end(args);
-
-	return r;
-}
-EXPORT_SYMBOL(bt_printk);
+EXPORT_SYMBOL(bt_err);
diff --git a/net/bluetooth/mgmt.c b/net/bluetooth/mgmt.c
index 829f587..8658b94 100644
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@ -1,6 +1,7 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
    Copyright (C) 2010  Nokia Corporation
+   Copyright (c) 2011-2013 The Linux Foundation.  All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2 as
@@ -22,111 +23,45 @@
 
 /* Bluetooth HCI Management interface */
 
-#include <linux/kernel.h>
 #include <linux/uaccess.h>
+#include <linux/interrupt.h>
 #include <linux/module.h>
 #include <asm/unaligned.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
+#include <net/bluetooth/l2cap.h>
 #include <net/bluetooth/mgmt.h>
 #include <net/bluetooth/smp.h>
 
 #define MGMT_VERSION	0
 #define MGMT_REVISION	1
 
-#define INQUIRY_LEN_BREDR 0x08 /* TGAP(100) */
-
-#define SERVICE_CACHE_TIMEOUT (5 * 1000)
+#define SCAN_IDLE	0x00
+#define SCAN_LE		0x01
+#define SCAN_BR		0x02
 
 struct pending_cmd {
 	struct list_head list;
-	u16 opcode;
+	__u16 opcode;
 	int index;
 	void *param;
 	struct sock *sk;
 	void *user_data;
 };
 
-/* HCI to MGMT error code conversion table */
-static u8 mgmt_status_table[] = {
-	MGMT_STATUS_SUCCESS,
-	MGMT_STATUS_UNKNOWN_COMMAND,	/* Unknown Command */
-	MGMT_STATUS_NOT_CONNECTED,	/* No Connection */
-	MGMT_STATUS_FAILED,		/* Hardware Failure */
-	MGMT_STATUS_CONNECT_FAILED,	/* Page Timeout */
-	MGMT_STATUS_AUTH_FAILED,	/* Authentication Failed */
-	MGMT_STATUS_NOT_PAIRED,		/* PIN or Key Missing */
-	MGMT_STATUS_NO_RESOURCES,	/* Memory Full */
-	MGMT_STATUS_TIMEOUT,		/* Connection Timeout */
-	MGMT_STATUS_NO_RESOURCES,	/* Max Number of Connections */
-	MGMT_STATUS_NO_RESOURCES,	/* Max Number of SCO Connections */
-	MGMT_STATUS_ALREADY_CONNECTED,	/* ACL Connection Exists */
-	MGMT_STATUS_BUSY,		/* Command Disallowed */
-	MGMT_STATUS_NO_RESOURCES,	/* Rejected Limited Resources */
-	MGMT_STATUS_REJECTED,		/* Rejected Security */
-	MGMT_STATUS_REJECTED,		/* Rejected Personal */
-	MGMT_STATUS_TIMEOUT,		/* Host Timeout */
-	MGMT_STATUS_NOT_SUPPORTED,	/* Unsupported Feature */
-	MGMT_STATUS_INVALID_PARAMS,	/* Invalid Parameters */
-	MGMT_STATUS_DISCONNECTED,	/* OE User Ended Connection */
-	MGMT_STATUS_NO_RESOURCES,	/* OE Low Resources */
-	MGMT_STATUS_DISCONNECTED,	/* OE Power Off */
-	MGMT_STATUS_DISCONNECTED,	/* Connection Terminated */
-	MGMT_STATUS_BUSY,		/* Repeated Attempts */
-	MGMT_STATUS_REJECTED,		/* Pairing Not Allowed */
-	MGMT_STATUS_FAILED,		/* Unknown LMP PDU */
-	MGMT_STATUS_NOT_SUPPORTED,	/* Unsupported Remote Feature */
-	MGMT_STATUS_REJECTED,		/* SCO Offset Rejected */
-	MGMT_STATUS_REJECTED,		/* SCO Interval Rejected */
-	MGMT_STATUS_REJECTED,		/* Air Mode Rejected */
-	MGMT_STATUS_INVALID_PARAMS,	/* Invalid LMP Parameters */
-	MGMT_STATUS_FAILED,		/* Unspecified Error */
-	MGMT_STATUS_NOT_SUPPORTED,	/* Unsupported LMP Parameter Value */
-	MGMT_STATUS_FAILED,		/* Role Change Not Allowed */
-	MGMT_STATUS_TIMEOUT,		/* LMP Response Timeout */
-	MGMT_STATUS_FAILED,		/* LMP Error Transaction Collision */
-	MGMT_STATUS_FAILED,		/* LMP PDU Not Allowed */
-	MGMT_STATUS_REJECTED,		/* Encryption Mode Not Accepted */
-	MGMT_STATUS_FAILED,		/* Unit Link Key Used */
-	MGMT_STATUS_NOT_SUPPORTED,	/* QoS Not Supported */
-	MGMT_STATUS_TIMEOUT,		/* Instant Passed */
-	MGMT_STATUS_NOT_SUPPORTED,	/* Pairing Not Supported */
-	MGMT_STATUS_FAILED,		/* Transaction Collision */
-	MGMT_STATUS_INVALID_PARAMS,	/* Unacceptable Parameter */
-	MGMT_STATUS_REJECTED,		/* QoS Rejected */
-	MGMT_STATUS_NOT_SUPPORTED,	/* Classification Not Supported */
-	MGMT_STATUS_REJECTED,		/* Insufficient Security */
-	MGMT_STATUS_INVALID_PARAMS,	/* Parameter Out Of Range */
-	MGMT_STATUS_BUSY,		/* Role Switch Pending */
-	MGMT_STATUS_FAILED,		/* Slot Violation */
-	MGMT_STATUS_FAILED,		/* Role Switch Failed */
-	MGMT_STATUS_INVALID_PARAMS,	/* EIR Too Large */
-	MGMT_STATUS_NOT_SUPPORTED,	/* Simple Pairing Not Supported */
-	MGMT_STATUS_BUSY,		/* Host Busy Pairing */
-	MGMT_STATUS_REJECTED,		/* Rejected, No Suitable Channel */
-	MGMT_STATUS_BUSY,		/* Controller Busy */
-	MGMT_STATUS_INVALID_PARAMS,	/* Unsuitable Connection Interval */
-	MGMT_STATUS_TIMEOUT,		/* Directed Advertising Timeout */
-	MGMT_STATUS_AUTH_FAILED,	/* Terminated Due to MIC Failure */
-	MGMT_STATUS_CONNECT_FAILED,	/* Connection Establishment Failed */
-	MGMT_STATUS_CONNECT_FAILED,	/* MAC Connection Failed */
+struct mgmt_pending_free_work {
+	struct work_struct work;
+	struct sock *sk;
 };
 
-static u8 mgmt_status(u8 hci_status)
-{
-	if (hci_status < ARRAY_SIZE(mgmt_status_table))
-		return mgmt_status_table[hci_status];
-
-	return MGMT_STATUS_FAILED;
-}
+LIST_HEAD(cmd_list);
 
 static int cmd_status(struct sock *sk, u16 index, u16 cmd, u8 status)
 {
 	struct sk_buff *skb;
 	struct mgmt_hdr *hdr;
 	struct mgmt_ev_cmd_status *ev;
-	int err;
 
 	BT_DBG("sock %p, index %u, cmd %u, status %u", sk, index, cmd, status);
 
@@ -144,11 +79,10 @@ static int cmd_status(struct sock *sk, u16 index, u16 cmd, u8 status)
 	ev->status = status;
 	put_unaligned_le16(cmd, &ev->opcode);
 
-	err = sock_queue_rcv_skb(sk, skb);
-	if (err < 0)
+	if (sock_queue_rcv_skb(sk, skb) < 0)
 		kfree_skb(skb);
 
-	return err;
+	return 0;
 }
 
 static int cmd_complete(struct sock *sk, u16 index, u16 cmd, void *rp,
@@ -157,7 +91,6 @@ static int cmd_complete(struct sock *sk, u16 index, u16 cmd, void *rp,
 	struct sk_buff *skb;
 	struct mgmt_hdr *hdr;
 	struct mgmt_ev_cmd_complete *ev;
-	int err;
 
 	BT_DBG("sock %p", sk);
 
@@ -177,11 +110,10 @@ static int cmd_complete(struct sock *sk, u16 index, u16 cmd, void *rp,
 	if (rp)
 		memcpy(ev->data, rp, rp_len);
 
-	err = sock_queue_rcv_skb(sk, skb);
-	if (err < 0)
+	if (sock_queue_rcv_skb(sk, skb) < 0)
 		kfree_skb(skb);
 
-	return err;;
+	return 0;
 }
 
 static int read_version(struct sock *sk)
@@ -201,7 +133,6 @@ static int read_index_list(struct sock *sk)
 {
 	struct mgmt_rp_read_index_list *rp;
 	struct list_head *p;
-	struct hci_dev *d;
 	size_t rp_len;
 	u16 count;
 	int i, err;
@@ -212,6 +143,9 @@ static int read_index_list(struct sock *sk)
 
 	count = 0;
 	list_for_each(p, &hci_dev_list) {
+		struct hci_dev *d = list_entry(p, struct hci_dev, list);
+		if (d->dev_type != HCI_BREDR)
+			continue;
 		count++;
 	}
 
@@ -222,17 +156,24 @@ static int read_index_list(struct sock *sk)
 		return -ENOMEM;
 	}
 
-	put_unaligned_le16(count, &rp->num_controllers);
+	put_unaligned_le16(0, &rp->num_controllers);
 
 	i = 0;
-	list_for_each_entry(d, &hci_dev_list, list) {
-		if (test_and_clear_bit(HCI_AUTO_OFF, &d->flags))
-			cancel_delayed_work(&d->power_off);
+	list_for_each(p, &hci_dev_list) {
+		struct hci_dev *d = list_entry(p, struct hci_dev, list);
+
+		hci_del_off_timer(d);
+
+		if (d->dev_type != HCI_BREDR)
+			continue;
+
+		set_bit(HCI_MGMT, &d->flags);
 
 		if (test_bit(HCI_SETUP, &d->flags))
 			continue;
 
 		put_unaligned_le16(d->id, &rp->index[i++]);
+		put_unaligned_le16((u16)i, &rp->num_controllers);
 		BT_DBG("Added hci%u", d->id);
 	}
 
@@ -246,213 +187,244 @@ static int read_index_list(struct sock *sk)
 	return err;
 }
 
-static u32 get_supported_settings(struct hci_dev *hdev)
+static int read_controller_info(struct sock *sk, u16 index)
 {
-	u32 settings = 0;
-
-	settings |= MGMT_SETTING_POWERED;
-	settings |= MGMT_SETTING_CONNECTABLE;
-	settings |= MGMT_SETTING_FAST_CONNECTABLE;
-	settings |= MGMT_SETTING_DISCOVERABLE;
-	settings |= MGMT_SETTING_PAIRABLE;
+	struct mgmt_rp_read_info rp;
+	struct hci_dev *hdev;
 
-	if (hdev->features[6] & LMP_SIMPLE_PAIR)
-		settings |= MGMT_SETTING_SSP;
+	BT_DBG("sock %p hci%u", sk, index);
 
-	if (!(hdev->features[4] & LMP_NO_BREDR)) {
-		settings |= MGMT_SETTING_BREDR;
-		settings |= MGMT_SETTING_LINK_SECURITY;
-	}
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index, MGMT_OP_READ_INFO, ENODEV);
 
-	if (hdev->features[4] & LMP_LE)
-		settings |= MGMT_SETTING_LE;
+	hci_del_off_timer(hdev);
 
-	return settings;
-}
+	hci_dev_lock_bh(hdev);
 
-static u32 get_current_settings(struct hci_dev *hdev)
-{
-	u32 settings = 0;
+	set_bit(HCI_MGMT, &hdev->flags);
 
-	if (test_bit(HCI_UP, &hdev->flags))
-		settings |= MGMT_SETTING_POWERED;
-	else
-		return settings;
+	memset(&rp, 0, sizeof(rp));
 
-	if (test_bit(HCI_PSCAN, &hdev->flags))
-		settings |= MGMT_SETTING_CONNECTABLE;
+	rp.type = hdev->dev_type;
 
-	if (test_bit(HCI_ISCAN, &hdev->flags))
-		settings |= MGMT_SETTING_DISCOVERABLE;
+	rp.powered = test_bit(HCI_UP, &hdev->flags);
+	rp.connectable = test_bit(HCI_PSCAN, &hdev->flags);
+	rp.discoverable = test_bit(HCI_ISCAN, &hdev->flags);
+	rp.pairable = test_bit(HCI_PSCAN, &hdev->flags);
 
-	if (test_bit(HCI_PAIRABLE, &hdev->flags))
-		settings |= MGMT_SETTING_PAIRABLE;
+	if (test_bit(HCI_AUTH, &hdev->flags))
+		rp.sec_mode = 3;
+	else if (hdev->ssp_mode > 0)
+		rp.sec_mode = 4;
+	else
+		rp.sec_mode = 2;
 
-	if (!(hdev->features[4] & LMP_NO_BREDR))
-		settings |= MGMT_SETTING_BREDR;
+	bacpy(&rp.bdaddr, &hdev->bdaddr);
+	memcpy(rp.features, hdev->features, 8);
+	memcpy(rp.dev_class, hdev->dev_class, 3);
+	put_unaligned_le16(hdev->manufacturer, &rp.manufacturer);
+	rp.hci_ver = hdev->hci_ver;
+	put_unaligned_le16(hdev->hci_rev, &rp.hci_rev);
 
-	if (hdev->host_features[0] & LMP_HOST_LE)
-		settings |= MGMT_SETTING_LE;
+	memcpy(rp.name, hdev->dev_name, sizeof(hdev->dev_name));
 
-	if (test_bit(HCI_AUTH, &hdev->flags))
-		settings |= MGMT_SETTING_LINK_SECURITY;
+	rp.le_white_list_size = hdev->le_white_list_size;
 
-	if (hdev->ssp_mode > 0)
-		settings |= MGMT_SETTING_SSP;
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
 
-	return settings;
+	return cmd_complete(sk, index, MGMT_OP_READ_INFO, &rp, sizeof(rp));
 }
 
-#define EIR_FLAGS		0x01 /* flags */
-#define EIR_UUID16_SOME		0x02 /* 16-bit UUID, more available */
-#define EIR_UUID16_ALL		0x03 /* 16-bit UUID, all listed */
-#define EIR_UUID32_SOME		0x04 /* 32-bit UUID, more available */
-#define EIR_UUID32_ALL		0x05 /* 32-bit UUID, all listed */
-#define EIR_UUID128_SOME	0x06 /* 128-bit UUID, more available */
-#define EIR_UUID128_ALL		0x07 /* 128-bit UUID, all listed */
-#define EIR_NAME_SHORT		0x08 /* shortened local name */
-#define EIR_NAME_COMPLETE	0x09 /* complete local name */
-#define EIR_TX_POWER		0x0A /* transmit power level */
-#define EIR_DEVICE_ID		0x10 /* device ID */
+static void mgmt_pending_free_worker(struct work_struct *work)
+{
+	struct mgmt_pending_free_work *free_work =
+		container_of(work, struct mgmt_pending_free_work, work);
 
-#define PNP_INFO_SVCLASS_ID		0x1200
+	BT_DBG("sk %p", free_work->sk);
 
-static u8 bluetooth_base_uuid[] = {
-			0xFB, 0x34, 0x9B, 0x5F, 0x80, 0x00, 0x00, 0x80,
-			0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-};
+	sock_put(free_work->sk);
+	kfree(free_work);
+}
 
-static u16 get_uuid16(u8 *uuid128)
+static void mgmt_pending_free(struct pending_cmd *cmd)
 {
-	u32 val;
-	int i;
+	struct mgmt_pending_free_work *free_work;
+	struct sock *sk = cmd->sk;
 
-	for (i = 0; i < 12; i++) {
-		if (bluetooth_base_uuid[i] != uuid128[i])
-			return 0;
-	}
+	BT_DBG("opcode %d, sk %p", cmd->opcode, sk);
 
-	memcpy(&val, &uuid128[12], 4);
+	kfree(cmd->param);
+	kfree(cmd);
 
-	val = le32_to_cpu(val);
-	if (val > 0xffff)
-		return 0;
+	free_work = kzalloc(sizeof(*free_work), GFP_ATOMIC);
+	if (free_work) {
+		INIT_WORK(&free_work->work, mgmt_pending_free_worker);
+		free_work->sk = sk;
 
-	return (u16) val;
+		if (!schedule_work(&free_work->work))
+			kfree(free_work);
+	}
 }
 
-static void create_eir(struct hci_dev *hdev, u8 *data)
+static struct pending_cmd *mgmt_pending_add(struct sock *sk, u16 opcode,
+						u16 index, void *data, u16 len)
 {
-	u8 *ptr = data;
-	u16 eir_len = 0;
-	u16 uuid16_list[HCI_MAX_EIR_LENGTH / sizeof(u16)];
-	int i, truncated = 0;
-	struct bt_uuid *uuid;
-	size_t name_len;
-
-	name_len = strlen(hdev->dev_name);
+	struct pending_cmd *cmd;
 
-	if (name_len > 0) {
-		/* EIR Data type */
-		if (name_len > 48) {
-			name_len = 48;
-			ptr[1] = EIR_NAME_SHORT;
-		} else
-			ptr[1] = EIR_NAME_COMPLETE;
+	BT_DBG("%d", opcode);
 
-		/* EIR Data length */
-		ptr[0] = name_len + 1;
+	cmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);
+	if (!cmd)
+		return NULL;
 
-		memcpy(ptr + 2, hdev->dev_name, name_len);
+	cmd->opcode = opcode;
+	cmd->index = index;
 
-		eir_len += (name_len + 2);
-		ptr += (name_len + 2);
+	cmd->param = kmalloc(len, GFP_ATOMIC);
+	if (!cmd->param) {
+		kfree(cmd);
+		return NULL;
 	}
 
-	memset(uuid16_list, 0, sizeof(uuid16_list));
+	if (data)
+		memcpy(cmd->param, data, len);
 
-	/* Group all UUID16 types */
-	list_for_each_entry(uuid, &hdev->uuids, list) {
-		u16 uuid16;
+	cmd->sk = sk;
+	sock_hold(sk);
 
-		uuid16 = get_uuid16(uuid->uuid);
-		if (uuid16 == 0)
-			return;
+	list_add(&cmd->list, &cmd_list);
 
-		if (uuid16 < 0x1100)
+	return cmd;
+}
+
+static void mgmt_pending_foreach(u16 opcode, int index,
+				void (*cb)(struct pending_cmd *cmd, void *data),
+				void *data)
+{
+	struct list_head *p, *n;
+
+	BT_DBG(" %d", opcode);
+
+	list_for_each_safe(p, n, &cmd_list) {
+		struct pending_cmd *cmd;
+
+		cmd = list_entry(p, struct pending_cmd, list);
+
+		if (opcode > 0 && cmd->opcode != opcode)
 			continue;
 
-		if (uuid16 == PNP_INFO_SVCLASS_ID)
+		if (index >= 0 && cmd->index != index)
 			continue;
 
-		/* Stop if not enough space to put next UUID */
-		if (eir_len + 2 + sizeof(u16) > HCI_MAX_EIR_LENGTH) {
-			truncated = 1;
-			break;
-		}
+		cb(cmd, data);
+	}
+}
 
-		/* Check for duplicates */
-		for (i = 0; uuid16_list[i] != 0; i++)
-			if (uuid16_list[i] == uuid16)
-				break;
+static struct pending_cmd *mgmt_pending_find(u16 opcode, int index)
+{
+	struct list_head *p;
 
-		if (uuid16_list[i] == 0) {
-			uuid16_list[i] = uuid16;
-			eir_len += sizeof(u16);
-		}
-	}
+	BT_DBG(" %d", opcode);
 
-	if (uuid16_list[0] != 0) {
-		u8 *length = ptr;
+	list_for_each(p, &cmd_list) {
+		struct pending_cmd *cmd;
 
-		/* EIR Data type */
-		ptr[1] = truncated ? EIR_UUID16_SOME : EIR_UUID16_ALL;
+		cmd = list_entry(p, struct pending_cmd, list);
 
-		ptr += 2;
-		eir_len += 2;
+		if (cmd->opcode != opcode)
+			continue;
 
-		for (i = 0; uuid16_list[i] != 0; i++) {
-			*ptr++ = (uuid16_list[i] & 0x00ff);
-			*ptr++ = (uuid16_list[i] & 0xff00) >> 8;
-		}
+		if (index >= 0 && cmd->index != index)
+			continue;
 
-		/* EIR Data length */
-		*length = (i * sizeof(u16)) + 1;
+		return cmd;
 	}
+
+	return NULL;
 }
 
-static int update_eir(struct hci_dev *hdev)
+static void mgmt_pending_remove(struct pending_cmd *cmd)
 {
-	struct hci_cp_write_eir cp;
+	BT_DBG(" %d", cmd->opcode);
 
-	if (!(hdev->features[6] & LMP_EXT_INQ))
-		return 0;
+	list_del(&cmd->list);
+	mgmt_pending_free(cmd);
+}
 
-	if (hdev->ssp_mode == 0)
-		return 0;
+static int set_powered(struct sock *sk, u16 index, unsigned char *data, u16 len)
+{
+	struct mgmt_mode *cp;
+	struct hci_dev *hdev;
+	struct pending_cmd *cmd;
+	int err, up;
 
-	if (test_bit(HCI_SERVICE_CACHE, &hdev->flags))
-		return 0;
+	cp = (void *) data;
 
-	memset(&cp, 0, sizeof(cp));
+	BT_DBG("request for hci%u", index);
 
-	create_eir(hdev, cp.data);
+	if (len != sizeof(*cp))
+		return cmd_status(sk, index, MGMT_OP_SET_POWERED, EINVAL);
 
-	if (memcmp(cp.data, hdev->eir, sizeof(cp.data)) == 0)
-		return 0;
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index, MGMT_OP_SET_POWERED, ENODEV);
 
-	memcpy(hdev->eir, cp.data, sizeof(cp.data));
+	hci_dev_lock_bh(hdev);
 
-	return hci_send_cmd(hdev, HCI_OP_WRITE_EIR, sizeof(cp), &cp);
+	up = test_bit(HCI_UP, &hdev->flags);
+	if ((cp->val && up) || (!cp->val && !up)) {
+		err = cmd_status(sk, index, MGMT_OP_SET_POWERED, EALREADY);
+		goto failed;
+	}
+
+	if (mgmt_pending_find(MGMT_OP_SET_POWERED, index)) {
+		err = cmd_status(sk, index, MGMT_OP_SET_POWERED, EBUSY);
+		goto failed;
+	}
+	/* Avoid queing power_on/off when the set up is going on via
+	 * hci_register_dev
+	 */
+	if (!test_bit(HCI_SETUP, &hdev->flags)) {
+		cmd = mgmt_pending_add(sk, MGMT_OP_SET_POWERED, index, data,
+									len);
+		if (!cmd) {
+			err = -ENOMEM;
+			goto failed;
+		}
+
+		hci_dev_unlock_bh(hdev);
+
+		if (cp->val)
+			queue_work(hdev->workqueue, &hdev->power_on);
+		else
+			queue_work(hdev->workqueue, &hdev->power_off);
+
+		err = 0;
+		hci_dev_put(hdev);
+	} else {
+		err = cmd_status(sk, index, MGMT_OP_SET_POWERED, ENODEV);
+		goto failed;
+	}
+	return err;
+
+failed:
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
+	return err;
 }
 
 static u8 get_service_classes(struct hci_dev *hdev)
 {
-	struct bt_uuid *uuid;
+	struct list_head *p;
 	u8 val = 0;
 
-	list_for_each_entry(uuid, &hdev->uuids, list)
+	list_for_each(p, &hdev->uuids) {
+		struct bt_uuid *uuid = list_entry(p, struct bt_uuid, list);
+
 		val |= uuid->svc_hint;
+	}
 
 	return val;
 }
@@ -460,6 +432,7 @@ static u8 get_service_classes(struct hci_dev *hdev)
 static int update_class(struct hci_dev *hdev)
 {
 	u8 cod[3];
+	int err = 0;
 
 	BT_DBG("%s", hdev->name);
 
@@ -473,213 +446,103 @@ static int update_class(struct hci_dev *hdev)
 	if (memcmp(cod, hdev->dev_class, 3) == 0)
 		return 0;
 
-	return hci_send_cmd(hdev, HCI_OP_WRITE_CLASS_OF_DEV, sizeof(cod), cod);
-}
-
-static void service_cache_off(struct work_struct *work)
-{
-	struct hci_dev *hdev = container_of(work, struct hci_dev,
-							service_cache.work);
-
-	if (!test_and_clear_bit(HCI_SERVICE_CACHE, &hdev->flags))
-		return;
-
-	hci_dev_lock(hdev);
+	err =  hci_send_cmd(hdev, HCI_OP_WRITE_CLASS_OF_DEV, sizeof(cod), cod);
 
-	update_eir(hdev);
-	update_class(hdev);
+	if (err == 0)
+		memcpy(hdev->dev_class, cod, 3);
 
-	hci_dev_unlock(hdev);
+	return err;
 }
 
-static void mgmt_init_hdev(struct hci_dev *hdev)
+static int set_limited_discoverable(struct sock *sk, u16 index,
+						unsigned char *data, u16 len)
 {
-	if (!test_and_set_bit(HCI_MGMT, &hdev->flags))
-		INIT_DELAYED_WORK(&hdev->service_cache, service_cache_off);
+	struct mgmt_mode *cp;
+	struct hci_dev *hdev;
+	struct pending_cmd *cmd;
+	struct hci_cp_write_current_iac_lap dcp;
+	int update_cod;
+	int err = 0;
+	/* General Inquiry LAP: 0x9E8B33, Limited Inquiry LAP: 0x9E8B00 */
+	u8 lap[] = { 0x33, 0x8b, 0x9e, 0x00, 0x8b, 0x9e };
 
-	if (!test_and_set_bit(HCI_SERVICE_CACHE, &hdev->flags))
-		schedule_delayed_work(&hdev->service_cache,
-				msecs_to_jiffies(SERVICE_CACHE_TIMEOUT));
-}
+	cp = (void *) data;
 
-static int read_controller_info(struct sock *sk, u16 index)
-{
-	struct mgmt_rp_read_info rp;
-	struct hci_dev *hdev;
+	BT_DBG("hci%u discoverable: %d", index, cp->val);
 
-	BT_DBG("sock %p hci%u", sk, index);
+	if (!cp || len != sizeof(*cp))
+		return cmd_status(sk, index, MGMT_OP_SET_LIMIT_DISCOVERABLE,
+									EINVAL);
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_READ_INFO,
-						MGMT_STATUS_INVALID_PARAMS);
-
-	if (test_and_clear_bit(HCI_AUTO_OFF, &hdev->flags))
-		cancel_delayed_work_sync(&hdev->power_off);
-
-	hci_dev_lock(hdev);
+		return cmd_status(sk, index, MGMT_OP_SET_LIMIT_DISCOVERABLE,
+									ENODEV);
 
-	if (test_and_clear_bit(HCI_PI_MGMT_INIT, &hci_pi(sk)->flags))
-		mgmt_init_hdev(hdev);
+	hci_dev_lock_bh(hdev);
 
-	memset(&rp, 0, sizeof(rp));
+	if (!test_bit(HCI_UP, &hdev->flags)) {
+		err = cmd_status(sk, index, MGMT_OP_SET_LIMIT_DISCOVERABLE,
+								ENETDOWN);
+		goto failed;
+	}
 
-	bacpy(&rp.bdaddr, &hdev->bdaddr);
+	if (mgmt_pending_find(MGMT_OP_SET_LIMIT_DISCOVERABLE, index)) {
+		err = cmd_status(sk, index, MGMT_OP_SET_LIMIT_DISCOVERABLE,
+									EBUSY);
+		goto failed;
+	}
 
-	rp.version = hdev->hci_ver;
+	if (cp->val == test_bit(HCI_ISCAN, &hdev->flags) &&
+					test_bit(HCI_PSCAN, &hdev->flags)) {
+		err = cmd_status(sk, index, MGMT_OP_SET_LIMIT_DISCOVERABLE,
+								EALREADY);
+		goto failed;
+	}
 
-	put_unaligned_le16(hdev->manufacturer, &rp.manufacturer);
-
-	rp.supported_settings = cpu_to_le32(get_supported_settings(hdev));
-	rp.current_settings = cpu_to_le32(get_current_settings(hdev));
-
-	memcpy(rp.dev_class, hdev->dev_class, 3);
-
-	memcpy(rp.name, hdev->dev_name, sizeof(hdev->dev_name));
-
-	hci_dev_unlock(hdev);
-	hci_dev_put(hdev);
-
-	return cmd_complete(sk, index, MGMT_OP_READ_INFO, &rp, sizeof(rp));
-}
-
-static void mgmt_pending_free(struct pending_cmd *cmd)
-{
-	sock_put(cmd->sk);
-	kfree(cmd->param);
-	kfree(cmd);
-}
-
-static struct pending_cmd *mgmt_pending_add(struct sock *sk, u16 opcode,
-							struct hci_dev *hdev,
-							void *data, u16 len)
-{
-	struct pending_cmd *cmd;
-
-	cmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);
-	if (!cmd)
-		return NULL;
-
-	cmd->opcode = opcode;
-	cmd->index = hdev->id;
-
-	cmd->param = kmalloc(len, GFP_ATOMIC);
-	if (!cmd->param) {
-		kfree(cmd);
-		return NULL;
-	}
-
-	if (data)
-		memcpy(cmd->param, data, len);
-
-	cmd->sk = sk;
-	sock_hold(sk);
-
-	list_add(&cmd->list, &hdev->mgmt_pending);
-
-	return cmd;
-}
-
-static void mgmt_pending_foreach(u16 opcode, struct hci_dev *hdev,
-				void (*cb)(struct pending_cmd *cmd, void *data),
-				void *data)
-{
-	struct list_head *p, *n;
-
-	list_for_each_safe(p, n, &hdev->mgmt_pending) {
-		struct pending_cmd *cmd;
-
-		cmd = list_entry(p, struct pending_cmd, list);
-
-		if (opcode > 0 && cmd->opcode != opcode)
-			continue;
-
-		cb(cmd, data);
-	}
-}
-
-static struct pending_cmd *mgmt_pending_find(u16 opcode, struct hci_dev *hdev)
-{
-	struct pending_cmd *cmd;
-
-	list_for_each_entry(cmd, &hdev->mgmt_pending, list) {
-		if (cmd->opcode == opcode)
-			return cmd;
-	}
-
-	return NULL;
-}
-
-static void mgmt_pending_remove(struct pending_cmd *cmd)
-{
-	list_del(&cmd->list);
-	mgmt_pending_free(cmd);
-}
-
-static int send_settings_rsp(struct sock *sk, u16 opcode, struct hci_dev *hdev)
-{
-	__le32 settings = cpu_to_le32(get_current_settings(hdev));
-
-	return cmd_complete(sk, hdev->id, opcode, &settings, sizeof(settings));
-}
-
-static int set_powered(struct sock *sk, u16 index, unsigned char *data, u16 len)
-{
-	struct mgmt_mode *cp;
-	struct hci_dev *hdev;
-	struct pending_cmd *cmd;
-	int err, up;
-
-	cp = (void *) data;
-
-	BT_DBG("request for hci%u", index);
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_POWERED,
-						MGMT_STATUS_INVALID_PARAMS);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_POWERED,
-						MGMT_STATUS_INVALID_PARAMS);
-
-	hci_dev_lock(hdev);
-
-	up = test_bit(HCI_UP, &hdev->flags);
-	if ((cp->val && up) || (!cp->val && !up)) {
-		err = send_settings_rsp(sk, MGMT_OP_SET_POWERED, hdev);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_LIMIT_DISCOVERABLE, index, data,
+									len);
+	if (!cmd) {
+		err = -ENOMEM;
 		goto failed;
 	}
 
-	if (mgmt_pending_find(MGMT_OP_SET_POWERED, hdev)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_POWERED,
-							MGMT_STATUS_BUSY);
-		goto failed;
-	}
+	memset(&dcp, 0, sizeof(dcp));
+	dcp.num_current_iac = cp->val ? 2 : 1;
+	memcpy(&dcp.lap, lap, dcp.num_current_iac * 3);
+	update_cod = 1;
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_SET_POWERED, hdev, data, len);
-	if (!cmd) {
-		err = -ENOMEM;
-		goto failed;
+	if (cp->val) {
+		if (hdev->major_class & MGMT_MAJOR_CLASS_LIMITED)
+			update_cod = 0;
+		hdev->major_class |= MGMT_MAJOR_CLASS_LIMITED;
+	} else {
+		if (!(hdev->major_class & MGMT_MAJOR_CLASS_LIMITED))
+			update_cod = 0;
+		hdev->major_class &= ~MGMT_MAJOR_CLASS_LIMITED;
 	}
 
-	if (cp->val)
-		schedule_work(&hdev->power_on);
-	else
-		schedule_work(&hdev->power_off.work);
+	if (update_cod)
+		err = update_class(hdev);
 
-	err = 0;
+	if (err >= 0)
+		err = hci_send_cmd(hdev, HCI_OP_WRITE_CURRENT_IAC_LAP,
+							sizeof(dcp), &dcp);
+
+	if (err < 0)
+		mgmt_pending_remove(cmd);
 
 failed:
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
+
 	return err;
 }
 
 static int set_discoverable(struct sock *sk, u16 index, unsigned char *data,
 									u16 len)
 {
-	struct mgmt_cp_set_discoverable *cp;
+	struct mgmt_mode *cp;
 	struct hci_dev *hdev;
 	struct pending_cmd *cmd;
 	u8 scan;
@@ -690,36 +553,32 @@ static int set_discoverable(struct sock *sk, u16 index, unsigned char *data,
 	BT_DBG("request for hci%u", index);
 
 	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE, EINVAL);
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE, ENODEV);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 
 	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE,
-						MGMT_STATUS_NOT_POWERED);
+		err = cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE, ENETDOWN);
 		goto failed;
 	}
 
-	if (mgmt_pending_find(MGMT_OP_SET_DISCOVERABLE, hdev) ||
-			mgmt_pending_find(MGMT_OP_SET_CONNECTABLE, hdev)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE,
-							MGMT_STATUS_BUSY);
+	if (mgmt_pending_find(MGMT_OP_SET_DISCOVERABLE, index) ||
+			mgmt_pending_find(MGMT_OP_SET_CONNECTABLE, index)) {
+		err = cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE, EBUSY);
 		goto failed;
 	}
 
 	if (cp->val == test_bit(HCI_ISCAN, &hdev->flags) &&
 					test_bit(HCI_PSCAN, &hdev->flags)) {
-		err = send_settings_rsp(sk, MGMT_OP_SET_DISCOVERABLE, hdev);
+		err = cmd_status(sk, index, MGMT_OP_SET_DISCOVERABLE, EALREADY);
 		goto failed;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_SET_DISCOVERABLE, hdev, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_DISCOVERABLE, index, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
@@ -729,18 +588,13 @@ static int set_discoverable(struct sock *sk, u16 index, unsigned char *data,
 
 	if (cp->val)
 		scan |= SCAN_INQUIRY;
-	else
-		cancel_delayed_work(&hdev->discov_off);
 
 	err = hci_send_cmd(hdev, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);
 	if (err < 0)
 		mgmt_pending_remove(cmd);
 
-	if (cp->val)
-		hdev->discov_timeout = get_unaligned_le16(&cp->timeout);
-
 failed:
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return err;
@@ -760,35 +614,31 @@ static int set_connectable(struct sock *sk, u16 index, unsigned char *data,
 	BT_DBG("request for hci%u", index);
 
 	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE, EINVAL);
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE, ENODEV);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 
 	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE,
-						MGMT_STATUS_NOT_POWERED);
+		err = cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE, ENETDOWN);
 		goto failed;
 	}
 
-	if (mgmt_pending_find(MGMT_OP_SET_DISCOVERABLE, hdev) ||
-			mgmt_pending_find(MGMT_OP_SET_CONNECTABLE, hdev)) {
-		err = cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE,
-							MGMT_STATUS_BUSY);
+	if (mgmt_pending_find(MGMT_OP_SET_DISCOVERABLE, index) ||
+			mgmt_pending_find(MGMT_OP_SET_CONNECTABLE, index)) {
+		err = cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE, EBUSY);
 		goto failed;
 	}
 
 	if (cp->val == test_bit(HCI_PSCAN, &hdev->flags)) {
-		err = send_settings_rsp(sk, MGMT_OP_SET_CONNECTABLE, hdev);
+		err = cmd_status(sk, index, MGMT_OP_SET_CONNECTABLE, EALREADY);
 		goto failed;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_SET_CONNECTABLE, hdev, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_CONNECTABLE, index, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
@@ -804,18 +654,20 @@ static int set_connectable(struct sock *sk, u16 index, unsigned char *data,
 		mgmt_pending_remove(cmd);
 
 failed:
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return err;
 }
 
-static int mgmt_event(u16 event, struct hci_dev *hdev, void *data,
-					u16 data_len, struct sock *skip_sk)
+static int mgmt_event(u16 event, u16 index, void *data, u16 data_len,
+							struct sock *skip_sk)
 {
 	struct sk_buff *skb;
 	struct mgmt_hdr *hdr;
 
+	BT_DBG("hci%d %d", index, event);
+
 	skb = alloc_skb(sizeof(*hdr) + data_len, GFP_ATOMIC);
 	if (!skb)
 		return -ENOMEM;
@@ -824,10 +676,7 @@ static int mgmt_event(u16 event, struct hci_dev *hdev, void *data,
 
 	hdr = (void *) skb_put(skb, sizeof(*hdr));
 	hdr->opcode = cpu_to_le16(event);
-	if (hdev)
-		hdr->index = cpu_to_le16(hdev->id);
-	else
-		hdr->index = cpu_to_le16(MGMT_INDEX_NONE);
+	hdr->index = cpu_to_le16(index);
 	hdr->len = cpu_to_le16(data_len);
 
 	if (data)
@@ -839,12 +688,20 @@ static int mgmt_event(u16 event, struct hci_dev *hdev, void *data,
 	return 0;
 }
 
+static int send_mode_rsp(struct sock *sk, u16 opcode, u16 index, u8 val)
+{
+	struct mgmt_mode rp;
+
+	rp.val = val;
+
+	return cmd_complete(sk, index, opcode, &rp, sizeof(rp));
+}
+
 static int set_pairable(struct sock *sk, u16 index, unsigned char *data,
 									u16 len)
 {
-	struct mgmt_mode *cp;
+	struct mgmt_mode *cp, ev;
 	struct hci_dev *hdev;
-	__le32 ev;
 	int err;
 
 	cp = (void *) data;
@@ -852,144 +709,288 @@ static int set_pairable(struct sock *sk, u16 index, unsigned char *data,
 	BT_DBG("request for hci%u", index);
 
 	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_PAIRABLE,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_SET_PAIRABLE, EINVAL);
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_PAIRABLE,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_SET_PAIRABLE, ENODEV);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 
 	if (cp->val)
 		set_bit(HCI_PAIRABLE, &hdev->flags);
 	else
 		clear_bit(HCI_PAIRABLE, &hdev->flags);
 
-	err = send_settings_rsp(sk, MGMT_OP_SET_PAIRABLE, hdev);
+	err = send_mode_rsp(sk, MGMT_OP_SET_PAIRABLE, index, cp->val);
 	if (err < 0)
 		goto failed;
 
-	ev = cpu_to_le32(get_current_settings(hdev));
+	ev.val = cp->val;
 
-	err = mgmt_event(MGMT_EV_NEW_SETTINGS, hdev, &ev, sizeof(ev), sk);
+	err = mgmt_event(MGMT_EV_PAIRABLE, index, &ev, sizeof(ev), sk);
 
 failed:
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return err;
 }
 
-static int add_uuid(struct sock *sk, u16 index, unsigned char *data, u16 len)
-{
-	struct mgmt_cp_add_uuid *cp;
-	struct hci_dev *hdev;
-	struct bt_uuid *uuid;
-	int err;
-
-	cp = (void *) data;
-
-	BT_DBG("request for hci%u", index);
+#define EIR_FLAGS		0x01 /* flags */
+#define EIR_UUID16_SOME		0x02 /* 16-bit UUID, more available */
+#define EIR_UUID16_ALL		0x03 /* 16-bit UUID, all listed */
+#define EIR_UUID32_SOME		0x04 /* 32-bit UUID, more available */
+#define EIR_UUID32_ALL		0x05 /* 32-bit UUID, all listed */
+#define EIR_UUID128_SOME	0x06 /* 128-bit UUID, more available */
+#define EIR_UUID128_ALL		0x07 /* 128-bit UUID, all listed */
+#define EIR_NAME_SHORT		0x08 /* shortened local name */
+#define EIR_NAME_COMPLETE	0x09 /* complete local name */
+#define EIR_TX_POWER		0x0A /* transmit power level */
+#define EIR_DEVICE_ID		0x10 /* device ID */
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_ADD_UUID,
-						MGMT_STATUS_INVALID_PARAMS);
+#define PNP_INFO_SVCLASS_ID		0x1200
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_ADD_UUID,
-						MGMT_STATUS_INVALID_PARAMS);
+static u8 bluetooth_base_uuid[] = {
+			0xFB, 0x34, 0x9B, 0x5F, 0x80, 0x00, 0x00, 0x80,
+			0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
 
-	hci_dev_lock(hdev);
+static u16 get_uuid16(u8 *uuid128)
+{
+	u32 val;
+	int i;
 
-	uuid = kmalloc(sizeof(*uuid), GFP_ATOMIC);
-	if (!uuid) {
-		err = -ENOMEM;
-		goto failed;
+	for (i = 0; i < 12; i++) {
+		if (bluetooth_base_uuid[i] != uuid128[i])
+			return 0;
 	}
 
-	memcpy(uuid->uuid, cp->uuid, 16);
-	uuid->svc_hint = cp->svc_hint;
-
-	list_add(&uuid->list, &hdev->uuids);
-
-	err = update_class(hdev);
-	if (err < 0)
-		goto failed;
-
-	err = update_eir(hdev);
-	if (err < 0)
-		goto failed;
-
-	err = cmd_complete(sk, index, MGMT_OP_ADD_UUID, NULL, 0);
+	memcpy(&val, &uuid128[12], 4);
 
-failed:
-	hci_dev_unlock(hdev);
-	hci_dev_put(hdev);
+	val = le32_to_cpu(val);
+	if (val > 0xffff)
+		return 0;
 
-	return err;
+	return (u16) val;
 }
 
-static int remove_uuid(struct sock *sk, u16 index, unsigned char *data, u16 len)
+static void create_eir(struct hci_dev *hdev, u8 *data)
 {
-	struct list_head *p, *n;
-	struct mgmt_cp_remove_uuid *cp;
-	struct hci_dev *hdev;
-	u8 bt_uuid_any[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-	int err, found;
-
-	cp = (void *) data;
+	u8 *ptr = data;
+	u16 eir_len = 0;
+	u16 uuid16_list[HCI_MAX_EIR_LENGTH / sizeof(u16)];
+	int i, truncated = 0;
+	struct list_head *p;
+	size_t name_len;
 
-	BT_DBG("request for hci%u", index);
+	name_len = strnlen(hdev->dev_name, HCI_MAX_EIR_LENGTH);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_REMOVE_UUID,
-						MGMT_STATUS_INVALID_PARAMS);
+	if (name_len > 0) {
+		/* EIR Data type */
+		if (name_len > 48) {
+			name_len = 48;
+			ptr[1] = EIR_NAME_SHORT;
+		} else
+			ptr[1] = EIR_NAME_COMPLETE;
 
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_REMOVE_UUID,
-						MGMT_STATUS_INVALID_PARAMS);
+		/* EIR Data length */
+		ptr[0] = name_len + 1;
 
-	hci_dev_lock(hdev);
+		memcpy(ptr + 2, hdev->dev_name, name_len);
 
-	if (memcmp(cp->uuid, bt_uuid_any, 16) == 0) {
-		err = hci_uuids_clear(hdev);
-		goto unlock;
+		eir_len += (name_len + 2);
+		ptr += (name_len + 2);
 	}
 
-	found = 0;
+	memset(uuid16_list, 0, sizeof(uuid16_list));
 
-	list_for_each_safe(p, n, &hdev->uuids) {
-		struct bt_uuid *match = list_entry(p, struct bt_uuid, list);
+	/* Group all UUID16 types */
+	list_for_each(p, &hdev->uuids) {
+		struct bt_uuid *uuid = list_entry(p, struct bt_uuid, list);
+		u16 uuid16;
 
-		if (memcmp(match->uuid, cp->uuid, 16) != 0)
-			continue;
+		uuid16 = get_uuid16(uuid->uuid);
+		if (uuid16 == 0)
+			return;
 
-		list_del(&match->list);
-		found++;
-	}
+		if (uuid16 < 0x1100)
+			continue;
 
-	if (found == 0) {
-		err = cmd_status(sk, index, MGMT_OP_REMOVE_UUID,
-						MGMT_STATUS_INVALID_PARAMS);
-		goto unlock;
-	}
+		if (uuid16 == PNP_INFO_SVCLASS_ID)
+			continue;
 
-	err = update_class(hdev);
-	if (err < 0)
-		goto unlock;
+		/* Stop if not enough space to put next UUID */
+		if (eir_len + 2 + sizeof(u16) > HCI_MAX_EIR_LENGTH) {
+			truncated = 1;
+			break;
+		}
 
-	err = update_eir(hdev);
-	if (err < 0)
-		goto unlock;
+		/* Check for duplicates */
+		for (i = 0; uuid16_list[i] != 0; i++)
+			if (uuid16_list[i] == uuid16)
+				break;
 
-	err = cmd_complete(sk, index, MGMT_OP_REMOVE_UUID, NULL, 0);
+		if (uuid16_list[i] == 0) {
+			uuid16_list[i] = uuid16;
+			eir_len += sizeof(u16);
+		}
+	}
+
+	if (uuid16_list[0] != 0) {
+		u8 *length = ptr;
+
+		/* EIR Data type */
+		ptr[1] = truncated ? EIR_UUID16_SOME : EIR_UUID16_ALL;
+
+		ptr += 2;
+		eir_len += 2;
+
+		for (i = 0; uuid16_list[i] != 0; i++) {
+			*ptr++ = (uuid16_list[i] & 0x00ff);
+			*ptr++ = (uuid16_list[i] & 0xff00) >> 8;
+		}
+
+		/* EIR Data length */
+		*length = (i * sizeof(u16)) + 1;
+	}
+}
+
+static int update_eir(struct hci_dev *hdev)
+{
+	struct hci_cp_write_eir cp;
+
+	if (!(hdev->features[6] & LMP_EXT_INQ))
+		return 0;
+
+	if (hdev->ssp_mode == 0)
+		return 0;
+
+	if (test_bit(HCI_SERVICE_CACHE, &hdev->flags))
+		return 0;
+
+	memset(&cp, 0, sizeof(cp));
+
+	create_eir(hdev, cp.data);
+
+	if (memcmp(cp.data, hdev->eir, sizeof(cp.data)) == 0)
+		return 0;
+
+	memcpy(hdev->eir, cp.data, sizeof(cp.data));
+
+	return hci_send_cmd(hdev, HCI_OP_WRITE_EIR, sizeof(cp), &cp);
+}
+
+static int add_uuid(struct sock *sk, u16 index, unsigned char *data, u16 len)
+{
+	struct mgmt_cp_add_uuid *cp;
+	struct hci_dev *hdev;
+	struct bt_uuid *uuid;
+	int err;
+
+	cp = (void *) data;
+
+	BT_DBG("request for hci%u", index);
+
+	if (len != sizeof(*cp))
+		return cmd_status(sk, index, MGMT_OP_ADD_UUID, EINVAL);
+
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index, MGMT_OP_ADD_UUID, ENODEV);
+
+	hci_dev_lock_bh(hdev);
+
+	uuid = kmalloc(sizeof(*uuid), GFP_ATOMIC);
+	if (!uuid) {
+		err = -ENOMEM;
+		goto failed;
+	}
+
+	memcpy(uuid->uuid, cp->uuid, 16);
+	uuid->svc_hint = cp->svc_hint;
+
+	list_add(&uuid->list, &hdev->uuids);
+
+	if (test_bit(HCI_UP, &hdev->flags)) {
+
+		err = update_class(hdev);
+		if (err < 0)
+			goto failed;
+
+		err = update_eir(hdev);
+		if (err < 0)
+			goto failed;
+	} else
+		err = 0;
+
+	err = cmd_complete(sk, index, MGMT_OP_ADD_UUID, NULL, 0);
+
+failed:
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
+
+	return err;
+}
+
+static int remove_uuid(struct sock *sk, u16 index, unsigned char *data, u16 len)
+{
+	struct list_head *p, *n;
+	struct mgmt_cp_remove_uuid *cp;
+	struct hci_dev *hdev;
+	u8 bt_uuid_any[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+	int err, found;
+
+	cp = (void *) data;
+
+	BT_DBG("request for hci%u", index);
+
+	if (len != sizeof(*cp))
+		return cmd_status(sk, index, MGMT_OP_REMOVE_UUID, EINVAL);
+
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index, MGMT_OP_REMOVE_UUID, ENODEV);
+
+	hci_dev_lock_bh(hdev);
+
+	if (memcmp(cp->uuid, bt_uuid_any, 16) == 0) {
+		err = hci_uuids_clear(hdev);
+		goto unlock;
+	}
+
+	found = 0;
+
+	list_for_each_safe(p, n, &hdev->uuids) {
+		struct bt_uuid *match = list_entry(p, struct bt_uuid, list);
+
+		if (memcmp(match->uuid, cp->uuid, 16) != 0)
+			continue;
+
+		list_del(&match->list);
+		found++;
+	}
+
+	if (found == 0) {
+		err = cmd_status(sk, index, MGMT_OP_REMOVE_UUID, ENOENT);
+		goto unlock;
+	}
+
+	if (test_bit(HCI_UP, &hdev->flags)) {
+		err = update_class(hdev);
+		if (err < 0)
+			goto unlock;
+
+		err = update_eir(hdev);
+		if (err < 0)
+			goto unlock;
+	} else
+		err = 0;
+
+	err = cmd_complete(sk, index, MGMT_OP_REMOVE_UUID, NULL, 0);
 
 unlock:
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return err;
@@ -1007,71 +1008,104 @@ static int set_dev_class(struct sock *sk, u16 index, unsigned char *data,
 	BT_DBG("request for hci%u", index);
 
 	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_DEV_CLASS,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_SET_DEV_CLASS, EINVAL);
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_DEV_CLASS,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_SET_DEV_CLASS, ENODEV);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 
-	hdev->major_class = cp->major;
+	hdev->major_class &= ~MGMT_MAJOR_CLASS_MASK;
+	hdev->major_class |= cp->major & MGMT_MAJOR_CLASS_MASK;
 	hdev->minor_class = cp->minor;
 
-	if (test_and_clear_bit(HCI_SERVICE_CACHE, &hdev->flags)) {
-		hci_dev_unlock(hdev);
-		cancel_delayed_work_sync(&hdev->service_cache);
-		hci_dev_lock(hdev);
-		update_eir(hdev);
-	}
+	if (test_bit(HCI_UP, &hdev->flags)) {
+		err = update_class(hdev);
+		if (err == 0)
+			err = cmd_complete(sk, index,
+		MGMT_OP_SET_DEV_CLASS, hdev->dev_class, sizeof(u8)*3);
+	} else
+		err = cmd_complete(sk, index, MGMT_OP_SET_DEV_CLASS, NULL, 0);
+
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
+
+	return err;
+}
+
+static int set_service_cache(struct sock *sk, u16 index,  unsigned char *data,
+									u16 len)
+{
+	struct hci_dev *hdev;
+	struct mgmt_cp_set_service_cache *cp;
+	int err;
+
+	cp = (void *) data;
+
+	if (len != sizeof(*cp))
+		return cmd_status(sk, index, MGMT_OP_SET_SERVICE_CACHE, EINVAL);
+
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index, MGMT_OP_SET_SERVICE_CACHE, ENODEV);
+
+	hci_dev_lock_bh(hdev);
+
+	BT_DBG("hci%u enable %d", index, cp->enable);
 
-	err = update_class(hdev);
+	if (cp->enable) {
+		set_bit(HCI_SERVICE_CACHE, &hdev->flags);
+		err = 0;
+	} else {
+		clear_bit(HCI_SERVICE_CACHE, &hdev->flags);
+		if (test_bit(HCI_UP, &hdev->flags)) {
+			err = update_class(hdev);
+			if (err == 0)
+				err = update_eir(hdev);
+		} else
+			err = 0;
+	}
 
 	if (err == 0)
-		err = cmd_complete(sk, index, MGMT_OP_SET_DEV_CLASS, NULL, 0);
+		err = cmd_complete(sk, index, MGMT_OP_SET_SERVICE_CACHE, NULL,
+									0);
 
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return err;
 }
 
-static int load_link_keys(struct sock *sk, u16 index, unsigned char *data,
-								u16 len)
+static int load_keys(struct sock *sk, u16 index, unsigned char *data, u16 len)
 {
 	struct hci_dev *hdev;
-	struct mgmt_cp_load_link_keys *cp;
+	struct mgmt_cp_load_keys *cp;
 	u16 key_count, expected_len;
-	int i;
+	int i, err;
 
 	cp = (void *) data;
 
 	if (len < sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_LOAD_LINK_KEYS,
-						MGMT_STATUS_INVALID_PARAMS);
+		return -EINVAL;
 
 	key_count = get_unaligned_le16(&cp->key_count);
 
-	expected_len = sizeof(*cp) + key_count *
-					sizeof(struct mgmt_link_key_info);
-	if (expected_len != len) {
-		BT_ERR("load_link_keys: expected %u bytes, got %u bytes",
-							len, expected_len);
-		return cmd_status(sk, index, MGMT_OP_LOAD_LINK_KEYS,
-						MGMT_STATUS_INVALID_PARAMS);
+	expected_len = sizeof(*cp) + key_count * sizeof(struct mgmt_key_info);
+	if (expected_len > len) {
+		BT_ERR("load_keys: expected at least %u bytes, got %u bytes",
+							expected_len, len);
+		return -EINVAL;
 	}
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_LOAD_LINK_KEYS,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_LOAD_KEYS, ENODEV);
 
 	BT_DBG("hci%u debug_keys %u key_count %u", index, cp->debug_keys,
 								key_count);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 
 	hci_link_keys_clear(hdev);
 
@@ -1082,85 +1116,79 @@ static int load_link_keys(struct sock *sk, u16 index, unsigned char *data,
 	else
 		clear_bit(HCI_DEBUG_KEYS, &hdev->flags);
 
-	for (i = 0; i < key_count; i++) {
-		struct mgmt_link_key_info *key = &cp->keys[i];
+	len -= sizeof(*cp);
+	i = 0;
+
+	while (i < len) {
+		struct mgmt_key_info *key = (void *) cp->keys + i;
 
-		hci_add_link_key(hdev, NULL, 0, &key->bdaddr, key->val, key->type,
+		i += sizeof(*key);
+
+		if (key->key_type == KEY_TYPE_LTK) {
+			struct key_master_id *id = (void *) key->data;
+
+			if (key->dlen != sizeof(struct key_master_id))
+				continue;
+
+			hci_add_ltk(hdev, 0, &key->bdaddr, key->addr_type,
+					key->pin_len, key->auth, id->ediv,
+					id->rand, key->val);
+
+			continue;
+		}
+
+		hci_add_link_key(hdev, 0, &key->bdaddr, key->val, key->key_type,
 								key->pin_len);
 	}
 
-	cmd_complete(sk, index, MGMT_OP_LOAD_LINK_KEYS, NULL, 0);
+	err = cmd_complete(sk, index, MGMT_OP_LOAD_KEYS, NULL, 0);
 
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
-	return 0;
+	return err;
 }
 
-static int remove_keys(struct sock *sk, u16 index, unsigned char *data,
-								u16 len)
+static int remove_key(struct sock *sk, u16 index, unsigned char *data, u16 len)
 {
 	struct hci_dev *hdev;
-	struct mgmt_cp_remove_keys *cp;
-	struct mgmt_rp_remove_keys rp;
-	struct hci_cp_disconnect dc;
-	struct pending_cmd *cmd;
+	struct mgmt_cp_remove_key *cp;
 	struct hci_conn *conn;
 	int err;
 
 	cp = (void *) data;
 
 	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_REMOVE_KEYS,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_REMOVE_KEY, EINVAL);
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_REMOVE_KEYS,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_REMOVE_KEY, ENODEV);
 
-	hci_dev_lock(hdev);
-
-	memset(&rp, 0, sizeof(rp));
-	bacpy(&rp.bdaddr, &cp->bdaddr);
-	rp.status = MGMT_STATUS_FAILED;
+	hci_dev_lock_bh(hdev);
 
 	err = hci_remove_link_key(hdev, &cp->bdaddr);
 	if (err < 0) {
-		rp.status = MGMT_STATUS_NOT_PAIRED;
+		err = cmd_status(sk, index, MGMT_OP_REMOVE_KEY, -err);
 		goto unlock;
 	}
 
-	if (!test_bit(HCI_UP, &hdev->flags) || !cp->disconnect) {
-		err = cmd_complete(sk, index, MGMT_OP_REMOVE_KEYS, &rp,
-								sizeof(rp));
+	err = 0;
+
+	if (!test_bit(HCI_UP, &hdev->flags) || !cp->disconnect)
 		goto unlock;
-	}
 
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
-	if (!conn) {
-		err = cmd_complete(sk, index, MGMT_OP_REMOVE_KEYS, &rp,
-								sizeof(rp));
-		goto unlock;
-	}
+	if (conn) {
+		struct hci_cp_disconnect dc;
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_REMOVE_KEYS, hdev, cp, sizeof(*cp));
-	if (!cmd) {
-		err = -ENOMEM;
-		goto unlock;
+		put_unaligned_le16(conn->handle, &dc.handle);
+		dc.reason = 0x13; /* Remote User Terminated Connection */
+		err = hci_send_cmd(hdev, HCI_OP_DISCONNECT, 0, NULL);
 	}
 
-	put_unaligned_le16(conn->handle, &dc.handle);
-	dc.reason = 0x13; /* Remote User Terminated Connection */
-	err = hci_send_cmd(hdev, HCI_OP_DISCONNECT, sizeof(dc), &dc);
-	if (err < 0)
-		mgmt_pending_remove(cmd);
-
 unlock:
-	if (err < 0)
-		err = cmd_complete(sk, index, MGMT_OP_REMOVE_KEYS, &rp,
-								sizeof(rp));
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return err;
@@ -1180,39 +1208,35 @@ static int disconnect(struct sock *sk, u16 index, unsigned char *data, u16 len)
 	cp = (void *) data;
 
 	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_DISCONNECT,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_DISCONNECT, EINVAL);
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_DISCONNECT,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_DISCONNECT, ENODEV);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 
 	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_DISCONNECT,
-						MGMT_STATUS_NOT_POWERED);
+		err = cmd_status(sk, index, MGMT_OP_DISCONNECT, ENETDOWN);
 		goto failed;
 	}
 
-	if (mgmt_pending_find(MGMT_OP_DISCONNECT, hdev)) {
-		err = cmd_status(sk, index, MGMT_OP_DISCONNECT,
-							MGMT_STATUS_BUSY);
+	if (mgmt_pending_find(MGMT_OP_DISCONNECT, index)) {
+		err = cmd_status(sk, index, MGMT_OP_DISCONNECT, EBUSY);
 		goto failed;
 	}
 
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
-	if (!conn)
-		conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
-
 	if (!conn) {
-		err = cmd_status(sk, index, MGMT_OP_DISCONNECT,
-						MGMT_STATUS_NOT_CONNECTED);
-		goto failed;
+		conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
+		if (!conn) {
+			err = cmd_status(sk, index, MGMT_OP_DISCONNECT,
+							ENOTCONN);
+			goto failed;
+		}
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_DISCONNECT, hdev, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_DISCONNECT, index, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
@@ -1226,36 +1250,16 @@ static int disconnect(struct sock *sk, u16 index, unsigned char *data, u16 len)
 		mgmt_pending_remove(cmd);
 
 failed:
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return err;
 }
 
-static u8 link_to_mgmt(u8 link_type, u8 addr_type)
-{
-	switch (link_type) {
-	case LE_LINK:
-		switch (addr_type) {
-		case ADDR_LE_DEV_PUBLIC:
-			return MGMT_ADDR_LE_PUBLIC;
-		case ADDR_LE_DEV_RANDOM:
-			return MGMT_ADDR_LE_RANDOM;
-		default:
-			return MGMT_ADDR_INVALID;
-		}
-	case ACL_LINK:
-		return MGMT_ADDR_BREDR;
-	default:
-		return MGMT_ADDR_INVALID;
-	}
-}
-
 static int get_connections(struct sock *sk, u16 index)
 {
 	struct mgmt_rp_get_connections *rp;
 	struct hci_dev *hdev;
-	struct hci_conn *c;
 	struct list_head *p;
 	size_t rp_len;
 	u16 count;
@@ -1265,17 +1269,16 @@ static int get_connections(struct sock *sk, u16 index)
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_GET_CONNECTIONS,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_GET_CONNECTIONS, ENODEV);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 
 	count = 0;
 	list_for_each(p, &hdev->conn_hash.list) {
 		count++;
 	}
 
-	rp_len = sizeof(*rp) + (count * sizeof(struct mgmt_addr_info));
+	rp_len = sizeof(*rp) + (count * sizeof(bdaddr_t));
 	rp = kmalloc(rp_len, GFP_ATOMIC);
 	if (!rp) {
 		err = -ENOMEM;
@@ -1284,53 +1287,31 @@ static int get_connections(struct sock *sk, u16 index)
 
 	put_unaligned_le16(count, &rp->conn_count);
 
+	read_lock(&hci_dev_list_lock);
+
 	i = 0;
-	list_for_each_entry(c, &hdev->conn_hash.list, list) {
-		bacpy(&rp->addr[i].bdaddr, &c->dst);
-		rp->addr[i].type = link_to_mgmt(c->type, c->dst_type);
-		if (rp->addr[i].type == MGMT_ADDR_INVALID)
-			continue;
-		i++;
+	list_for_each(p, &hdev->conn_hash.list) {
+		struct hci_conn *c = list_entry(p, struct hci_conn, list);
+
+		bacpy(&rp->conn[i++], &c->dst);
 	}
 
-	/* Recalculate length in case of filtered SCO connections, etc */
-	rp_len = sizeof(*rp) + (i * sizeof(struct mgmt_addr_info));
+	read_unlock(&hci_dev_list_lock);
 
 	err = cmd_complete(sk, index, MGMT_OP_GET_CONNECTIONS, rp, rp_len);
 
 unlock:
 	kfree(rp);
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 	return err;
 }
 
-static int send_pin_code_neg_reply(struct sock *sk, u16 index,
-		struct hci_dev *hdev, struct mgmt_cp_pin_code_neg_reply *cp)
-{
-	struct pending_cmd *cmd;
-	int err;
-
-	cmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_NEG_REPLY, hdev, cp,
-								sizeof(*cp));
-	if (!cmd)
-		return -ENOMEM;
-
-	err = hci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY, sizeof(cp->bdaddr),
-								&cp->bdaddr);
-	if (err < 0)
-		mgmt_pending_remove(cmd);
-
-	return err;
-}
-
 static int pin_code_reply(struct sock *sk, u16 index, unsigned char *data,
 									u16 len)
 {
 	struct hci_dev *hdev;
-	struct hci_conn *conn;
 	struct mgmt_cp_pin_code_reply *cp;
-	struct mgmt_cp_pin_code_neg_reply ncp;
 	struct hci_cp_pin_code_reply reply;
 	struct pending_cmd *cmd;
 	int err;
@@ -1340,43 +1321,20 @@ static int pin_code_reply(struct sock *sk, u16 index, unsigned char *data,
 	cp = (void *) data;
 
 	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY, EINVAL);
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY, ENODEV);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 
 	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY,
-						MGMT_STATUS_NOT_POWERED);
-		goto failed;
-	}
-
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
-	if (!conn) {
-		err = cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY,
-						MGMT_STATUS_NOT_CONNECTED);
-		goto failed;
-	}
-
-	if (conn->pending_sec_level == BT_SECURITY_HIGH && cp->pin_len != 16) {
-		bacpy(&ncp.bdaddr, &cp->bdaddr);
-
-		BT_ERR("PIN code is not 16 bytes long");
-
-		err = send_pin_code_neg_reply(sk, index, hdev, &ncp);
-		if (err >= 0)
-			err = cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY,
-						MGMT_STATUS_INVALID_PARAMS);
-
+		err = cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY, ENETDOWN);
 		goto failed;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_REPLY, hdev, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_REPLY, index, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
@@ -1384,51 +1342,302 @@ static int pin_code_reply(struct sock *sk, u16 index, unsigned char *data,
 
 	bacpy(&reply.bdaddr, &cp->bdaddr);
 	reply.pin_len = cp->pin_len;
-	memcpy(reply.pin_code, cp->pin_code, sizeof(reply.pin_code));
+	memcpy(reply.pin_code, cp->pin_code, 16);
 
 	err = hci_send_cmd(hdev, HCI_OP_PIN_CODE_REPLY, sizeof(reply), &reply);
 	if (err < 0)
 		mgmt_pending_remove(cmd);
 
 failed:
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return err;
 }
 
-static int pin_code_neg_reply(struct sock *sk, u16 index, unsigned char *data,
+static int encrypt_link(struct sock *sk, u16 index, unsigned char *data,
 									u16 len)
 {
 	struct hci_dev *hdev;
-	struct mgmt_cp_pin_code_neg_reply *cp;
-	int err;
+	struct mgmt_cp_encrypt_link *cp;
+	struct hci_cp_set_conn_encrypt enc;
+	struct hci_conn *conn;
+	int err = 0;
 
 	BT_DBG("");
 
 	cp = (void *) data;
 
 	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_PIN_CODE_NEG_REPLY,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_ENCRYPT_LINK, EINVAL);
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_PIN_CODE_NEG_REPLY,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_ENCRYPT_LINK, ENODEV);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 
 	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_PIN_CODE_NEG_REPLY,
-						MGMT_STATUS_NOT_POWERED);
-		goto failed;
+		err = cmd_status(sk, index, MGMT_OP_ENCRYPT_LINK, ENETDOWN);
+		goto done;
+	}
+
+	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
+	if (!conn) {
+		err = cmd_status(sk, index, MGMT_OP_ENCRYPT_LINK, ENOTCONN);
+		goto done;
+	}
+
+	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
+		err = cmd_status(sk, index, MGMT_OP_ENCRYPT_LINK, EINPROGRESS);
+		goto done;
+	}
+
+	if (conn->link_mode & HCI_LM_AUTH) {
+		enc.handle = cpu_to_le16(conn->handle);
+		enc.encrypt = cp->enable;
+		err = hci_send_cmd(hdev,
+				HCI_OP_SET_CONN_ENCRYPT, sizeof(enc), &enc);
+	} else {
+		conn->auth_initiator = 1;
+		if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
+			struct hci_cp_auth_requested cp;
+			cp.handle = cpu_to_le16(conn->handle);
+			err = hci_send_cmd(conn->hdev,
+				HCI_OP_AUTH_REQUESTED, sizeof(cp), &cp);
+		}
+	}
+
+done:
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
+
+	return err;
+}
+
+
+static int pin_code_neg_reply(struct sock *sk, u16 index, unsigned char *data,
+									u16 len)
+{
+	struct hci_dev *hdev;
+	struct mgmt_cp_pin_code_neg_reply *cp;
+	struct pending_cmd *cmd;
+	int err;
+
+	BT_DBG("");
+
+	cp = (void *) data;
+
+	if (len != sizeof(*cp))
+		return cmd_status(sk, index, MGMT_OP_PIN_CODE_NEG_REPLY,
+									EINVAL);
+
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index, MGMT_OP_PIN_CODE_NEG_REPLY,
+									ENODEV);
+
+	hci_dev_lock_bh(hdev);
+
+	if (!test_bit(HCI_UP, &hdev->flags)) {
+		err = cmd_status(sk, index, MGMT_OP_PIN_CODE_NEG_REPLY,
+								ENETDOWN);
+		goto failed;
+	}
+
+	cmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_NEG_REPLY, index,
+								data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto failed;
+	}
+
+	err = hci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY, sizeof(cp->bdaddr),
+								&cp->bdaddr);
+	if (err < 0)
+		mgmt_pending_remove(cmd);
+
+failed:
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
+
+	return err;
+}
+
+static int le_add_dev_white_list(struct sock *sk, u16 index,
+					unsigned char *data, u16 len)
+{
+	struct hci_dev *hdev;
+	struct mgmt_cp_le_add_dev_white_list *cp;
+	int err = 0;
+
+	BT_DBG("");
+
+	cp = (void *) data;
+
+	if (len != sizeof(*cp))
+		return cmd_status(sk, index, MGMT_OP_LE_ADD_DEV_WHITE_LIST,
+									EINVAL);
+
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index, MGMT_OP_LE_ADD_DEV_WHITE_LIST,
+									ENODEV);
+
+	hci_dev_lock_bh(hdev);
+
+	if (!test_bit(HCI_UP, &hdev->flags)) {
+		err = cmd_status(sk, index, MGMT_OP_LE_ADD_DEV_WHITE_LIST,
+								ENETDOWN);
+		goto failed;
 	}
 
-	err = send_pin_code_neg_reply(sk, index, hdev, cp);
+	hci_le_add_dev_white_list(hdev, &cp->bdaddr);
 
 failed:
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
+
+	return err;
+}
+
+static int le_remove_dev_white_list(struct sock *sk, u16 index,
+					unsigned char *data, u16 len)
+{
+	struct hci_dev *hdev;
+	struct mgmt_cp_le_remove_dev_white_list *cp;
+	int err = 0;
+
+	BT_DBG("");
+
+	cp = (void *) data;
+
+	if (len != sizeof(*cp))
+		return cmd_status(sk, index, MGMT_OP_LE_REMOVE_DEV_WHITE_LIST,
+									EINVAL);
+
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index, MGMT_OP_LE_REMOVE_DEV_WHITE_LIST,
+									ENODEV);
+
+	hci_dev_lock_bh(hdev);
+
+	if (!test_bit(HCI_UP, &hdev->flags)) {
+		err = cmd_status(sk, index, MGMT_OP_LE_REMOVE_DEV_WHITE_LIST,
+								ENETDOWN);
+		goto failed;
+	}
+
+	hci_le_remove_dev_white_list(hdev, &cp->bdaddr);
+
+failed:
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
+
+	return err;
+}
+
+static int le_create_conn_white_list(struct sock *sk, u16 index)
+{
+	struct hci_dev *hdev;
+	struct hci_conn *conn;
+	u8 sec_level, auth_type;
+	struct pending_cmd *cmd;
+	bdaddr_t bdaddr;
+	int err = 0;
+
+	BT_DBG("");
+
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index, MGMT_OP_LE_CREATE_CONN_WHITE_LIST,
+									ENODEV);
+
+	hci_dev_lock_bh(hdev);
+
+	if (!test_bit(HCI_UP, &hdev->flags)) {
+		err = cmd_status(sk, index, MGMT_OP_LE_CREATE_CONN_WHITE_LIST,
+								ENETDOWN);
+		goto failed;
+	}
+
+	cmd = mgmt_pending_add(sk, MGMT_OP_LE_CREATE_CONN_WHITE_LIST, index,
+								NULL, 0);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto failed;
+	}
+
+	sec_level = BT_SECURITY_MEDIUM;
+	auth_type = HCI_AT_GENERAL_BONDING;
+	memset(&bdaddr, 0, sizeof(bdaddr));
+	conn = hci_le_connect(hdev, 0, BDADDR_ANY, sec_level, auth_type, NULL);
+	if (IS_ERR(conn)) {
+		err = PTR_ERR(conn);
+		mgmt_pending_remove(cmd);
+	}
+
+failed:
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
+
+	return err;
+}
+
+static int le_cancel_create_conn_white_list(struct sock *sk, u16 index)
+{
+	struct hci_dev *hdev;
+	int err = 0;
+
+	BT_DBG("");
+
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index,
+			MGMT_OP_LE_CANCEL_CREATE_CONN_WHITE_LIST, ENODEV);
+
+	hci_dev_lock_bh(hdev);
+
+	if (!test_bit(HCI_UP, &hdev->flags)) {
+		err = cmd_status(sk, index,
+			MGMT_OP_LE_CANCEL_CREATE_CONN_WHITE_LIST, ENETDOWN);
+		goto failed;
+	}
+
+	hci_le_cancel_create_connect(hdev, BDADDR_ANY);
+
+failed:
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
+
+	return err;
+}
+
+static int le_clear_white_list(struct sock *sk, u16 index)
+{
+	struct hci_dev *hdev;
+	int err;
+
+	BT_DBG("");
+
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index,
+			MGMT_OP_LE_CLEAR_WHITE_LIST, ENODEV);
+
+	hci_dev_lock_bh(hdev);
+
+	if (!test_bit(HCI_UP, &hdev->flags)) {
+		err = cmd_status(sk, index,
+			MGMT_OP_LE_CLEAR_WHITE_LIST, ENETDOWN);
+		goto failed;
+	}
+
+	err = hci_send_cmd(hdev, HCI_OP_LE_CLEAR_WHITE_LIST, 0, NULL);
+
+failed:
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return err;
@@ -1445,22 +1654,20 @@ static int set_io_capability(struct sock *sk, u16 index, unsigned char *data,
 	cp = (void *) data;
 
 	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_IO_CAPABILITY,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_SET_IO_CAPABILITY, EINVAL);
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_IO_CAPABILITY,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_SET_IO_CAPABILITY, ENODEV);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 
 	hdev->io_capability = cp->io_capability;
 
 	BT_DBG("%s IO capability set to 0x%02x", hdev->name,
 							hdev->io_capability);
 
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return cmd_complete(sk, index, MGMT_OP_SET_IO_CAPABILITY, NULL, 0);
@@ -1469,12 +1676,19 @@ static int set_io_capability(struct sock *sk, u16 index, unsigned char *data,
 static inline struct pending_cmd *find_pairing(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
-	struct pending_cmd *cmd;
+	struct list_head *p;
+
+	list_for_each(p, &cmd_list) {
+		struct pending_cmd *cmd;
+
+		cmd = list_entry(p, struct pending_cmd, list);
 
-	list_for_each_entry(cmd, &hdev->mgmt_pending, list) {
 		if (cmd->opcode != MGMT_OP_PAIR_DEVICE)
 			continue;
 
+		if (cmd->index != hdev->id)
+			continue;
+
 		if (cmd->user_data != conn)
 			continue;
 
@@ -1489,8 +1703,9 @@ static void pairing_complete(struct pending_cmd *cmd, u8 status)
 	struct mgmt_rp_pair_device rp;
 	struct hci_conn *conn = cmd->user_data;
 
-	bacpy(&rp.addr.bdaddr, &conn->dst);
-	rp.addr.type = link_to_mgmt(conn->type, conn->dst_type);
+	BT_DBG(" %u", status);
+
+	bacpy(&rp.bdaddr, &conn->dst);
 	rp.status = status;
 
 	cmd_complete(cmd->sk, cmd->index, MGMT_OP_PAIR_DEVICE, &rp, sizeof(rp));
@@ -1500,8 +1715,6 @@ static void pairing_complete(struct pending_cmd *cmd, u8 status)
 	conn->security_cfm_cb = NULL;
 	conn->disconn_cfm_cb = NULL;
 
-	hci_conn_put(conn);
-
 	mgmt_pending_remove(cmd);
 }
 
@@ -1509,23 +1722,85 @@ static void pairing_complete_cb(struct hci_conn *conn, u8 status)
 {
 	struct pending_cmd *cmd;
 
-	BT_DBG("status %u", status);
+	BT_DBG(" %u", status);
 
 	cmd = find_pairing(conn);
-	if (!cmd)
+	if (!cmd) {
 		BT_DBG("Unable to find a pending command");
+		return;
+	}
+
+	pairing_complete(cmd, status);
+	hci_conn_put(conn);
+}
+
+static void pairing_security_complete_cb(struct hci_conn *conn, u8 status)
+{
+	struct pending_cmd *cmd;
+
+	BT_DBG(" %u", status);
+
+	cmd = find_pairing(conn);
+	if (!cmd) {
+		BT_DBG("Unable to find a pending command");
+		return;
+	}
+
+	if (conn->type == LE_LINK)
+		smp_link_encrypt_cmplt(conn->l2cap_data, status,
+				status ? 0 : 1);
 	else
 		pairing_complete(cmd, status);
 }
 
+static void pairing_connect_complete_cb(struct hci_conn *conn, u8 status)
+{
+	struct pending_cmd *cmd;
+
+	BT_DBG("conn: %p %u", conn, status);
+
+	cmd = find_pairing(conn);
+	if (!cmd) {
+		BT_DBG("Unable to find a pending command");
+		return;
+	}
+
+	if (status || conn->pending_sec_level < BT_SECURITY_MEDIUM)
+		pairing_complete(cmd, status);
+
+	hci_conn_put(conn);
+}
+
+static void discovery_terminated(struct pending_cmd *cmd, void *data)
+{
+	struct hci_dev *hdev;
+	struct mgmt_mode ev = {0};
+
+	BT_DBG("");
+	hdev = hci_dev_get(cmd->index);
+	if (!hdev)
+		goto not_found;
+
+	del_timer(&hdev->disco_le_timer);
+	del_timer(&hdev->disco_timer);
+	hci_dev_put(hdev);
+
+not_found:
+	mgmt_event(MGMT_EV_DISCOVERING, cmd->index, &ev, sizeof(ev), NULL);
+
+	list_del(&cmd->list);
+
+	mgmt_pending_free(cmd);
+}
+
 static int pair_device(struct sock *sk, u16 index, unsigned char *data, u16 len)
 {
 	struct hci_dev *hdev;
 	struct mgmt_cp_pair_device *cp;
-	struct mgmt_rp_pair_device rp;
 	struct pending_cmd *cmd;
-	u8 sec_level, auth_type;
+	u8 sec_level, auth_type, io_cap;
 	struct hci_conn *conn;
+	struct adv_entry *entry;
 	int err;
 
 	BT_DBG("");
@@ -1533,214 +1808,347 @@ static int pair_device(struct sock *sk, u16 index, unsigned char *data, u16 len)
 	cp = (void *) data;
 
 	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_PAIR_DEVICE,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_PAIR_DEVICE, EINVAL);
 
 	hdev = hci_dev_get(index);
+
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_PAIR_DEVICE,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_PAIR_DEVICE, ENODEV);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 
-	sec_level = BT_SECURITY_MEDIUM;
-	if (cp->io_cap == 0x03)
-		auth_type = HCI_AT_DEDICATED_BONDING;
-	else
-		auth_type = HCI_AT_DEDICATED_BONDING_MITM;
+	io_cap = cp->io_cap;
 
-	if (cp->addr.type == MGMT_ADDR_BREDR)
-		conn = hci_connect(hdev, ACL_LINK, 0, &cp->addr.bdaddr,
-							sec_level, auth_type);
-	else
-		conn = hci_connect(hdev, LE_LINK, 0, &cp->addr.bdaddr,
-							sec_level, auth_type);
+	sec_level = BT_SECURITY_MEDIUM;
+	auth_type = HCI_AT_DEDICATED_BONDING;
 
-	memset(&rp, 0, sizeof(rp));
-	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
-	rp.addr.type = cp->addr.type;
+	entry = hci_find_adv_entry(hdev, &cp->bdaddr);
+	if (entry && entry->flags & 0x04) {
+		conn = hci_le_connect(hdev, 0, &cp->bdaddr, sec_level,
+							auth_type, NULL);
+	} else {
+		/* ACL-SSP does not support io_cap 0x04 (KeyboadDisplay) */
+		if (io_cap == 0x04)
+			io_cap = 0x01;
+		conn = hci_connect(hdev, ACL_LINK, 0, &cp->bdaddr, sec_level,
+								auth_type);
+		conn->auth_initiator = 1;
+	}
 
 	if (IS_ERR(conn)) {
-		rp.status = -PTR_ERR(conn);
-		err = cmd_complete(sk, index, MGMT_OP_PAIR_DEVICE,
-							&rp, sizeof(rp));
+		err = PTR_ERR(conn);
 		goto unlock;
 	}
 
 	if (conn->connect_cfm_cb) {
 		hci_conn_put(conn);
-		rp.status = EBUSY;
-		err = cmd_complete(sk, index, MGMT_OP_PAIR_DEVICE,
-							&rp, sizeof(rp));
+		err = cmd_status(sk, index, MGMT_OP_PAIR_DEVICE, EBUSY);
 		goto unlock;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_PAIR_DEVICE, hdev, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_PAIR_DEVICE, index, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		hci_conn_put(conn);
 		goto unlock;
 	}
 
-	/* For LE, just connecting isn't a proof that the pairing finished */
-	if (cp->addr.type == MGMT_ADDR_BREDR)
-		conn->connect_cfm_cb = pairing_complete_cb;
+	conn->connect_cfm_cb = pairing_connect_complete_cb;
+	conn->security_cfm_cb = pairing_security_complete_cb;
+	conn->disconn_cfm_cb = pairing_complete_cb;
+	conn->io_capability = io_cap;
+	cmd->user_data = conn;
+
+	if (conn->state == BT_CONNECTED &&
+				hci_conn_security(conn, sec_level, auth_type))
+		pairing_complete(cmd, 0);
+
+	err = 0;
+
+unlock:
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
+
+	return err;
+}
+
+static int user_confirm_reply(struct sock *sk, u16 index, unsigned char *data,
+							u16 len, u16 opcode)
+{
+	struct mgmt_cp_user_confirm_reply *cp = (void *) data;
+	u16 mgmt_op = opcode, hci_op;
+	struct pending_cmd *cmd;
+	struct hci_dev *hdev;
+	struct hci_conn *le_conn;
+	int err;
+
+	BT_DBG("%d", mgmt_op);
+
+	if (mgmt_op == MGMT_OP_USER_CONFIRM_NEG_REPLY)
+		hci_op = HCI_OP_USER_CONFIRM_NEG_REPLY;
+	else
+		hci_op = HCI_OP_USER_CONFIRM_REPLY;
+
+	if (len < sizeof(*cp))
+		return cmd_status(sk, index, mgmt_op, EINVAL);
+
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index, mgmt_op, ENODEV);
+
+	hci_dev_lock_bh(hdev);
+
+	if (!test_bit(HCI_UP, &hdev->flags)) {
+		err = cmd_status(sk, index, mgmt_op, ENETDOWN);
+		goto done;
+	}
+
+	le_conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
+	if (le_conn) {
+		err = le_user_confirm_reply(le_conn, mgmt_op, (void *) cp);
+		goto done;
+	}
+	BT_DBG("BR/EDR: %s", mgmt_op == MGMT_OP_USER_CONFIRM_NEG_REPLY ?
+							"Reject" : "Accept");
+
+	cmd = mgmt_pending_add(sk, mgmt_op, index, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto done;
+	}
+
+	err = hci_send_cmd(hdev, hci_op, sizeof(cp->bdaddr), &cp->bdaddr);
+	if (err < 0)
+		mgmt_pending_remove(cmd);
+
+done:
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
+
+	return err;
+}
+
+static int resolve_name(struct sock *sk, u16 index, unsigned char *data,
+								u16 len)
+{
+	struct mgmt_cp_resolve_name *mgmt_cp = (void *) data;
+	struct hci_cp_remote_name_req hci_cp;
+	struct hci_dev *hdev;
+	struct pending_cmd *cmd;
+	int err;
+
+	BT_DBG("");
+
+	if (len != sizeof(*mgmt_cp))
+		return cmd_status(sk, index, MGMT_OP_RESOLVE_NAME, EINVAL);
+
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index, MGMT_OP_RESOLVE_NAME, ENODEV);
+
+	hci_dev_lock_bh(hdev);
+
+	cmd = mgmt_pending_add(sk, MGMT_OP_RESOLVE_NAME, index, data, len);
+	if (!cmd) {
+		err = -ENOMEM;
+		goto failed;
+	}
+
+	memset(&hci_cp, 0, sizeof(hci_cp));
+	bacpy(&hci_cp.bdaddr, &mgmt_cp->bdaddr);
+	err = hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ, sizeof(hci_cp),
+								&hci_cp);
+	if (err < 0)
+		mgmt_pending_remove(cmd);
+
+failed:
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
+
+	return err;
+}
+
+static int cancel_resolve_name(struct sock *sk, u16 index, unsigned char *data,
+								u16 len)
+{
+	struct mgmt_cp_cancel_resolve_name *mgmt_cp = (void *) data;
+	struct hci_cp_remote_name_req_cancel hci_cp;
+	struct hci_dev *hdev;
+	int err;
+
+	BT_DBG("");
 
-	conn->security_cfm_cb = pairing_complete_cb;
-	conn->disconn_cfm_cb = pairing_complete_cb;
-	conn->io_capability = cp->io_cap;
-	cmd->user_data = conn;
+	if (len != sizeof(*mgmt_cp))
+		return cmd_status(sk, index, MGMT_OP_CANCEL_RESOLVE_NAME,
+								EINVAL);
 
-	if (conn->state == BT_CONNECTED &&
-				hci_conn_security(conn, sec_level, auth_type))
-		pairing_complete(cmd, 0);
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index, MGMT_OP_CANCEL_RESOLVE_NAME,
+								ENODEV);
 
-	err = 0;
+	hci_dev_lock_bh(hdev);
 
-unlock:
-	hci_dev_unlock(hdev);
+	memset(&hci_cp, 0, sizeof(hci_cp));
+	bacpy(&hci_cp.bdaddr, &mgmt_cp->bdaddr);
+	err = hci_send_cmd(hdev, HCI_OP_REMOTE_NAME_REQ_CANCEL, sizeof(hci_cp),
+								&hci_cp);
+
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return err;
 }
 
-static int user_pairing_resp(struct sock *sk, u16 index, bdaddr_t *bdaddr,
-					u16 mgmt_op, u16 hci_op, __le32 passkey)
+static int set_connection_params(struct sock *sk, u16 index,
+				unsigned char *data, u16 len)
 {
-	struct pending_cmd *cmd;
+	struct mgmt_cp_set_connection_params *cp = (void *) data;
 	struct hci_dev *hdev;
 	struct hci_conn *conn;
 	int err;
 
+	BT_DBG("");
+
+	if (len != sizeof(*cp))
+		return cmd_status(sk, index, MGMT_OP_SET_CONNECTION_PARAMS,
+									EINVAL);
+
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, mgmt_op,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_SET_CONNECTION_PARAMS,
+									ENODEV);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, mgmt_op, MGMT_STATUS_NOT_POWERED);
-		goto done;
+	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
+	if (!conn) {
+		err = cmd_status(sk, index, MGMT_OP_SET_CONNECTION_PARAMS,
+								ENOTCONN);
+		goto failed;
 	}
 
-	/*
-	 * Check for an existing ACL link, if present pair via
-	 * HCI commands.
-	 *
-	 * If no ACL link is present, check for an LE link and if
-	 * present, pair via the SMP engine.
-	 *
-	 * If neither ACL nor LE links are present, fail with error.
-	 */
-	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, bdaddr);
-	if (!conn) {
-		conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, bdaddr);
-		if (!conn) {
-			err = cmd_status(sk, index, mgmt_op,
-						MGMT_STATUS_NOT_CONNECTED);
-			goto done;
-		}
+	hci_le_conn_update(conn, le16_to_cpu(cp->interval_min),
+				le16_to_cpu(cp->interval_max),
+				le16_to_cpu(cp->slave_latency),
+				le16_to_cpu(cp->timeout_multiplier));
 
-		/* Continue with pairing via SMP */
-		err = smp_user_confirm_reply(conn, mgmt_op, passkey);
+	err = cmd_status(sk, index, MGMT_OP_SET_CONNECTION_PARAMS, 0);
 
-		if (!err)
-			err = cmd_status(sk, index, mgmt_op,
-							MGMT_STATUS_SUCCESS);
-		else
-			err = cmd_status(sk, index, mgmt_op,
-							MGMT_STATUS_FAILED);
+failed:
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
 
-		goto done;
-	}
+	return err;
+}
 
-	cmd = mgmt_pending_add(sk, mgmt_op, hdev, bdaddr, sizeof(*bdaddr));
-	if (!cmd) {
-		err = -ENOMEM;
-		goto done;
-	}
+static int set_rssi_reporter(struct sock *sk, u16 index,
+				unsigned char *data, u16 len)
+{
+	struct mgmt_cp_set_rssi_reporter *cp = (void *) data;
+	struct hci_dev *hdev;
+	struct hci_conn *conn;
+	int err = 0;
 
-	/* Continue with pairing via HCI */
-	if (hci_op == HCI_OP_USER_PASSKEY_REPLY) {
-		struct hci_cp_user_passkey_reply cp;
+	if (len != sizeof(*cp))
+		return cmd_status(sk, index, MGMT_OP_SET_RSSI_REPORTER,
+								EINVAL);
 
-		bacpy(&cp.bdaddr, bdaddr);
-		cp.passkey = passkey;
-		err = hci_send_cmd(hdev, hci_op, sizeof(cp), &cp);
-	} else
-		err = hci_send_cmd(hdev, hci_op, sizeof(*bdaddr), bdaddr);
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index, MGMT_OP_SET_RSSI_REPORTER,
+							ENODEV);
 
-	if (err < 0)
-		mgmt_pending_remove(cmd);
+	hci_dev_lock_bh(hdev);
 
-done:
-	hci_dev_unlock(hdev);
+	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
+
+	if (!conn) {
+		err = cmd_status(sk, index, MGMT_OP_SET_RSSI_REPORTER,
+						ENOTCONN);
+		goto failed;
+	}
+
+	BT_DBG("updateOnThreshExceed %d ", cp->updateOnThreshExceed);
+	hci_conn_set_rssi_reporter(conn, cp->rssi_threshold,
+			__le16_to_cpu(cp->interval), cp->updateOnThreshExceed);
+
+failed:
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return err;
 }
 
-static int user_confirm_reply(struct sock *sk, u16 index, void *data, u16 len)
+static int unset_rssi_reporter(struct sock *sk, u16 index,
+			unsigned char *data, u16 len)
 {
-	struct mgmt_cp_user_confirm_reply *cp = (void *) data;
-
-	BT_DBG("");
+	struct mgmt_cp_unset_rssi_reporter *cp = (void *) data;
+	struct hci_dev *hdev;
+	struct hci_conn *conn;
+	int err = 0;
 
 	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_USER_CONFIRM_REPLY,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_UNSET_RSSI_REPORTER,
+					EINVAL);
 
-	return user_pairing_resp(sk, index, &cp->bdaddr,
-			MGMT_OP_USER_CONFIRM_REPLY,
-			HCI_OP_USER_CONFIRM_REPLY, 0);
-}
+	hdev = hci_dev_get(index);
 
-static int user_confirm_neg_reply(struct sock *sk, u16 index, void *data,
-									u16 len)
-{
-	struct mgmt_cp_user_confirm_neg_reply *cp = data;
+	if (!hdev)
+		return cmd_status(sk, index, MGMT_OP_UNSET_RSSI_REPORTER,
+					ENODEV);
 
-	BT_DBG("");
+	hci_dev_lock_bh(hdev);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_USER_CONFIRM_NEG_REPLY,
-						MGMT_STATUS_INVALID_PARAMS);
+	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, &cp->bdaddr);
+
+	if (!conn) {
+		err = cmd_status(sk, index, MGMT_OP_UNSET_RSSI_REPORTER,
+					ENOTCONN);
+		goto failed;
+	}
+
+	hci_conn_unset_rssi_reporter(conn);
+
+failed:
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
 
-	return user_pairing_resp(sk, index, &cp->bdaddr,
-			MGMT_OP_USER_CONFIRM_NEG_REPLY,
-			HCI_OP_USER_CONFIRM_NEG_REPLY, 0);
+	return err;
 }
 
-static int user_passkey_reply(struct sock *sk, u16 index, void *data, u16 len)
+static int le_cancel_create_conn(struct sock *sk, u16 index,
+	unsigned char *data, u16 len)
 {
-	struct mgmt_cp_user_passkey_reply *cp = (void *) data;
-
-	BT_DBG("");
+	struct mgmt_cp_le_cancel_create_conn *cp = (void *) data;
+	struct hci_dev *hdev;
+	int err = 0;
 
 	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_USER_PASSKEY_REPLY,
-									EINVAL);
+		return cmd_status(sk, index, MGMT_OP_LE_CANCEL_CREATE_CONN,
+							EINVAL);
 
-	return user_pairing_resp(sk, index, &cp->bdaddr,
-			MGMT_OP_USER_PASSKEY_REPLY,
-			HCI_OP_USER_PASSKEY_REPLY, cp->passkey);
-}
+	hdev = hci_dev_get(index);
 
-static int user_passkey_neg_reply(struct sock *sk, u16 index, void *data,
-									u16 len)
-{
-	struct mgmt_cp_user_passkey_neg_reply *cp = (void *) data;
+	if (!hdev)
+		return cmd_status(sk, index, MGMT_OP_LE_CANCEL_CREATE_CONN,
+							ENODEV);
 
-	BT_DBG("");
+	hci_dev_lock_bh(hdev);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_USER_PASSKEY_NEG_REPLY,
-									EINVAL);
+	if (!test_bit(HCI_UP, &hdev->flags)) {
+		err = cmd_status(sk, index, MGMT_OP_LE_CANCEL_CREATE_CONN,
+						ENETDOWN);
+		goto failed;
+	}
 
-	return user_pairing_resp(sk, index, &cp->bdaddr,
-			MGMT_OP_USER_PASSKEY_NEG_REPLY,
-			HCI_OP_USER_PASSKEY_NEG_REPLY, 0);
+	hci_le_cancel_create_connect(hdev, &cp->bdaddr);
+
+failed:
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
+
+return err;
 }
 
 static int set_local_name(struct sock *sk, u16 index, unsigned char *data,
@@ -1755,17 +2163,15 @@ static int set_local_name(struct sock *sk, u16 index, unsigned char *data,
 	BT_DBG("");
 
 	if (len != sizeof(*mgmt_cp))
-		return cmd_status(sk, index, MGMT_OP_SET_LOCAL_NAME,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_SET_LOCAL_NAME, EINVAL);
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_LOCAL_NAME,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_SET_LOCAL_NAME, ENODEV);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_SET_LOCAL_NAME, hdev, data, len);
+	cmd = mgmt_pending_add(sk, MGMT_OP_SET_LOCAL_NAME, index, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
@@ -1778,177 +2184,305 @@ static int set_local_name(struct sock *sk, u16 index, unsigned char *data,
 		mgmt_pending_remove(cmd);
 
 failed:
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return err;
 }
 
-static int read_local_oob_data(struct sock *sk, u16 index)
+static void discovery_rsp(struct pending_cmd *cmd, void *data)
 {
-	struct hci_dev *hdev;
-	struct pending_cmd *cmd;
-	int err;
+	struct mgmt_mode ev;
 
-	BT_DBG("hci%u", index);
+	BT_DBG("");
+	if (cmd->opcode == MGMT_OP_START_DISCOVERY) {
+		ev.val = 1;
+		cmd_status(cmd->sk, cmd->index, MGMT_OP_START_DISCOVERY, 0);
+	} else {
+		ev.val = 0;
+		cmd_complete(cmd->sk, cmd->index, MGMT_OP_STOP_DISCOVERY,
+								NULL, 0);
+		if (cmd->opcode == MGMT_OP_STOP_DISCOVERY) {
+			struct hci_dev *hdev = hci_dev_get(cmd->index);
+			if (hdev) {
+				del_timer(&hdev->disco_le_timer);
+				del_timer(&hdev->disco_timer);
+				hci_dev_put(hdev);
+			}
+		}
+	}
+
+	mgmt_event(MGMT_EV_DISCOVERING, cmd->index, &ev, sizeof(ev), NULL);
+
+	list_del(&cmd->list);
+
+	mgmt_pending_free(cmd);
+}
+
+void mgmt_inquiry_started(u16 index)
+{
+	BT_DBG("");
+	mgmt_pending_foreach(MGMT_OP_START_DISCOVERY, index,
+						discovery_rsp, NULL);
+}
+
+void mgmt_inquiry_complete_evt(u16 index, u8 status)
+{
+	struct hci_dev *hdev;
+	struct hci_cp_le_set_scan_enable le_cp = {1, 0};
+	struct mgmt_mode cp = {0};
+	int err = -1;
 
 	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
-						MGMT_STATUS_INVALID_PARAMS);
 
-	hci_dev_lock(hdev);
+	if (hdev)
+		BT_DBG("disco_state: %d", hdev->disco_state);
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
-						MGMT_STATUS_NOT_POWERED);
-		goto unlock;
-	}
+	if (!hdev || !lmp_le_capable(hdev)) {
 
-	if (!(hdev->features[6] & LMP_SIMPLE_PAIR)) {
-		err = cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
-						MGMT_STATUS_NOT_SUPPORTED);
-		goto unlock;
-	}
+		mgmt_pending_foreach(MGMT_OP_STOP_DISCOVERY, index,
+						discovery_terminated, NULL);
 
-	if (mgmt_pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev)) {
-		err = cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
-							MGMT_STATUS_BUSY);
-		goto unlock;
+		mgmt_event(MGMT_EV_DISCOVERING, index, &cp, sizeof(cp), NULL);
+
+		if (hdev) {
+			BT_DBG("Setting state to SCAN_IDLE\n");
+			hdev->disco_state = SCAN_IDLE;
+			goto done;
+		}
+		else
+			return;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_DATA, hdev, NULL, 0);
-	if (!cmd) {
-		err = -ENOMEM;
-		goto unlock;
+	if (hdev->disco_state != SCAN_IDLE) {
+		err = hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE,
+						sizeof(le_cp), &le_cp);
+		if (err >= 0) {
+			mod_timer(&hdev->disco_le_timer, jiffies +
+				msecs_to_jiffies(hdev->disco_int_phase * 1000));
+			hdev->disco_state = SCAN_LE;
+		} else
+			hdev->disco_state = SCAN_IDLE;
 	}
 
-	err = hci_send_cmd(hdev, HCI_OP_READ_LOCAL_OOB_DATA, 0, NULL);
+	if (hdev->disco_state == SCAN_IDLE)
+		mgmt_event(MGMT_EV_DISCOVERING, index, &cp, sizeof(cp), NULL);
+
 	if (err < 0)
-		mgmt_pending_remove(cmd);
+		mgmt_pending_foreach(MGMT_OP_STOP_DISCOVERY, index,
+						discovery_terminated, NULL);
 
-unlock:
-	hci_dev_unlock(hdev);
+done:
 	hci_dev_put(hdev);
-
-	return err;
 }
 
-static int add_remote_oob_data(struct sock *sk, u16 index, unsigned char *data,
-									u16 len)
+void mgmt_disco_timeout(unsigned long data)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_add_remote_oob_data *cp = (void *) data;
-	int err;
+	struct hci_dev *hdev = (void *) data;
+	struct pending_cmd *cmd;
+	struct mgmt_mode cp = {0};
 
-	BT_DBG("hci%u ", index);
+	BT_DBG("hci%d", hdev->id);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA,
-						MGMT_STATUS_INVALID_PARAMS);
+	hdev = hci_dev_get(hdev->id);
 
-	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA,
-						MGMT_STATUS_INVALID_PARAMS);
+		return;
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
+	del_timer(&hdev->disco_le_timer);
 
-	err = hci_add_remote_oob_data(hdev, &cp->bdaddr, cp->hash,
-								cp->randomizer);
-	if (err < 0)
-		err = cmd_status(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA,
-							MGMT_STATUS_FAILED);
-	else
-		err = cmd_complete(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA, NULL,
-									0);
+	if (hdev->disco_state != SCAN_IDLE) {
+		struct hci_cp_le_set_scan_enable le_cp = {0, 0};
 
-	hci_dev_unlock(hdev);
-	hci_dev_put(hdev);
+		if (test_bit(HCI_UP, &hdev->flags)) {
+			if (hdev->disco_state == SCAN_LE)
+				hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE,
+							sizeof(le_cp), &le_cp);
+			else
+				hci_send_cmd(hdev, HCI_OP_INQUIRY_CANCEL, 0,
+									 NULL);
+		}
+		hdev->disco_state = SCAN_IDLE;
+	}
 
-	return err;
+	mgmt_event(MGMT_EV_DISCOVERING, hdev->id, &cp, sizeof(cp), NULL);
+
+	cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, hdev->id);
+	if (cmd)
+		mgmt_pending_remove(cmd);
+
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
 }
 
-static int remove_remote_oob_data(struct sock *sk, u16 index,
-						unsigned char *data, u16 len)
+void mgmt_disco_le_timeout(unsigned long data)
 {
-	struct hci_dev *hdev;
-	struct mgmt_cp_remove_remote_oob_data *cp = (void *) data;
-	int err;
+	struct hci_dev *hdev = (void *)data;
+	struct hci_cp_le_set_scan_enable le_cp = {0, 0};
 
-	BT_DBG("hci%u ", index);
+	BT_DBG("hci%d", hdev->id);
 
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
-						MGMT_STATUS_INVALID_PARAMS);
+	hdev = hci_dev_get(hdev->id);
 
-	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
-						MGMT_STATUS_INVALID_PARAMS);
-
-	hci_dev_lock(hdev);
+		return;
 
-	err = hci_remove_remote_oob_data(hdev, &cp->bdaddr);
-	if (err < 0)
-		err = cmd_status(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
-						MGMT_STATUS_INVALID_PARAMS);
-	else
-		err = cmd_complete(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
-								NULL, 0);
+	hci_dev_lock_bh(hdev);
+
+	if (test_bit(HCI_UP, &hdev->flags)) {
+		if (hdev->disco_state == SCAN_LE)
+			hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE,
+					sizeof(le_cp), &le_cp);
+
+	/* re-start BR scan */
+		if (hdev->disco_state != SCAN_IDLE) {
+			struct hci_cp_inquiry cp = {{0x33, 0x8b, 0x9e}, 4, 0};
+			hdev->disco_int_phase *= 2;
+			hdev->disco_int_count = 0;
+			cp.num_rsp = (u8) hdev->disco_int_phase;
+			hci_send_cmd(hdev, HCI_OP_INQUIRY, sizeof(cp), &cp);
+			hdev->disco_state = SCAN_BR;
+		}
+	}
 
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
-
-	return err;
 }
 
-static int start_discovery(struct sock *sk, u16 index,
-						unsigned char *data, u16 len)
+static int start_discovery(struct sock *sk, u16 index)
 {
-	struct mgmt_cp_start_discovery *cp = (void *) data;
-	struct pending_cmd *cmd;
+	struct hci_cp_inquiry cp = {{0x33, 0x8b, 0x9e}, 8, 0};
 	struct hci_dev *hdev;
+	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("hci%u", index);
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_START_DISCOVERY,
-						MGMT_STATUS_INVALID_PARAMS);
+	BT_DBG("");
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_START_DISCOVERY,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_START_DISCOVERY, ENODEV);
 
-	hci_dev_lock(hdev);
+	BT_DBG("disco_state: %d", hdev->disco_state);
+	hci_dev_lock_bh(hdev);
 
-	if (!test_bit(HCI_UP, &hdev->flags)) {
-		err = cmd_status(sk, index, MGMT_OP_START_DISCOVERY,
-						MGMT_STATUS_NOT_POWERED);
+	if (hdev->disco_state && timer_pending(&hdev->disco_timer)) {
+		err = -EBUSY;
 		goto failed;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_START_DISCOVERY, hdev, NULL, 0);
+	cmd = mgmt_pending_add(sk, MGMT_OP_START_DISCOVERY, index, NULL, 0);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
 	}
 
-	err = hci_do_inquiry(hdev, INQUIRY_LEN_BREDR);
-	if (err < 0)
+	/* If LE Capable, we will alternate between BR/EDR and LE */
+	if (lmp_le_capable(hdev)) {
+		struct hci_cp_le_set_scan_parameters le_cp;
+
+		/* Shorten BR scan params */
+		cp.num_rsp = 1;
+		cp.length /= 2;
+
+		/* Setup LE scan params */
+		memset(&le_cp, 0, sizeof(le_cp));
+		le_cp.type = 0x01;		/* Active scanning */
+		/* The recommended value for scan interval and window is
+		 * 11.25 msec. It is calculated by: time = n * 0.625 msec */
+		le_cp.interval = cpu_to_le16(0x0012);
+		le_cp.window = cpu_to_le16(0x0012);
+		le_cp.own_bdaddr_type = 0;	/* Public address */
+		le_cp.filter = 0;		/* Accept all adv packets */
+
+		hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_PARAMETERS,
+						sizeof(le_cp), &le_cp);
+	}
+
+	err = hci_send_cmd(hdev, HCI_OP_INQUIRY, sizeof(cp), &cp);
+
+	if (err < 0) {
 		mgmt_pending_remove(cmd);
+		hdev->disco_state = SCAN_IDLE;
+	} else if (lmp_le_capable(hdev)) {
+		cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, index);
+		if (!cmd)
+			mgmt_pending_add(sk, MGMT_OP_STOP_DISCOVERY, index,
+								NULL, 0);
+		hdev->disco_int_phase = 1;
+		hdev->disco_int_count = 0;
+		hdev->disco_state = SCAN_BR;
+		del_timer(&hdev->disco_le_timer);
+		del_timer(&hdev->disco_timer);
+		mod_timer(&hdev->disco_timer,
+				jiffies + msecs_to_jiffies(20000));
+	} else
+		hdev->disco_state = SCAN_BR;
 
 failed:
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
+	if (err < 0)
+		return cmd_status(sk, index, MGMT_OP_START_DISCOVERY, -err);
+
 	return err;
 }
 
 static int stop_discovery(struct sock *sk, u16 index)
 {
+	struct hci_cp_le_set_scan_enable le_cp = {0, 0};
+	struct mgmt_mode mode_cp = {0};
+	struct hci_dev *hdev;
+	struct pending_cmd *cmd = NULL;
+	int err = -EPERM;
+	u8 state;
+
+	BT_DBG("");
+
+	hdev = hci_dev_get(index);
+	if (!hdev)
+		return cmd_status(sk, index, MGMT_OP_STOP_DISCOVERY, ENODEV);
+
+	BT_DBG("disco_state: %d", hdev->disco_state);
+
+	hci_dev_lock_bh(hdev);
+
+	state = hdev->disco_state;
+	hdev->disco_state = SCAN_IDLE;
+	del_timer(&hdev->disco_le_timer);
+	del_timer(&hdev->disco_timer);
+
+	if (state == SCAN_LE) {
+		err = hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE,
+							sizeof(le_cp), &le_cp);
+		if (err >= 0) {
+			mgmt_pending_foreach(MGMT_OP_STOP_DISCOVERY, index,
+						discovery_terminated, NULL);
+
+			err = cmd_complete(sk, index, MGMT_OP_STOP_DISCOVERY,
+								NULL, 0);
+		}
+	} else if (state == SCAN_BR)
+		err = hci_send_cmd(hdev, HCI_OP_INQUIRY_CANCEL, 0, NULL);
+
+	cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, index);
+	if (err < 0 && cmd)
+		mgmt_pending_remove(cmd);
+
+	mgmt_event(MGMT_EV_DISCOVERING, index, &mode_cp, sizeof(mode_cp), NULL);
+
+	hci_dev_unlock_bh(hdev);
+	hci_dev_put(hdev);
+
+	if (err < 0)
+		return cmd_status(sk, index, MGMT_OP_STOP_DISCOVERY, -err);
+	else
+		return err;
+}
+
+static int read_local_oob_data(struct sock *sk, u16 index)
+{
 	struct hci_dev *hdev;
 	struct pending_cmd *cmd;
 	int err;
@@ -1957,148 +2491,108 @@ static int stop_discovery(struct sock *sk, u16 index)
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_STOP_DISCOVERY,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
+									ENODEV);
+
+	hci_dev_lock_bh(hdev);
+
+	if (!test_bit(HCI_UP, &hdev->flags)) {
+		err = cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
+								ENETDOWN);
+		goto unlock;
+	}
+
+	if (!(hdev->features[6] & LMP_SIMPLE_PAIR)) {
+		err = cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
+								EOPNOTSUPP);
+		goto unlock;
+	}
 
-	hci_dev_lock(hdev);
+	if (mgmt_pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, index)) {
+		err = cmd_status(sk, index, MGMT_OP_READ_LOCAL_OOB_DATA, EBUSY);
+		goto unlock;
+	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_STOP_DISCOVERY, hdev, NULL, 0);
+	cmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_DATA, index, NULL, 0);
 	if (!cmd) {
 		err = -ENOMEM;
-		goto failed;
+		goto unlock;
 	}
 
-	err = hci_cancel_inquiry(hdev);
+	err = hci_send_cmd(hdev, HCI_OP_READ_LOCAL_OOB_DATA, 0, NULL);
 	if (err < 0)
 		mgmt_pending_remove(cmd);
 
-failed:
-	hci_dev_unlock(hdev);
+unlock:
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return err;
 }
 
-static int block_device(struct sock *sk, u16 index, unsigned char *data,
-								u16 len)
+static int add_remote_oob_data(struct sock *sk, u16 index, unsigned char *data,
+									u16 len)
 {
 	struct hci_dev *hdev;
-	struct mgmt_cp_block_device *cp = (void *) data;
+	struct mgmt_cp_add_remote_oob_data *cp = (void *) data;
 	int err;
 
-	BT_DBG("hci%u", index);
+	BT_DBG("hci%u ", index);
 
 	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_BLOCK_DEVICE,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA,
+									EINVAL);
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_BLOCK_DEVICE,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA,
+									ENODEV);
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
 
-	err = hci_blacklist_add(hdev, &cp->bdaddr);
+	err = hci_add_remote_oob_data(hdev, &cp->bdaddr, cp->hash,
+								cp->randomizer);
 	if (err < 0)
-		err = cmd_status(sk, index, MGMT_OP_BLOCK_DEVICE,
-							MGMT_STATUS_FAILED);
+		err = cmd_status(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA, -err);
 	else
-		err = cmd_complete(sk, index, MGMT_OP_BLOCK_DEVICE,
-							NULL, 0);
+		err = cmd_complete(sk, index, MGMT_OP_ADD_REMOTE_OOB_DATA, NULL,
+									0);
 
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return err;
 }
 
-static int unblock_device(struct sock *sk, u16 index, unsigned char *data,
-								u16 len)
+static int remove_remote_oob_data(struct sock *sk, u16 index,
+						unsigned char *data, u16 len)
 {
 	struct hci_dev *hdev;
-	struct mgmt_cp_unblock_device *cp = (void *) data;
+	struct mgmt_cp_remove_remote_oob_data *cp = (void *) data;
 	int err;
 
-	BT_DBG("hci%u", index);
+	BT_DBG("hci%u ", index);
 
 	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_UNBLOCK_DEVICE,
-						MGMT_STATUS_INVALID_PARAMS);
+		return cmd_status(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
+									EINVAL);
 
 	hdev = hci_dev_get(index);
 	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_UNBLOCK_DEVICE,
-						MGMT_STATUS_INVALID_PARAMS);
-
-	hci_dev_lock(hdev);
+		return cmd_status(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
+									ENODEV);
 
-	err = hci_blacklist_del(hdev, &cp->bdaddr);
+	hci_dev_lock_bh(hdev);
 
+	err = hci_remove_remote_oob_data(hdev, &cp->bdaddr);
 	if (err < 0)
-		err = cmd_status(sk, index, MGMT_OP_UNBLOCK_DEVICE,
-						MGMT_STATUS_INVALID_PARAMS);
+		err = cmd_status(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
+									-err);
 	else
-		err = cmd_complete(sk, index, MGMT_OP_UNBLOCK_DEVICE,
+		err = cmd_complete(sk, index, MGMT_OP_REMOVE_REMOTE_OOB_DATA,
 								NULL, 0);
 
-	hci_dev_unlock(hdev);
-	hci_dev_put(hdev);
-
-	return err;
-}
-
-static int set_fast_connectable(struct sock *sk, u16 index,
-					unsigned char *data, u16 len)
-{
-	struct hci_dev *hdev;
-	struct mgmt_mode *cp = (void *) data;
-	struct hci_cp_write_page_scan_activity acp;
-	u8 type;
-	int err;
-
-	BT_DBG("hci%u", index);
-
-	if (len != sizeof(*cp))
-		return cmd_status(sk, index, MGMT_OP_SET_FAST_CONNECTABLE,
-						MGMT_STATUS_INVALID_PARAMS);
-
-	hdev = hci_dev_get(index);
-	if (!hdev)
-		return cmd_status(sk, index, MGMT_OP_SET_FAST_CONNECTABLE,
-						MGMT_STATUS_INVALID_PARAMS);
-
-	hci_dev_lock(hdev);
-
-	if (cp->val) {
-		type = PAGE_SCAN_TYPE_INTERLACED;
-		acp.interval = 0x0024;	/* 22.5 msec page scan interval */
-	} else {
-		type = PAGE_SCAN_TYPE_STANDARD;	/* default */
-		acp.interval = 0x0800;	/* default 1.28 sec page scan */
-	}
-
-	acp.window = 0x0012;	/* default 11.25 msec page scan window */
-
-	err = hci_send_cmd(hdev, HCI_OP_WRITE_PAGE_SCAN_ACTIVITY,
-						sizeof(acp), &acp);
-	if (err < 0) {
-		err = cmd_status(sk, index, MGMT_OP_SET_FAST_CONNECTABLE,
-							MGMT_STATUS_FAILED);
-		goto done;
-	}
-
-	err = hci_send_cmd(hdev, HCI_OP_WRITE_PAGE_SCAN_TYPE, 1, &type);
-	if (err < 0) {
-		err = cmd_status(sk, index, MGMT_OP_SET_FAST_CONNECTABLE,
-							MGMT_STATUS_FAILED);
-		goto done;
-	}
-
-	err = cmd_complete(sk, index, MGMT_OP_SET_FAST_CONNECTABLE,
-							NULL, 0);
-done:
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 
 	return err;
@@ -2135,6 +2629,7 @@ int mgmt_control(struct sock *sk, struct msghdr *msg, size_t msglen)
 		goto done;
 	}
 
+	BT_DBG("got opcode %x", opcode);
 	switch (opcode) {
 	case MGMT_OP_READ_VERSION:
 		err = read_version(sk);
@@ -2151,13 +2646,13 @@ int mgmt_control(struct sock *sk, struct msghdr *msg, size_t msglen)
 	case MGMT_OP_SET_DISCOVERABLE:
 		err = set_discoverable(sk, index, buf + sizeof(*hdr), len);
 		break;
+	case MGMT_OP_SET_LIMIT_DISCOVERABLE:
+		err = set_limited_discoverable(sk, index, buf + sizeof(*hdr),
+									len);
+		break;
 	case MGMT_OP_SET_CONNECTABLE:
 		err = set_connectable(sk, index, buf + sizeof(*hdr), len);
 		break;
-	case MGMT_OP_SET_FAST_CONNECTABLE:
-		err = set_fast_connectable(sk, index, buf + sizeof(*hdr),
-								len);
-		break;
 	case MGMT_OP_SET_PAIRABLE:
 		err = set_pairable(sk, index, buf + sizeof(*hdr), len);
 		break;
@@ -2170,11 +2665,14 @@ int mgmt_control(struct sock *sk, struct msghdr *msg, size_t msglen)
 	case MGMT_OP_SET_DEV_CLASS:
 		err = set_dev_class(sk, index, buf + sizeof(*hdr), len);
 		break;
-	case MGMT_OP_LOAD_LINK_KEYS:
-		err = load_link_keys(sk, index, buf + sizeof(*hdr), len);
+	case MGMT_OP_SET_SERVICE_CACHE:
+		err = set_service_cache(sk, index, buf + sizeof(*hdr), len);
 		break;
-	case MGMT_OP_REMOVE_KEYS:
-		err = remove_keys(sk, index, buf + sizeof(*hdr), len);
+	case MGMT_OP_LOAD_KEYS:
+		err = load_keys(sk, index, buf + sizeof(*hdr), len);
+		break;
+	case MGMT_OP_REMOVE_KEY:
+		err = remove_key(sk, index, buf + sizeof(*hdr), len);
 		break;
 	case MGMT_OP_DISCONNECT:
 		err = disconnect(sk, index, buf + sizeof(*hdr), len);
@@ -2195,22 +2693,35 @@ int mgmt_control(struct sock *sk, struct msghdr *msg, size_t msglen)
 		err = pair_device(sk, index, buf + sizeof(*hdr), len);
 		break;
 	case MGMT_OP_USER_CONFIRM_REPLY:
-		err = user_confirm_reply(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_USER_CONFIRM_NEG_REPLY:
-		err = user_confirm_neg_reply(sk, index, buf + sizeof(*hdr),
-									len);
-		break;
 	case MGMT_OP_USER_PASSKEY_REPLY:
-		err = user_passkey_reply(sk, index, buf + sizeof(*hdr), len);
-		break;
-	case MGMT_OP_USER_PASSKEY_NEG_REPLY:
-		err = user_passkey_neg_reply(sk, index, buf + sizeof(*hdr),
-									len);
+	case MGMT_OP_USER_CONFIRM_NEG_REPLY:
+		err = user_confirm_reply(sk, index, buf + sizeof(*hdr),
+								len, opcode);
 		break;
 	case MGMT_OP_SET_LOCAL_NAME:
 		err = set_local_name(sk, index, buf + sizeof(*hdr), len);
 		break;
+	case MGMT_OP_START_DISCOVERY:
+		err = start_discovery(sk, index);
+		break;
+	case MGMT_OP_STOP_DISCOVERY:
+		err = stop_discovery(sk, index);
+		break;
+	case MGMT_OP_RESOLVE_NAME:
+		err = resolve_name(sk, index, buf + sizeof(*hdr), len);
+		break;
+	case MGMT_OP_CANCEL_RESOLVE_NAME:
+		err = cancel_resolve_name(sk, index, buf + sizeof(*hdr), len);
+		break;
+	case MGMT_OP_SET_CONNECTION_PARAMS:
+		err = set_connection_params(sk, index, buf + sizeof(*hdr), len);
+		break;
+	case MGMT_OP_SET_RSSI_REPORTER:
+		err = set_rssi_reporter(sk, index, buf + sizeof(*hdr), len);
+		break;
+	case MGMT_OP_UNSET_RSSI_REPORTER:
+		err = unset_rssi_reporter(sk, index, buf + sizeof(*hdr), len);
+		break;
 	case MGMT_OP_READ_LOCAL_OOB_DATA:
 		err = read_local_oob_data(sk, index);
 		break;
@@ -2221,22 +2732,32 @@ int mgmt_control(struct sock *sk, struct msghdr *msg, size_t msglen)
 		err = remove_remote_oob_data(sk, index, buf + sizeof(*hdr),
 									len);
 		break;
-	case MGMT_OP_START_DISCOVERY:
-		err = start_discovery(sk, index, buf + sizeof(*hdr), len);
+	case MGMT_OP_ENCRYPT_LINK:
+		err = encrypt_link(sk, index, buf + sizeof(*hdr), len);
 		break;
-	case MGMT_OP_STOP_DISCOVERY:
-		err = stop_discovery(sk, index);
+	case MGMT_OP_LE_ADD_DEV_WHITE_LIST:
+		err = le_add_dev_white_list(sk, index, buf + sizeof(*hdr),
+									len);
+		break;
+	case MGMT_OP_LE_REMOVE_DEV_WHITE_LIST:
+		err = le_remove_dev_white_list(sk, index, buf + sizeof(*hdr),
+									len);
+		break;
+	case MGMT_OP_LE_CLEAR_WHITE_LIST:
+		err = le_clear_white_list(sk, index);
+		break;
+	case MGMT_OP_LE_CREATE_CONN_WHITE_LIST:
+		err = le_create_conn_white_list(sk, index);
 		break;
-	case MGMT_OP_BLOCK_DEVICE:
-		err = block_device(sk, index, buf + sizeof(*hdr), len);
+	case MGMT_OP_LE_CANCEL_CREATE_CONN_WHITE_LIST:
+		err = le_cancel_create_conn_white_list(sk, index);
 		break;
-	case MGMT_OP_UNBLOCK_DEVICE:
-		err = unblock_device(sk, index, buf + sizeof(*hdr), len);
+	case MGMT_OP_LE_CANCEL_CREATE_CONN:
+		err = le_cancel_create_conn(sk, index, buf + sizeof(*hdr), len);
 		break;
 	default:
 		BT_DBG("Unknown op %u", opcode);
-		err = cmd_status(sk, index, opcode,
-						MGMT_STATUS_UNKNOWN_COMMAND);
+		err = cmd_status(sk, index, opcode, 0x01);
 		break;
 	}
 
@@ -2258,31 +2779,37 @@ static void cmd_status_rsp(struct pending_cmd *cmd, void *data)
 	mgmt_pending_remove(cmd);
 }
 
-int mgmt_index_added(struct hci_dev *hdev)
+int mgmt_index_added(u16 index)
 {
-	return mgmt_event(MGMT_EV_INDEX_ADDED, hdev, NULL, 0, NULL);
+	BT_DBG("%d", index);
+	return mgmt_event(MGMT_EV_INDEX_ADDED, index, NULL, 0, NULL);
 }
 
-int mgmt_index_removed(struct hci_dev *hdev)
+int mgmt_index_removed(u16 index)
 {
 	u8 status = ENODEV;
 
-	mgmt_pending_foreach(0, hdev, cmd_status_rsp, &status);
+	BT_DBG("%d", index);
 
-	return mgmt_event(MGMT_EV_INDEX_REMOVED, hdev, NULL, 0, NULL);
+	mgmt_pending_foreach(0, index, cmd_status_rsp, &status);
+
+	return mgmt_event(MGMT_EV_INDEX_REMOVED, index, NULL, 0, NULL);
 }
 
 struct cmd_lookup {
 	u8 val;
 	struct sock *sk;
-	struct hci_dev *hdev;
 };
 
-static void settings_rsp(struct pending_cmd *cmd, void *data)
+static void mode_rsp(struct pending_cmd *cmd, void *data)
 {
+	struct mgmt_mode *cp = cmd->param;
 	struct cmd_lookup *match = data;
 
-	send_settings_rsp(cmd->sk, cmd->opcode, match->hdev);
+	if (cp->val != match->val)
+		return;
+
+	send_mode_rsp(cmd->sk, cmd->opcode, cmd->index, cp->val);
 
 	list_del(&cmd->list);
 
@@ -2294,23 +2821,24 @@ static void settings_rsp(struct pending_cmd *cmd, void *data)
 	mgmt_pending_free(cmd);
 }
 
-int mgmt_powered(struct hci_dev *hdev, u8 powered)
+int mgmt_powered(u16 index, u8 powered)
 {
-	struct cmd_lookup match = { powered, NULL, hdev };
-	__le32 ev;
+	struct mgmt_mode ev;
+	struct cmd_lookup match = { powered, NULL };
 	int ret;
 
-	mgmt_pending_foreach(MGMT_OP_SET_POWERED, hdev, settings_rsp, &match);
+	BT_DBG("hci%u %d", index, powered);
+
+	mgmt_pending_foreach(MGMT_OP_SET_POWERED, index, mode_rsp, &match);
 
 	if (!powered) {
 		u8 status = ENETDOWN;
-		mgmt_pending_foreach(0, hdev, cmd_status_rsp, &status);
+		mgmt_pending_foreach(0, index, cmd_status_rsp, &status);
 	}
 
-	ev = cpu_to_le32(get_current_settings(hdev));
+	ev.val = powered;
 
-	ret = mgmt_event(MGMT_EV_NEW_SETTINGS, hdev, &ev, sizeof(ev),
-								match.sk);
+	ret = mgmt_event(MGMT_EV_POWERED, index, &ev, sizeof(ev), match.sk);
 
 	if (match.sk)
 		sock_put(match.sk);
@@ -2318,36 +2846,36 @@ int mgmt_powered(struct hci_dev *hdev, u8 powered)
 	return ret;
 }
 
-int mgmt_discoverable(struct hci_dev *hdev, u8 discoverable)
+int mgmt_discoverable(u16 index, u8 discoverable)
 {
-	struct cmd_lookup match = { discoverable, NULL, hdev };
-	__le32 ev;
+	struct mgmt_mode ev;
+	struct cmd_lookup match = { discoverable, NULL };
 	int ret;
 
-	mgmt_pending_foreach(MGMT_OP_SET_DISCOVERABLE, hdev, settings_rsp, &match);
+	mgmt_pending_foreach(MGMT_OP_SET_DISCOVERABLE, index, mode_rsp, &match);
 
-	ev = cpu_to_le32(get_current_settings(hdev));
+	ev.val = discoverable;
 
-	ret = mgmt_event(MGMT_EV_NEW_SETTINGS, hdev, &ev, sizeof(ev),
+	ret = mgmt_event(MGMT_EV_DISCOVERABLE, index, &ev, sizeof(ev),
 								match.sk);
+
 	if (match.sk)
 		sock_put(match.sk);
 
 	return ret;
 }
 
-int mgmt_connectable(struct hci_dev *hdev, u8 connectable)
+int mgmt_connectable(u16 index, u8 connectable)
 {
-	__le32 ev;
-	struct cmd_lookup match = { connectable, NULL, hdev };
+	struct mgmt_mode ev;
+	struct cmd_lookup match = { connectable, NULL };
 	int ret;
 
-	mgmt_pending_foreach(MGMT_OP_SET_CONNECTABLE, hdev, settings_rsp,
-								&match);
+	mgmt_pending_foreach(MGMT_OP_SET_CONNECTABLE, index, mode_rsp, &match);
 
-	ev = cpu_to_le32(get_current_settings(hdev));
+	ev.val = connectable;
 
-	ret = mgmt_event(MGMT_EV_NEW_SETTINGS, hdev, &ev, sizeof(ev), match.sk);
+	ret = mgmt_event(MGMT_EV_CONNECTABLE, index, &ev, sizeof(ev), match.sk);
 
 	if (match.sk)
 		sock_put(match.sk);
@@ -2355,46 +2883,71 @@ int mgmt_connectable(struct hci_dev *hdev, u8 connectable)
 	return ret;
 }
 
-int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status)
+int mgmt_new_key(u16 index, struct link_key *key, u8 bonded)
 {
-	u8 mgmt_err = mgmt_status(status);
+	struct mgmt_ev_new_key *ev;
+	int err, total;
+
+	total = sizeof(struct mgmt_ev_new_key) + key->dlen;
+	ev = kzalloc(total, GFP_ATOMIC);
+	if (!ev)
+		return -ENOMEM;
 
-	if (scan & SCAN_PAGE)
-		mgmt_pending_foreach(MGMT_OP_SET_CONNECTABLE, hdev,
-						cmd_status_rsp, &mgmt_err);
+	bacpy(&ev->key.bdaddr, &key->bdaddr);
+	ev->key.addr_type = key->addr_type;
+	ev->key.key_type = key->key_type;
+	memcpy(ev->key.val, key->val, 16);
+	ev->key.pin_len = key->pin_len;
+	ev->key.auth = key->auth;
+	ev->store_hint = bonded;
+	ev->key.dlen = key->dlen;
 
-	if (scan & SCAN_INQUIRY)
-		mgmt_pending_foreach(MGMT_OP_SET_DISCOVERABLE, hdev,
-						cmd_status_rsp, &mgmt_err);
+	memcpy(ev->key.data, key->data, key->dlen);
 
-	return 0;
+	err = mgmt_event(MGMT_EV_NEW_KEY, index, ev, total, NULL);
+
+	kfree(ev);
+
+	return err;
 }
 
-int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
-								u8 persistent)
+int mgmt_connected(u16 index, bdaddr_t *bdaddr, u8 le)
 {
-	struct mgmt_ev_new_link_key ev;
+	struct mgmt_ev_connected ev;
+	struct pending_cmd *cmd;
+	struct hci_dev *hdev;
 
-	memset(&ev, 0, sizeof(ev));
+	BT_DBG("hci%u", index);
+
+	hdev = hci_dev_get(index);
+
+	if (!hdev)
+		return -ENODEV;
+
+	bacpy(&ev.bdaddr, bdaddr);
+	ev.le = le;
 
-	ev.store_hint = persistent;
-	bacpy(&ev.key.bdaddr, &key->bdaddr);
-	ev.key.type = key->type;
-	memcpy(ev.key.val, key->val, 16);
-	ev.key.pin_len = key->pin_len;
+	cmd = mgmt_pending_find(MGMT_OP_LE_CREATE_CONN_WHITE_LIST, index);
+	if (cmd) {
+		BT_ERR("mgmt_connected remove mgmt pending white_list");
+		mgmt_pending_remove(cmd);
+	}
 
-	return mgmt_event(MGMT_EV_NEW_LINK_KEY, hdev, &ev, sizeof(ev), NULL);
+	return mgmt_event(MGMT_EV_CONNECTED, index, &ev, sizeof(ev), NULL);
 }
 
-int mgmt_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-								u8 addr_type)
+int mgmt_le_conn_params(u16 index, bdaddr_t *bdaddr, u16 interval,
+						u16 latency, u16 timeout)
 {
-	struct mgmt_addr_info ev;
+	struct mgmt_ev_le_conn_params ev;
 
 	bacpy(&ev.bdaddr, bdaddr);
-	ev.type = link_to_mgmt(link_type, addr_type);
+	ev.interval = interval;
+	ev.latency = latency;
+	ev.timeout = timeout;
 
-	return mgmt_event(MGMT_EV_CONNECTED, hdev, &ev, sizeof(ev), NULL);
+	return mgmt_event(MGMT_EV_LE_CONN_PARAMS, index, &ev, sizeof(ev),
+									NULL);
 }
 
 static void disconnect_rsp(struct pending_cmd *cmd, void *data)
@@ -2404,7 +2957,6 @@ static void disconnect_rsp(struct pending_cmd *cmd, void *data)
 	struct mgmt_rp_disconnect rp;
 
 	bacpy(&rp.bdaddr, &cp->bdaddr);
-	rp.status = 0;
 
 	cmd_complete(cmd->sk, cmd->index, MGMT_OP_DISCONNECT, &rp, sizeof(rp));
 
@@ -2414,110 +2966,78 @@ static void disconnect_rsp(struct pending_cmd *cmd, void *data)
 	mgmt_pending_remove(cmd);
 }
 
-static void remove_keys_rsp(struct pending_cmd *cmd, void *data)
-{
-	u8 *status = data;
-	struct mgmt_cp_remove_keys *cp = cmd->param;
-	struct mgmt_rp_remove_keys rp;
-
-	memset(&rp, 0, sizeof(rp));
-	bacpy(&rp.bdaddr, &cp->bdaddr);
-	if (status != NULL)
-		rp.status = *status;
-
-	cmd_complete(cmd->sk, cmd->index, MGMT_OP_REMOVE_KEYS, &rp,
-								sizeof(rp));
-
-	mgmt_pending_remove(cmd);
-}
-
-int mgmt_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-								u8 addr_type)
+int mgmt_disconnected(u16 index, bdaddr_t *bdaddr, u8 reason)
 {
-	struct mgmt_addr_info ev;
+	struct mgmt_ev_disconnected ev;
 	struct sock *sk = NULL;
 	int err;
 
-	mgmt_pending_foreach(MGMT_OP_DISCONNECT, hdev, disconnect_rsp, &sk);
-
 	bacpy(&ev.bdaddr, bdaddr);
-	ev.type = link_to_mgmt(link_type, addr_type);
+	ev.reason = reason;
 
-	err = mgmt_event(MGMT_EV_DISCONNECTED, hdev, &ev, sizeof(ev), sk);
+	err = mgmt_event(MGMT_EV_DISCONNECTED, index, &ev, sizeof(ev), sk);
 
 	if (sk)
 		sock_put(sk);
 
-	mgmt_pending_foreach(MGMT_OP_REMOVE_KEYS, hdev, remove_keys_rsp, NULL);
+	mgmt_pending_foreach(MGMT_OP_DISCONNECT, index, disconnect_rsp, &sk);
 
 	return err;
 }
 
-int mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 status)
+int mgmt_disconnect_failed(u16 index)
 {
 	struct pending_cmd *cmd;
-	u8 mgmt_err = mgmt_status(status);
 	int err;
 
-	cmd = mgmt_pending_find(MGMT_OP_DISCONNECT, hdev);
+	cmd = mgmt_pending_find(MGMT_OP_DISCONNECT, index);
 	if (!cmd)
 		return -ENOENT;
 
-	if (bdaddr) {
-		struct mgmt_rp_disconnect rp;
-
-		bacpy(&rp.bdaddr, bdaddr);
-		rp.status = status;
-
-		err = cmd_complete(cmd->sk, cmd->index, MGMT_OP_DISCONNECT,
-							&rp, sizeof(rp));
-	} else
-		err = cmd_status(cmd->sk, hdev->id, MGMT_OP_DISCONNECT,
-								mgmt_err);
+	err = cmd_status(cmd->sk, index, MGMT_OP_DISCONNECT, EIO);
 
 	mgmt_pending_remove(cmd);
 
 	return err;
 }
 
-int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-						u8 addr_type, u8 status)
+int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 status)
 {
 	struct mgmt_ev_connect_failed ev;
 
-	bacpy(&ev.addr.bdaddr, bdaddr);
-	ev.addr.type = link_to_mgmt(link_type, addr_type);
-	ev.status = mgmt_status(status);
+	bacpy(&ev.bdaddr, bdaddr);
+	ev.status = status;
 
-	return mgmt_event(MGMT_EV_CONNECT_FAILED, hdev, &ev, sizeof(ev), NULL);
+	return mgmt_event(MGMT_EV_CONNECT_FAILED, index, &ev, sizeof(ev), NULL);
 }
 
-int mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure)
+int mgmt_pin_code_request(u16 index, bdaddr_t *bdaddr)
 {
 	struct mgmt_ev_pin_code_request ev;
 
+	BT_DBG("hci%u", index);
+
 	bacpy(&ev.bdaddr, bdaddr);
-	ev.secure = secure;
+	ev.secure = 0;
 
-	return mgmt_event(MGMT_EV_PIN_CODE_REQUEST, hdev, &ev, sizeof(ev),
+	return mgmt_event(MGMT_EV_PIN_CODE_REQUEST, index, &ev, sizeof(ev),
 									NULL);
 }
 
-int mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								u8 status)
+int mgmt_pin_code_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status)
 {
 	struct pending_cmd *cmd;
 	struct mgmt_rp_pin_code_reply rp;
 	int err;
 
-	cmd = mgmt_pending_find(MGMT_OP_PIN_CODE_REPLY, hdev);
+	cmd = mgmt_pending_find(MGMT_OP_PIN_CODE_REPLY, index);
 	if (!cmd)
 		return -ENOENT;
 
 	bacpy(&rp.bdaddr, bdaddr);
-	rp.status = mgmt_status(status);
+	rp.status = status;
 
-	err = cmd_complete(cmd->sk, hdev->id, MGMT_OP_PIN_CODE_REPLY, &rp,
+	err = cmd_complete(cmd->sk, index, MGMT_OP_PIN_CODE_REPLY, &rp,
 								sizeof(rp));
 
 	mgmt_pending_remove(cmd);
@@ -2525,21 +3045,20 @@ int mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 	return err;
 }
 
-int mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								u8 status)
+int mgmt_pin_code_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status)
 {
 	struct pending_cmd *cmd;
 	struct mgmt_rp_pin_code_reply rp;
 	int err;
 
-	cmd = mgmt_pending_find(MGMT_OP_PIN_CODE_NEG_REPLY, hdev);
+	cmd = mgmt_pending_find(MGMT_OP_PIN_CODE_NEG_REPLY, index);
 	if (!cmd)
 		return -ENOENT;
 
 	bacpy(&rp.bdaddr, bdaddr);
-	rp.status = mgmt_status(status);
+	rp.status = status;
 
-	err = cmd_complete(cmd->sk, hdev->id, MGMT_OP_PIN_CODE_NEG_REPLY, &rp,
+	err = cmd_complete(cmd->sk, index, MGMT_OP_PIN_CODE_NEG_REPLY, &rp,
 								sizeof(rp));
 
 	mgmt_pending_remove(cmd);
@@ -2547,119 +3066,149 @@ int mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 	return err;
 }
 
-int mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
-						__le32 value, u8 confirm_hint)
+int mgmt_user_confirm_request(u16 index, u8 event,
+					bdaddr_t *bdaddr, __le32 value)
 {
 	struct mgmt_ev_user_confirm_request ev;
+	struct hci_conn *conn = NULL;
+	struct hci_dev *hdev;
+	u8 loc_cap, rem_cap, loc_mitm, rem_mitm;
 
-	BT_DBG("%s", hdev->name);
+	BT_DBG("hci%u", index);
+
+	hdev = hci_dev_get(index);
+
+	if (!hdev)
+		return -ENODEV;
+
+	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, bdaddr);
+
+	ev.auto_confirm = 0;
+
+	if (!conn || event != HCI_EV_USER_CONFIRM_REQUEST)
+		goto no_auto_confirm;
+
+	loc_cap = (conn->io_capability == 0x04) ? 0x01 : conn->io_capability;
+	rem_cap = conn->remote_cap;
+	loc_mitm = conn->auth_type & 0x01;
+	rem_mitm = conn->remote_auth & 0x01;
+
+	if ((conn->auth_type & HCI_AT_DEDICATED_BONDING) &&
+			conn->auth_initiator && rem_cap == 0x03)
+		ev.auto_confirm = 1;
+	else if (loc_cap == 0x01 && (rem_cap == 0x00 || rem_cap == 0x03)) {
+		if (!loc_mitm && !rem_mitm)
+			value = 0;
+		goto no_auto_confirm;
+	}
+
+	/* Show bonding dialog if neither side requires no bonding */
+	if ((conn->auth_type > 0x01) && (conn->remote_auth > 0x01)) {
+		if (!loc_mitm && !rem_mitm)
+			value = 0;
+		goto no_auto_confirm;
+	}
+
+	if ((!loc_mitm || rem_cap == 0x03) && (!rem_mitm || loc_cap == 0x03))
+		ev.auto_confirm = 1;
 
+no_auto_confirm:
 	bacpy(&ev.bdaddr, bdaddr);
-	ev.confirm_hint = confirm_hint;
+	ev.event = event;
 	put_unaligned_le32(value, &ev.value);
 
-	return mgmt_event(MGMT_EV_USER_CONFIRM_REQUEST, hdev, &ev, sizeof(ev),
+	hci_dev_put(hdev);
+
+	return mgmt_event(MGMT_EV_USER_CONFIRM_REQUEST, index, &ev, sizeof(ev),
 									NULL);
 }
 
-int mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr)
+int mgmt_user_passkey_request(u16 index, bdaddr_t *bdaddr)
 {
 	struct mgmt_ev_user_passkey_request ev;
 
-	BT_DBG("%s", hdev->name);
+	BT_DBG("hci%u", index);
 
 	bacpy(&ev.bdaddr, bdaddr);
 
-	return mgmt_event(MGMT_EV_USER_PASSKEY_REQUEST, hdev, &ev, sizeof(ev),
+	return mgmt_event(MGMT_EV_USER_PASSKEY_REQUEST, index, &ev, sizeof(ev),
 									NULL);
 }
 
-static int user_pairing_resp_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-							u8 status, u8 opcode)
+static int confirm_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status,
+								u8 opcode)
 {
 	struct pending_cmd *cmd;
 	struct mgmt_rp_user_confirm_reply rp;
 	int err;
 
-	cmd = mgmt_pending_find(opcode, hdev);
+	cmd = mgmt_pending_find(opcode, index);
 	if (!cmd)
 		return -ENOENT;
 
 	bacpy(&rp.bdaddr, bdaddr);
-	rp.status = mgmt_status(status);
-	err = cmd_complete(cmd->sk, hdev->id, opcode, &rp, sizeof(rp));
+	rp.status = status;
+	err = cmd_complete(cmd->sk, index, opcode, &rp, sizeof(rp));
 
 	mgmt_pending_remove(cmd);
 
 	return err;
 }
 
-int mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								u8 status)
+int mgmt_user_confirm_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status)
 {
-	return user_pairing_resp_complete(hdev, bdaddr, status,
+	return confirm_reply_complete(index, bdaddr, status,
 						MGMT_OP_USER_CONFIRM_REPLY);
 }
 
-int mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev,
-						bdaddr_t *bdaddr, u8 status)
+int mgmt_user_confirm_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status)
 {
-	return user_pairing_resp_complete(hdev, bdaddr, status,
+	return confirm_reply_complete(index, bdaddr, status,
 					MGMT_OP_USER_CONFIRM_NEG_REPLY);
 }
 
-int mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								u8 status)
-{
-	return user_pairing_resp_complete(hdev, bdaddr, status,
-						MGMT_OP_USER_PASSKEY_REPLY);
-}
-
-int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev,
-						bdaddr_t *bdaddr, u8 status)
-{
-	return user_pairing_resp_complete(hdev, bdaddr, status,
-					MGMT_OP_USER_PASSKEY_NEG_REPLY);
-}
-
-int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 status)
+int mgmt_auth_failed(u16 index, bdaddr_t *bdaddr, u8 status)
 {
 	struct mgmt_ev_auth_failed ev;
 
 	bacpy(&ev.bdaddr, bdaddr);
-	ev.status = mgmt_status(status);
+	ev.status = status;
 
-	return mgmt_event(MGMT_EV_AUTH_FAILED, hdev, &ev, sizeof(ev), NULL);
+	return mgmt_event(MGMT_EV_AUTH_FAILED, index, &ev, sizeof(ev), NULL);
 }
 
-int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status)
+int mgmt_set_local_name_complete(u16 index, u8 *name, u8 status)
 {
 	struct pending_cmd *cmd;
+	struct hci_dev *hdev;
 	struct mgmt_cp_set_local_name ev;
 	int err;
 
 	memset(&ev, 0, sizeof(ev));
 	memcpy(ev.name, name, HCI_MAX_NAME_LENGTH);
 
-	cmd = mgmt_pending_find(MGMT_OP_SET_LOCAL_NAME, hdev);
+	cmd = mgmt_pending_find(MGMT_OP_SET_LOCAL_NAME, index);
 	if (!cmd)
 		goto send_event;
 
 	if (status) {
-		err = cmd_status(cmd->sk, hdev->id, MGMT_OP_SET_LOCAL_NAME,
-							mgmt_status(status));
+		err = cmd_status(cmd->sk, index, MGMT_OP_SET_LOCAL_NAME, EIO);
 		goto failed;
 	}
 
-	update_eir(hdev);
+	hdev = hci_dev_get(index);
+	if (hdev) {
+		update_eir(hdev);
+		hci_dev_put(hdev);
+	}
 
-	err = cmd_complete(cmd->sk, hdev->id, MGMT_OP_SET_LOCAL_NAME, &ev,
+	err = cmd_complete(cmd->sk, index, MGMT_OP_SET_LOCAL_NAME, &ev,
 								sizeof(ev));
 	if (err < 0)
 		goto failed;
 
 send_event:
-	err = mgmt_event(MGMT_EV_LOCAL_NAME_CHANGED, hdev, &ev, sizeof(ev),
+	err = mgmt_event(MGMT_EV_LOCAL_NAME_CHANGED, index, &ev, sizeof(ev),
 							cmd ? cmd->sk : NULL);
 
 failed:
@@ -2668,31 +3217,29 @@ failed:
 	return err;
 }
 
-int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
-						u8 *randomizer, u8 status)
+int mgmt_read_local_oob_data_reply_complete(u16 index, u8 *hash, u8 *randomizer,
+								u8 status)
 {
 	struct pending_cmd *cmd;
 	int err;
 
-	BT_DBG("%s status %u", hdev->name, status);
+	BT_DBG("hci%u status %u", index, status);
 
-	cmd = mgmt_pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev);
+	cmd = mgmt_pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, index);
 	if (!cmd)
 		return -ENOENT;
 
 	if (status) {
-		err = cmd_status(cmd->sk, hdev->id,
-						MGMT_OP_READ_LOCAL_OOB_DATA,
-						mgmt_status(status));
+		err = cmd_status(cmd->sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
+									EIO);
 	} else {
 		struct mgmt_rp_read_local_oob_data rp;
 
 		memcpy(rp.hash, hash, sizeof(rp.hash));
 		memcpy(rp.randomizer, randomizer, sizeof(rp.randomizer));
 
-		err = cmd_complete(cmd->sk, hdev->id,
-						MGMT_OP_READ_LOCAL_OOB_DATA,
-						&rp, sizeof(rp));
+		err = cmd_complete(cmd->sk, index, MGMT_OP_READ_LOCAL_OOB_DATA,
+							&rp, sizeof(rp));
 	}
 
 	mgmt_pending_remove(cmd);
@@ -2700,108 +3247,182 @@ int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 	return err;
 }
 
-int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-				u8 addr_type, u8 *dev_class, s8 rssi, u8 *eir)
+void mgmt_read_rssi_complete(u16 index, s8 rssi, bdaddr_t *bdaddr,
+		u16 handle, u8 status)
+{
+	struct mgmt_ev_rssi_update ev;
+	struct hci_conn *conn;
+	struct hci_dev *hdev;
+
+	if (status)
+		return;
+
+	hdev = hci_dev_get(index);
+	conn = hci_conn_hash_lookup_handle(hdev, handle);
+
+	if (!conn)
+		return;
+
+	BT_DBG("rssi_update_thresh_exceed : %d ",
+		   conn->rssi_update_thresh_exceed);
+	BT_DBG("RSSI Threshold : %d , recvd RSSI : %d ",
+			conn->rssi_threshold, rssi);
+
+	if (conn->rssi_update_thresh_exceed == 1) {
+		BT_DBG("rssi_update_thresh_exceed == 1");
+		if (rssi > conn->rssi_threshold) {
+			memset(&ev, 0, sizeof(ev));
+			bacpy(&ev.bdaddr, bdaddr);
+			ev.rssi = rssi;
+			mgmt_event(MGMT_EV_RSSI_UPDATE, index, &ev,
+				sizeof(ev), NULL);
+		} else {
+			hci_conn_set_rssi_reporter(conn, conn->rssi_threshold,
+				conn->rssi_update_interval,
+				conn->rssi_update_thresh_exceed);
+		}
+	} else {
+		BT_DBG("rssi_update_thresh_exceed == 0");
+		if (rssi < conn->rssi_threshold) {
+			memset(&ev, 0, sizeof(ev));
+			bacpy(&ev.bdaddr, bdaddr);
+			ev.rssi = rssi;
+			mgmt_event(MGMT_EV_RSSI_UPDATE, index, &ev,
+				sizeof(ev), NULL);
+		} else {
+			hci_conn_set_rssi_reporter(conn, conn->rssi_threshold,
+				conn->rssi_update_interval,
+				conn->rssi_update_thresh_exceed);
+		}
+	}
+}
+
+
+int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 type, u8 le,
+			u8 *dev_class, s8 rssi, u8 eir_len, u8 *eir)
 {
 	struct mgmt_ev_device_found ev;
+	struct hci_dev *hdev;
+	int err;
+
+	BT_DBG("le: %d", le);
 
 	memset(&ev, 0, sizeof(ev));
 
-	bacpy(&ev.addr.bdaddr, bdaddr);
-	ev.addr.type = link_to_mgmt(link_type, addr_type);
+	bacpy(&ev.bdaddr, bdaddr);
 	ev.rssi = rssi;
-
-	if (eir)
-		memcpy(ev.eir, eir, sizeof(ev.eir));
+	ev.type = type;
+	ev.le = le;
 
 	if (dev_class)
 		memcpy(ev.dev_class, dev_class, sizeof(ev.dev_class));
 
-	return mgmt_event(MGMT_EV_DEVICE_FOUND, hdev, &ev, sizeof(ev), NULL);
-}
+	if (eir && eir_len)
+		memcpy(ev.eir, eir, eir_len);
 
-int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *name)
-{
-	struct mgmt_ev_remote_name ev;
+	err = mgmt_event(MGMT_EV_DEVICE_FOUND, index, &ev, sizeof(ev), NULL);
 
-	memset(&ev, 0, sizeof(ev));
+	if (err < 0)
+		return err;
 
-	bacpy(&ev.bdaddr, bdaddr);
-	memcpy(ev.name, name, HCI_MAX_NAME_LENGTH);
+	hdev = hci_dev_get(index);
+
+	if (!hdev)
+		return 0;
+
+	if (hdev->disco_state == SCAN_IDLE)
+		goto done;
+
+	hdev->disco_int_count++;
+
+	if (hdev->disco_int_count >= hdev->disco_int_phase) {
+		/* Inquiry scan for General Discovery LAP */
+		struct hci_cp_inquiry cp = {{0x33, 0x8b, 0x9e}, 4, 0};
+		struct hci_cp_le_set_scan_enable le_cp = {0, 0};
+
+		hdev->disco_int_phase *= 2;
+		hdev->disco_int_count = 0;
+		if (hdev->disco_state == SCAN_LE) {
+			/* cancel LE scan */
+			hci_send_cmd(hdev, HCI_OP_LE_SET_SCAN_ENABLE,
+					sizeof(le_cp), &le_cp);
+			/* start BR scan */
+			cp.num_rsp = (u8) hdev->disco_int_phase;
+			hci_send_cmd(hdev, HCI_OP_INQUIRY,
+					sizeof(cp), &cp);
+			hdev->disco_state = SCAN_BR;
+			del_timer_sync(&hdev->disco_le_timer);
+		}
+	}
 
-	return mgmt_event(MGMT_EV_REMOTE_NAME, hdev, &ev, sizeof(ev), NULL);
+done:
+	hci_dev_put(hdev);
+	return 0;
 }
 
-int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status)
+
+int mgmt_remote_name(u16 index, bdaddr_t *bdaddr, u8 status, u8 *name)
 {
-	struct pending_cmd *cmd;
-	int err;
+	struct mgmt_ev_remote_name ev;
 
-	cmd = mgmt_pending_find(MGMT_OP_START_DISCOVERY, hdev);
-	if (!cmd)
-		return -ENOENT;
+	memset(&ev, 0, sizeof(ev));
 
-	err = cmd_status(cmd->sk, hdev->id, cmd->opcode, mgmt_status(status));
-	mgmt_pending_remove(cmd);
+	bacpy(&ev.bdaddr, bdaddr);
+	ev.status = status;
+	memcpy(ev.name, name, HCI_MAX_NAME_LENGTH);
 
-	return err;
+	return mgmt_event(MGMT_EV_REMOTE_NAME, index, &ev, sizeof(ev), NULL);
 }
 
-int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status)
+int mgmt_encrypt_change(u16 index, bdaddr_t *bdaddr, u8 status)
 {
-	struct pending_cmd *cmd;
-	int err;
+	struct mgmt_ev_encrypt_change ev;
 
-	cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, hdev);
-	if (!cmd)
-		return -ENOENT;
+	BT_DBG("hci%u", index);
 
-	err = cmd_status(cmd->sk, hdev->id, cmd->opcode, mgmt_status(status));
-	mgmt_pending_remove(cmd);
+	bacpy(&ev.bdaddr, bdaddr);
+	ev.status = status;
 
-	return err;
+	return mgmt_event(MGMT_EV_ENCRYPT_CHANGE, index, &ev, sizeof(ev),
+									NULL);
 }
 
-int mgmt_discovering(struct hci_dev *hdev, u8 discovering)
+int mgmt_remote_class(u16 index, bdaddr_t *bdaddr, u8 dev_class[3])
 {
-	struct pending_cmd *cmd;
+	struct mgmt_ev_remote_class ev;
 
-	if (discovering)
-		cmd = mgmt_pending_find(MGMT_OP_START_DISCOVERY, hdev);
-	else
-		cmd = mgmt_pending_find(MGMT_OP_STOP_DISCOVERY, hdev);
+	memset(&ev, 0, sizeof(ev));
 
-	if (cmd != NULL) {
-		cmd_complete(cmd->sk, hdev->id, cmd->opcode, NULL, 0);
-		mgmt_pending_remove(cmd);
-	}
+	bacpy(&ev.bdaddr, bdaddr);
+	memcpy(ev.dev_class, dev_class, 3);
 
-	return mgmt_event(MGMT_EV_DISCOVERING, hdev, &discovering,
-						sizeof(discovering), NULL);
+	return mgmt_event(MGMT_EV_REMOTE_CLASS, index, &ev, sizeof(ev), NULL);
 }
 
-int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr)
+int mgmt_remote_version(u16 index, bdaddr_t *bdaddr, u8 ver, u16 mnf,
+							u16 sub_ver)
 {
-	struct pending_cmd *cmd;
-	struct mgmt_ev_device_blocked ev;
+	struct mgmt_ev_remote_version ev;
 
-	cmd = mgmt_pending_find(MGMT_OP_BLOCK_DEVICE, hdev);
+	memset(&ev, 0, sizeof(ev));
 
 	bacpy(&ev.bdaddr, bdaddr);
+	ev.lmp_ver = ver;
+	ev.manufacturer = mnf;
+	ev.lmp_subver = sub_ver;
 
-	return mgmt_event(MGMT_EV_DEVICE_BLOCKED, hdev, &ev, sizeof(ev),
-							cmd ? cmd->sk : NULL);
+	return mgmt_event(MGMT_EV_REMOTE_VERSION, index, &ev, sizeof(ev), NULL);
 }
 
-int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr)
+int mgmt_remote_features(u16 index, bdaddr_t *bdaddr, u8 features[8])
 {
-	struct pending_cmd *cmd;
-	struct mgmt_ev_device_unblocked ev;
+	struct mgmt_ev_remote_features ev;
 
-	cmd = mgmt_pending_find(MGMT_OP_UNBLOCK_DEVICE, hdev);
+	memset(&ev, 0, sizeof(ev));
 
 	bacpy(&ev.bdaddr, bdaddr);
+	memcpy(ev.features, features, sizeof(ev.features));
 
-	return mgmt_event(MGMT_EV_DEVICE_UNBLOCKED, hdev, &ev, sizeof(ev),
-							cmd ? cmd->sk : NULL);
+	return mgmt_event(MGMT_EV_REMOTE_FEATURES, index, &ev, sizeof(ev),
+									NULL);
 }
diff --git a/net/bluetooth/rfcomm/core.c b/net/bluetooth/rfcomm/core.c
index 9652707..d1914ea 100644
--- a/net/bluetooth/rfcomm/core.c
+++ b/net/bluetooth/rfcomm/core.c
@@ -39,6 +39,7 @@
 #include <linux/mutex.h>
 #include <linux/kthread.h>
 #include <linux/slab.h>
+#include <linux/interrupt.h>
 
 #include <net/sock.h>
 #include <linux/uaccess.h>
@@ -50,6 +51,9 @@
 #include <net/bluetooth/rfcomm.h>
 
 #define VERSION "1.11"
+/* 1 Byte DLCI, 1 Byte Control filed, 2 Bytes Length, 1 Byte for Credits,
+ * 1 Byte FCS */
+#define RFCOMM_HDR_SIZE 6
 
 static bool disable_cfc;
 static bool l2cap_ertm;
@@ -62,6 +66,7 @@ static DEFINE_MUTEX(rfcomm_mutex);
 #define rfcomm_lock()	mutex_lock(&rfcomm_mutex)
 #define rfcomm_unlock()	mutex_unlock(&rfcomm_mutex)
 
+static unsigned long rfcomm_event;
 
 static LIST_HEAD(session_list);
 
@@ -81,7 +86,9 @@ static void rfcomm_process_connect(struct rfcomm_session *s);
 static struct rfcomm_session *rfcomm_session_create(bdaddr_t *src,
 							bdaddr_t *dst,
 							u8 sec_level,
-							int *err);
+							int *err,
+							u8 channel,
+							struct rfcomm_dlc *d);
 static struct rfcomm_session *rfcomm_session_get(bdaddr_t *src, bdaddr_t *dst);
 static void rfcomm_session_del(struct rfcomm_session *s);
 
@@ -115,15 +122,37 @@ static void rfcomm_session_del(struct rfcomm_session *s);
 #define __get_rpn_stop_bits(line) (((line) >> 2) & 0x1)
 #define __get_rpn_parity(line)    (((line) >> 3) & 0x7)
 
+struct rfcomm_sock_release_work {
+	struct work_struct work;
+	struct socket *sock;
+	int state;
+};
+
 static inline void rfcomm_schedule(void)
 {
 	if (!rfcomm_thread)
 		return;
+	set_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event);
 	wake_up_process(rfcomm_thread);
 }
 
 static inline void rfcomm_session_put(struct rfcomm_session *s)
 {
+	bool match = false;
+	struct rfcomm_session *sess;
+	struct list_head *p, *n;
+	list_for_each_safe(p, n, &session_list) {
+		sess = list_entry(p, struct rfcomm_session, list);
+		if (s == sess) {
+			match = true;
+			break;
+		}
+	}
+	if (!match) {
+		BT_ERR("session already freed previously");
+		dump_stack();
+		return;
+	}
 	if (atomic_dec_and_test(&s->refcnt))
 		rfcomm_session_del(s);
 }
@@ -230,11 +259,10 @@ static int rfcomm_l2sock_create(struct socket **sock)
 static inline int rfcomm_check_security(struct rfcomm_dlc *d)
 {
 	struct sock *sk = d->session->sock->sk;
-	struct l2cap_conn *conn = l2cap_pi(sk)->chan->conn;
-
 	__u8 auth_type;
 
 	switch (d->sec_level) {
+	case BT_SECURITY_VERY_HIGH:
 	case BT_SECURITY_HIGH:
 		auth_type = HCI_AT_GENERAL_BONDING_MITM;
 		break;
@@ -246,7 +274,8 @@ static inline int rfcomm_check_security(struct rfcomm_dlc *d)
 		break;
 	}
 
-	return hci_conn_security(conn->hcon, d->sec_level, auth_type);
+	return hci_conn_security(l2cap_pi(sk)->conn->hcon, d->sec_level,
+								auth_type);
 }
 
 static void rfcomm_session_timeout(unsigned long arg)
@@ -377,11 +406,13 @@ static void rfcomm_dlc_unlink(struct rfcomm_dlc *d)
 static struct rfcomm_dlc *rfcomm_dlc_get(struct rfcomm_session *s, u8 dlci)
 {
 	struct rfcomm_dlc *d;
+	struct list_head *p;
 
-	list_for_each_entry(d, &s->dlcs, list)
+	list_for_each(p, &s->dlcs) {
+		d = list_entry(p, struct rfcomm_dlc, list);
 		if (d->dlci == dlci)
 			return d;
-
+	}
 	return NULL;
 }
 
@@ -402,31 +433,31 @@ static int __rfcomm_dlc_open(struct rfcomm_dlc *d, bdaddr_t *src, bdaddr_t *dst,
 
 	s = rfcomm_session_get(src, dst);
 	if (!s) {
-		s = rfcomm_session_create(src, dst, d->sec_level, &err);
+		s = rfcomm_session_create(src, dst,
+						d->sec_level, &err, channel, d);
 		if (!s)
 			return err;
-	}
+	} else {
+		dlci = __dlci(!s->initiator, channel);
 
-	dlci = __dlci(!s->initiator, channel);
+		/* Check if DLCI already exists */
+		if (rfcomm_dlc_get(s, dlci))
+			return -EBUSY;
 
-	/* Check if DLCI already exists */
-	if (rfcomm_dlc_get(s, dlci))
-		return -EBUSY;
+		rfcomm_dlc_clear_state(d);
 
-	rfcomm_dlc_clear_state(d);
+		d->dlci     = dlci;
+		d->addr     = __addr(s->initiator, dlci);
+		d->priority = 7;
 
-	d->dlci     = dlci;
-	d->addr     = __addr(s->initiator, dlci);
-	d->priority = 7;
-
-	d->state = BT_CONFIG;
-	rfcomm_dlc_link(s, d);
-
-	d->out = 1;
+		d->state = BT_CONFIG;
+		rfcomm_dlc_link(s, d);
 
-	d->mtu = s->mtu;
-	d->cfc = (s->cfc == RFCOMM_CFC_UNKNOWN) ? 0 : s->cfc;
+		d->out = 1;
 
+		d->mtu = s->mtu;
+		d->cfc = (s->cfc == RFCOMM_CFC_UNKNOWN) ? 0 : s->cfc;
+	}
 	if (s->state == BT_CONNECTED) {
 		if (rfcomm_check_security(d))
 			rfcomm_send_pn(s, 1, d);
@@ -622,9 +653,25 @@ static struct rfcomm_session *rfcomm_session_add(struct socket *sock, int state)
 	return s;
 }
 
+static void rfcomm_sock_release_worker(struct work_struct *work)
+{
+	struct rfcomm_sock_release_work *release_work =
+		container_of(work, struct rfcomm_sock_release_work, work);
+
+	BT_DBG("sock %p", release_work->sock);
+
+	sock_release(release_work->sock);
+	if (release_work->state != BT_LISTEN)
+		module_put(THIS_MODULE);
+
+	kfree(release_work);
+}
+
 static void rfcomm_session_del(struct rfcomm_session *s)
 {
 	int state = s->state;
+	struct socket *sock = s->sock;
+	struct rfcomm_sock_release_work *release_work;
 
 	BT_DBG("session %p state %ld", s, s->state);
 
@@ -634,11 +681,19 @@ static void rfcomm_session_del(struct rfcomm_session *s)
 		rfcomm_send_disc(s, 0);
 
 	rfcomm_session_clear_timer(s);
-	sock_release(s->sock);
+
 	kfree(s);
 
-	if (state != BT_LISTEN)
-		module_put(THIS_MODULE);
+	release_work = kzalloc(sizeof(*release_work), GFP_ATOMIC);
+	if (release_work) {
+		INIT_WORK(&release_work->work, rfcomm_sock_release_worker);
+		release_work->sock = sock;
+		release_work->state = state;
+
+		if (!schedule_work(&release_work->work))
+			kfree(release_work);
+	}
+
 }
 
 static struct rfcomm_session *rfcomm_session_get(bdaddr_t *src, bdaddr_t *dst)
@@ -682,12 +737,15 @@ static void rfcomm_session_close(struct rfcomm_session *s, int err)
 static struct rfcomm_session *rfcomm_session_create(bdaddr_t *src,
 							bdaddr_t *dst,
 							u8 sec_level,
-							int *err)
+							int *err,
+							u8 channel,
+							struct rfcomm_dlc *d)
 {
 	struct rfcomm_session *s = NULL;
 	struct sockaddr_l2 addr;
 	struct socket *sock;
 	struct sock *sk;
+	u8 dlci;
 
 	BT_DBG("%s %s", batostr(src), batostr(dst));
 
@@ -706,10 +764,10 @@ static struct rfcomm_session *rfcomm_session_create(bdaddr_t *src,
 	/* Set L2CAP options */
 	sk = sock->sk;
 	lock_sock(sk);
-	l2cap_pi(sk)->chan->imtu = l2cap_mtu;
-	l2cap_pi(sk)->chan->sec_level = sec_level;
+	l2cap_pi(sk)->imtu = l2cap_mtu;
+	l2cap_pi(sk)->sec_level = sec_level;
 	if (l2cap_ertm)
-		l2cap_pi(sk)->chan->mode = L2CAP_MODE_ERTM;
+		l2cap_pi(sk)->mode = L2CAP_MODE_ERTM;
 	release_sock(sk);
 
 	s = rfcomm_session_add(sock, BT_BOUND);
@@ -724,11 +782,30 @@ static struct rfcomm_session *rfcomm_session_create(bdaddr_t *src,
 	addr.l2_family = AF_BLUETOOTH;
 	addr.l2_psm    = cpu_to_le16(RFCOMM_PSM);
 	addr.l2_cid    = 0;
+	dlci = __dlci(!s->initiator, channel);
+
+	/* Check if DLCI already exists */
+	if (rfcomm_dlc_get(s, dlci))
+		return NULL;
+
+	rfcomm_dlc_clear_state(d);
+
+	d->dlci     = dlci;
+	d->addr     = __addr(s->initiator, dlci);
+	d->priority = 7;
+
+	d->state = BT_CONFIG;
+	rfcomm_dlc_link(s, d);
+
+	d->out = 1;
+
+	d->mtu = s->mtu;
+	d->cfc = (s->cfc == RFCOMM_CFC_UNKNOWN) ? 0 : s->cfc;
 	*err = kernel_connect(sock, (struct sockaddr *) &addr, sizeof(addr), O_NONBLOCK);
 	if (*err == 0 || *err == -EINPROGRESS)
 		return s;
-
-	rfcomm_session_del(s);
+	BT_ERR("error ret is %d, going to delete session", *err);
+	rfcomm_dlc_unlink(d);
 	return NULL;
 
 failed:
@@ -748,6 +825,7 @@ void rfcomm_session_getaddr(struct rfcomm_session *s, bdaddr_t *src, bdaddr_t *d
 /* ---- RFCOMM frame sending ---- */
 static int rfcomm_send_frame(struct rfcomm_session *s, u8 *data, int len)
 {
+	struct socket *sock = s->sock;
 	struct kvec iv = { data, len };
 	struct msghdr msg;
 
@@ -755,14 +833,7 @@ static int rfcomm_send_frame(struct rfcomm_session *s, u8 *data, int len)
 
 	memset(&msg, 0, sizeof(msg));
 
-	return kernel_sendmsg(s->sock, &msg, &iv, 1, len);
-}
-
-static int rfcomm_send_cmd(struct rfcomm_session *s, struct rfcomm_cmd *cmd)
-{
-	BT_DBG("%p cmd %u", s, cmd->ctrl);
-
-	return rfcomm_send_frame(s, (void *) cmd, sizeof(*cmd));
+	return kernel_sendmsg(sock, &msg, &iv, 1, len);
 }
 
 static int rfcomm_send_sabm(struct rfcomm_session *s, u8 dlci)
@@ -776,7 +847,7 @@ static int rfcomm_send_sabm(struct rfcomm_session *s, u8 dlci)
 	cmd.len  = __len8(0);
 	cmd.fcs  = __fcs2((u8 *) &cmd);
 
-	return rfcomm_send_cmd(s, &cmd);
+	return rfcomm_send_frame(s, (void *) &cmd, sizeof(cmd));
 }
 
 static int rfcomm_send_ua(struct rfcomm_session *s, u8 dlci)
@@ -790,7 +861,7 @@ static int rfcomm_send_ua(struct rfcomm_session *s, u8 dlci)
 	cmd.len  = __len8(0);
 	cmd.fcs  = __fcs2((u8 *) &cmd);
 
-	return rfcomm_send_cmd(s, &cmd);
+	return rfcomm_send_frame(s, (void *) &cmd, sizeof(cmd));
 }
 
 static int rfcomm_send_disc(struct rfcomm_session *s, u8 dlci)
@@ -804,7 +875,7 @@ static int rfcomm_send_disc(struct rfcomm_session *s, u8 dlci)
 	cmd.len  = __len8(0);
 	cmd.fcs  = __fcs2((u8 *) &cmd);
 
-	return rfcomm_send_cmd(s, &cmd);
+	return rfcomm_send_frame(s, (void *) &cmd, sizeof(cmd));
 }
 
 static int rfcomm_queue_disc(struct rfcomm_dlc *d)
@@ -840,7 +911,7 @@ static int rfcomm_send_dm(struct rfcomm_session *s, u8 dlci)
 	cmd.len  = __len8(0);
 	cmd.fcs  = __fcs2((u8 *) &cmd);
 
-	return rfcomm_send_cmd(s, &cmd);
+	return rfcomm_send_frame(s, (void *) &cmd, sizeof(cmd));
 }
 
 static int rfcomm_send_nsc(struct rfcomm_session *s, int cr, u8 type)
@@ -1163,18 +1234,12 @@ static int rfcomm_recv_ua(struct rfcomm_session *s, u8 dlci)
 			break;
 
 		case BT_DISCONN:
-			/* rfcomm_session_put is called later so don't do
-			 * anything here otherwise we will mess up the session
-			 * reference counter:
-			 *
-			 * (a) when we are the initiator dlc_unlink will drive
-			 * the reference counter to 0 (there is no initial put
-			 * after session_add)
-			 *
-			 * (b) when we are not the initiator rfcomm_rx_process
-			 * will explicitly call put to balance the initial hold
-			 * done after session add.
-			 */
+			/* When socket is closed and we are not RFCOMM
+			 * initiator rfcomm_process_rx already calls
+			 * rfcomm_session_put() */
+			if (s->sock->sk->sk_state != BT_CLOSED)
+				if (list_empty(&s->dlcs))
+					rfcomm_session_put(s);
 			break;
 		}
 	}
@@ -1250,7 +1315,6 @@ static int rfcomm_recv_disc(struct rfcomm_session *s, u8 dlci)
 void rfcomm_dlc_accept(struct rfcomm_dlc *d)
 {
 	struct sock *sk = d->session->sock->sk;
-	struct l2cap_conn *conn = l2cap_pi(sk)->chan->conn;
 
 	BT_DBG("dlc %p", d);
 
@@ -1264,7 +1328,7 @@ void rfcomm_dlc_accept(struct rfcomm_dlc *d)
 	rfcomm_dlc_unlock(d);
 
 	if (d->role_switch)
-		hci_conn_switch_role(conn->hcon, 0x00);
+		hci_conn_switch_role(l2cap_pi(sk)->conn->hcon, 0x00);
 
 	rfcomm_send_msc(d->session, 1, d->dlci, d->v24_sig);
 }
@@ -1812,11 +1876,6 @@ static inline void rfcomm_process_dlcs(struct rfcomm_session *s)
 			continue;
 		}
 
-		if (test_bit(RFCOMM_ENC_DROP, &d->flags)) {
-			__rfcomm_dlc_close(d, ECONNREFUSED);
-			continue;
-		}
-
 		if (test_and_clear_bit(RFCOMM_AUTH_ACCEPT, &d->flags)) {
 			rfcomm_dlc_clear_timer(d);
 			if (d->out) {
@@ -1907,9 +1966,10 @@ static inline void rfcomm_accept_connection(struct rfcomm_session *s)
 		rfcomm_session_hold(s);
 
 		/* We should adjust MTU on incoming sessions.
-		 * L2CAP MTU minus UIH header and FCS. */
-		s->mtu = min(l2cap_pi(nsock->sk)->chan->omtu,
-				l2cap_pi(nsock->sk)->chan->imtu) - 5;
+		 * L2CAP MTU minus UIH header and FCS.
+		 * Need to accomodate 1 Byte credits information */
+		s->mtu = min(l2cap_pi(nsock->sk)->omtu,
+				l2cap_pi(nsock->sk)->imtu) - RFCOMM_HDR_SIZE;
 
 		rfcomm_schedule();
 	} else
@@ -1927,8 +1987,9 @@ static inline void rfcomm_check_connection(struct rfcomm_session *s)
 		s->state = BT_CONNECT;
 
 		/* We can adjust MTU on outgoing sessions.
-		 * L2CAP MTU minus UIH header and FCS. */
-		s->mtu = min(l2cap_pi(sk)->chan->omtu, l2cap_pi(sk)->chan->imtu) - 5;
+		 * L2CAP MTU minus UIH header, Credits and FCS. */
+		s->mtu = min(l2cap_pi(sk)->omtu, l2cap_pi(sk)->imtu) -
+						RFCOMM_HDR_SIZE;
 
 		rfcomm_send_sabm(s, 0);
 		break;
@@ -2011,7 +2072,7 @@ static int rfcomm_add_listener(bdaddr_t *ba)
 	/* Set L2CAP options */
 	sk = sock->sk;
 	lock_sock(sk);
-	l2cap_pi(sk)->chan->imtu = l2cap_mtu;
+	l2cap_pi(sk)->imtu = l2cap_mtu;
 	release_sock(sk);
 
 	/* Start listening on the socket */
@@ -2054,18 +2115,19 @@ static int rfcomm_run(void *unused)
 
 	rfcomm_add_listener(BDADDR_ANY);
 
-	while (1) {
+	while (!kthread_should_stop()) {
 		set_current_state(TASK_INTERRUPTIBLE);
-
-		if (kthread_should_stop())
-			break;
+		if (!test_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event)) {
+			/* No pending events. Let's sleep.
+			 * Incoming connections and data will wake us up. */
+			schedule();
+		}
+		set_current_state(TASK_RUNNING);
 
 		/* Process stuff */
+		clear_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event);
 		rfcomm_process_sessions();
-
-		schedule();
 	}
-	__set_current_state(TASK_RUNNING);
 
 	rfcomm_kill_listener();
 
@@ -2092,7 +2154,7 @@ static void rfcomm_security_cfm(struct hci_conn *conn, u8 status, u8 encrypt)
 		if (test_and_clear_bit(RFCOMM_SEC_PENDING, &d->flags)) {
 			rfcomm_dlc_clear_timer(d);
 			if (status || encrypt == 0x00) {
-				set_bit(RFCOMM_ENC_DROP, &d->flags);
+				__rfcomm_dlc_close(d, ECONNREFUSED);
 				continue;
 			}
 		}
@@ -2102,8 +2164,9 @@ static void rfcomm_security_cfm(struct hci_conn *conn, u8 status, u8 encrypt)
 				set_bit(RFCOMM_SEC_PENDING, &d->flags);
 				rfcomm_dlc_set_timer(d, RFCOMM_AUTH_TIMEOUT);
 				continue;
-			} else if (d->sec_level == BT_SECURITY_HIGH) {
-				set_bit(RFCOMM_ENC_DROP, &d->flags);
+			} else if (d->sec_level == BT_SECURITY_HIGH ||
+				d->sec_level == BT_SECURITY_VERY_HIGH) {
+				__rfcomm_dlc_close(d, ECONNREFUSED);
 				continue;
 			}
 		}
@@ -2111,7 +2174,7 @@ static void rfcomm_security_cfm(struct hci_conn *conn, u8 status, u8 encrypt)
 		if (!test_and_clear_bit(RFCOMM_AUTH_PENDING, &d->flags))
 			continue;
 
-		if (!status && hci_conn_check_secure(conn, d->sec_level))
+		if (!status)
 			set_bit(RFCOMM_AUTH_ACCEPT, &d->flags);
 		else
 			set_bit(RFCOMM_AUTH_REJECT, &d->flags);
@@ -2130,13 +2193,15 @@ static struct hci_cb rfcomm_cb = {
 static int rfcomm_dlc_debugfs_show(struct seq_file *f, void *x)
 {
 	struct rfcomm_session *s;
+	struct list_head *pp, *p;
 
 	rfcomm_lock();
 
-	list_for_each_entry(s, &session_list, list) {
-		struct rfcomm_dlc *d;
-		list_for_each_entry(d, &s->dlcs, list) {
+	list_for_each(p, &session_list) {
+		s = list_entry(p, struct rfcomm_session, list);
+		list_for_each(pp, &s->dlcs) {
 			struct sock *sk = s->sock->sk;
+			struct rfcomm_dlc *d = list_entry(pp, struct rfcomm_dlc, list);
 
 			seq_printf(f, "%s %s %ld %d %d %d %d\n",
 						batostr(&bt_sk(sk)->src),
diff --git a/net/bluetooth/rfcomm/sock.c b/net/bluetooth/rfcomm/sock.c
index 22169c3..216068f 100644
--- a/net/bluetooth/rfcomm/sock.c
+++ b/net/bluetooth/rfcomm/sock.c
@@ -42,7 +42,6 @@
 #include <linux/device.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
-#include <linux/security.h>
 #include <net/sock.h>
 
 #include <asm/system.h>
@@ -265,8 +264,6 @@ static void rfcomm_sock_init(struct sock *sk, struct sock *parent)
 
 		pi->sec_level = rfcomm_pi(parent)->sec_level;
 		pi->role_switch = rfcomm_pi(parent)->role_switch;
-
-		security_sk_clone(parent, sk);
 	} else {
 		pi->dlc->defer_setup = 0;
 
@@ -370,7 +367,7 @@ static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr
 		goto done;
 	}
 
-	write_lock(&rfcomm_sk_list.lock);
+	write_lock_bh(&rfcomm_sk_list.lock);
 
 	if (sa->rc_channel && __rfcomm_get_sock_by_addr(sa->rc_channel, &sa->rc_bdaddr)) {
 		err = -EADDRINUSE;
@@ -381,7 +378,7 @@ static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr
 		sk->sk_state = BT_BOUND;
 	}
 
-	write_unlock(&rfcomm_sk_list.lock);
+	write_unlock_bh(&rfcomm_sk_list.lock);
 
 done:
 	release_sock(sk);
@@ -455,7 +452,7 @@ static int rfcomm_sock_listen(struct socket *sock, int backlog)
 
 		err = -EINVAL;
 
-		write_lock(&rfcomm_sk_list.lock);
+		write_lock_bh(&rfcomm_sk_list.lock);
 
 		for (channel = 1; channel < 31; channel++)
 			if (!__rfcomm_get_sock_by_addr(channel, src)) {
@@ -464,7 +461,7 @@ static int rfcomm_sock_listen(struct socket *sock, int backlog)
 				break;
 			}
 
-		write_unlock(&rfcomm_sk_list.lock);
+		write_unlock_bh(&rfcomm_sk_list.lock);
 
 		if (err < 0)
 			goto done;
@@ -488,6 +485,11 @@ static int rfcomm_sock_accept(struct socket *sock, struct socket *newsock, int f
 
 	lock_sock(sk);
 
+	if (sk->sk_state != BT_LISTEN) {
+		err = -EBADFD;
+		goto done;
+	}
+
 	if (sk->sk_type != SOCK_STREAM) {
 		err = -EINVAL;
 		goto done;
@@ -499,20 +501,19 @@ static int rfcomm_sock_accept(struct socket *sock, struct socket *newsock, int f
 
 	/* Wait for an incoming connection. (wake-one). */
 	add_wait_queue_exclusive(sk_sleep(sk), &wait);
-	while (1) {
+	while (!(nsk = bt_accept_dequeue(sk, newsock))) {
 		set_current_state(TASK_INTERRUPTIBLE);
-
-		if (sk->sk_state != BT_LISTEN) {
-			err = -EBADFD;
+		if (!timeo) {
+			err = -EAGAIN;
 			break;
 		}
 
-		nsk = bt_accept_dequeue(sk, newsock);
-		if (nsk)
-			break;
+		release_sock(sk);
+		timeo = schedule_timeout(timeo);
+		lock_sock(sk);
 
-		if (!timeo) {
-			err = -EAGAIN;
+		if (sk->sk_state != BT_LISTEN) {
+			err = -EBADFD;
 			break;
 		}
 
@@ -520,12 +521,8 @@ static int rfcomm_sock_accept(struct socket *sock, struct socket *newsock, int f
 			err = sock_intr_errno(timeo);
 			break;
 		}
-
-		release_sock(sk);
-		timeo = schedule_timeout(timeo);
-		lock_sock(sk);
 	}
-	__set_current_state(TASK_RUNNING);
+	set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 
 	if (err)
@@ -600,8 +597,6 @@ static int rfcomm_sock_sendmsg(struct kiocb *iocb, struct socket *sock,
 			break;
 		}
 
-		skb->priority = sk->sk_priority;
-
 		err = rfcomm_dlc_send(d, skb);
 		if (err < 0) {
 			kfree_skb(skb);
@@ -684,8 +679,7 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level, int optname, c
 {
 	struct sock *sk = sock->sk;
 	struct bt_security sec;
-	int err = 0;
-	size_t len;
+	int len, err = 0;
 	u32 opt;
 
 	BT_DBG("sk %p", sk);
@@ -713,12 +707,13 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level, int optname, c
 			break;
 		}
 
-		if (sec.level > BT_SECURITY_HIGH) {
+		if (sec.level > BT_SECURITY_VERY_HIGH) {
 			err = -EINVAL;
 			break;
 		}
 
 		rfcomm_pi(sk)->sec_level = sec.level;
+		BT_DBG("set to %d", sec.level);
 		break;
 
 	case BT_DEFER_SETUP:
@@ -747,8 +742,8 @@ static int rfcomm_sock_setsockopt(struct socket *sock, int level, int optname, c
 static int rfcomm_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)
 {
 	struct sock *sk = sock->sk;
+	struct sock *l2cap_sk;
 	struct rfcomm_conninfo cinfo;
-	struct l2cap_conn *conn = l2cap_pi(sk)->chan->conn;
 	int len, err = 0;
 	u32 opt;
 
@@ -769,6 +764,7 @@ static int rfcomm_sock_getsockopt_old(struct socket *sock, int optname, char __u
 			opt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT;
 			break;
 		case BT_SECURITY_HIGH:
+		case BT_SECURITY_VERY_HIGH:
 			opt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT |
 							RFCOMM_LM_SECURE;
 			break;
@@ -791,9 +787,10 @@ static int rfcomm_sock_getsockopt_old(struct socket *sock, int optname, char __u
 			break;
 		}
 
-		memset(&cinfo, 0, sizeof(cinfo));
-		cinfo.hci_handle = conn->hcon->handle;
-		memcpy(cinfo.dev_class, conn->hcon->dev_class, 3);
+		l2cap_sk = rfcomm_pi(sk)->dlc->session->sock->sk;
+
+		cinfo.hci_handle = l2cap_pi(l2cap_sk)->conn->hcon->handle;
+		memcpy(cinfo.dev_class, l2cap_pi(l2cap_sk)->conn->hcon->dev_class, 3);
 
 		len = min_t(unsigned int, len, sizeof(cinfo));
 		if (copy_to_user(optval, (char *) &cinfo, len))
@@ -956,8 +953,6 @@ int rfcomm_connect_ind(struct rfcomm_session *s, u8 channel, struct rfcomm_dlc *
 	if (!sk)
 		goto done;
 
-	bt_sock_reclassify_lock(sk, BTPROTO_RFCOMM);
-
 	rfcomm_sock_init(sk, parent);
 	bacpy(&bt_sk(sk)->src, &src);
 	bacpy(&bt_sk(sk)->dst, &dst);
@@ -984,7 +979,7 @@ static int rfcomm_sock_debugfs_show(struct seq_file *f, void *p)
 	struct sock *sk;
 	struct hlist_node *node;
 
-	read_lock(&rfcomm_sk_list.lock);
+	read_lock_bh(&rfcomm_sk_list.lock);
 
 	sk_for_each(sk, node, &rfcomm_sk_list.head) {
 		seq_printf(f, "%s %s %d %d\n",
@@ -993,7 +988,7 @@ static int rfcomm_sock_debugfs_show(struct seq_file *f, void *p)
 				sk->sk_state, rfcomm_pi(sk)->channel);
 	}
 
-	read_unlock(&rfcomm_sk_list.lock);
+	read_unlock_bh(&rfcomm_sk_list.lock);
 
 	return 0;
 }
diff --git a/net/bluetooth/rfcomm/tty.c b/net/bluetooth/rfcomm/tty.c
index a2d4f51..e18781c 100644
--- a/net/bluetooth/rfcomm/tty.c
+++ b/net/bluetooth/rfcomm/tty.c
@@ -26,6 +26,7 @@
  */
 
 #include <linux/module.h>
+#include <linux/interrupt.h>
 
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
@@ -34,7 +35,6 @@
 #include <linux/capability.h>
 #include <linux/slab.h>
 #include <linux/skbuff.h>
-#include <linux/workqueue.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
@@ -66,7 +66,7 @@ struct rfcomm_dev {
 	struct rfcomm_dlc	*dlc;
 	struct tty_struct	*tty;
 	wait_queue_head_t       wait;
-	struct work_struct	wakeup_task;
+	struct tasklet_struct   wakeup_task;
 
 	struct device		*tty_dev;
 
@@ -76,13 +76,13 @@ struct rfcomm_dev {
 };
 
 static LIST_HEAD(rfcomm_dev_list);
-static DEFINE_SPINLOCK(rfcomm_dev_lock);
+static DEFINE_RWLOCK(rfcomm_dev_lock);
 
 static void rfcomm_dev_data_ready(struct rfcomm_dlc *dlc, struct sk_buff *skb);
 static void rfcomm_dev_state_change(struct rfcomm_dlc *dlc, int err);
 static void rfcomm_dev_modem_status(struct rfcomm_dlc *dlc, u8 v24_sig);
 
-static void rfcomm_tty_wakeup(struct work_struct *work);
+static void rfcomm_tty_wakeup(unsigned long arg);
 
 /* ---- Device functions ---- */
 static void rfcomm_dev_destruct(struct rfcomm_dev *dev)
@@ -134,10 +134,13 @@ static inline void rfcomm_dev_put(struct rfcomm_dev *dev)
 static struct rfcomm_dev *__rfcomm_dev_get(int id)
 {
 	struct rfcomm_dev *dev;
+	struct list_head  *p;
 
-	list_for_each_entry(dev, &rfcomm_dev_list, list)
+	list_for_each(p, &rfcomm_dev_list) {
+		dev = list_entry(p, struct rfcomm_dev, list);
 		if (dev->id == id)
 			return dev;
+	}
 
 	return NULL;
 }
@@ -146,7 +149,7 @@ static inline struct rfcomm_dev *rfcomm_dev_get(int id)
 {
 	struct rfcomm_dev *dev;
 
-	spin_lock(&rfcomm_dev_lock);
+	read_lock(&rfcomm_dev_lock);
 
 	dev = __rfcomm_dev_get(id);
 
@@ -157,7 +160,7 @@ static inline struct rfcomm_dev *rfcomm_dev_get(int id)
 			rfcomm_dev_hold(dev);
 	}
 
-	spin_unlock(&rfcomm_dev_lock);
+	read_unlock(&rfcomm_dev_lock);
 
 	return dev;
 }
@@ -195,7 +198,7 @@ static DEVICE_ATTR(channel, S_IRUGO, show_channel, NULL);
 
 static int rfcomm_dev_add(struct rfcomm_dev_req *req, struct rfcomm_dlc *dlc)
 {
-	struct rfcomm_dev *dev, *entry;
+	struct rfcomm_dev *dev;
 	struct list_head *head = &rfcomm_dev_list, *p;
 	int err = 0;
 
@@ -205,13 +208,13 @@ static int rfcomm_dev_add(struct rfcomm_dev_req *req, struct rfcomm_dlc *dlc)
 	if (!dev)
 		return -ENOMEM;
 
-	spin_lock(&rfcomm_dev_lock);
+	write_lock_bh(&rfcomm_dev_lock);
 
 	if (req->dev_id < 0) {
 		dev->id = 0;
 
-		list_for_each_entry(entry, &rfcomm_dev_list, list) {
-			if (entry->id != dev->id)
+		list_for_each(p, &rfcomm_dev_list) {
+			if (list_entry(p, struct rfcomm_dev, list)->id != dev->id)
 				break;
 
 			dev->id++;
@@ -220,7 +223,9 @@ static int rfcomm_dev_add(struct rfcomm_dev_req *req, struct rfcomm_dlc *dlc)
 	} else {
 		dev->id = req->dev_id;
 
-		list_for_each_entry(entry, &rfcomm_dev_list, list) {
+		list_for_each(p, &rfcomm_dev_list) {
+			struct rfcomm_dev *entry = list_entry(p, struct rfcomm_dev, list);
+
 			if (entry->id == dev->id) {
 				err = -EADDRINUSE;
 				goto out;
@@ -253,7 +258,7 @@ static int rfcomm_dev_add(struct rfcomm_dev_req *req, struct rfcomm_dlc *dlc)
 	atomic_set(&dev->opened, 0);
 
 	init_waitqueue_head(&dev->wait);
-	INIT_WORK(&dev->wakeup_task, rfcomm_tty_wakeup);
+	tasklet_init(&dev->wakeup_task, rfcomm_tty_wakeup, (unsigned long) dev);
 
 	skb_queue_head_init(&dev->pending);
 
@@ -290,7 +295,7 @@ static int rfcomm_dev_add(struct rfcomm_dev_req *req, struct rfcomm_dlc *dlc)
 	__module_get(THIS_MODULE);
 
 out:
-	spin_unlock(&rfcomm_dev_lock);
+	write_unlock_bh(&rfcomm_dev_lock);
 
 	if (err < 0)
 		goto free;
@@ -327,9 +332,9 @@ static void rfcomm_dev_del(struct rfcomm_dev *dev)
 	if (atomic_read(&dev->opened) > 0)
 		return;
 
-	spin_lock(&rfcomm_dev_lock);
+	write_lock_bh(&rfcomm_dev_lock);
 	list_del_init(&dev->list);
-	spin_unlock(&rfcomm_dev_lock);
+	write_unlock_bh(&rfcomm_dev_lock);
 
 	rfcomm_dev_put(dev);
 }
@@ -347,7 +352,7 @@ static void rfcomm_wfree(struct sk_buff *skb)
 	struct rfcomm_dev *dev = (void *) skb->sk;
 	atomic_sub(skb->truesize, &dev->wmem_alloc);
 	if (test_bit(RFCOMM_TTY_ATTACHED, &dev->flags))
-		queue_work(system_nrt_wq, &dev->wakeup_task);
+		tasklet_schedule(&dev->wakeup_task);
 	rfcomm_dev_put(dev);
 }
 
@@ -451,9 +456,9 @@ static int rfcomm_release_dev(void __user *arg)
 
 static int rfcomm_get_dev_list(void __user *arg)
 {
-	struct rfcomm_dev *dev;
 	struct rfcomm_dev_list_req *dl;
 	struct rfcomm_dev_info *di;
+	struct list_head *p;
 	int n = 0, size, err;
 	u16 dev_num;
 
@@ -473,9 +478,10 @@ static int rfcomm_get_dev_list(void __user *arg)
 
 	di = dl->dev_info;
 
-	spin_lock(&rfcomm_dev_lock);
+	read_lock_bh(&rfcomm_dev_lock);
 
-	list_for_each_entry(dev, &rfcomm_dev_list, list) {
+	list_for_each(p, &rfcomm_dev_list) {
+		struct rfcomm_dev *dev = list_entry(p, struct rfcomm_dev, list);
 		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
 			continue;
 		(di + n)->id      = dev->id;
@@ -488,7 +494,7 @@ static int rfcomm_get_dev_list(void __user *arg)
 			break;
 	}
 
-	spin_unlock(&rfcomm_dev_lock);
+	read_unlock_bh(&rfcomm_dev_lock);
 
 	dl->dev_num = n;
 	size = sizeof(*dl) + n * sizeof(*di);
@@ -630,10 +636,9 @@ static void rfcomm_dev_modem_status(struct rfcomm_dlc *dlc, u8 v24_sig)
 }
 
 /* ---- TTY functions ---- */
-static void rfcomm_tty_wakeup(struct work_struct *work)
+static void rfcomm_tty_wakeup(unsigned long arg)
 {
-	struct rfcomm_dev *dev = container_of(work, struct rfcomm_dev,
-								wakeup_task);
+	struct rfcomm_dev *dev = (void *) arg;
 	struct tty_struct *tty = dev->tty;
 	if (!tty)
 		return;
@@ -758,7 +763,7 @@ static void rfcomm_tty_close(struct tty_struct *tty, struct file *filp)
 		rfcomm_dlc_close(dev->dlc, 0);
 
 		clear_bit(RFCOMM_TTY_ATTACHED, &dev->flags);
-		cancel_work_sync(&dev->wakeup_task);
+		tasklet_kill(&dev->wakeup_task);
 
 		rfcomm_dlc_lock(dev->dlc);
 		tty->driver_data = NULL;
@@ -766,9 +771,9 @@ static void rfcomm_tty_close(struct tty_struct *tty, struct file *filp)
 		rfcomm_dlc_unlock(dev->dlc);
 
 		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags)) {
-			spin_lock(&rfcomm_dev_lock);
+			write_lock_bh(&rfcomm_dev_lock);
 			list_del_init(&dev->list);
-			spin_unlock(&rfcomm_dev_lock);
+			write_unlock_bh(&rfcomm_dev_lock);
 
 			rfcomm_dev_put(dev);
 		}
@@ -1151,11 +1156,9 @@ static const struct tty_operations rfcomm_ops = {
 
 int __init rfcomm_init_ttys(void)
 {
-	int error;
-
 	rfcomm_tty_driver = alloc_tty_driver(RFCOMM_TTY_PORTS);
 	if (!rfcomm_tty_driver)
-		return -ENOMEM;
+		return -1;
 
 	rfcomm_tty_driver->owner	= THIS_MODULE;
 	rfcomm_tty_driver->driver_name	= "rfcomm";
@@ -1170,11 +1173,10 @@ int __init rfcomm_init_ttys(void)
 	rfcomm_tty_driver->init_termios.c_lflag &= ~ICANON;
 	tty_set_operations(rfcomm_tty_driver, &rfcomm_ops);
 
-	error = tty_register_driver(rfcomm_tty_driver);
-	if (error) {
+	if (tty_register_driver(rfcomm_tty_driver)) {
 		BT_ERR("Can't register RFCOMM TTY driver");
 		put_tty_driver(rfcomm_tty_driver);
-		return error;
+		return -1;
 	}
 
 	BT_INFO("RFCOMM TTY layer initialized");
diff --git a/net/bluetooth/sco.c b/net/bluetooth/sco.c
old mode 100755
new mode 100644
index 3031aca..3170190
--- a/net/bluetooth/sco.c
+++ b/net/bluetooth/sco.c
@@ -1,6 +1,7 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
    Copyright (C) 2000-2001 Qualcomm Incorporated
+   Copyright (c) 2011, The Linux Foundation. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 
@@ -24,6 +25,7 @@
 
 /* Bluetooth SCO sockets. */
 
+#include <linux/interrupt.h>
 #include <linux/module.h>
 
 #include <linux/types.h>
@@ -41,7 +43,6 @@
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/list.h>
-#include <linux/security.h>
 #include <net/sock.h>
 
 #include <asm/system.h>
@@ -62,7 +63,7 @@ static struct bt_sock_list sco_sk_list = {
 static void __sco_chan_add(struct sco_conn *conn, struct sock *sk, struct sock *parent);
 static void sco_chan_del(struct sock *sk, int err);
 
-static int  sco_conn_del(struct hci_conn *conn, int err);
+static int  sco_conn_del(struct hci_conn *conn, int err, u8 is_process);
 
 static void sco_sock_close(struct sock *sk);
 static void sco_sock_kill(struct sock *sk);
@@ -135,7 +136,7 @@ static inline struct sock *sco_chan_get(struct sco_conn *conn)
 	return sk;
 }
 
-static int sco_conn_del(struct hci_conn *hcon, int err)
+static int sco_conn_del(struct hci_conn *hcon, int err, u8 is_process)
 {
 	struct sco_conn *conn = hcon->sco_data;
 	struct sock *sk;
@@ -148,10 +149,16 @@ static int sco_conn_del(struct hci_conn *hcon, int err)
 	/* Kill socket */
 	sk = sco_chan_get(conn);
 	if (sk) {
-		bh_lock_sock(sk);
+		if (is_process)
+			lock_sock(sk);
+		else
+			bh_lock_sock(sk);
 		sco_sock_clear_timer(sk);
 		sco_chan_del(sk, err);
-		bh_unlock_sock(sk);
+		if (is_process)
+			release_sock(sk);
+		else
+			bh_unlock_sock(sk);
 		sco_sock_kill(sk);
 	}
 
@@ -174,7 +181,7 @@ static inline int sco_chan_add(struct sco_conn *conn, struct sock *sk, struct so
 	return err;
 }
 
-static int sco_connect(struct sock *sk)
+static int sco_connect(struct sock *sk, __s8 is_wbs)
 {
 	bdaddr_t *src = &bt_sk(sk)->src;
 	bdaddr_t *dst = &bt_sk(sk)->dst;
@@ -190,21 +197,35 @@ static int sco_connect(struct sock *sk)
 	if (!hdev)
 		return -EHOSTUNREACH;
 
-	hci_dev_lock(hdev);
+	hci_dev_lock_bh(hdev);
+
+	hdev->is_wbs = is_wbs;
 
-	if (lmp_esco_capable(hdev) && !disable_esco)
+	if (lmp_esco_capable(hdev) && !disable_esco) {
 		type = ESCO_LINK;
-	else {
+	} else if (is_wbs) {
+		return -ENAVAIL;
+	} else {
 		type = SCO_LINK;
 		pkt_type &= SCO_ESCO_MASK;
 	}
 
-	hcon = hci_connect(hdev, type, pkt_type, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);
+	BT_DBG("type: %d, pkt_type: 0x%x", type, pkt_type);
+
+	hcon = hci_connect(hdev, type, pkt_type, dst,
+					BT_SECURITY_LOW, HCI_AT_NO_BONDING);
 	if (IS_ERR(hcon)) {
 		err = PTR_ERR(hcon);
 		goto done;
 	}
 
+	if (is_wbs && (hcon->type != ESCO_LINK)) {
+		BT_ERR("WBS [ hcon->type: 0x%x, hcon->pkt_type: 0x%x ]",
+				hcon->type, hcon->pkt_type);
+		err = -EREMOTEIO;
+		goto done;
+	}
+
 	conn = sco_conn_add(hcon, 0);
 	if (!conn) {
 		hci_conn_put(hcon);
@@ -228,7 +249,7 @@ static int sco_connect(struct sock *sk)
 	}
 
 done:
-	hci_dev_unlock(hdev);
+	hci_dev_unlock_bh(hdev);
 	hci_dev_put(hdev);
 	return err;
 }
@@ -376,7 +397,7 @@ static void __sco_sock_close(struct sock *sk)
 		if (sco_pi(sk)->conn) {
 			sk->sk_state = BT_DISCONN;
 			sco_sock_set_timer(sk, SCO_DISCONN_TIMEOUT);
-			if (sco_pi(sk)->conn->hcon) {
+			if (sco_pi(sk)->conn->hcon != NULL) {
 				hci_conn_put(sco_pi(sk)->conn->hcon);
 				sco_pi(sk)->conn->hcon = NULL;
 			}
@@ -409,10 +430,8 @@ static void sco_sock_init(struct sock *sk, struct sock *parent)
 {
 	BT_DBG("sk %p", sk);
 
-	if (parent) {
+	if (parent)
 		sk->sk_type = parent->sk_type;
-		security_sk_clone(parent, sk);
-	}
 }
 
 static struct proto sco_proto = {
@@ -491,7 +510,7 @@ static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
 		goto done;
 	}
 
-	write_lock(&sco_sk_list.lock);
+	write_lock_bh(&sco_sk_list.lock);
 
 	if (bacmp(src, BDADDR_ANY) && __sco_get_sock_by_addr(src)) {
 		err = -EADDRINUSE;
@@ -502,7 +521,7 @@ static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
 		sk->sk_state = BT_BOUND;
 	}
 
-	write_unlock(&sco_sk_list.lock);
+	write_unlock_bh(&sco_sk_list.lock);
 
 done:
 	release_sock(sk);
@@ -540,7 +559,7 @@ static int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int alen
 	bacpy(&bt_sk(sk)->dst, &sa.sco_bdaddr);
 	sco_pi(sk)->pkt_type = sa.sco_pkt_type;
 
-	err = sco_connect(sk);
+	err = sco_connect(sk, sa.is_wbs);
 	if (err)
 		goto done;
 
@@ -584,26 +603,30 @@ static int sco_sock_accept(struct socket *sock, struct socket *newsock, int flag
 
 	lock_sock(sk);
 
+	if (sk->sk_state != BT_LISTEN) {
+		err = -EBADFD;
+		goto done;
+	}
+
 	timeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);
 
 	BT_DBG("sk %p timeo %ld", sk, timeo);
 
 	/* Wait for an incoming connection. (wake-one). */
 	add_wait_queue_exclusive(sk_sleep(sk), &wait);
-	while (1) {
+	while (!(ch = bt_accept_dequeue(sk, newsock))) {
 		set_current_state(TASK_INTERRUPTIBLE);
-
-		if (sk->sk_state != BT_LISTEN) {
-			err = -EBADFD;
+		if (!timeo) {
+			err = -EAGAIN;
 			break;
 		}
 
-		ch = bt_accept_dequeue(sk, newsock);
-		if (ch)
-			break;
+		release_sock(sk);
+		timeo = schedule_timeout(timeo);
+		lock_sock(sk);
 
-		if (!timeo) {
-			err = -EAGAIN;
+		if (sk->sk_state != BT_LISTEN) {
+			err = -EBADFD;
 			break;
 		}
 
@@ -611,12 +634,8 @@ static int sco_sock_accept(struct socket *sock, struct socket *newsock, int flag
 			err = sock_intr_errno(timeo);
 			break;
 		}
-
-		release_sock(sk);
-		timeo = schedule_timeout(timeo);
-		lock_sock(sk);
 	}
-	__set_current_state(TASK_RUNNING);
+	set_current_state(TASK_RUNNING);
 	remove_wait_queue(sk_sleep(sk), &wait);
 
 	if (err)
@@ -795,6 +814,9 @@ static int sco_sock_shutdown(struct socket *sock, int how)
 		if (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime)
 			err = bt_sock_wait_state(sk, BT_CLOSED,
 							sk->sk_lingertime);
+		else
+			err = bt_sock_wait_state(sk, BT_CLOSED,
+							SCO_DISCONN_TIMEOUT);
 	}
 	release_sock(sk);
 	return err;
@@ -816,6 +838,11 @@ static int sco_sock_release(struct socket *sock)
 		lock_sock(sk);
 		err = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);
 		release_sock(sk);
+	} else {
+		lock_sock(sk);
+		err = bt_sock_wait_state(sk, BT_CLOSED,
+							SCO_DISCONN_TIMEOUT);
+		release_sock(sk);
 	}
 
 	sock_orphan(sk);
@@ -911,12 +938,15 @@ done:
 }
 
 /* ----- SCO interface with lower layer (HCI) ----- */
-int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr)
+static int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)
 {
 	register struct sock *sk;
 	struct hlist_node *node;
 	int lm = 0;
 
+	if (type != SCO_LINK && type != ESCO_LINK)
+		return 0;
+
 	BT_DBG("hdev %s, bdaddr %s", hdev->name, batostr(bdaddr));
 
 	/* Find listening sockets */
@@ -936,9 +966,13 @@ int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr)
 	return lm;
 }
 
-int sco_connect_cfm(struct hci_conn *hcon, __u8 status)
+static int sco_connect_cfm(struct hci_conn *hcon, __u8 status)
 {
 	BT_DBG("hcon %p bdaddr %s status %d", hcon, batostr(&hcon->dst), status);
+
+	if (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)
+		return -EINVAL;
+
 	if (!status) {
 		struct sco_conn *conn;
 
@@ -946,20 +980,24 @@ int sco_connect_cfm(struct hci_conn *hcon, __u8 status)
 		if (conn)
 			sco_conn_ready(conn);
 	} else
-		sco_conn_del(hcon, bt_to_errno(status));
+		sco_conn_del(hcon, bt_err(status), 0);
 
 	return 0;
 }
 
-int sco_disconn_cfm(struct hci_conn *hcon, __u8 reason)
+static int sco_disconn_cfm(struct hci_conn *hcon, __u8 reason, __u8 is_process)
 {
 	BT_DBG("hcon %p reason %d", hcon, reason);
 
-	sco_conn_del(hcon, bt_to_errno(reason));
+	if (hcon->type != SCO_LINK && hcon->type != ESCO_LINK)
+		return -EINVAL;
+
+	sco_conn_del(hcon, bt_err(reason), is_process);
+
 	return 0;
 }
 
-int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)
+static int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)
 {
 	struct sco_conn *conn = hcon->sco_data;
 
@@ -983,14 +1021,14 @@ static int sco_debugfs_show(struct seq_file *f, void *p)
 	struct sock *sk;
 	struct hlist_node *node;
 
-	read_lock(&sco_sk_list.lock);
+	read_lock_bh(&sco_sk_list.lock);
 
 	sk_for_each(sk, node, &sco_sk_list.head) {
 		seq_printf(f, "%s %s %d\n", batostr(&bt_sk(sk)->src),
 				batostr(&bt_sk(sk)->dst), sk->sk_state);
 	}
 
-	read_unlock(&sco_sk_list.lock);
+	read_unlock_bh(&sco_sk_list.lock);
 
 	return 0;
 }
@@ -1035,6 +1073,15 @@ static const struct net_proto_family sco_sock_family_ops = {
 	.create	= sco_sock_create,
 };
 
+static struct hci_proto sco_hci_proto = {
+	.name		= "SCO",
+	.id		= HCI_PROTO_SCO,
+	.connect_ind	= sco_connect_ind,
+	.connect_cfm	= sco_connect_cfm,
+	.disconn_cfm	= sco_disconn_cfm,
+	.recv_scodata	= sco_recv_scodata
+};
+
 int __init sco_init(void)
 {
 	int err;
@@ -1049,6 +1096,13 @@ int __init sco_init(void)
 		goto error;
 	}
 
+	err = hci_register_proto(&sco_hci_proto);
+	if (err < 0) {
+		BT_ERR("SCO protocol registration failed");
+		bt_sock_unregister(BTPROTO_SCO);
+		goto error;
+	}
+
 	if (bt_debugfs) {
 		sco_debugfs = debugfs_create_file("sco", 0444,
 					bt_debugfs, NULL, &sco_debugfs_fops);
@@ -1072,6 +1126,9 @@ void __exit sco_exit(void)
 	if (bt_sock_unregister(BTPROTO_SCO) < 0)
 		BT_ERR("SCO socket unregistration failed");
 
+	if (hci_unregister_proto(&sco_hci_proto) < 0)
+		BT_ERR("SCO protocol unregistration failed");
+
 	proto_unregister(&sco_proto);
 }
 
diff --git a/net/bluetooth/smp.c b/net/bluetooth/smp.c
index 32a22b2..4a83020 100644
--- a/net/bluetooth/smp.c
+++ b/net/bluetooth/smp.c
@@ -20,17 +20,32 @@
    SOFTWARE IS DISCLAIMED.
 */
 
+#include <linux/interrupt.h>
+#include <linux/module.h>
+
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 #include <net/bluetooth/l2cap.h>
 #include <net/bluetooth/mgmt.h>
 #include <net/bluetooth/smp.h>
 #include <linux/crypto.h>
-#include <linux/scatterlist.h>
 #include <crypto/b128ops.h>
+#include <asm/unaligned.h>
 
 #define SMP_TIMEOUT 30000 /* 30 seconds */
 
+#define SMP_MIN_CONN_INTERVAL	40	/* 50ms (40 * 1.25ms) */
+#define SMP_MAX_CONN_INTERVAL	56	/* 70ms (56 * 1.25ms) */
+#define SMP_MAX_CONN_LATENCY	0	/* 0ms (0 * 1.25ms) */
+#define SMP_SUPERVISION_TIMEOUT	500	/* 5 seconds (500 * 10ms) */
+
+#ifndef FALSE
+#define FALSE 0
+#define TRUE (!FALSE)
+#endif
+
+static int smp_distribute_keys(struct l2cap_conn *conn, __u8 force);
+
 static inline void swap128(u8 src[16], u8 dst[16])
 {
 	int i;
@@ -147,7 +162,7 @@ static int smp_rand(u8 *buf)
 }
 
 static struct sk_buff *smp_build_cmd(struct l2cap_conn *conn, u8 code,
-						u16 dlen, void *data)
+		u16 dlen, void *data)
 {
 	struct sk_buff *skb;
 	struct l2cap_hdr *lh;
@@ -182,29 +197,26 @@ static void smp_send_cmd(struct l2cap_conn *conn, u8 code, u16 len, void *data)
 	if (!skb)
 		return;
 
-	skb->priority = HCI_PRIO_MAX;
-	hci_send_acl(conn->hchan, skb, 0);
-
-	cancel_delayed_work_sync(&conn->security_timer);
-	schedule_delayed_work(&conn->security_timer,
-					msecs_to_jiffies(SMP_TIMEOUT));
+	hci_send_acl(conn->hcon, NULL, skb, 0);
 }
 
 static __u8 authreq_to_seclevel(__u8 authreq)
 {
 	if (authreq & SMP_AUTH_MITM)
 		return BT_SECURITY_HIGH;
-	else
+	else if (authreq & SMP_AUTH_BONDING)
 		return BT_SECURITY_MEDIUM;
+	else
+		return BT_SECURITY_LOW;
 }
 
-static __u8 seclevel_to_authreq(__u8 sec_level)
+static __u8 seclevel_to_authreq(__u8 level)
 {
-	switch (sec_level) {
+	switch (level) {
+	case BT_SECURITY_VERY_HIGH:
 	case BT_SECURITY_HIGH:
 		return SMP_AUTH_MITM | SMP_AUTH_BONDING;
-	case BT_SECURITY_MEDIUM:
-		return SMP_AUTH_BONDING;
+
 	default:
 		return SMP_AUTH_NONE;
 	}
@@ -215,591 +227,562 @@ static void build_pairing_cmd(struct l2cap_conn *conn,
 				struct smp_cmd_pairing *rsp,
 				__u8 authreq)
 {
+	struct hci_conn *hcon = conn->hcon;
+	u8 all_keys = 0;
 	u8 dist_keys = 0;
 
-	if (test_bit(HCI_PAIRABLE, &conn->hcon->hdev->flags)) {
-		dist_keys = SMP_DIST_ENC_KEY;
-		authreq |= SMP_AUTH_BONDING;
-	} else {
-		authreq &= ~SMP_AUTH_BONDING;
-	}
+	dist_keys = SMP_DIST_ENC_KEY;
+	authreq |= SMP_AUTH_BONDING;
+
+	BT_DBG("conn->hcon->io_capability:%d", conn->hcon->io_capability);
 
 	if (rsp == NULL) {
 		req->io_capability = conn->hcon->io_capability;
-		req->oob_flag = SMP_OOB_NOT_PRESENT;
+		req->oob_flag = hcon->oob ? SMP_OOB_PRESENT :
+							SMP_OOB_NOT_PRESENT;
 		req->max_key_size = SMP_MAX_ENC_KEY_SIZE;
-		req->init_key_dist = 0;
+		req->init_key_dist = all_keys;
 		req->resp_key_dist = dist_keys;
 		req->auth_req = authreq;
+		BT_DBG("SMP_CMD_PAIRING_REQ %d %d %d %d %2.2x %2.2x",
+				req->io_capability, req->oob_flag,
+				req->auth_req, req->max_key_size,
+				req->init_key_dist, req->resp_key_dist);
 		return;
 	}
 
+	/* Only request OOB if remote AND we support it */
+	if (req->oob_flag)
+		rsp->oob_flag = hcon->oob ? SMP_OOB_PRESENT :
+						SMP_OOB_NOT_PRESENT;
+	else
+		rsp->oob_flag = SMP_OOB_NOT_PRESENT;
+
 	rsp->io_capability = conn->hcon->io_capability;
-	rsp->oob_flag = SMP_OOB_NOT_PRESENT;
 	rsp->max_key_size = SMP_MAX_ENC_KEY_SIZE;
-	rsp->init_key_dist = 0;
+	rsp->init_key_dist = req->init_key_dist & all_keys;
 	rsp->resp_key_dist = req->resp_key_dist & dist_keys;
 	rsp->auth_req = authreq;
+	BT_DBG("SMP_CMD_PAIRING_RSP %d %d %d %d %2.2x %2.2x",
+			req->io_capability, req->oob_flag, req->auth_req,
+			req->max_key_size, req->init_key_dist,
+			req->resp_key_dist);
 }
 
 static u8 check_enc_key_size(struct l2cap_conn *conn, __u8 max_key_size)
 {
-	struct smp_chan *smp = conn->smp_chan;
+	struct hci_conn *hcon = conn->hcon;
 
 	if ((max_key_size > SMP_MAX_ENC_KEY_SIZE) ||
 			(max_key_size < SMP_MIN_ENC_KEY_SIZE))
 		return SMP_ENC_KEY_SIZE;
 
-	smp->smp_key_size = max_key_size;
+	hcon->smp_key_size = max_key_size;
 
 	return 0;
 }
 
-static void smp_failure(struct l2cap_conn *conn, u8 reason, u8 send)
-{
-	if (send)
-		smp_send_cmd(conn, SMP_CMD_PAIRING_FAIL, sizeof(reason),
-								&reason);
-
-	clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->hcon->pend);
-	mgmt_auth_failed(conn->hcon->hdev, conn->dst, reason);
-	cancel_delayed_work_sync(&conn->security_timer);
-	smp_chan_destroy(conn);
-}
-
-#define JUST_WORKS	0x00
-#define JUST_CFM	0x01
-#define REQ_PASSKEY	0x02
-#define CFM_PASSKEY	0x03
-#define REQ_OOB		0x04
-#define OVERLAP		0xFF
-
-static const u8 gen_method[5][5] = {
-	{ JUST_WORKS,  JUST_CFM,    REQ_PASSKEY, JUST_WORKS, REQ_PASSKEY },
-	{ JUST_WORKS,  JUST_CFM,    REQ_PASSKEY, JUST_WORKS, REQ_PASSKEY },
-	{ CFM_PASSKEY, CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, CFM_PASSKEY },
-	{ JUST_WORKS,  JUST_CFM,    JUST_WORKS,  JUST_WORKS, JUST_CFM    },
-	{ CFM_PASSKEY, CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, OVERLAP     },
+#define JUST_WORKS	SMP_JUST_WORKS
+#define REQ_PASSKEY	SMP_REQ_PASSKEY
+#define CFM_PASSKEY	SMP_CFM_PASSKEY
+#define JUST_CFM	SMP_JUST_CFM
+#define OVERLAP		SMP_OVERLAP
+static const u8	gen_method[5][5] = {
+	{JUST_WORKS,  JUST_CFM,    REQ_PASSKEY, JUST_WORKS, REQ_PASSKEY},
+	{JUST_WORKS,  JUST_CFM,    REQ_PASSKEY, JUST_WORKS, REQ_PASSKEY},
+	{CFM_PASSKEY, CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, CFM_PASSKEY},
+	{JUST_WORKS,  JUST_CFM,    JUST_WORKS,  JUST_WORKS, JUST_CFM},
+	{CFM_PASSKEY, CFM_PASSKEY, REQ_PASSKEY, JUST_WORKS, OVERLAP}
 };
 
 static int tk_request(struct l2cap_conn *conn, u8 remote_oob, u8 auth,
 						u8 local_io, u8 remote_io)
 {
 	struct hci_conn *hcon = conn->hcon;
-	struct smp_chan *smp = conn->smp_chan;
 	u8 method;
 	u32 passkey = 0;
 	int ret = 0;
 
-	/* Initialize key for JUST WORKS */
-	memset(smp->tk, 0, sizeof(smp->tk));
-	clear_bit(SMP_FLAG_TK_VALID, &smp->smp_flags);
+	/* Initialize key to JUST WORKS */
+	memset(hcon->tk, 0, sizeof(hcon->tk));
+	hcon->tk_valid = FALSE;
+	hcon->auth = auth;
+
+	/* By definition, OOB data will be used if both sides have it available
+	 */
+	if (remote_oob && hcon->oob) {
+		method = SMP_REQ_OOB;
+		goto agent_request;
+	}
 
 	BT_DBG("tk_request: auth:%d lcl:%d rem:%d", auth, local_io, remote_io);
 
 	/* If neither side wants MITM, use JUST WORKS */
-	/* If either side has unknown io_caps, use JUST WORKS */
-	/* Otherwise, look up method from the table */
+	/* If either side has unknown io_caps, use JUST_WORKS */
 	if (!(auth & SMP_AUTH_MITM) ||
 			local_io > SMP_IO_KEYBOARD_DISPLAY ||
-			remote_io > SMP_IO_KEYBOARD_DISPLAY)
-		method = JUST_WORKS;
-	else
-		method = gen_method[local_io][remote_io];
-
-	/* If not bonding, don't ask user to confirm a Zero TK */
-	if (!(auth & SMP_AUTH_BONDING) && method == JUST_CFM)
-		method = JUST_WORKS;
-
-	/* If Just Works, Continue with Zero TK */
-	if (method == JUST_WORKS) {
-		set_bit(SMP_FLAG_TK_VALID, &smp->smp_flags);
+			remote_io > SMP_IO_KEYBOARD_DISPLAY) {
+		hcon->auth &= ~SMP_AUTH_MITM;
+		hcon->tk_valid = TRUE;
 		return 0;
 	}
 
-	/* Not Just Works/Confirm results in MITM Authentication */
-	if (method != JUST_CFM)
-		set_bit(SMP_FLAG_MITM_AUTH, &smp->smp_flags);
+	/* MITM is now officially requested, but not required */
+	/* Determine what we need (if anything) from the agent */
+	method = gen_method[local_io][remote_io];
 
-	/* If both devices have Keyoard-Display I/O, the master
-	 * Confirms and the slave Enters the passkey.
-	 */
-	if (method == OVERLAP) {
+	BT_DBG("tk_method: %d", method);
+
+	if (method == SMP_JUST_WORKS || method == SMP_JUST_CFM)
+		hcon->auth &= ~SMP_AUTH_MITM;
+
+	/* Don't bother confirming unbonded JUST_WORKS */
+	if (!(auth & SMP_AUTH_BONDING) && method == SMP_JUST_CFM) {
+		hcon->tk_valid = TRUE;
+		return 0;
+	} else if (method == SMP_JUST_WORKS) {
+		hcon->tk_valid = TRUE;
+		return 0;
+	} else if (method == SMP_OVERLAP) {
 		if (hcon->link_mode & HCI_LM_MASTER)
-			method = CFM_PASSKEY;
+			method = SMP_CFM_PASSKEY;
 		else
-			method = REQ_PASSKEY;
+			method = SMP_REQ_PASSKEY;
 	}
 
-	/* Generate random passkey. Not valid until confirmed. */
-	if (method == CFM_PASSKEY) {
-		u8 key[16];
+	BT_DBG("tk_method-2: %d", method);
 
+	if (method == SMP_CFM_PASSKEY) {
+		u8 key[16];
+		/* Generate a passkey for display. It is not valid until
+		 * confirmed.
+		 */
 		memset(key, 0, sizeof(key));
 		get_random_bytes(&passkey, sizeof(passkey));
 		passkey %= 1000000;
 		put_unaligned_le32(passkey, key);
-		swap128(key, smp->tk);
+		swap128(key, hcon->tk);
 		BT_DBG("PassKey: %d", passkey);
 	}
 
+agent_request:
 	hci_dev_lock(hcon->hdev);
 
-	if (method == REQ_PASSKEY)
-		ret = mgmt_user_passkey_request(hcon->hdev, conn->dst);
-	else
-		ret = mgmt_user_confirm_request(hcon->hdev, conn->dst,
-						cpu_to_le32(passkey), 0);
+	switch (method) {
+	case SMP_REQ_PASSKEY:
+		ret = mgmt_user_confirm_request(hcon->hdev->id,
+				HCI_EV_USER_PASSKEY_REQUEST, conn->dst, 0);
+		break;
+	case SMP_CFM_PASSKEY:
+	default:
+		ret = mgmt_user_confirm_request(hcon->hdev->id,
+			HCI_EV_USER_CONFIRM_REQUEST, conn->dst, passkey);
+		break;
+	}
 
 	hci_dev_unlock(hcon->hdev);
 
 	return ret;
 }
 
-static void confirm_work(struct work_struct *work)
+static int send_pairing_confirm(struct l2cap_conn *conn)
 {
-	struct smp_chan *smp = container_of(work, struct smp_chan, confirm);
-	struct l2cap_conn *conn = smp->conn;
-	struct crypto_blkcipher *tfm;
+	struct hci_conn *hcon = conn->hcon;
+	struct crypto_blkcipher *tfm = hcon->hdev->tfm;
 	struct smp_cmd_pairing_confirm cp;
 	int ret;
-	u8 res[16], reason;
-
-	BT_DBG("conn %p", conn);
-
-	tfm = crypto_alloc_blkcipher("ecb(aes)", 0, CRYPTO_ALG_ASYNC);
-	if (IS_ERR(tfm)) {
-		reason = SMP_UNSPECIFIED;
-		goto error;
-	}
-
-	smp->tfm = tfm;
+	u8 res[16];
 
 	if (conn->hcon->out)
-		ret = smp_c1(tfm, smp->tk, smp->prnd, smp->preq, smp->prsp, 0,
-				conn->src, conn->hcon->dst_type, conn->dst,
-				res);
+		ret = smp_c1(tfm, hcon->tk, hcon->prnd, hcon->preq, hcon->prsp,
+				0, conn->src, hcon->dst_type, conn->dst, res);
 	else
-		ret = smp_c1(tfm, smp->tk, smp->prnd, smp->preq, smp->prsp,
-				conn->hcon->dst_type, conn->dst, 0, conn->src,
-				res);
-	if (ret) {
-		reason = SMP_UNSPECIFIED;
-		goto error;
-	}
+		ret = smp_c1(tfm, hcon->tk, hcon->prnd, hcon->preq, hcon->prsp,
+				hcon->dst_type, conn->dst, 0, conn->src, res);
 
-	clear_bit(SMP_FLAG_CFM_PENDING, &smp->smp_flags);
+	if (ret)
+		return SMP_CONFIRM_FAILED;
 
 	swap128(res, cp.confirm_val);
-	smp_send_cmd(smp->conn, SMP_CMD_PAIRING_CONFIRM, sizeof(cp), &cp);
-
-	return;
-
-error:
-	smp_failure(conn, reason, 1);
-}
-
-static void random_work(struct work_struct *work)
-{
-	struct smp_chan *smp = container_of(work, struct smp_chan, random);
-	struct l2cap_conn *conn = smp->conn;
-	struct hci_conn *hcon = conn->hcon;
-	struct crypto_blkcipher *tfm = smp->tfm;
-	u8 reason, confirm[16], res[16], key[16];
-	int ret;
-
-	if (IS_ERR_OR_NULL(tfm)) {
-		reason = SMP_UNSPECIFIED;
-		goto error;
-	}
-
-	BT_DBG("conn %p %s", conn, conn->hcon->out ? "master" : "slave");
-
-	if (hcon->out)
-		ret = smp_c1(tfm, smp->tk, smp->rrnd, smp->preq, smp->prsp, 0,
-				conn->src, hcon->dst_type, conn->dst,
-				res);
-	else
-		ret = smp_c1(tfm, smp->tk, smp->rrnd, smp->preq, smp->prsp,
-				hcon->dst_type, conn->dst, 0, conn->src,
-				res);
-	if (ret) {
-		reason = SMP_UNSPECIFIED;
-		goto error;
-	}
-
-	swap128(res, confirm);
-
-	if (memcmp(smp->pcnf, confirm, sizeof(smp->pcnf)) != 0) {
-		BT_ERR("Pairing failed (confirmation values mismatch)");
-		reason = SMP_CONFIRM_FAILED;
-		goto error;
-	}
-
-	if (hcon->out) {
-		u8 stk[16], rand[8];
-		__le16 ediv;
-
-		memset(rand, 0, sizeof(rand));
-		ediv = 0;
-
-		smp_s1(tfm, smp->tk, smp->rrnd, smp->prnd, key);
-		swap128(key, stk);
-
-		memset(stk + smp->smp_key_size, 0,
-				SMP_MAX_ENC_KEY_SIZE - smp->smp_key_size);
-
-		if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend)) {
-			reason = SMP_UNSPECIFIED;
-			goto error;
-		}
-
-		hci_le_start_enc(hcon, ediv, rand, stk);
-		hcon->enc_key_size = smp->smp_key_size;
-	} else {
-		u8 stk[16], r[16], rand[8];
-		__le16 ediv;
-
-		memset(rand, 0, sizeof(rand));
-		ediv = 0;
-
-		swap128(smp->prnd, r);
-		smp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM, sizeof(r), r);
-
-		smp_s1(tfm, smp->tk, smp->prnd, smp->rrnd, key);
-		swap128(key, stk);
-
-		memset(stk + smp->smp_key_size, 0,
-				SMP_MAX_ENC_KEY_SIZE - smp->smp_key_size);
-
-		hci_add_ltk(hcon->hdev, 0, conn->dst, smp->smp_key_size,
-							ediv, rand, stk);
-	}
-
-	return;
-
-error:
-	smp_failure(conn, reason, 1);
-}
-
-static struct smp_chan *smp_chan_create(struct l2cap_conn *conn)
-{
-	struct smp_chan *smp;
-
-	smp = kzalloc(sizeof(struct smp_chan), GFP_ATOMIC);
-	if (!smp)
-		return NULL;
-
-	INIT_WORK(&smp->confirm, confirm_work);
-	INIT_WORK(&smp->random, random_work);
 
-	smp->conn = conn;
-	conn->smp_chan = smp;
-	conn->hcon->smp_conn = conn;
+	hcon->cfm_pending = FALSE;
 
-	hci_conn_hold(conn->hcon);
+	smp_send_cmd(conn, SMP_CMD_PAIRING_CONFIRM, sizeof(cp), &cp);
 
-	return smp;
-}
-
-void smp_chan_destroy(struct l2cap_conn *conn)
-{
-	struct smp_chan *smp = conn->smp_chan;
-
-	clear_bit(HCI_CONN_LE_SMP_PEND, &conn->hcon->pend);
-
-	if (smp->tfm)
-		crypto_free_blkcipher(smp->tfm);
-
-	kfree(smp);
-	conn->smp_chan = NULL;
-	conn->hcon->smp_conn = NULL;
-	hci_conn_put(conn->hcon);
+	return 0;
 }
 
-int smp_user_confirm_reply(struct hci_conn *hcon, u16 mgmt_op, __le32 passkey)
+int le_user_confirm_reply(struct hci_conn *hcon, u16 mgmt_op, void *cp)
 {
+	struct mgmt_cp_user_passkey_reply *psk_reply = cp;
 	struct l2cap_conn *conn = hcon->smp_conn;
-	struct smp_chan *smp;
-	u32 value;
 	u8 key[16];
+	u8 reason = 0;
+	int ret = 0;
 
 	BT_DBG("");
 
-	if (!conn)
-		return -ENOTCONN;
-
-	smp = conn->smp_chan;
+	hcon->tk_valid = TRUE;
 
 	switch (mgmt_op) {
+	case MGMT_OP_USER_CONFIRM_NEG_REPLY:
+		reason = SMP_CONFIRM_FAILED;
+		break;
+	case MGMT_OP_USER_CONFIRM_REPLY:
+		break;
 	case MGMT_OP_USER_PASSKEY_REPLY:
-		value = le32_to_cpu(passkey);
 		memset(key, 0, sizeof(key));
-		BT_DBG("PassKey: %d", value);
-		put_unaligned_le32(value, key);
-		swap128(key, smp->tk);
-		/* Fall Through */
-	case MGMT_OP_USER_CONFIRM_REPLY:
-		set_bit(SMP_FLAG_TK_VALID, &smp->smp_flags);
+		BT_DBG("PassKey: %d", psk_reply->passkey);
+		put_unaligned_le32(psk_reply->passkey, key);
+		swap128(key, hcon->tk);
 		break;
-	case MGMT_OP_USER_PASSKEY_NEG_REPLY:
-	case MGMT_OP_USER_CONFIRM_NEG_REPLY:
-		smp_failure(conn, SMP_PASSKEY_ENTRY_FAILED, 1);
-		return 0;
 	default:
-		smp_failure(conn, SMP_PASSKEY_ENTRY_FAILED, 1);
-		return -EOPNOTSUPP;
+		reason = SMP_CONFIRM_FAILED;
+		ret = -EOPNOTSUPP;
+		break;
 	}
 
-	/* If it is our turn to send Pairing Confirm, do so now */
-	if (test_bit(SMP_FLAG_CFM_PENDING, &smp->smp_flags))
-		queue_work(hcon->hdev->workqueue, &smp->confirm);
+	if (reason) {
+		BT_DBG("smp_send_cmd: SMP_CMD_PAIRING_FAIL");
+		smp_send_cmd(conn, SMP_CMD_PAIRING_FAIL, sizeof(reason),
+								&reason);
+		del_timer(&hcon->smp_timer);
+		if (hcon->disconn_cfm_cb)
+			hcon->disconn_cfm_cb(hcon, SMP_UNSPECIFIED);
+		clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
+		mgmt_auth_failed(hcon->hdev->id, conn->dst, reason);
+		hci_conn_put(hcon);
+	} else if (hcon->cfm_pending) {
+		BT_DBG("send_pairing_confirm");
+		ret = send_pairing_confirm(conn);
+	}
 
-	return 0;
+	return ret;
 }
 
 static u8 smp_cmd_pairing_req(struct l2cap_conn *conn, struct sk_buff *skb)
 {
+	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_pairing rsp, *req = (void *) skb->data;
-	struct smp_chan *smp;
 	u8 key_size;
 	u8 auth = SMP_AUTH_NONE;
 	int ret;
 
 	BT_DBG("conn %p", conn);
 
-	if (conn->hcon->link_mode & HCI_LM_MASTER)
-		return SMP_CMD_NOTSUPP;
-
-	if (!test_and_set_bit(HCI_CONN_LE_SMP_PEND, &conn->hcon->pend))
-		smp = smp_chan_create(conn);
-
-	smp = conn->smp_chan;
-
-	smp->preq[0] = SMP_CMD_PAIRING_REQ;
-	memcpy(&smp->preq[1], req, sizeof(*req));
+	hcon->preq[0] = SMP_CMD_PAIRING_REQ;
+	memcpy(&hcon->preq[1], req, sizeof(*req));
 	skb_pull(skb, sizeof(*req));
 
-	/* We didn't start the pairing, so match remote */
-	if (req->auth_req & SMP_AUTH_BONDING)
-		auth = req->auth_req;
+	if (req->oob_flag && hcon->oob) {
+		/* By definition, OOB data pairing will have MITM protection */
+		auth = req->auth_req | SMP_AUTH_MITM;
+	} else if (req->auth_req & SMP_AUTH_BONDING) {
+		/* We will attempt MITM for all Bonding attempts */
+		auth = SMP_AUTH_BONDING | SMP_AUTH_MITM;
+	}
 
+	/* We didn't start the pairing, so no requirements */
 	build_pairing_cmd(conn, req, &rsp, auth);
 
 	key_size = min(req->max_key_size, rsp.max_key_size);
 	if (check_enc_key_size(conn, key_size))
 		return SMP_ENC_KEY_SIZE;
 
-	ret = smp_rand(smp->prnd);
+	ret = smp_rand(hcon->prnd);
 	if (ret)
 		return SMP_UNSPECIFIED;
 
-	smp->prsp[0] = SMP_CMD_PAIRING_RSP;
-	memcpy(&smp->prsp[1], &rsp, sizeof(rsp));
-
-	smp_send_cmd(conn, SMP_CMD_PAIRING_RSP, sizeof(rsp), &rsp);
-
 	/* Request setup of TK */
-	ret = tk_request(conn, 0, auth, rsp.io_capability, req->io_capability);
+	ret = tk_request(conn, req->oob_flag, auth, rsp.io_capability,
+							req->io_capability);
 	if (ret)
 		return SMP_UNSPECIFIED;
 
+	hcon->prsp[0] = SMP_CMD_PAIRING_RSP;
+	memcpy(&hcon->prsp[1], &rsp, sizeof(rsp));
+
+	smp_send_cmd(conn, SMP_CMD_PAIRING_RSP, sizeof(rsp), &rsp);
+
+	mod_timer(&hcon->smp_timer, jiffies + msecs_to_jiffies(SMP_TIMEOUT));
+
 	return 0;
 }
 
 static u8 smp_cmd_pairing_rsp(struct l2cap_conn *conn, struct sk_buff *skb)
 {
+	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_pairing *req, *rsp = (void *) skb->data;
-	struct smp_chan *smp = conn->smp_chan;
-	struct hci_dev *hdev = conn->hcon->hdev;
 	u8 key_size, auth = SMP_AUTH_NONE;
 	int ret;
 
 	BT_DBG("conn %p", conn);
 
-	if (!(conn->hcon->link_mode & HCI_LM_MASTER))
-		return SMP_CMD_NOTSUPP;
-
 	skb_pull(skb, sizeof(*rsp));
 
-	req = (void *) &smp->preq[1];
+	req = (void *) &hcon->preq[1];
 
 	key_size = min(req->max_key_size, rsp->max_key_size);
 	if (check_enc_key_size(conn, key_size))
 		return SMP_ENC_KEY_SIZE;
 
-	ret = smp_rand(smp->prnd);
+	hcon->prsp[0] = SMP_CMD_PAIRING_RSP;
+	memcpy(&hcon->prsp[1], rsp, sizeof(*rsp));
+
+	ret = smp_rand(hcon->prnd);
 	if (ret)
 		return SMP_UNSPECIFIED;
 
-	smp->prsp[0] = SMP_CMD_PAIRING_RSP;
-	memcpy(&smp->prsp[1], rsp, sizeof(*rsp));
-
 	if ((req->auth_req & SMP_AUTH_BONDING) &&
 			(rsp->auth_req & SMP_AUTH_BONDING))
 		auth = SMP_AUTH_BONDING;
 
 	auth |= (req->auth_req | rsp->auth_req) & SMP_AUTH_MITM;
 
-	ret = tk_request(conn, 0, auth, rsp->io_capability, req->io_capability);
+	ret = tk_request(conn, req->oob_flag, auth, rsp->io_capability,
+							req->io_capability);
 	if (ret)
 		return SMP_UNSPECIFIED;
 
-	set_bit(SMP_FLAG_CFM_PENDING, &smp->smp_flags);
+	hcon->cfm_pending = TRUE;
 
 	/* Can't compose response until we have been confirmed */
-	if (!test_bit(SMP_FLAG_TK_VALID, &smp->smp_flags))
+	if (!hcon->tk_valid)
 		return 0;
 
-	queue_work(hdev->workqueue, &smp->confirm);
+	ret = send_pairing_confirm(conn);
+	if (ret)
+		return SMP_CONFIRM_FAILED;
 
 	return 0;
 }
 
 static u8 smp_cmd_pairing_confirm(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct smp_chan *smp = conn->smp_chan;
-	struct hci_dev *hdev = conn->hcon->hdev;
+	struct hci_conn *hcon = conn->hcon;
+	int ret;
 
 	BT_DBG("conn %p %s", conn, conn->hcon->out ? "master" : "slave");
 
-	memcpy(smp->pcnf, skb->data, sizeof(smp->pcnf));
-	skb_pull(skb, sizeof(smp->pcnf));
+	memcpy(hcon->pcnf, skb->data, sizeof(hcon->pcnf));
+	skb_pull(skb, sizeof(hcon->pcnf));
 
 	if (conn->hcon->out) {
 		u8 random[16];
 
-		swap128(smp->prnd, random);
+		swap128(hcon->prnd, random);
 		smp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM, sizeof(random),
 								random);
-	} else if (test_bit(SMP_FLAG_TK_VALID, &smp->smp_flags)) {
-		queue_work(hdev->workqueue, &smp->confirm);
-	} else {
-		set_bit(SMP_FLAG_CFM_PENDING, &smp->smp_flags);
-	}
+	} else if (hcon->tk_valid) {
+		ret = send_pairing_confirm(conn);
+
+		if (ret)
+			return SMP_CONFIRM_FAILED;
+	} else
+		hcon->cfm_pending = TRUE;
+
+
+	mod_timer(&hcon->smp_timer, jiffies + msecs_to_jiffies(SMP_TIMEOUT));
 
 	return 0;
 }
 
 static u8 smp_cmd_pairing_random(struct l2cap_conn *conn, struct sk_buff *skb)
 {
-	struct smp_chan *smp = conn->smp_chan;
-	struct hci_dev *hdev = conn->hcon->hdev;
+	struct hci_conn *hcon = conn->hcon;
+	struct crypto_blkcipher *tfm = hcon->hdev->tfm;
+	int ret;
+	u8 key[16], res[16], random[16], confirm[16];
 
-	BT_DBG("conn %p", conn);
+	swap128(skb->data, random);
+	skb_pull(skb, sizeof(random));
 
-	swap128(skb->data, smp->rrnd);
-	skb_pull(skb, sizeof(smp->rrnd));
+	if (conn->hcon->out)
+		ret = smp_c1(tfm, hcon->tk, random, hcon->preq, hcon->prsp, 0,
+				conn->src, hcon->dst_type, conn->dst,
+				res);
+	else
+		ret = smp_c1(tfm, hcon->tk, random, hcon->preq, hcon->prsp,
+				hcon->dst_type, conn->dst, 0, conn->src,
+				res);
+	if (ret)
+		return SMP_UNSPECIFIED;
+
+	BT_DBG("conn %p %s", conn, conn->hcon->out ? "master" : "slave");
+
+	swap128(res, confirm);
 
-	queue_work(hdev->workqueue, &smp->random);
+	if (memcmp(hcon->pcnf, confirm, sizeof(hcon->pcnf)) != 0) {
+		BT_ERR("Pairing failed (confirmation values mismatch)");
+		return SMP_CONFIRM_FAILED;
+	}
+
+	if (conn->hcon->out) {
+		u8 stk[16], rand[8];
+		__le16 ediv;
+
+		memset(rand, 0, sizeof(rand));
+		ediv = 0;
+
+		smp_s1(tfm, hcon->tk, random, hcon->prnd, key);
+		swap128(key, stk);
+
+		memset(stk + hcon->smp_key_size, 0,
+				SMP_MAX_ENC_KEY_SIZE - hcon->smp_key_size);
+
+		hci_le_start_enc(hcon, ediv, rand, stk);
+		hcon->enc_key_size = hcon->smp_key_size;
+	} else {
+		u8 stk[16], r[16], rand[8];
+		__le16 ediv;
+
+		memset(rand, 0, sizeof(rand));
+		ediv = 0;
+
+		swap128(hcon->prnd, r);
+		smp_send_cmd(conn, SMP_CMD_PAIRING_RANDOM, sizeof(r), r);
+
+		smp_s1(tfm, hcon->tk, hcon->prnd, random, key);
+		swap128(key, stk);
+
+		memset(stk + hcon->smp_key_size, 0,
+				SMP_MAX_ENC_KEY_SIZE - hcon->smp_key_size);
+
+		hci_add_ltk(conn->hcon->hdev, 0, conn->dst, hcon->dst_type,
+			hcon->smp_key_size, hcon->auth, ediv, rand, stk);
+	}
 
 	return 0;
 }
 
-static u8 smp_ltk_encrypt(struct l2cap_conn *conn)
+static int smp_encrypt_link(struct hci_conn *hcon, struct link_key *key)
 {
-	struct link_key *key;
 	struct key_master_id *master;
-	struct hci_conn *hcon = conn->hcon;
+	u8 sec_level;
+	u8 zerobuf[8];
 
-	key = hci_find_link_key_type(hcon->hdev, conn->dst,
-						HCI_LK_SMP_LTK);
-	if (!key)
-		return 0;
+	if (!hcon || !key || !key->data)
+		return -EINVAL;
 
-	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND,
-					&hcon->pend))
-		return 1;
+	memset(zerobuf, 0, sizeof(zerobuf));
 
 	master = (void *) key->data;
-	hci_le_start_enc(hcon, master->ediv, master->rand,
-						key->val);
+
+	if (!master->ediv && !memcmp(master->rand, zerobuf, sizeof(zerobuf)))
+		return -EINVAL;
+
 	hcon->enc_key_size = key->pin_len;
+	hcon->sec_req = TRUE;
+	sec_level = authreq_to_seclevel(key->auth);
+
+	BT_DBG("cur %d, req: %d", hcon->sec_level, sec_level);
 
-	return 1;
+	if (sec_level > hcon->sec_level)
+		hcon->pending_sec_level = sec_level;
 
+
+	if (!(hcon->link_mode & HCI_LM_ENCRYPT))
+		hci_conn_hold(hcon);
+
+	hci_le_start_enc(hcon, master->ediv, master->rand, key->val);
+
+	return 0;
 }
+
 static u8 smp_cmd_security_req(struct l2cap_conn *conn, struct sk_buff *skb)
 {
+	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_security_req *rp = (void *) skb->data;
 	struct smp_cmd_pairing cp;
-	struct hci_conn *hcon = conn->hcon;
-	struct smp_chan *smp;
+	struct link_key *key;
 
 	BT_DBG("conn %p", conn);
 
-	hcon->pending_sec_level = authreq_to_seclevel(rp->auth_req);
-
-	if (smp_ltk_encrypt(conn))
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend))
 		return 0;
 
-	if (test_and_set_bit(HCI_CONN_LE_SMP_PEND, &hcon->pend))
+	key = hci_find_link_key_type(hcon->hdev, conn->dst, KEY_TYPE_LTK);
+	if (key && ((key->auth & SMP_AUTH_MITM) ||
+					!(rp->auth_req & SMP_AUTH_MITM))) {
+
+		if (smp_encrypt_link(hcon, key) < 0)
+			goto invalid_key;
+
 		return 0;
+	}
 
-	smp = smp_chan_create(conn);
+invalid_key:
+	hcon->sec_req = FALSE;
 
 	skb_pull(skb, sizeof(*rp));
 
 	memset(&cp, 0, sizeof(cp));
 	build_pairing_cmd(conn, &cp, NULL, rp->auth_req);
 
-	smp->preq[0] = SMP_CMD_PAIRING_REQ;
-	memcpy(&smp->preq[1], &cp, sizeof(cp));
+	hcon->pending_sec_level = authreq_to_seclevel(rp->auth_req);
+	hcon->preq[0] = SMP_CMD_PAIRING_REQ;
+	memcpy(&hcon->preq[1], &cp, sizeof(cp));
 
 	smp_send_cmd(conn, SMP_CMD_PAIRING_REQ, sizeof(cp), &cp);
 
+	mod_timer(&hcon->smp_timer, jiffies + msecs_to_jiffies(SMP_TIMEOUT));
+
+	set_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
+
+	hci_conn_hold(hcon);
+
 	return 0;
 }
 
 int smp_conn_security(struct l2cap_conn *conn, __u8 sec_level)
 {
 	struct hci_conn *hcon = conn->hcon;
-	struct smp_chan *smp = conn->smp_chan;
 	__u8 authreq;
 
-	BT_DBG("conn %p hcon %p level 0x%2.2x", conn, hcon, sec_level);
+	BT_DBG("conn %p hcon %p %d req: %d",
+			conn, hcon, hcon->sec_level, sec_level);
 
-	if (!lmp_host_le_capable(hcon->hdev))
+	if (IS_ERR(hcon->hdev->tfm))
 		return 1;
 
-	if (sec_level == BT_SECURITY_LOW)
-		return 1;
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend))
+		return -EINPROGRESS;
 
-	if (hcon->sec_level >= sec_level)
+	if (sec_level == BT_SECURITY_LOW)
 		return 1;
 
-	if (hcon->link_mode & HCI_LM_MASTER)
-		if (smp_ltk_encrypt(conn))
-			goto done;
 
-	if (test_and_set_bit(HCI_CONN_LE_SMP_PEND, &hcon->pend))
-		return 0;
-
-	smp = smp_chan_create(conn);
-	if (!smp)
+	if (hcon->sec_level >= sec_level)
 		return 1;
 
 	authreq = seclevel_to_authreq(sec_level);
 
+	hcon->smp_conn = conn;
+	hcon->pending_sec_level = sec_level;
 	if (hcon->link_mode & HCI_LM_MASTER) {
-		struct smp_cmd_pairing cp;
 		struct link_key *key;
 
 		key = hci_find_link_key_type(hcon->hdev, conn->dst,
-							HCI_LK_SMP_LTK);
-		if (key) {
-			struct key_master_id *master = (void *) key->data;
+							KEY_TYPE_LTK);
 
-			hci_le_start_enc(hcon, master->ediv, master->rand,
-								key->val);
+		if (smp_encrypt_link(hcon, key) == 0)
 			goto done;
-		}
+	}
+
+	hcon->sec_req = FALSE;
+
+	if (hcon->link_mode & HCI_LM_MASTER) {
+		struct smp_cmd_pairing cp;
 
 		build_pairing_cmd(conn, &cp, NULL, authreq);
-		smp->preq[0] = SMP_CMD_PAIRING_REQ;
-		memcpy(&smp->preq[1], &cp, sizeof(cp));
+		hcon->preq[0] = SMP_CMD_PAIRING_REQ;
+		memcpy(&hcon->preq[1], &cp, sizeof(cp));
+
+		mod_timer(&hcon->smp_timer, jiffies +
+					msecs_to_jiffies(SMP_TIMEOUT));
 
 		smp_send_cmd(conn, SMP_CMD_PAIRING_REQ, sizeof(cp), &cp);
+		hci_conn_hold(hcon);
 	} else {
 		struct smp_cmd_security_req cp;
 		cp.auth_req = authreq;
@@ -807,50 +790,81 @@ int smp_conn_security(struct l2cap_conn *conn, __u8 sec_level)
 	}
 
 done:
-	hcon->pending_sec_level = sec_level;
+	set_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
 
 	return 0;
 }
 
 static int smp_cmd_encrypt_info(struct l2cap_conn *conn, struct sk_buff *skb)
 {
+	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_encrypt_info *rp = (void *) skb->data;
-	struct smp_chan *smp = conn->smp_chan;
+	u8 rand[8];
+	int err;
 
 	skb_pull(skb, sizeof(*rp));
 
-	memcpy(smp->tk, rp->ltk, sizeof(smp->tk));
+	BT_DBG("conn %p", conn);
+
+	memset(rand, 0, sizeof(rand));
+
+	err = hci_add_ltk(hcon->hdev, 0, conn->dst, hcon->dst_type,
+						0, 0, 0, rand, rp->ltk);
+	if (err)
+		return SMP_UNSPECIFIED;
 
 	return 0;
 }
 
 static int smp_cmd_master_ident(struct l2cap_conn *conn, struct sk_buff *skb)
 {
+	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_master_ident *rp = (void *) skb->data;
-	struct smp_chan *smp = conn->smp_chan;
+	struct smp_cmd_pairing *paircmd = (void *) &hcon->prsp[1];
+	struct link_key *key;
+	u8 *keydist;
 
 	skb_pull(skb, sizeof(*rp));
 
-	hci_add_ltk(conn->hcon->hdev, 1, conn->dst, smp->smp_key_size,
-						rp->ediv, rp->rand, smp->tk);
+	key = hci_find_link_key_type(hcon->hdev, conn->dst, KEY_TYPE_LTK);
+	if (key == NULL)
+		return SMP_UNSPECIFIED;
+
+	if (hcon->out)
+		keydist = &paircmd->resp_key_dist;
+	else
+		keydist = &paircmd->init_key_dist;
+
+	BT_DBG("keydist 0x%x", *keydist);
 
-	smp_distribute_keys(conn, 1);
+	hci_add_ltk(hcon->hdev, 1, conn->dst, hcon->dst_type,
+			hcon->smp_key_size, hcon->auth, rp->ediv,
+			rp->rand, key->val);
+
+	*keydist &= ~SMP_DIST_ENC_KEY;
+	if (hcon->out) {
+		if (!(*keydist))
+			smp_distribute_keys(conn, 1);
+	}
 
 	return 0;
 }
 
 int smp_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb)
 {
+	struct hci_conn *hcon = conn->hcon;
 	__u8 code = skb->data[0];
 	__u8 reason;
 	int err = 0;
 
-	if (!lmp_host_le_capable(conn->hcon->hdev)) {
-		err = -ENOTSUPP;
+	if (IS_ERR(hcon->hdev->tfm)) {
+		err = PTR_ERR(hcon->hdev->tfm);
 		reason = SMP_PAIRING_NOTSUPP;
+		BT_ERR("SMP_PAIRING_NOTSUPP %p", hcon->hdev->tfm);
 		goto done;
 	}
 
+	hcon->smp_conn = conn;
 	skb_pull(skb, sizeof(code));
 
 	switch (code) {
@@ -859,9 +873,12 @@ int smp_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb)
 		break;
 
 	case SMP_CMD_PAIRING_FAIL:
-		smp_failure(conn, skb->data[0], 0);
 		reason = 0;
 		err = -EPERM;
+		del_timer(&hcon->smp_timer);
+		clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
+		mgmt_auth_failed(hcon->hdev->id, conn->dst, skb->data[0]);
+		hci_conn_put(hcon);
 		break;
 
 	case SMP_CMD_PAIRING_RSP:
@@ -904,33 +921,40 @@ int smp_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb)
 	}
 
 done:
-	if (reason)
-		smp_failure(conn, reason, 1);
+	if (reason) {
+		BT_ERR("SMP_CMD_PAIRING_FAIL: %d", reason);
+		smp_send_cmd(conn, SMP_CMD_PAIRING_FAIL, sizeof(reason),
+								&reason);
+		del_timer(&hcon->smp_timer);
+		clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
+		mgmt_auth_failed(hcon->hdev->id, conn->dst, reason);
+		hci_conn_put(hcon);
+	}
 
 	kfree_skb(skb);
 	return err;
 }
 
-int smp_distribute_keys(struct l2cap_conn *conn, __u8 force)
+static int smp_distribute_keys(struct l2cap_conn *conn, __u8 force)
 {
+	struct hci_conn *hcon = conn->hcon;
 	struct smp_cmd_pairing *req, *rsp;
-	struct smp_chan *smp = conn->smp_chan;
 	__u8 *keydist;
 
 	BT_DBG("conn %p force %d", conn, force);
 
-	if (!test_bit(HCI_CONN_LE_SMP_PEND, &conn->hcon->pend))
-		return 0;
+	if (IS_ERR(hcon->hdev->tfm))
+		return PTR_ERR(hcon->hdev->tfm);
 
-	rsp = (void *) &smp->prsp[1];
+	rsp = (void *) &hcon->prsp[1];
 
 	/* The responder sends its keys first */
-	if (!force && conn->hcon->out && (rsp->resp_key_dist & 0x07))
+	if (!force && hcon->out && (rsp->resp_key_dist & 0x07))
 		return 0;
 
-	req = (void *) &smp->preq[1];
+	req = (void *) &hcon->preq[1];
 
-	if (conn->hcon->out) {
+	if (hcon->out) {
 		keydist = &rsp->init_key_dist;
 		*keydist &= req->init_key_dist;
 	} else {
@@ -952,8 +976,9 @@ int smp_distribute_keys(struct l2cap_conn *conn, __u8 force)
 
 		smp_send_cmd(conn, SMP_CMD_ENCRYPT_INFO, sizeof(enc), &enc);
 
-		hci_add_ltk(conn->hcon->hdev, 1, conn->dst, smp->smp_key_size,
-						ediv, ident.rand, enc.ltk);
+		hci_add_ltk(hcon->hdev, 1, conn->dst, hcon->dst_type,
+				hcon->smp_key_size, hcon->auth, ediv,
+				ident.rand, enc.ltk);
 
 		ident.ediv = cpu_to_le16(ediv);
 
@@ -992,11 +1017,55 @@ int smp_distribute_keys(struct l2cap_conn *conn, __u8 force)
 		*keydist &= ~SMP_DIST_SIGN;
 	}
 
-	if (conn->hcon->out || force) {
-		clear_bit(HCI_CONN_LE_SMP_PEND, &conn->hcon->pend);
-		cancel_delayed_work_sync(&conn->security_timer);
-		smp_chan_destroy(conn);
+	if (hcon->out) {
+		if (hcon->disconn_cfm_cb)
+			hcon->disconn_cfm_cb(hcon, 0);
+		del_timer(&hcon->smp_timer);
+		clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
+		hci_conn_put(hcon);
+	} else if (rsp->resp_key_dist) {
+		if (hcon->disconn_cfm_cb)
+			hcon->disconn_cfm_cb(hcon, SMP_UNSPECIFIED);
+		clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
+		mgmt_auth_failed(hcon->hdev->id, conn->dst, SMP_UNSPECIFIED);
+		hci_conn_put(hcon);
 	}
 
 	return 0;
 }
+
+int smp_link_encrypt_cmplt(struct l2cap_conn *conn, u8 status, u8 encrypt)
+{
+	struct hci_conn *hcon = conn->hcon;
+
+	BT_DBG("smp: %d %d %d", status, encrypt, hcon->sec_req);
+
+	clear_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend);
+
+	if (!status && encrypt && hcon->sec_level < hcon->pending_sec_level)
+		hcon->sec_level = hcon->pending_sec_level;
+
+	if (!status && encrypt && !hcon->sec_req)
+		return smp_distribute_keys(conn, 0);
+
+	/* Fall back to Pairing request if failed a Link Security request */
+	else if (hcon->sec_req  && (status || !encrypt))
+		smp_conn_security(conn, hcon->pending_sec_level);
+
+	hci_conn_put(hcon);
+
+	return 0;
+}
+
+void smp_timeout(unsigned long arg)
+{
+	struct l2cap_conn *conn = (void *) arg;
+	u8 reason = SMP_UNSPECIFIED;
+
+	BT_DBG("%p", conn);
+
+	smp_send_cmd(conn, SMP_CMD_PAIRING_FAIL, sizeof(reason), &reason);
+	clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->hcon->pend);
+	mgmt_auth_failed(conn->hcon->hdev->id, conn->dst, SMP_UNSPECIFIED);
+	hci_conn_put(conn->hcon);
+}
diff --git a/scripts/build_sun6i_fiber.sh b/scripts/build_sun6i_fiber.sh
index 8c093cb..d9d7dfe 100755
--- a/scripts/build_sun6i_fiber.sh
+++ b/scripts/build_sun6i_fiber.sh
@@ -64,8 +64,8 @@ build_nand_lib()
 	echo "build nand library ${NAND_ROOT}/lib"
 	if [ -d ${NAND_ROOT}/lib ]; then
 		echo "build nand library now"
-	make -C modules/nand/lib clean	2>/dev/null
-	make -C modules/nand/lib lib install
+	make ARCH=${ARCH} CROSS_COMPILE=${CROSS_COMPILE} -C modules/nand/lib clean	2>/dev/null
+	make ARCH=${ARCH} CROSS_COMPILE=${CROSS_COMPILE} -C modules/nand/lib lib install
 	else
 		echo "build nand with existing library"
 	fi
@@ -115,7 +115,7 @@ build_kernel()
 
 	build_standby
 	build_mdfs
-	make ARCH=arm CROSS_COMPILE=${CROSS_COMPILE} -j8 uImage modules
+	make ARCH=${ARCH} CROSS_COMPILE=${CROSS_COMPILE} -j8 uImage modules
 
 	${OBJCOPY} -R .note.gnu.build-id -S -O binary vmlinux bImage
 
@@ -162,14 +162,14 @@ build_modules()
 	(
 	unset OUT
 	unset TOP
-	make -C modules/eurasia_km/eurasiacon/build/linux2/sunxi_android LICHEE_MOD_DIR=${LICHEE_MOD_DIR} LICHEE_KDIR=${LICHEE_KDIR}
+	make ARCH=${ARCH} CROSS_COMPILE=${CROSS_COMPILE} -C modules/eurasia_km/eurasiacon/build/linux2/sunxi_android LICHEE_MOD_DIR=${LICHEE_MOD_DIR} LICHEE_KDIR=${LICHEE_KDIR}
 	)
 
-	make -C modules/example LICHEE_MOD_DIR=${LICHEE_MOD_DIR} LICHEE_KDIR=${LICHEE_KDIR} \
+	make ARCH=${ARCH} CROSS_COMPILE=${CROSS_COMPILE} -C modules/example LICHEE_MOD_DIR=${LICHEE_MOD_DIR} LICHEE_KDIR=${LICHEE_KDIR} \
 		CONFIG_CHIP_ID=${CONFIG_CHIP_ID} install
 
 	build_nand_lib
-	make -C modules/nand LICHEE_MOD_DIR=${LICHEE_MOD_DIR} LICHEE_KDIR=${LICHEE_KDIR} \
+	make ARCH=${ARCH} CROSS_COMPILE=${CROSS_COMPILE} -C modules/nand LICHEE_MOD_DIR=${LICHEE_MOD_DIR} LICHEE_KDIR=${LICHEE_KDIR} \
 		CONFIG_CHIP_ID=${CONFIG_CHIP_ID} install
 	copy_nand_mod
 
@@ -246,8 +246,8 @@ clean_modules()
 #
 #####################################################################
 
-LICHEE_ROOT=`(cd ${LICHEE_KDIR}/..; pwd)`
-export PATH=${LICHEE_ROOT}/buildroot/output/external-toolchain/bin:${LICHEE_ROOT}/tools/pack/pctools/linux/android:$PATH
+#LICHEE_ROOT=`(cd ${LICHEE_KDIR}/..; pwd)`
+#export PATH=${LICHEE_ROOT}/buildroot/output/external-toolchain/bin:${LICHEE_ROOT}/tools/pack/pctools/linux/android:$PATH
 
 case "$1" in
 kernel)
diff --git a/sound/soc/sun6i/sun6i-codec.c b/sound/soc/sun6i/sun6i-codec.c
index 4708b65..fd20f19 100755
--- a/sound/soc/sun6i/sun6i-codec.c
+++ b/sound/soc/sun6i/sun6i-codec.c
@@ -378,6 +378,7 @@ static  void codec_init(void)
 *	the system voice come out from speaker
 * 	this function just used for the system voice(such as music and moive voice and so on).
 */
+static int s = 0;
 static int codec_pa_play_open(void)
 {
 	int pa_vol = 0;
@@ -443,11 +444,14 @@ static int codec_pa_play_open(void)
 	codec_wr_control(SUN6I_MIC_CTRL, 0x1f, LINEOUT_VOL, pa_vol);
 
 	usleep_range(2000, 3000);
+	if(s!=0){
 	item.gpio.data = 1;
 	/*config gpio info of audio_pa_ctrl open*/
 	if (0 != sw_gpio_setall_range(&item.gpio, 1)) {
 		printk("sw_gpio_setall_range failed\n");
 	}
+	}
+	s = 1;
 	msleep(62);
 
 	return 0;
@@ -791,13 +795,13 @@ static int codec_capture_open(void)
 
 	/*enable Master microphone bias*/
 	codec_wr_control(SUN6I_MIC_CTRL, 0x1, MBIASEN, 0x1);
-
-	if (codec_headsetmic_en){
+//	printk("codec_headsetmic_en = %d, codec_mainmic_en = %d",codec_headsetmic_en,codec_mainmic_en);
+//	if (codec_headsetmic_en){
 		type = script_get_item("audio_para", "headset_mic_vol", &val);
 		if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
 		    printk("[audiocodec] codec_set_headsetmic type err!\n");
 	        }
-
+//		printk("headsetmic_en;;;;;;;;;;;;;;;;;;;;;;");
 		codec_wr_control(SUN6I_MIC_CTRL, 0x1, MIC2AMPEN, 0x1);
 		/*select mic3 source:0:mic3,1:mic2 */
 		codec_wr_control(SUN6I_MIC_CTRL, 0x1, MIC2_SEL, 0x1);
@@ -806,7 +810,7 @@ static int codec_capture_open(void)
 		codec_wr_control(SUN6I_ADC_ACTL, 0x1, RADCMIXMUTEMIC2BOOST, 0x1);
 		/*enable Left MIC2 Boost stage*/
 		codec_wr_control(SUN6I_ADC_ACTL, 0x1, LADCMIXMUTEMIC2BOOST, 0x1);
-	} else if (codec_mainmic_en){
+//	} else if (codec_mainmic_en){
 		type = script_get_item("audio_para", "main_mic_vol", &val);
 		if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
 		        printk("[audiocodec] codec_set_mainmic type err!\n");
@@ -820,16 +824,16 @@ static int codec_capture_open(void)
 		codec_wr_control(SUN6I_ADC_ACTL, 0x1, RADCMIXMUTEMIC1BOOST, 0x1);
 		/*enable Left MIC1 Boost stage*/
 		codec_wr_control(SUN6I_ADC_ACTL, 0x1, LADCMIXMUTEMIC1BOOST, 0x1);
-	} else {
+//	} else {
 		/*enable mic1 pa*/
-		codec_wr_control(SUN6I_MIC_CTRL, 0x1, MIC1AMPEN, 0x1);
+//		codec_wr_control(SUN6I_MIC_CTRL, 0x1, MIC1AMPEN, 0x1);
 		/*mic1 gain 36dB,if capture volume is too small, enlarge the mic1boost*/
-		codec_wr_control(SUN6I_MIC_CTRL, 0x7,MIC1BOOST,cap_vol);//36db
+//		codec_wr_control(SUN6I_MIC_CTRL, 0x7,MIC1BOOST,cap_vol);//36db
 		/*enable Right MIC1 Boost stage*/
-		codec_wr_control(SUN6I_ADC_ACTL, 0x1, RADCMIXMUTEMIC1BOOST, 0x1);
+//		codec_wr_control(SUN6I_ADC_ACTL, 0x1, RADCMIXMUTEMIC1BOOST, 0x1);
 		/*enable Left MIC1 Boost stage*/
-		codec_wr_control(SUN6I_ADC_ACTL, 0x1, LADCMIXMUTEMIC1BOOST, 0x1);
-	} 
+//		codec_wr_control(SUN6I_ADC_ACTL, 0x1, LADCMIXMUTEMIC1BOOST, 0x1);
+//	} 
 
 	/*enable adc_r adc_l analog*/
 	codec_wr_control(SUN6I_ADC_ACTL, 0x1,  ADCREN, 0x1);
-- 
1.7.10.4

